(function() {
define('js/mixIn',[],function() {

	/**
	 * @param dest optional, defaults to {}
	 * @param src
	 * @param mustHaveOwnProperty optional, default is true
	 * @param recursive optional default is false
	 */
	return function mixIn(dest, src, mustHaveOwnProperty, recursive) {
		if(typeof src === "undefined" || typeof src === "boolean") {
			recursive = false;
			mustHaveOwnProperty = src;
			src = dest;
			dest = {};
		}

		for(var k in src) {
			/*- if k is to be included */
			if(mustHaveOwnProperty === false || src.hasOwnProperty(k)) {
				if(recursive === true) {
					/*- if src[k] is object */
					if(src[k] !== null && typeof src[k] === "object" && src[k].constructor === Object) {
						if(dest[k] === null || typeof dest[k] !== "object") {
							/* dest[k] should be of type object */
							dest[k] = {};
						}
						mixIn(dest[k], src[k], mustHaveOwnProperty, recursive);
					} else {
						/* normal behaviour (see js/mixIn.js) */
						dest[k] = src[k];
					}
				} else {
					dest[k] = src[k];
				}
			}
		}
		return dest;
	};
});
define('js/extensions',['require','./mixIn'],function(require) {

//	var nameOf = require("./nameOf");
	var mixIn = require("./mixIn");

	// RequireJS stuff, needed for make/Build
	(function() {
		var ctx = requirejs.s.contexts._;
		var inh = ctx.completeLoad;
		ctx.modulesLoaded = [];
		ctx.completeLoad = function(moduleName) {
			ctx.modulesLoaded.push(moduleName);
			//console.log(moduleName);
			return inh.apply(this, arguments);
		};
	}());


	Error.chain = function(e, cause) {
		return mixIn(e, {
			cause: cause
		});
	};

	/**
	 * Array.js
	 */
	if(Array.prototype.indexOf === undefined) {

		/**
		 *
		 * @param element
		 * @returns {Number}
		 */
		Array.prototype.indexOf = function(element) {
			for(var i = 0, l = this.length; i < l; ++i) {
				if(this[i] === element) {
					return i;
				}
			}
			return -1;
		};
		//console.debug("Array.prototype.indexOf declared");
	}

	if(Array.prototype.forEach === undefined) {
		var thiz = this;

		/**
		 *
		 * @param f
		 * @param this_
		 */
		Array.prototype.forEach = function(f, this_) {
			for(var i = 0, l = this.length; i < l; ++i) {
				f.apply(this_ || thiz, [this[i], i, this]);
			}
		};
		//console.debug("Array.prototype.forEach declared");
	}

	if(Array.prototype.remove === undefined) {

		/**
		 *
		 * @param obj
		 * @returns
		 */
		function remove(obj) {
			var i = this.indexOf(obj);
			return i !== -1 ? this.splice(i, 1)[0] : undefined;
		}

		if(Object.create) {
			Array.prototype = Object.create(Array, {
				remove: {
					value: remove
				}
			});
		} else {
			Array.prototype.remove = remove;
		}
	}

	/**
	 *
	 * @param array
	 * @param oldIndex
	 * @param newIndex
	 * @returns
	 */
	Array.move = function(array, oldIndex, newIndex) {
		var arr = [].concat(array);
		var item = arr.splice(oldIndex, 1)[0];
		before = arr.splice(0, newIndex);
		return before.concat([item]).concat(arr);
	};

	if (typeof String.prototype.endsWith !== 'function') {
	    String.prototype.endsWith = function(suffix) {
	        return this.indexOf(suffix, this.length - suffix.length) !== -1;
	    };
	}

	if(String.of === undefined) {
		/**
		 *
		 * @param obj
		 */
		String.of = function(obj) {
			return obj && obj.toString();
		};
	}

	/**
	 *
	 * @param str
	 * @returns
	 */
	String.camelize = function(str) {
		return str.substring(0, 1).toUpperCase() + str.substring(1);
	};

	/**
	 *
	 * @param s
	 * @returns
	 */
	String.escape = function (s) {
		return ('"' + s.replace(/(["\\])/g, '\\$1') + '"').
			replace(/[\f]/g, "\\f").
			replace(/[\b]/g, "\\b").
			replace(/\n/g, "\\n").
			replace(/[\t]/g, "\\t").
			replace(/[\r]/g, "\\r");
	};

	/**
	 *
	 * @param s
	 * @returns
	 */
	String.escapeHtml = function(s) {
		return s && s.replace ? s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") : s;
	};

	/**
	 *
	 * @param s
	 * @returns
	 */
	String.unescapeHtml = function(s) {
		return s && s.replace ? s.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">") : s;
	};

	/**
	 *
	 * @param str
	 * @returns
	 */
	String.trim = function(str) {
		return str.replace(/\s+$/, "").replace(/^\s+/, "");
	};

	/**
	 *
	 * @param s
	 * @returns
	 */
	String.toJS = function(s) {
		return String.format("%s", s);
	};

	/**
	 *
	 * @param str
	 * @param on
	 * @param escape
	 * @returns {Array}
	 */
	String.split = function(str, on, escape) {
		var r = [];
	    var s = "";
	    var c;
	    var b = false;

	    if(escape === undefined) {
	    	escape = "\\a".charAt(0);
	    }

	    for (var i = 0, l = str.length; i < l; ++i) {
	        c = str.charAt(i);
	        if (b === true) {
	            s += c;
	            b = false;
	        } else if (c === on) {
	            r.push(s);
	            s = "";
	        } else if (c === escape) {
	            b = true;
	        } else {
	            s += c;
	        }
	    }
	    r.push(s);
	    return r;
	};

	/**
	 *
	 * @param fmt
	 * @returns
	 */
	String.format = function(fmt/*, ... */) {
		var s = [];
		var idx = -1, pos = 0;
		var i = 1;
		var specifiers = "cdfsHn";

		do {
			idx = fmt.indexOf("%", ++idx);

			if(idx !== -1) {
				if(fmt.charAt(idx + 1) === "%") {
					s.push(fmt.substring(pos, idx));
					s.push("%");
					idx++;
					pos = idx + 1;
				} else {
					s.push(fmt.substring(pos, idx));
					var mod = "", ch = fmt.charAt(idx + 1);
					while(specifiers.indexOf(ch) === -1) {
						mod += ch;
						idx++;
						ch = fmt.charAt(idx + 1);
					}
					if(ch === "c") {
						if(mod === "*") {
							var n = arguments[i++];
							while(n--) {
								s.push(arguments[i]);
							}
							i++;
						} else {
							s.push(arguments[i++]);
						}
					} else if(ch === "d") {
						var value = "" + parseInt(arguments[i++], 10);
						if(mod.length) {
							if(mod.charAt(0) === "0") {
								var len = parseInt(mod.substring(1), 10) || 0;
								while(value.length < len) {
									value = "0" + value;
								}
							} else {
								len = parseInt(mod, 10) || 0;
								while(value.length < len) {
									value = " " + value;
								}
							}
						}
						s.push(value);
					} else if(ch === "f") {
	                    if (mod.charAt(0) === ".") {
	                        len = parseInt(mod.substring(1), 10) || 0;
	                        value = arguments[i++];
	                        var i1 = parseInt(value, 10) || 0;
	                        var f = Math.abs(value - i1);
							f *= Math.pow(10, len + 1);
							f = "" + Math.round(Math.round(f) / 10);
							while(f.length < len) {
							    f = "0" + f;
							}
	                        s.push(i1 + "." + f);
	                    } else {
	                        s.push(arguments[i++]);
	                    }
					} else if(ch === "s" || ch === "H" || ch === "n") {
						if(ch === "n") {
							value = String.of(arguments[i++]);
						} else {
							value = "" + arguments[i++];
						}
						if(mod.charAt(0) === "-") {
							len = parseInt(mod.substring(1), 10) || 0;
							while(value.length < len) {
								value = " " + value;
							}
						} else {
							len = parseInt(mod, 10) || 0;
							if(mod === "*") {
								len = parseInt(value, 10);
								value = "" + arguments[i++];
							}
							while(value.length < len) {
								value += " ";
							}
						}
						if(ch === "H" && value) {
							try {
								value = String.escapeHtml(value);
							} catch(e) { value = e.message; }
						}
						s.push(value);
					} else {
						s.push(arguments[i++]);
					}
					pos = idx + 2;
				}
			}
		} while(idx !== -1);
		s.push(fmt.substring(pos));
		return s.join("");
	};

	Date.prototype.getWeekNumber = function(){
	    var d = new Date(+this);
	    d.setHours(0, 0, 0);
	    d.setDate(d.getDate() + 4 - (d.getDay() || 7));
	    return Math.ceil((((d - new Date(d.getFullYear(), 0, 1))
	    		/ 8.64e7) + 1) / 7);
	};

});
define('js/nameOf',[],function() {

	var methods = [];

	/**
	 *
	 * @param obj
	 * @returns
	 */
	function nameOf(obj) {
		for(var i = methods.length - 1, r; i >= 0; --i) {
			if((r = methods[i].apply(this, arguments)) !== undefined) {
				return r;
			}
		}
		
		if(obj && obj.hasOwnProperty("toString") && obj.constructor !== Object) {
            return obj.toString();
		}
		
		if(obj && obj.constructor && obj.constructor.prototype.toString === Object.prototype.toString) {
			return obj.constructor.name;
		}

		return obj ? obj.toString() || obj.constructor.prototype.toString.apply(obj, []) : String(obj);
	}

	String.of = function(obj) {
		return nameOf(obj);
	};

	nameOf.methods = methods;

	return nameOf;
});
define('js/Method',["module", "./nameOf"], function(module, nameOf) {

	var registry = {
		override: module.id + ".override",
		connect: module.id + ".connect",
		trace: module.id + ".trace",
		name: module.id + ".name"
	};

	var time = Date.now();
	var stack = [];
	var traces = 0;

	/**
	 * Register a nameOf for functions (inclucing methods and constructors)
	 */
	nameOf.methods.push(function(obj) {
		if(obj instanceof Function) {
			return Method.getName(obj);
		}
	});

	/**
	 *
	 * @param args
	 *            {Arguments}
	 * @returns {Array}
	 */
	function copy_args(args) {
		return Array.prototype.slice.apply(args, [0]);
	}

	/**
	 * Returns an array containing string representations of an arguments
	 * object.
	 *
	 * @param args
	 *            {Arguments}
	 * @returns {Array} An array containing string representations of the
	 *          specified {Arguments} object
	 */
	function args2strs(args) {
		var s = [];
		for( var i = 0, l = args.length; i < l; ++i) {
			var v = args[i];
			switch(typeof v) {
				case "string":
					v = String.escape(v);
					if(v.length > 40) {
						v = v.substring(0, 40) + "...";
						v += "\"";
					}
					s.push(v);
				break;

				case "object":
					if(v !== null) {
						s.push(nameOf(v));
					} else {
						s.push("null");
					}
				break;

				case "undefined":
					s.push("undefined");
				break;

				case "function":
					s.push(nameOf(v));
				break;

				default:
					s.push(v);
			}
		}
		return s;
	}

	/**
	 *
	 * @param obj
	 * @param methodName
	 * @param f
	 * @param allowNoImpl
	 * @returns
	 */
	function override(obj, methodName, f, allowNoImpl) {
		if(typeof methodName === "object") {
			for(var name in methodName) {
				override(obj, name, methodName[name], f);
			}
		} else {
			var method = obj[methodName];

			if(f[registry.override] !== undefined) {
				throw new Error(String.format("%s.override: Supplied function already seems to " +
						"override something (%n - %s)", module.id, obj, methodName), f);
			}

			if(typeof method !== "function") {
				if(allowNoImpl !== true) {
					throw new Error(String.format("%s.override: %s is not a method of %n",
							module.id, methodName, obj));
				}
				obj[methodName] = f;
				f[registry.override] = function() {};
			} else {
				var info;
				if((info = method[registry.connect]) !== undefined) {
					f[registry.override] = info.method;
					info.method = f;
				} else {
					obj[methodName] = f;
					f[registry.override] = method;
				}
			}
		}
	}

	/**
	 *
	 * @param thisObj
	 * @param args
	 * @param skip
	 * @returns
	 */
	function inherited(thisObj, args, skip) {
		args = args || arguments.callee.caller['arguments'];

		var mth = args.callee[registry.override];

		// skip indicates how many levels of inheritance should be skipped
		for(skip = skip || 0; typeof mth === "function" && skip > 0; skip--) {
			mth = mth[registry.override];
		}

		if(typeof mth === "function") {
			return mth.apply(thisObj, args);
		}

		if(skip === undefined) {
			throw new Error(String.format("%n does not override an inherited method",
					args.callee, this, arguments));
		}
	}

	/**
	 *
	 */
	function Call(arr) {
		for(var i = 0; i < arr.length; ++i) {
			this.push(arr[i]);
		}
	}

	Call.prototype = new Array(); // FIXME inherit Array
	Call.prototype.constructor = Call;
	Call.prototype.toString = function() {
		return String.format("%n(%s) - %n", this[1], js.args2strs(this[2]), this[0]);
	};

	/**
	 *
	 */
	function CallStack(arr) {
		for(var i = 0; i < arr.length; ++i) {
			this.push(new Call(arr[i]));
		}
	}

	CallStack.prototype = new Array(); // FIXME inherit Array
	CallStack.prototype.constructor = CallStack;
	CallStack.prototype.toConsole = function(message) {
		if(this.length > 0) {
			var last = this.length - 1;
			var item = this[last];
			console.groupCollapsed(message || item.toString());

			for(var i = last; i >= 0; --i) {
				item = this[i];
				if(typeof item[0] !== "string") {
					console.groupCollapsed(item.toString(), item[3] - time, item[4]);
					console.log(item[0]);
					console.log("arguments:", item[2]);
					console.groupEnd();
				} else {
					console.log(item[0]);
				}
			}

			console.groupEnd();
		}
	};
	CallStack.prototype.toString = function() {
		return String.format("[object CallStack,%d]", this.length);
	};

	var Method = {

		CallStack: CallStack,
		Call: Call,

		override: override,
		callInherited: inherited,
		copy_args: copy_args,
		args2strs: args2strs,

		/**
		 *
		 * @param srcObj
		 * @param srcMethodName
		 * @param destObj
		 * @param destMethodName
		 * @param type
		 * @returns
		 */
		connect: function(srcObj, srcMethodName, destObj, destMethodName, type) {
			function createConnectMethod () {
				return function callListeners() {
					var info = arguments.callee[registry.connect];
					var r, i, li, l;

					if(info.firing === undefined) {
						info.firing = 1;
					} else {
						info.firing++;
					}

					for(i = 0, l = info.listeners.length; i < l; ++i) {
						li = info.listeners[i];
						if(li.type === "before") {
							li.method.apply(li.obj, arguments);
						} else if(li.type === "_before") {
							li.method.apply(li.obj, [this, arguments]);
						}
					}

					try {
						r = info.method.apply(this, arguments);
						for(i = 0, l = info.listeners.length; i < l; ++i) {
							li = info.listeners[i];
							if(li === undefined) {
								console.log(info);
							}
							if(li.type === "after") {
								li.method.apply(li.obj, arguments);
							} else if(li.type === "_after") {
								li.method.apply(li.obj, [this, arguments]);
							}
						}

					} catch(e) {
						var rt = e;
						for(i = 0, l = info.listeners.length; i < l; ++i) {
							li = info.listeners[i];
							if(li.type === "catch") {
								try {
									li.method.apply(li.obj, [e, this, arguments]);
									rt = undefined;
								} catch(ex) {
									rt = ex;
								}
							}
						}

						if(rt !== undefined) {
							throw rt;
						}

					} finally {

						try {
							for(i = 0, l = info.listeners.length; i < l; ++i) {
								li = info.listeners[i];
								if(li.type === "finally") {
									li.method.apply(li.obj, arguments);
								} else if(li.type === "_finally") {
									li.method.apply(li.obj, [this, arguments]);
								}
							}
						} finally {
							info.firing--;
							if(info.firing === 0) {
								delete info.firing;

								for(i = 0; i < info.listeners.length;) {
									if(info.listeners[i].type === "") {
										info.listeners.splice(i, 1);
									} else {
										i++;
									}
								}
								if(info.listeners.length === 0) {
									info.srcObj[info.srcMethodName] = info.method;
									delete info.srcObj;
									delete info.srcMethodName;
								}
							}
						}
					}
					return r;
				};
			}

			if(srcObj === null || srcObj === undefined) {
				throw new Error(String.format("%s.connect: srcObj is %n", module.id, srcObj));
			}

			if(destObj === null || destObj === undefined) {
				throw new Error(String.format("%s.connect: destObj is %n", module.id, destObj));
			}

			var src = srcObj[srcMethodName];
			var dest = destObj[destMethodName];
			var info;

			if(typeof src !== "function") {
				throw new Error(String.format("%s.connect: typeof srcObj['%s'] === %s, must be function",
						module.id, srcMethodName, typeof src));
			}

			if(typeof dest !== "function") {
				throw new Error(String.format("%s.connect: typeof destObj['%s'] === %s, must be function",
						module.id, destMethodName, typeof dest));
			}

			if((info = src[registry.connect]) === undefined) {
				info = {method: src, listeners: []};
				src = (srcObj[srcMethodName] = createConnectMethod());
				src[registry.connect] = info;
			}

			info.listeners.push({
				obj: destObj,
				method: dest,
				type: type || "after"
			});
		},

		/**
		 *
		 * @param srcObj
		 * @param srcMethodName
		 * @param destObj
		 * @param destMethodName
		 * @returns
		 */
		disconnect: function(srcObj, srcMethodName, destObj, destMethodName) {
			var src = srcObj[srcMethodName];
			var dest = destObj[destMethodName];
			var info;

			if(typeof src !== "function") {
				throw new Error(String.format("%s.disconnect: typeof srcObj['%s'] === %s, must be function",
					module.id, srcMethodName, typeof src));
			}

			if(typeof dest !== "function") {
				throw new Error(String.format("%s.disconnect: typeof destObj['%s'] === %s, must be function",
					module.id, destMethodName, typeof dest));
			}

			if(src[registry.connect] === undefined) {
				throw new Error(String.format("%s.disconnect: srcObj['%s'] has never been connected to",
					module.id, srcMethodName));
			}

			info = src[registry.connect];
			for(var i = 0, l = info.listeners.length; i < l; ++i) {
				var li = info.listeners[i];
				if(li.obj === destObj && li.method === dest) {
					if(info.firing !== undefined) {
						info.listeners[i] = {type: ""};
						info.srcObj = srcObj;
						info.srcMethodName = srcMethodName;
						return;
					} else {
						info.listeners.splice(i, 1);
						if(info.listeners.length === 0) {
							srcObj[srcMethodName] = info.method;
						}
						return;
					}
				}
			}

			throw new Error(String.format("%s.disconnect: srcObj['%s'] has never been connected to by destObj['%s']",
				module.id, srcMethodName, destMethodName));
		},

		/**
		 * Replaces the method with
		 *
		 * @param obj
		 * @param methodName
		 */
		trace: function(obj, methodName) {
			function createTraceMethod() {
				return function stacktrace() {
					var method = arguments.callee[registry.trace];
					stack.push([this, method, arguments, Date.now() - time, traces++]);
					try {
						return method.apply(this, arguments);
					} catch(e) {
						if(e.callStack === undefined) {
							e.callStack = Method.getCallStack();
							//e.callStack.toConsole(e.name + ": " + e.message);
						}
						Method.lastError = e;
						throw e;
					} finally {
						stack.pop();
					}
				};
			}

			var method;
			if(typeof obj === "function" && typeof methodName === "undefined") {
				method = obj;
				methodName = "mth";
				obj = {
					mth: method
				};
			} else {
				method = obj[methodName];
				if(typeof method !== "function") {
					throw new Error(String.format("%s.override: %s is not a method of %n",
							module.id, methodName, obj));
				}
			}

			if(this.isTraced(method)) {
				console.warn(String.format("Already tracing %n", method));
			} else {
				var info = method[registry.connect];
				if(info !== undefined) {
					method = info.method;
					info.method = createTraceMethod();
					info.method[registry.trace] = method;
				} else {
					obj[methodName] = createTraceMethod();
					obj[methodName][registry.trace] = method;
				}
			}
			return obj[methodName];
		},

		/**
		 *
		 * @param method
		 * @returns
		 */
		isTraced: function(method) {
			var info;
			if((info = method[registry.connect]) !== undefined) {
				return this.isTraced(info.method);
			//} else if((info = method[registry.override]) !== undefined) {
				//return this.isTraced(info);
			}
			return method[registry.trace] !== undefined;
		},

		/**
		 *
		 * @param method
		 */
		getName: function(method) {
			if(typeof method === "function") {
				var info;
				if((info = method[registry.connect]) !== undefined) {
					method = info.method;
				}
				if((info = method[registry.trace]) !== undefined) {
					method = info;
				}
				if((info = method[registry.name]) !== undefined) {
					return info;
				}
			}
		},

		/**
		 *
		 * @param method
		 * @param value
		 * @returns
		 */
		setName: function(method, value) {
			return method[registry.name] = value;
		},

		/**
		 *
		 * @param method
		 * @returns
		 */
		getInherited: function(method) {
			return method[registry.override];
		},

		/**
		 *
		 * @param method
		 * @param value
		 * @returns
		 */
		setInherited: function(method, value) {
			method[registry.override] = value;
		},

		/**
		 *
		 * @returns {CallStack}
		 */
		getCallStack: function() {
			return new CallStack(stack);
		},

		/**
		 *
		 * @param method
		 * @returns
		 */
		getOriginal: function(method) {
			var info;
			if((info = method[registry.connect]) !== undefined) {
				method = info.method;
			}
			if((info = method[registry.trace]) !== undefined) {
				method = info;
			}
			while((info = method[registry.override]) !== undefined) {
				method = info;
			}
			return method;//.apply(thisObj, args || []);
		}

	};

	// override Function.prototype.toString in order to hide wrapper functions
	Method.override(Function.prototype, "toString", function() {
		var method = this;
		if(method[registry.connect] !== undefined) {
			method = method[registry.connect].method;
		}
		if(method[registry.trace] !== undefined) {
			method = method[registry.trace];
		}
		return Method.callInherited(method, arguments);
	});

	/**
	 *
	function inherited(thisObj, args, skip, name) {
		args = args || arguments.callee.caller.arguments;
		return Method.callInherited(thisObj, args, skip, name);
	}
	 */

	return Method;
});
define('js/Type',["require", "module", "./mixIn", "./extensions"], function(require, module, Type) {

	function keys(obj) {
		var r = [];
		for(var k in obj) {
			r.push(k);
		}
		return r;
	}

	var types = {

			ARRAY: {
				"class": Array,
				defaultValue: []
			},

			BOOLEAN: {
				"class": Boolean,
				defaultValue: true,
				trueIdent: "true",
				falseIdent: "false"
			},

			CLASS: {
				"class": Object,
				defaultValue: null
			},

			DATE: {
				"class": Date,
				defaultValue: new Date(0)//{ nameOf: "DATE(null)" }
			},

			TIMESTAMP: {
				"class": Date,
				defaultValue: new Date(0)//{ nameOf: "DATETIME(null)" }
			},

			ENUM: {
				"class": Object,
				defaultValue: undefined//{ nameOf: "ENUM(null)" }
			},

			ERROR: {
				"class": Error,
				defaultValue: undefined
			},

			EVENT: {
				"class": Function,
				defaultValue: function() {}
			},

			FLOAT: {
				"class": Number,
				defaultValue: 0.0
			},

			CONSTRUCTOR: {
				"class": Function,
				defaultValue: function() {}//function() { /** null function */ }
			},

			FUNCTION: {
				"class": Function,
				defaultValue: function() {}//function() { /** null function */ }
			},

			INTEGER: {
				"class": Number,
				defaultValue: 0
			},

			JAVA_OBJECT: {
				"class": "",
				defaultValue: null
			},

			METACLASS: {
				"class": Object,
				defaultValue: null
			},

			NUMBER: {
				"class": Number,
				defaultValue: 0
			},

			OBJECT: {
				"class": Object,
				defaultValue: { }
			},

			PROTOTYPE: {
				"class": Object,
				defaultValue: { }
			},

			PACKAGE: {
				"class": Object,
				defaultValue: null
			},

			STRING: {
				"class": String,
				defaultValue: ""
			},

			TEXT: {
				"class": String,
				defaultValue: ""
			},

			TIME: {
				"class": Date,
				defaultValue: new Date(0)//{ nameOf: "TIME(null)" }
			},

			UNDEFINED: {
				"class": undefined,
				defaultValue: undefined
			} // nicely at the bottom ;-)
		};

		for(var k in types) {
			types[k].name = String.format("%s/Type.%s", module.id, k);
			//types[k].get = eval(String.format("({f:function() { return types.%s; }})", k)).f;
			types[k].get = function() {
                return types[k];
            };
		}

		return (Type = Type(types, {

			types: keys(types),

			/**
			 *
			 */
			byValue: function(value) {
				var type;

				try {
					type = typeof value;
				} catch(e) {
					return types.JAVA_OBJECT;
				}

				switch(type) {
					case "number":
						if(parseInt(value, 10) === parseFloat(value)) {
							return types.INTEGER;
						}
						return types.FLOAT;

					case "string":
						return types.STRING;

					case "boolean":
						return types.BOOLEAN;

					case "function":
						if(Class.isConstructor(value)) {
							return types.CONSTRUCTOR;
						}
						return types.FUNCTION;

					case "object":
						if(value instanceof Class) {
							return types.CLASS;
						} else if(value instanceof Date) {
							return types.TIMESTAMP;
						} else if(value instanceof Error) {
							return types.ERROR;
						} else	if(value instanceof Array) {
							return types.ARRAY;
						}

					return types.OBJECT;
				}

//				console.warn(String.format("returning UNDEFINED for %s", value));
				return types.UNDEFINED;
			},

			/**
			 *
			 */
			isCompatible: function(type, value) {
				var type2 = types.byValue(value);
				if(type === types.FLOAT && type2 === types.INTEGER) {
					return true;
				}
				return type === type2 || value === type.defaultValue;
			},

			/**
			 *
			 */
			isType: function(obj) {
				for(var k in types) {
					if(types[k] === obj) {
						return true;
					}
				}
				return false;
			}
		}));
});
define('js/Class',['require','./extensions','./mixIn','./nameOf','./Method','./Type'],function(require) {

	require("./extensions");

	var mixIn = require("./mixIn");
	var nameOf = require("./nameOf");
	var Method = require("./Method");
	var Type = require("./Type");

	var classObjKeyName = "@class obj";
	var classKeyName = "class";
	var classMap = {};

	/**
	 * Register method for instances of Class.defin(e)itions
	 */
	nameOf.methods.push(function(obj) {
		if(obj instanceof Function && (obj = obj[classObjKeyName]) !== undefined) {
			return obj.name;
		}
	});

	/**
	 *
	 */
	function getDefaultInherits() {
		if(classMap["js/JsObject"] === undefined) {
			console.log("JsObject not defined!");
            require(["js/JsObject"], function(JsObject) {
                console.log("JsObject defined", classMap["js/JsObject"] === JsObject);
            });
		}
		return classMap["js/JsObject"];
	}

	/**
	 * toString implementation for constructors
	 */
	function classConstructorToString() {
		if(this.hasOwnProperty(classObjKeyName)) {
			return String.format("function %s() { [constructor code] }", this[classObjKeyName].name);
		}
		return Function.prototype.toString.apply(this, arguments);
	}

	/**
	 * This is Chrome specific (as far as I know). It will show fancy names for
	 * object instances in the console.
	 */
	function namedFunction(name, f) {
		var symbol;
		var g = f;
		name = name.split(".");
		if(name.length > 1) {
			symbol = name.shift();
			name = name.join(".");
		} else {
			symbol = "$";
			name = name[0];
		}

		if(f.name === "") {
			// FIXME f.replace below should be a centralized method to replace illegal function name chars
			f = "function " + name.split("/").pop().replace(/\./g, "_") + f.toString().substring("function".length + 1);
		} else {
			f = f.toString();
		}

		try {
			symbol = symbol.replace(/\//g, "_");
			return eval(String.format("(function() { var %s = {'%s': (%s)}; return %s['%s'];})();",
					symbol, name, f, symbol, name));
		} catch (e) {
			console.error(e.message, e);
			return g;
		}
		return f;
	}

	/**
	 * Create a constructor function used for instances of Class.defin(e)itions
	 *
	 * @returns {Function}
	 */
	function createConstructor(name) {
		return namedFunction(name || "AnonymousClass", function() {
			/**
			 * js/Class.constructor: This constructor inspects it's classObj in
			 * order to determine which constructor should be called
			 */
			var classObj = arguments.callee[classObjKeyName];
			if(classObj) {
				if(classObj.implicitConstructorCall === false) {
					if(classObj.hasOwnProperty("constructor")) {
						var args = Array.prototype.slice.apply(arguments, [0]);
						// pass on inherits as last parameter (FIXME should/can
						// length be taken into account?)
						args.concat(classObj.inherits);
						classObj.constructor.apply(this, args);
					}
				} else {
					if(classObj.hasOwnProperty("inherits")) {
						classObj.inherits.apply(this, arguments);
					}
					if(classObj.hasOwnProperty("constructor")) {
						classObj.constructor.apply(this, arguments);
					}
				}
			}
		});
	}

	var Class = {

		Type: Type,

		/**
		 * @overrides http://requirejs.org/docs/plugins.html#apiload
		 */
		load: function(name, parentRequire, load, config) {
			load(classMap[name] || Class.create(name));
		},

		/**
		 *
		 */
		define: function(localRequire, classObj, overwrite) {
			var name = localRequire("module").id;
			var cls = classMap[name];
			if(overwrite || !cls) {
			    cls = Class.create(name);
			}
			return cls.define(classObj);
		},
		
		/**
		 *
		 */
		reference: function(name) {
			return classMap[name] || this.create(name);
		},

		/**
		 *
		 * @param name
		 * @param f
		 * @returns
		 */
		create: function(name, f) {
			var cls = (classMap[name] = createConstructor(name));
			var classObj = Object.create({}, {
				name: {
					value: name
				}
			});
			cls.define = function(classObjEx) {
				/**
				 * Once this method is called, it will delete itself. It was
				 * basically syntaxic sugar, together with possibility to define
				 * the class using itself (the other keys like inherits,
				 * prototype, etc). All the definitions are moved to the
				 * classObj.
				 */
				delete this.define;
				mixIn(classObj, classObjEx, true);
				return Class.make(classObj, cls);
			};

			return typeof f === "function" ? f(cls) : cls;
		},

		/**
		 * 'Makes' (by lack of better name and the fact that create and define
		 * are already taken) the class specified by classObj and ctor
		 *
		 * @param classObj
		 * @param ctor
		 * @returns {Function} Constructor function
		 */
		make: function(classObj, ctor) {
			if(classObj.hasOwnProperty("prototyqe")) {
				// TODO deprecated
				console.warn("prototyqe will be deprecated");
				classObj.prototype = classObj.prototyqe;
			}

			classObj.inherits = classObj.inherits || getDefaultInherits();

			var proto = classObj.prototype || {};
			var superproto = classObj.inherits.prototype;
			var k;

			if(typeof ctor !== "function") {
				ctor = createConstructor();
			}

			ctor[classObjKeyName] = classObj;
			ctor.toString = classConstructorToString;
			ctor.prototype = Object.create(superproto);
			ctor.prototype.constructor = ctor;

			for(k in proto) {
				if(proto.hasOwnProperty(k)) {
					if(k !== "constructor") {
						if(typeof (ctor.prototype[k] = proto[k]) === "function" && k.indexOf("_") !== 0) {
							if(typeof superproto[k] === "function") {
								Method.setInherited(proto[k], superproto[k]);
							}
							//Method.setName(proto[k], classObj.name + ".prototype." + k);
							if(classObj.traceProtoMethods !== false) {
								//Method.trace(proto, k);
							}
							proto[k][classKeyName] = ctor;
						}
					} else {
						classObj.constructor = proto[k];
					}
				}
			}

			// FIXME setName/inherited?
			for(k in classObj.statics) {
				if(classObj.statics.hasOwnProperty(k)) {
					ctor[k] = classObj.statics[k];
					//Method.setName(ctor[k], classObj.name + "." + k);
					if(classObj.traceStaticMethods !== false) {
						//Method.trace(ctor, k);
					}
				}
			}
			
			// for(k in classObj.properties) {
			// 	var prop = classObj.properties[k];
			// 	if(k.indexOf("on") === 0 && k.charAt(2) >= 'A' && k.charAt(2) <= 'Z') {
			// 		if(!prop.hasOwnProperty("set")) {
						
			// 		}
			// 	}
			// }

			classObj.properties = classObj.properties || {};
			classObj['parse-properties'] = true;

			return ctor;
		},

		/**
		 *
		 * @param obj
		 */
		getProperties: function(obj) {
			if(Class.isConstructor(obj)) {
				var classObj = Class.getClassObj(obj);
				if(classObj.hasOwnProperty("parse-properties")) {
					delete classObj['parse-properties'];

					var props = classObj.properties;
					for(var k in props) {
						if(props.hasOwnProperty(k)) {
							props[k] = new ((require)("js/" + "Property"))(obj, k, props[k]);
						}
					}

					var prototype = Class.getProperties(classObj.inherits);
					classObj.properties = mixIn(Object.create(prototype), classObj.properties);
				}
				return classObj.properties;
			}
			return {};
		},

		/**
		 *
		 * @param obj
		 * @returns {Boolean}
		 */
		isConstructor: function(obj) {
			return obj && obj[classObjKeyName] ? classMap[obj[classObjKeyName].name] === obj : false;
		},

		/**
		 *
		 * @param ctor
		 */
		getClassObj: function(ctor) {
			if(Class.isConstructor(ctor)) {
				return ctor[classObjKeyName];
			}
		},

		/**
		 *
		 * @param ctor
		 * @returns
		 */
		getSuperClass: function(ctor) {
			if(Class.isConstructor(ctor)) {
				return ctor[classObjKeyName].inherits;
			}
		}
	};

	return Class;
});
define('js/JsObject',['require','./Class','./Method','./Method'],function(require) {

	var Class = require("./Class");
	var inherited = require("./Method").callInherited;
	var override = require("./Method").override;
	
	/**
	 * Keeps track of the next hashCode
	 */
	var hashCode = 0;
	var all = [];

	all.push = function() {
		hashCode += arguments.length;
		return Array.prototype.push.apply(this, arguments);
	};

	var JsObject = Class.define;

	return (JsObject = JsObject(require, {

		inherits: Object,

		prototype: {

			'@hashCode': null,

			/**
			 * @overrides Object.prototype.toString
			 */
			toString: function() {
				return String.format("%n#%d", this.constructor, this.hashCode());
			},

			/**
			 *
			 */
			destroy: function() {
				if(this.hasOwnProperty("@hashCode")) {
					delete JsObject.$[this['@hashCode']];
				}

				// some debugging handy-dandy: when a reference to an object is
				// found with a negative hashCode, destroy has been called for
				// that instance and caution is advised
				for( var k in this) {
					if(k !== "@hashCode") {
						delete this[k];
					} else {// if(this.hasOwnProperty("@hashCode")) {
						delete all[this['@hashCode']];
						this['_@hashCode'] = -this['@hashCode'];
					}
				}
			},

			/**
			 *
			 * @returns {Boolean}
			 */
			hashCode: function() {
				if(this instanceof JsObject) { // prototype stuff
					if(this.hasOwnProperty("@hashCode")) {
						return this['@hashCode'];
					}
					this['@hashCode'] = hashCode++;

					all[this['@hashCode']] = this;

					return this['@hashCode'];
				}
			},

			/**
			 *
			 */
			inherited: function(args, skip) {
				return inherited(this, args, skip);
			},

			/**
			 *
			 */
			override: function(obj, allowNoImpl) {
				return override(this, obj, allowNoImpl);
			},

			/**
			 *
			 */
			defineProperties: function() {
				return Class.getProperties(this.constructor);
			},
			
			/**
			 * 
			 */
			setProperties: function(values) {
			    var props = this.defineProperties();
			    for(var k in values) {
			        var prop = props[k];
			        if(k) {
			            prop.set(this, values[k]);
			        }
			    }
			    return this;
			}

		},

		statics: {

			$: all,
			all: all

		}
	}));
});
define('js/defineClass',["./Class", "./JsObject"], function(Class) {
	return function(localRequire, classObj) {

		function f(what) {
			if(what !== "module") {
				return require.apply(this, arguments);
			}
			return {id: localRequire}; // NB typeof localRequire === "string"
		}

		return Class.define(typeof localRequire === "string" ? f : localRequire, classObj);
	};
});
define('js/Deferred',['require','./defineClass','./Method','./mixIn'],function(require) {

	var Deferred = require("./defineClass");
	var Method = require("./Method");
	var mixIn = require("./mixIn");

	return (Deferred = Deferred(require, {

		prototype: {

			/**
			 *
			 */
			constructor: function(/* optional */ canceller) {
				this.chain = [];
				this.results = [null, null];
				if(arguments.length > 0) {
					this.canceller = canceller;
				}

				this.callStack = Method.getCallStack();
			},

			chain: null,
			fired: -1,
			paused: 0,
			results: null,
//			result: null,
			canceller: null,
			silentlyCancelled: false,
			chained: false,

			callStack: null,

			/**
			 *
			 */
			cancel: function () {
				if (this.fired === -1) {
					if (this.canceller) {
						this.canceller(this);
					} else {
						this.silentlyCancelled = true;
					}
					if (this.fired === -1) {
						this.errback(new Error("Cancelled"));
					}
				} else if ((this.fired === 0) && (this.results[0] instanceof Deferred)) {
					this.results[0].cancel();
				}
			},


			/**
			 *
			 */
			_pause: function () {
				/***

				Used internally to signal that it's waiting on another Deferred

				***/
				this.paused++;
			},

			/**
			 *
			 */
			_unpause: function () {
				/***

				Used internally to signal that it's no longer waiting on another
				Deferred.

				***/
				this.paused--;
				if ((this.paused === 0) && (this.fired >= 0)) {
					this._fire();
				}
			},

			/**
			 *
			 */
			_continue: function (res) {
				/***

				Used internally when a dependent deferred fires.

				***/
				this._resback(res);
				this._unpause();
			},

			/**
			 *
			 */
			_resback: function (res) {
				/***

				The primitive that means either callback or errback

				***/
				this.fired = ((res instanceof Error) ? 1 : 0);
				this.results[this.fired] = (this.result = res);
				this._fire();
			},

			/**
			 *
			 */
			_check: function () {
				if (this.fired !== -1) {
					if (!this.silentlyCancelled) {
						throw new Error("Already called");
					}
					this.silentlyCancelled = false;
					return;
				}
			},

			/**
			 *
			 */
			callback: function (res) {
				this._check();
				if (res instanceof Deferred) {
					throw new Error("Deferred instances can only be chained if they are the result of a callback");
				}
				this._resback(res);
			},

			/**
			 *
			 */
			errback: function (res) {
				this._check();
				if (res instanceof Deferred) {
					throw new Error("Deferred instances can only be chained if they are the result of a callback");
				}
				if (!(res instanceof Error)) {
					res = new Error(res);
				}
				this._resback(res);
			},

			addBoth: function (fn) {
				return this.addCallbacks(fn, fn);
			},

			addCallback: function (fn) {
				return this.addCallbacks(fn, null);
			},

			addErrback: function (fn) {
				return this.addCallbacks(null, fn);
			},

			addCallbacks: function (cb, eb) {
				if (this.chained) {
					throw new Error("Chained Deferreds can not be re-used");
				}
				this.chain.push([cb, eb]);
				if (this.fired >= 0) {
					this._fire();
				}
				return this;
			},

			_fire: function () {
				/***

				Used internally to exhaust the callback sequence when a result
				is available.

				***/
				var chain = this.chain;
				var fired = this.fired;
				var res = this.results[fired];
				var self = this;
				var cb = null;

				function fcb(res) {
					self._continue(res);
				}

				while (chain.length > 0 && this.paused === 0) {
					// Array
					var pair = chain.shift();
					var f = pair[fired];
					if (f === null) {
						continue;
					}
					try {
						res = f(res);
						fired = ((res instanceof Error) ? 1 : 0);
						if (res instanceof Deferred) {
							cb = fcb;
							this._pause();
						}
					} catch (err) {
						fired = 1;
						if (!(err instanceof Error)) {
							res = new Error(err);
						} else {
							res = err;
						}
					}
				}
				this.fired = fired;
				this.results[fired] = res;

				if(fired === 1 && chain.length === 0 && this.reported === undefined) {
					this.reported = true;
					Deferred.unhandled_error(this);
				}

				if (cb && this.paused) {
					// this is for "tail recursion" in case the dependent deferred
					// is already fired
					res.addBoth(cb);
					res.chained = true;
				}
			}
		},

		statics: {

			/**
			 *
			 * @param deferred
			 */
			unhandled_error: function(deferred) {
				var e = deferred.results[1];
				console.error("Uncaught deferred exception:", e.message, e, mixIn(e));
/*
				if(e.callStack) {
					if(deferred.callStack) {
						e.callStack.splice(0, 0, DeferredSeperator);
						deferred.callStack.forEach(function(call) {
							var args = [0, 0].concat(call);
							Array.prototype.splice.apply(e.callStack, args);
						});
					}
					Method.stack2console("Uncaught deferred exception: " + e.message, e.callStack);
				} else {
					console.error("Uncaught deferred exception: ", e.message, e, mixIn(e));
				}
*/
			},

			require: function(require, what) {
				var d = new Deferred();
				require(what, function() {
					d.callback.apply(d, arguments);
				}, function() {
					d.errback.apply(d, arguments);
				});
				return d;
			},

            waitFor: function(arr) {
                var r = new Deferred();
                var n = arr.length;
                var results = [];

                arr.forEach(function(deferred) {
                    deferred.addBoth(function(res) {
                        results.push(res);
                        if(--n === 0) {
                            r.callback(results);
                            n--; // prevent from being called again
                        }
                        return res;
                    });
                });

                if(n === 0) {
                    r.callback(results);
                }

                return r;
            }
		}

	}));
});
define('js/global',[],function() {
	return this;
});
/*!
minify.js - 2012-09-07
Author: Ralph Kazemier
Removed String.prototype.has extension. Reformated code.

jsmin.js - 2010-01-15
Author: NanaLich (http://www.cnblogs.com/NanaLich)
Another patched version for jsmin.js patched by Billy Hoffman,
this version will try to keep CR LF pairs inside the important comments
away from being changed into double LF pairs.

jsmin.js - 2009-11-05
Author: Billy Hoffman
This is a patched version of jsmin.js created by Franck Marcia which
supports important comments denoted with /*! ...
Permission is hereby granted to use the Javascript version under the same
conditions as the jsmin.js on which it is based.

jsmin.js - 2006-08-31
Author: Franck Marcia
This work is an adaptation of jsminc.c published by Douglas Crockford.
Permission is hereby granted to use the Javascript version under the same
conditions as the jsmin.c on which it is based.

jsmin.c
2006-05-04

Copyright (c) 2002 Douglas Crockford  (www.crockford.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Update:
add level:
1: minimal, keep linefeeds if single
2: normal, the standard algorithm
3: agressive, remove any linefeed and doesn't take care of potential
missing semicolons (can be regressive)
store stats
jsmin.oldSize
jsmin.newSize
*/
define('js/minify',[],function () {

    return function jsmin(comment, input, level) {

        if (input === undefined) {
            input = comment;
            comment = '';
            level = 2;
        } else if (level === undefined || level < 1 || level > 3) {
            level = 2;
        }

        if (comment.length > 0) {
            comment += '\n';
        }

        var a = '',
        b = '',
        EOF = -1,
        LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
        DIGITS = '0123456789',
        ALNUM = LETTERS + DIGITS + '_$\\',
        theLookahead = EOF;

        /* isAlphanum -- return true if the character is a letter, digit, underscore,
          dollar sign, or non-ASCII character. */

        function isAlphanum(c) {
            return c != EOF && (ALNUM.indexOf(c) > -1 || c.charCodeAt(0) > 126);
        }

        /* getc(IC) -- return the next character. Watch out for lookahead. If the
          character is a control character, translate it to a space or
          linefeed. */

        var iChar = 0,
        lInput = input.length;
        function getc() {

            var c = theLookahead;
            if (iChar == lInput) {
                return EOF;
            }
            theLookahead = EOF;
            if (c == EOF) {
                c = input.charAt(iChar);
                ++iChar;
            }
            if (c >= ' ' || c == '\n') {
                return c;
            }
            if (c == '\r') {
                return '\n';
            }
            return ' ';
        }
        function getcIC() {
            var c = theLookahead;
            if (iChar == lInput) {
                return EOF;
            }
            theLookahead = EOF;
            if (c == EOF) {
                c = input.charAt(iChar);
                ++iChar;
            }
            if (c >= ' ' || c == '\n' || c == '\r') {
                return c;
            }
            return ' ';
        }

        /* peek -- get the next character without getting it. */
        function peek() {
            theLookahead = getc();
            return theLookahead;
        }

        /* next -- get the next character, excluding comments. peek() is used to see
          if a '/' is followed by a '/' or '*'. */
        function next() {

            var c = getc();
            if (c == '/') {
                switch (peek()) {
                case '/':
                    for (;;) {
                        c = getc();
                        if (c <= '\n') {
                            return c;
                        }
                    }
                    break;
                case '*':
                    //this is a comment. What kind?
                    getc();
                    if (peek() == '!') {
                        // kill the extra one
                        getc();
                        //important comment
                        var d = '/*!';
                        for (;;) {
                            c = getcIC(); // let it know it's inside an important comment
                            switch (c) {
                            case '*':
                                if (peek() == '/') {
                                    getc();
                                    return d + '*/';
                                }
                                break;
                            case EOF:
                                throw 'Error: Unterminated comment.';
                            default:
                                //modern JS engines handle string concats much better than the
                                //array+push+join hack.
                                d += c;
                            }
                        }
                    } else {
                        //unimportant comment
                        for (;;) {
                            switch (getc()) {
                            case '*':
                                if (peek() == '/') {
                                    getc();
                                    return ' ';
                                }
                                break;
                            case EOF:
                                throw 'Error: Unterminated comment.';
                            }
                        }
                    }
                    break;
                default:
                    return c;
                }
            }
            return c;
        }

        /* action -- do something! What you do is determined by the argument:
          1   Output A. Copy B to A. Get the next B.
          2   Copy B to A. Get the next B. (Delete A).
          3   Get the next B. (Delete B).
          action treats a string as a single character. Wow!
          action recognizes a regular expression if it is preceded by ( or , or =. */
        function action(d) {

            var r = [];

            if (d == 1) {
                r.push(a);
            }

            if (d < 3) {
                a = b;
                if (a == '\'' || a == '"') {
                    for (;;) {
                        r.push(a);
                        a = getc();
                        if (a == b) {
                            break;
                        }
                        if (a <= '\n') {
                            throw 'Error: unterminated string literal: ' + a;
                        }
                        if (a == '\\') {
                            r.push(a);
                            a = getc();
                        }
                    }
                }
            }

            b = next();

            if (b == '/' && '(,=:[!&|'.indexOf(a) > -1) {
                r.push(a);
                r.push(b);
                for (;;) {
                    a = getc();
                    if (a == '/') {
                        break;
                    } else if (a == '\\') {
                        r.push(a);
                        a = getc();
                    } else if (a <= '\n') {
                        throw 'Error: unterminated Regular Expression literal';
                    }
                    r.push(a);
                }
                b = next();
            }

            return r.join('');
        }

        /* m -- Copy the input to the output, deleting the characters which are
          insignificant to JavaScript. Comments will be removed. Tabs will be
          replaced with spaces. Carriage returns will be replaced with
          linefeeds. Most spaces and linefeeds will be removed. */
        function m() {

            var r = [];
            a = '\n';

            r.push(action(3));

            while (a != EOF) {
                switch (a) {
                case ' ':
                    if (isAlphanum(b)) {
                        r.push(action(1));
                    } else {
                        r.push(action(2));
                    }
                    break;
                case '\n':
                    switch (b) {
                    case '{':
                    case '[':
                    case '(':
                    case '+':
                    case '-':
                        r.push(action(1));
                        break;
                    case ' ':
                        r.push(action(3));
                        break;
                    default:
                        if (isAlphanum(b)) {
                            r.push(action(1));
                        } else {
                            if (level == 1 && b != '\n') {
                                r.push(action(1));
                            } else {
                                r.push(action(2));
                            }
                        }
                    }
                    break;
                default:
                    switch (b) {
                    case ' ':
                        if (isAlphanum(a)) {
                            r.push(action(1));
                            break;
                        }
                        r.push(action(3));
                        break;
                    case '\n':
                        if (level == 1 && a != '\n') {
                            r.push(action(1));
                        } else {
                            switch (a) {
                            case '}':
                            case ']':
                            case ')':
                            case '+':
                            case '-':
                            case '"':
                            case '\'':
                                if (level == 3) {
                                    r.push(action(3));
                                } else {
                                    r.push(action(1));
                                }
                                break;
                            default:
                                if (isAlphanum(a)) {
                                    r.push(action(1));
                                } else {
                                    r.push(action(3));
                                }
                            }
                        }
                        break;
                    default:
                        r.push(action(1));
                        break;
                    }
                }
            }

            return r.join('');
        }

        jsmin.oldSize = input.length;
        ret = m(input);
        jsmin.newSize = ret.length;
        
        if(ret.charAt(0) === "\n") {
            ret = ret.substring(1);
        }

        return comment + ret;
    };
});
/**
 * beautify.js
 *
 * Written by Einar Lielmanis, <einars@gmail.com>
 *         http://jsbeautifier.org/
 */
define('js/beautify',[],function () {

    return function (js_source_text, options) {

        var input, output, token_text, last_type, last_text, last_word, current_mode, modes, indent_string;
        var whitespace, wordchar, punct, parser_pos, line_starters, in_case, digits;
        var prefix, token_type, do_block_just_closed, var_line, var_line_tainted, if_line_flag;
        var indent_level;

        var inside_block = [];

        var end_block_comma = false;

        inside_block.indent = function (token_text) {
            if ((last_text === ":" || token_text !== "function") && token_text.charAt(0) !== "$") {
                return;
            }

            var i = this.length - 1;
            if (this[i] === false) {
                indent();
                print_newline();
                this[i] = true;
            }
        };

        inside_block.unindent = function () {
            var i = this.length - 1;
            if (this[i] === true) {
                unindent();
                print_newline();
            }
        };

        inside_block.newline = function () {
            var i = this.length - 1;
            if (this[i] === true) {
                print_newline();
            }
        };

        options = options || {
            jso: false
        };
        var opt_indent_size = options.indent_size || 4;
        var opt_indent_char = options.indent_char || ' ';
        var opt_preserve_newlines = typeof options.preserve_newlines === 'undefined' ? true : options.preserve_newlines;
        var opt_indent_level = options.indent_level || 0; // starting indentation

        function trim_output() {
            while (output.length && (output[output.length - 1] === ' ' || output[output.length - 1] === indent_string)) {
                output.pop();
            }
        }

        function print_newline(ignore_repeated) {

            ignore_repeated = typeof ignore_repeated === 'undefined' ? true : ignore_repeated;

            if_line_flag = false;
            trim_output();

            if (!output.length) {
                return; // no newline on start of file
            }

            if (output[output.length - 1] !== "\n" || !ignore_repeated) {
                output.push("\n");
            }
            for (var i = 0; i < indent_level; i += 1) {
                output.push(indent_string);
            }
        }

        function print_space() {
            var last_output = ' ';
            if (output.length) {
                last_output = output[output.length - 1];
            }
            if (last_output !== ' ' && last_output !== '\n' && last_output !== indent_string) { // prevent occassional duplicate space
                output.push(' ');
            }
        }

        function print_token() {
            output.push(token_text);
        }

        function indent() {
            indent_level += 1;
        }

        function unindent() {
            if (indent_level) {
                indent_level -= 1;
            }
        }

        function remove_indent() {
            if (output.length && output[output.length - 1] === indent_string) {
                output.pop();
            }
        }

        function set_mode(mode) {
            modes.push(current_mode);
            current_mode = mode;
        }

        function restore_mode() {
            do_block_just_closed = current_mode === 'DO_BLOCK';
            current_mode = modes.pop();
        }

        function in_array(what, arr) {
            for (var i = 0; i < arr.length; i += 1) {
                if (arr[i] === what) {
                    return true;
                }
            }
            return false;
        }

        // Walk backwards from the colon to find a '?' (colon is part of a ternary op)
        // or a '{' (colon is part of a class literal).  Along the way, keep track of
        // the blocks and expressions we pass so we only trigger on those chars in our
        // own level, and keep track of the colons so we only trigger on the matching '?'.
        function is_ternary_op() {
            var level = 0,
            colon_count = 0;
            for (var i = output.length - 1; i >= 0; i--) {
                switch (output[i]) {
                case ':':
                    if (level === 0) {
                        colon_count++;
                    }
                    break;
                case '?':
                    if (level === 0) {
                        if (colon_count === 0) {
                            return true;
                        } else {
                            colon_count--;
                        }
                    }
                    break;
                case '{':
                    if (level === 0) {
                        return false;
                    }
                    level--;
                    break;
                case '(':
                case '[':
                    level--;
                    break;
                case ')':
                case ']':
                case '}':
                    level++;
                    break;
                }
            }
        }

        function get_next_token() {
            var n_newlines = 0;

            if (parser_pos >= input.length) {
                return ['', 'TK_EOF'];
            }

            var c = input.charAt(parser_pos);
            parser_pos += 1;

            while (in_array(c, whitespace)) {
                if (parser_pos >= input.length) {
                    return ['', 'TK_EOF'];
                }

                if (c === "\n") {
                    n_newlines += 1;
                }

                c = input.charAt(parser_pos);
                parser_pos += 1;

            }

            var wanted_newline = false;

            if (opt_preserve_newlines) {
                if (n_newlines > 1) {
                    for (var i = 0; i < 2; i += 1) {
                        print_newline(i === 0);
                    }
                }
                wanted_newline = (n_newlines === 1);
            }

            if (in_array(c, wordchar)) {
                if (parser_pos < input.length) {
                    while (in_array(input.charAt(parser_pos), wordchar)) {
                        c += input.charAt(parser_pos);
                        parser_pos += 1;
                        if (parser_pos === input.length) {
                            break;
                        }
                    }
                }

                // small and surprisingly unugly hack for 1E-10 representation
                if (parser_pos !== input.length && c.match(/^[0-9]+[Ee]$/) && (input.charAt(parser_pos) === '-' || input.charAt(parser_pos) === '+')) {

                    var sign = input.charAt(parser_pos);
                    parser_pos += 1;

                    var t = get_next_token(parser_pos);
                    c += sign + t[0];
                    return [c, 'TK_WORD'];
                }

                if (c === 'in') { // hack for 'in' operator
                    return [c, 'TK_OPERATOR'];
                }
                if (wanted_newline && last_type !== 'TK_OPERATOR' && !if_line_flag) {
                    print_newline();
                }
                return [c, 'TK_WORD'];
            }

            if (c === '(' || c === '[') {
                return [c, 'TK_START_EXPR'];
            }

            if (c === ')' || c === ']') {
                return [c, 'TK_END_EXPR'];
            }

            if (c === '{') {
                return [c, 'TK_START_BLOCK'];
            }

            if (c === '}') {
                return [c, 'TK_END_BLOCK'];
            }

            if (c === ';') {
                return [c, 'TK_SEMICOLON'];
            }

            if (c === '/') {
                var comment = '';
                // peek for comment /* ... */
                if (input.charAt(parser_pos) === '*') {
                    parser_pos += 1;
                    if (parser_pos < input.length) {
                        while (! (input.charAt(parser_pos) === '*' && input.charAt(parser_pos + 1) && input.charAt(parser_pos + 1) === '/') && parser_pos < input.length) {
                            comment += input.charAt(parser_pos);
                            parser_pos += 1;
                            if (parser_pos >= input.length) {
                                break;
                            }
                        }
                    }
                    parser_pos += 2;
                    return ['/*' + comment.replace(/\t/g, indent_string) + '*/', 'TK_BLOCK_COMMENT'];
                }
                // peek for comment // ...
                if (input.charAt(parser_pos) === '/') {
                    comment = c;
                    while (input.charAt(parser_pos) !== "\x0d" && input.charAt(parser_pos) !== "\x0a") {
                        comment += input.charAt(parser_pos);
                        parser_pos += 1;
                        if (parser_pos >= input.length) {
                            break;
                        }
                    }
                    parser_pos += 1;
                    if (wanted_newline) {
                        print_newline();
                    }
                    return [comment, 'TK_COMMENT'];
                }

            }

            if (c === "'" || // string
            c === '"' || // string
            (c === '/' && ((last_type === 'TK_WORD' && last_text === 'return') || (last_type === 'TK_START_EXPR' || last_type === 'TK_START_BLOCK' || last_type === 'TK_END_BLOCK' || last_type === 'TK_OPERATOR' || last_type === 'TK_EOF' || last_type === 'TK_SEMICOLON')))) { // regexp
                var sep = c;
                var esc = false;
                var resulting_string = c;

                if (parser_pos < input.length) {
                    if (sep === '/') {
                        //
                        // handle regexp separately...
                        //

                        var in_char_class = false;
                        while (esc || in_char_class || input.charAt(parser_pos) !== sep) {
                            resulting_string += input.charAt(parser_pos);
                            if (!esc) {
                                esc = input.charAt(parser_pos) === "\\";
                                if (input.charAt(parser_pos) === '[') {
                                    in_char_class = true;
                                } else if (input.charAt(parser_pos) === ']') {
                                    in_char_class = false;
                                }
                            } else {
                                esc = false;
                            }
                            parser_pos += 1;
                            if (parser_pos >= input.length) {
                                // incomplete string/rexp when end-of-file reached.
                                // bail out with what had been received so far.
                                return [resulting_string, 'TK_STRING'];
                            }
                        }

                    } else {
                        //
                        // and handle string also separately
                        //
                        while (esc || input.charAt(parser_pos) !== sep) {
                            resulting_string += input.charAt(parser_pos);
                            if (!esc) {
                                esc = input.charAt(parser_pos) === '\\';
                            } else {
                                esc = false;
                            }
                            parser_pos += 1;
                            if (parser_pos >= input.length) {
                                // incomplete string/rexp when end-of-file reached.
                                // bail out with what had been received so far.
                                return [resulting_string, 'TK_STRING'];
                            }
                        }
                    }

                }

                parser_pos += 1;

                resulting_string += sep;

                if (sep === '/') {
                    // regexps may have modifiers /regexp/MOD , so fetch those, too
                    while (parser_pos < input.length && in_array(input.charAt(parser_pos), wordchar)) {
                        resulting_string += input.charAt(parser_pos);
                        parser_pos += 1;
                    }
                }
                return [resulting_string, 'TK_STRING'];
            }

            if (c === '#') {
                // Spidermonkey-specific sharp variables for circular references
                // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript
                // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935
                var sharp = '#';
                if (parser_pos < input.length && in_array(input.charAt(parser_pos), digits)) {
                    do {
                        c = input.charAt(parser_pos);
                        sharp += c;
                        parser_pos += 1;
                    } while (parser_pos < input.length && c !== '#' && c !== '=');
                    if (c === '#') {
                        return [sharp, 'TK_WORD'];
                    } else {
                        return [sharp, 'TK_OPERATOR'];
                    }
                }
            }

            if (c === '<' && input.substring(parser_pos - 1, parser_pos + 3) === '<!--') {
                parser_pos += 3;
                return ['<!--', 'TK_COMMENT'];
            }

            if (c === '-' && input.substring(parser_pos - 1, parser_pos + 2) === '-->') {
                parser_pos += 2;
                if (wanted_newline) {
                    print_newline();
                }
                return ['-->', 'TK_COMMENT'];
            }

            if (in_array(c, punct)) {
                while (parser_pos < input.length && in_array(c + input.charAt(parser_pos), punct)) {
                    c += input.charAt(parser_pos);
                    parser_pos += 1;
                    if (parser_pos >= input.length) {
                        break;
                    }
                }

                return [c, 'TK_OPERATOR'];
            }

            return [c, 'TK_UNKNOWN'];
        }

        //----------------------------------

        indent_string = '';
        while (opt_indent_size > 0) {
            indent_string += opt_indent_char;
            opt_indent_size -= 1;
        }

        indent_level = opt_indent_level;

        input = js_source_text;

        last_word = ''; // last 'TK_WORD' passed
        last_type = 'TK_START_EXPR'; // last token type
        last_text = ''; // last token text
        output = [];

        do_block_just_closed = false;
        var_line = false; // currently drawing var .... ;
        var_line_tainted = false; // false: var a = 5; true: var a = 5, b = 6

        whitespace = "\n\r\t ".split('');
        wordchar = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$'.split('');
        digits = '0123456789'.split('');

        // <!-- is a special case (ok, it's a minor hack actually)
        punct = '+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! !! , : ? ^ ^= |= ::'.split(' ');

        // words which should always start on new line.
        line_starters = 'continue,try,throw,return,var,if,switch,case,default,for,while,break,function'.split(',');

        // states showing if we are currently in expression (i.e. "if" case) - 'EXPRESSION', or in usual block (like, procedure), 'BLOCK'.
        // some formatting depends on that.
        current_mode = 'BLOCK';
        modes = [current_mode];

        parser_pos = 0;
        in_case = false; // flag for parser that case/default has been processed, and next colon needs special attention
        while (true) {
            var t = get_next_token(parser_pos);
            token_text = t[0];
            token_type = t[1];
            if (token_type === 'TK_EOF') {
                break;
            }

            if (end_block_comma === true) {
                if (token_text !== '[') {
                    print_newline();
                }
                end_block_comma = false;
            }

            switch (token_type) {

            case 'TK_START_EXPR':
                var_line = false;
                set_mode('EXPRESSION');
                if (token_text === '[') {
                    inside_block.push(false);
                } else {
                    inside_block.push(undefined);
                }
                if (last_text === ';' || last_type === 'TK_START_BLOCK') {
                    print_newline();
                } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR') {
                    // do nothing on (( and )( and ][ and ]( ..
                } else if (last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {
                    print_space();
                } else if (in_array(last_word, line_starters)) {
                    print_space();
                }
                print_token();
                break;

            case 'TK_END_EXPR':
                if (token_text === ']') {
                    inside_block.unindent();
                }
                inside_block.pop();
                print_token();
                restore_mode();
                break;

            case 'TK_START_BLOCK':
                if (last_word === 'do') {
                    set_mode('DO_BLOCK');
                } else {
                    set_mode('BLOCK');
                }
                if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {
                    if (last_type === 'TK_START_BLOCK') {
                        print_newline();
                    } else {
                        print_space();
                    }
                }
                print_token();
                indent();
                break;

            case 'TK_END_BLOCK':
                if (last_type === 'TK_START_BLOCK') {
                    // nothing
                    trim_output();
                    unindent();
                } else {
                    unindent();
                    print_newline();
                }
                print_token();
                restore_mode();
                break;

            case 'TK_WORD':

                if (do_block_just_closed) {
                    // do {} ## while ()
                    print_space();
                    print_token();
                    print_space();
                    do_block_just_closed = false;
                    break;
                }

                inside_block.indent(token_text);

                if (token_text === 'case' || token_text === 'default') {
                    if (last_text === ':') {
                        // switch cases following one another
                        remove_indent();
                    } else {
                        // case statement starts in the same line where switch
                        unindent();
                        print_newline();
                        indent();
                    }
                    print_token();
                    in_case = true;
                    break;
                }

                prefix = 'NONE';

                if (last_type === 'TK_END_BLOCK') {
                    if (!in_array(token_text.toLowerCase(), ['else', 'catch', 'finally'])) {
                        prefix = 'NEWLINE';
                    } else {
                        prefix = 'SPACE';
                        print_space();
                    }
                } else if (last_type === 'TK_SEMICOLON' && (current_mode === 'BLOCK' || current_mode === 'DO_BLOCK')) {
                    prefix = 'NEWLINE';
                } else if (last_type === 'TK_SEMICOLON' && current_mode === 'EXPRESSION') {
                    prefix = 'SPACE';
                } else if (last_type === 'TK_STRING') {
                    prefix = 'NEWLINE';
                } else if (last_type === 'TK_WORD') {
                    prefix = 'SPACE';
                } else if (last_type === 'TK_START_BLOCK') {
                    prefix = 'NEWLINE';
                } else if (last_type === 'TK_END_EXPR') {
                    print_space();
                    prefix = 'NEWLINE';
                }

                if (last_type !== 'TK_END_BLOCK' && in_array(token_text.toLowerCase(), ['else', 'catch', 'finally'])) {
                    print_newline();
                } else if (in_array(token_text, line_starters) || prefix === 'NEWLINE') {
                    if (last_text === 'else') {
                        // no need to force newline on else break
                        print_space();
                    } else if ((last_type === 'TK_START_EXPR' || last_text === '=' || last_text === ',') && token_text === 'function') {
                        // no need to force newline on 'function': (function
                        // DONOTHING
                    } else if (last_type === 'TK_WORD' && (last_text === 'return' || last_text === 'throw')) {
                        // no newline between 'return nnn'
                        print_space();
                    } else if (last_type !== 'TK_END_EXPR') {
                        if ((last_type !== 'TK_START_EXPR' || token_text !== 'var') && last_text !== ':') {
                            // no need to force newline on 'var': for (var x = 0...)
                            if (token_text === 'if' && last_type === 'TK_WORD' && last_word === 'else') {
                                // no newline for } else if {
                                print_space();
                            } else {
                                print_newline();
                            }
                        }
                    } else {
                        if (in_array(token_text, line_starters) && last_text !== ')') {
                            print_newline();
                        }
                    }
                } else if (prefix === 'SPACE') {
                    print_space();
                }
                print_token();
                last_word = token_text;

                if (token_text === 'var') {
                    var_line = true;
                    var_line_tainted = false;
                }

                if (token_text === 'if' || token_text === 'else') {
                    if_line_flag = true;
                }

                break;

            case 'TK_SEMICOLON':

                print_token();
                var_line = false;
                break;

            case 'TK_STRING':

                if (last_type === 'TK_START_BLOCK' || last_type === 'TK_END_BLOCK' || last_type === 'TK_SEMICOLON') {
                    print_newline();
                } else if (last_type === 'TK_WORD') {
                    print_space();
                }
                print_token();
                break;

            case 'TK_OPERATOR':

                var start_delim = true;
                var end_delim = true;
                if (var_line && token_text !== ',') {
                    var_line_tainted = true;
                    if (token_text === ':') {
                        var_line = false;
                    }
                }
                if (var_line && token_text === ',' && current_mode === 'EXPRESSION') {
                    // do not break on comma, for(var a = 1, b = 2)
                    var_line_tainted = false;
                }

                if (token_text === ':' && in_case) {
                    print_token(); // colon really asks for separate treatment
                    print_newline();
                    in_case = false;
                    break;
                }

                if (token_text === '::') {
                    // no spaces around exotic namespacing syntax operator
                    print_token();
                    break;
                }

                if (token_text === ',') {
                    end_block_comma = last_type === 'TK_END_BLOCK';
                    if (var_line) {
                        if (var_line_tainted) {
                            print_token();
                            print_newline();
                            var_line_tainted = false;
                        } else {
                            print_token();
                            print_space();
                        }
                    } else if (last_type === 'TK_END_BLOCK') {
                        print_token();
                        print_space();
                        //print_newline();
                    } else if (options.jso === true && last_text === ')') {
                        print_token();
                        print_newline();
                    } else {
                        if (current_mode === 'BLOCK') {
                            print_token();
                            //                        print_space();
                            print_newline();
                        } else {
                            // EXPR od DO_BLOCK
                            print_token();
                            print_space();
                        }
                    }
                    inside_block.newline();

                    break;
                } else if (token_text === '--' || token_text === '++') { // unary operators special case
                    if (last_text === ';') {
                        if (current_mode === 'BLOCK') {
                            // { foo; --i }
                            print_newline();
                            start_delim = true;
                            end_delim = false;
                        } else {
                            // space for (;; ++i)
                            start_delim = true;
                            end_delim = false;
                        }
                    } else {
                        if (last_text === '{') {
                            // {--i
                            print_newline();
                        }
                        start_delim = false;
                        end_delim = false;
                    }
                } else if ((token_text === '!' || token_text === '+' || token_text === '-') && (last_text === 'return' || last_text === 'case')) {
                    start_delim = true;
                    end_delim = false;
                } else if ((token_text === '!' || token_text === '+' || token_text === '-') && last_type === 'TK_START_EXPR') {
                    // special case handling: if (!a)
                    start_delim = false;
                    end_delim = false;
                } else if (last_type === 'TK_OPERATOR') {
                    start_delim = false;
                    end_delim = false;
                } else if (last_type === 'TK_END_EXPR') {
                    start_delim = true;
                    end_delim = true;
                } else if (token_text === '.') {
                    // decimal digits or object.property
                    start_delim = false;
                    end_delim = false;

                } else if (token_text === ':') {
                    if (is_ternary_op()) {
                        start_delim = true;
                    } else {
                        start_delim = false;
                    }
                }
                if (start_delim) {
                    print_space();
                }

                print_token();

                if (end_delim) {
                    print_space();
                }
                break;

            case 'TK_BLOCK_COMMENT':

                print_newline();
                print_token();
                print_newline();
                break;

            case 'TK_COMMENT':

                // print_newline();
                print_space();
                print_token();
                print_newline();
                break;

            case 'TK_UNKNOWN':
                print_token();
                break;
            }

            last_type = token_type;
            last_text = token_text;
        }

        return output.join('').replace(/\n+$/, '');
    };

});
define('js/serialize',['require'],function(require) {

	var CIRCULAR_TOO_DEEP	= { toString: function() { return "CIRCULAR_TOO_DEEP"; }};
	var CIRCULAR_REFERENCE	= { toString: function() { return "CIRCULAR_REFERENCE"; }};
	var TOO_DEEP			= { toString: function() { return "TOO_DEEP"; }};

	Date.prototype.serializeJson = function() {
		return "" + this.getTime();
	};

	var keywords =
		("break,class,catch,const,continue,default,delete," +
			"do,else,export,for,function,if,import,in,instanceof," +
			"implements,label,let,new,package,return,super,switch," +
			"this,throw,try,typeof,var,void,while,with,yield").
		split(",");

	var serialize = {

		/**
		 *
		 */
		isKeyword: function(word) {
			return keywords.indexOf(word) !== -1;
		},

		/**
		 *
		 */
		keyNeedsEscape: function(key) {
			var m = /^[A-Za-z_][A-Za-z_0-9]*$/.exec(key);
			if(m === null) {
				return true;
			}
			return serialize.isKeyword(key);
		},

		/**
		 *
		 */
		serialize: function (obj, indent, objs, depth) {
			var pushed = false;
			try {
				if(depth !== undefined) {
					--depth;
				}
				if(typeof obj === "object") {
					if(objs !== undefined) {
						if(objs.indexOf(obj) !== -1) {
							if(depth !== undefined) {
								if(depth === 0) {
									return CIRCULAR_TOO_DEEP;
								}
							} else {
								return CIRCULAR_REFERENCE;
							}
						}
						objs.push(obj);
						pushed = true;
					} else if(depth === 0) {
						return TOO_DEEP;
					}
				}

			    var nextIndent = indent !== undefined ? indent + "	" : indent;
			    if (obj === undefined) {
			        return "undefined";
			    }
			    if (obj === null) {
			        return "null";
			    }

			    var type = typeof obj;
			    if (type === "number" || type === "boolean") {
			        return "" + obj;
			    }
			    if (type === "string") {
			        return String.escape(obj);
			    }
			    if (type === "function") {
		//	    	var comm = obj['comment'];
		        	var r = obj.toString().split("\n");
		        	if(r[0].length === 0) {
		        		r.splice(0, 1);
		        	}
		        	if(r[r.length - 1].length === 0) {
		        		r.splice(r.length - 1, 1);
		        	}
			        if (indent !== undefined) {
			        	r = r.join("\n" + indent);
			        } else {
			        	r = r.join("\n");
			        }
		//	        if(comm === undefined) {
		//		        return r.join("\n");
		//	        }
		//	        comm = String.format("/*\n * %s\n */", comm.split("\n").join("\n * "));
		//	        return comm + "\n" + r.join("\n");
					return r;
			    }
			    if(obj.serializeJson) {
			    	return obj.serializeJson();
			    }
			    var me = arguments.callee;
			    if (obj instanceof Array) {
			        var res = [];
			        for (var i = 0, l = obj.length; i < l; ++i) {
			            var val = me(obj[i], nextIndent, objs, depth);
			            if(val === CIRCULAR_TOO_DEEP || val === CIRCULAR_REFERENCE || val === TOO_DEEP) {
			            	res.push(String.format("%s", val.__name));
			            } else {
			            	res.push(typeof val === "string" ? val : "undefined");
			            }
			        }
			        return String.format("[%s%s%s%s]",
			        	nextIndent ? "\n" : "",
			        	nextIndent || "",
			        	res.join(nextIndent ? ",\n" + nextIndent : ","),
			        	nextIndent ? "\n" + indent : "");
			    } else {
			    	res = [];
			        for (var k in obj) {
			        	if(1) {//obj.hasOwnProperty(k)) {
				            var key;
				            if (typeof k === "number") {
				                key = String.format("\"%s\"", k);
				                val = me(obj[k], nextIndent, objs, depth);
				            } else if (typeof k === "string") {
				                key = serialize.keyNeedsEscape(k) ? String.escape(k) : k;
				                val = me(obj[k], nextIndent, objs, depth);
				            } else {
				            }
				            if(val === CIRCULAR_TOO_DEEP || val === CIRCULAR_REFERENCE || val === TOO_DEEP) {
				            	res.push(String.format("%s:%s", key, val.__name));
				            } else if (typeof val === "string") {
				                res.push(String.format("%s:%s", key, val));
				            } else {
				            }
				        }
			        }
			        return String.format("{%s%s%s%s}",
			        	nextIndent ? "\n" : "",
			        	nextIndent || "",
			        	res.join(nextIndent ? ",\n" + nextIndent : ","),
			        	nextIndent ? "\n" + indent : "");
			    }
			} finally {
				if(pushed) {
					objs.pop();
				}
			}
		}
	};

	return serialize;

});
define('js/_js',['require','./extensions','./global','./minify','./mixIn','./beautify','./nameOf','./serialize','./defineClass','./Method','./JsObject'],function(require) {

	require("./extensions");

	var global = require("./global");
	var minify = require("./minify");
	var mixIn = require("./mixIn");
	var beautify = require("./beautify");
	var nameOf = require("./nameOf");
	var serialize = require("./serialize");
	var defineClass = require("./defineClass");
	var Method = require("./Method");
//	var js;

    var JsObject = require("./JsObject");

	return (js = {

		// handy-dandy
		inh: Method.callInherited,
		inherited: Method.callInherited,
		override: Method.override,
		connect: Method.connect,
		disconnect: Method.disconnect,
		args2strs: Method.args2strs,
		copy_args: Method.copy_args,
		
		$: JsObject.$,

		b: beautify,
		m: minify,
		sj: serialize.serialize,
		nameOf: nameOf,
		defineClass: defineClass,
		mixIn: mixIn,

		/**
		 *
		 * @param name
		 * @param obj
		 * @param defaultValue
		 * @returns
		 */
		get: function(name, obj, defaultValue) {
			obj = obj || global;
			name = name.split(".");
			for( var i = 0, l = name.length - 1; i < l; ++i) {
				obj = obj[name[i]];
				if(obj === null || obj === undefined || (typeof obj !== "object" && typeof obj !== "function")) {
					return defaultValue !== undefined ? js.set(name.join("."), defaultValue, obj) : undefined;
				}
			}

			if(defaultValue !== undefined && obj[name[l]] === undefined) {
				return js.set(name.join("."), defaultValue, obj);
			}

			return obj[name[l]];
		},

		/**
		 *
		 * @param name
		 * @param value
		 * @param obj
		 * @returns
		 */
		set: function(name, value, obj) {
			obj = obj || global;
			name = name.split(".");
			for( var i = 0, l = name.length - 1; i < l; ++i) {
				if(obj[name[i]] === undefined) {
					obj[name[i]] = {};
				}
				obj = obj[name[i]];
			}

			return (obj[name[name.length - 1]] = value);
		},

		/**
		 *
		 * @param base
		 * @param uri
		 * @param first
		 * @returns
		 */
		normalize: function(base, uri, first) {
			if(uri.charAt(0) !== ".") {
				return uri;
			}

			var r = base.split("/");
			r.pop();

			uri.split("/").forEach(function(part) {
				if(part === "..") {
					r.pop();
				} else if(part !== ".") {
					r.push(part);
				}
			});

			return r.join("/");
		},

		/**
		 *
		 * @param path
		 * @param count
		 * @returns
		 */
		up: function(path, count) {
			count = count || 1;
			path = path.split("/");
			while(count--) {
				path.pop();
			}
			return path.join("/");
		},

		/**
		 *
		 * @param prototype
		 * @param obj
		 * @returns
		 */
		extend: function(prototype, obj) {
			return js.mixIn(Object.create(prototype), obj);
		},

		/**
		 * @param obj
		 * @param f
		 * @param mustHaveOwnProperty
		 */
		forEach: function(obj, f, mustHaveOwnProperty) {
			for( var k in obj) {
				if(mustHaveOwnProperty === false || obj.hasOwnProperty(k)) {
					var value = obj[k];
					if((value = f(value)) !== undefined) {
						return value;
					}
				}
			}
		},

		/**
		 *
		 * @param obj
		 * @returns {Array}
		 */
		keys: function(obj, mustHaveOwnProperty) {
			var r = [];
			for( var k in obj) {
				if(mustHaveOwnProperty !== true || obj.hasOwnProperty(k)) {
					r.push(k);
				}
			}
			return r;
		},

		values: function(obj) {
			var arr = [];
			for(var k in obj) {
				arr.push(obj[k]);
			}
			return arr;
		},

		/**
		 *
		 */
		str2obj: function(str) {
			var attrs = str.split(";");
			var obj = {};
			for( var i = 0, l = attrs.length; i < l; ++i) {
				if(attrs[i].indexOf(":") !== -1) {
					var kv = attrs[i].split(":");
					var key = String.trim(kv[0]);
					var value = String.trim(kv[1]);
					obj[key] = value;
				}
			}
			return obj;
		},

		/**
		 *
		 * @param obj
		 * @returns {___anonymous2972_2973}
		 */
		clone: function(obj) {
			var o = {};
			for( var k in obj) {
				if(obj[k] !== null && typeof obj[k] === "object") {
					o[k] = js.clone(obj[k]);
				} else {
					o[k] = obj[k];
				}
			}
			return o;
		},

		/**
		 *
		 */
		equals: function(obj1, obj2, recursive) {
			if(obj1 === obj2) {
				// console.log("===");
				return true;
			}

			if(obj1 instanceof Date) {
				if(obj2 instanceof Date) {
					// console.log("Date.prototype.getTime()");
					return obj1.getTime() === obj2.getTime();
				}
				return false;
			}

			var t1 = typeof obj1;
			var t2 = typeof obj2;

			if(t1 !== t2) {
				// console.log("types differ");
				return false;
			}

			if(obj1 === undefined || obj1 === null || obj2 === undefined || obj2 === null) {
				// console.log("typeof null");
				return false;
			}

			if(t1 === "function") {
				// console.log("function");
				return recursive !== true && obj1.toString() === obj2.toString();
			}

			if(t1 === "object") {

				if(t1.length !== t2.length) {
					// console.log("array or object, length must the same");
					return false;
				}

				var keys = js.keys(obj1);
				if(keys.length !== js.keys(obj2).length) {
					// console.log("keys differ");
					return false;
				}

				for( var v in obj2) {
					if(obj2.hasOwnProperty(v)) {
						var value1 = obj1[v];
						if(value1 !== undefined || keys.indexOf(v) !== -1) {
							var value2 = obj2[v];
							if(value1 !== value2 && (recursive !== true || !js.equals(value1, obj2[v], true))) {
								// console.log(String.format("%s differs", v));
								return false;
							}
						} else {
							// console.log(String.format("%s missing", v));
							return false;
						}
					}
				}
				return true;
			}

			// console.log("types are the same, but values differ");
			return false;
		},

		/**
		 *
		 * @param deferred
		 * @param callback
		 * @param errback
		 */
		d: function(deferred, callback, errback, option) {
			if(typeof errback === "string") {
				option = errback;
				errback = undefined;
			}
			if(callback) {
				if(!errback) {
					if(option === "both") {
						deferred.addBoth(callback);
					} else {
						deferred.addCallback(callback);
					}
				} else {
					deferred.addCallbacks(callback, errback);
				}
			} else if(errback) {
				deferred.addErrback(errback);
			}
			return deferred;
		},

		/**
		 *
		 * @param f
		 * @param ms
		 * @returns
		 */
		setTimeout: function(f, ms) {
			return window.setTimeout(f, ms);
		},

		/**
		 *
		 * @param id
		 * @returns
		 */
		clearTimeout: function(id) {
			return window.clearTimeout(id);
		}
	});
});
define('js/referenceClass',["js/Class"], function(Class) {

	return {

		/**
		 * @overrides http://requirejs.org/docs/plugins.html#apiload
		 * @param name
		 * @param parentRequire
		 * @param load
		 * @param config
		 * @returns
		 */
		load: function(name, parentRequire, load, config) {
			load(Class.reference(name));
		},

		/**
		 * @overrides http://requirejs.org/docs/plugins.html#apinormalize
		 * @param name
		 * @param normalize
		 * @returns
		 */
		normalize: function(name, normalize) {
			return normalize(name);
		}
	};

});

define('js/Enum',['require'],function(require) {

	function Enum(name, values) {
		if(values instanceof Array) {
			var arr = values;
			values = {};
			for(var i = 0; i < arr.length; ++i) {
				values[arr[i]] = arr[i];
			}
		}
		this.values = values;
		this.name = name;
	}

	Enum.prototype.nameOf = function(value) {
		for(var k in this.values) {
			if(this.values[k] === value) {
				return k;
			}
		}
	};

	Enum.prototype.valueOf = function(name) {
		return this.values[name];
	};

	return Enum;
});


define('js',['require','js/_js','js/Method','js/Class','js/JsObject','js/Type','js/referenceClass!./js/Property','js/Enum'],function(require) {

	var js = require("js/_js");
	var Method = require("js/Method");
	var Class = require("js/Class");
	var JsObject = require("js/JsObject");
	var Type = require("js/Type");
	var Property = require("js/referenceClass!./js/Property");
	var Enum = require("js/Enum");

	return js.mixIn(js, {
		Method: Method,
		Class: Class,
		Object: JsObject,
		Type: Type,
		Property: Property,
		Enum: Enum,

		cs: function() {
			return Method.getCallStack();
		}
	});

});
define('cavalion.org/util/Browser',['require'],function(require) {

	var BrowserDetect = {

		/**
		 *
		 */
		init: function () {
			this.browser = this.searchString(this.dataBrowser) || "An unknown browser";
			this.version = this.searchVersion(navigator.userAgent)
				|| this.searchVersion(navigator.appVersion)
				|| "an unknown version";
			this.OS = this.searchString(this.dataOS) || "an unknown OS";
		},

		/**
		 *
		 * @param data
		 * @returns
		 */
		searchString: function (data) {
			for (var i=0;i<data.length;i++)	{
				var dataString = data[i].string;
				var dataProp = data[i].prop;
				this.versionSearchString = data[i].versionSearch || data[i].identity;
				if (dataString) {
					if (dataString.indexOf(data[i].subString) != -1)
						return data[i].identity;
				}
				else if (dataProp)
					return data[i].identity;
			}
		},

		/**
		 *
		 * @param dataString
		 * @returns
		 */
		searchVersion: function (dataString) {
			var index = dataString.indexOf(this.versionSearchString);
			if (index == -1) return;
			return parseFloat(dataString.substring(index+this.versionSearchString.length+1));
		},

		/**
		 *
		 */
		dataBrowser: [
			{
				string: navigator.userAgent,
				subString: "Chrome",
				identity: "Chrome"
			},
			{ 	string: navigator.userAgent,
				subString: "OmniWeb",
				versionSearch: "OmniWeb/",
				identity: "OmniWeb"
			},
			{
				string: navigator.vendor,
				subString: "Apple",
				identity: "Safari",
				versionSearch: "Version"
			},
			{
				prop: window.opera,
				identity: "Opera",
				versionSearch: "Version"
			},
			{
				string: navigator.vendor,
				subString: "iCab",
				identity: "iCab"
			},
			{
				string: navigator.vendor,
				subString: "KDE",
				identity: "Konqueror"
			},
			{
				string: navigator.userAgent,
				subString: "Firefox",
				identity: "Firefox"
			},
			{
				string: navigator.vendor,
				subString: "Camino",
				identity: "Camino"
			},
			{		// for newer Netscapes (6+)
				string: navigator.userAgent,
				subString: "Netscape",
				identity: "Netscape"
			},
			{
				string: navigator.userAgent,
				subString: "MSIE",
				identity: "Explorer",
				versionSearch: "MSIE"
			},
			{
				string: navigator.userAgent,
				subString: "Gecko",
				identity: "Mozilla",
				versionSearch: "rv"
			},
			{ 		// for older Netscapes (4-)
				string: navigator.userAgent,
				subString: "Mozilla",
				identity: "Netscape",
				versionSearch: "Mozilla"
			}
		],
		dataOS : [
			{
				string: navigator.platform,
				subString: "Win",
				identity: "Windows"
			},
			{
				string: navigator.platform,
				subString: "Mac",
				identity: "Mac"
			},
			{
                string: navigator.userAgent,
                subString: "iPhone",
                identity: "iPhone"
		    },
			{
                string: navigator.userAgent,
                subString: "iPad",
                identity: "iPad"
		    },
			{
                string: navigator.platform,
                subString: "Linux",
                identity: "Linux"
			}
		]

	};
	BrowserDetect.init();

	var Browser = {
		safari: BrowserDetect.browser === "Safari",
		chrome: BrowserDetect.browser === "Chrome",
		ie: BrowserDetect.browser === "Explorer",
		mozilla: BrowserDetect.browser === "Firefox",
		ios: BrowserDetect.OS.indexOf("iP") === 0,
		ipad: BrowserDetect.OS === "iPad",
		iphone: BrowserDetect.OS === "iPhone",
		win: BrowserDetect.OS === "Windows",
		mac: BrowserDetect.OS === "Mac",
		_: BrowserDetect
	};

	Browser.webkit = Browser.safari || Browser.chrome;
	Browser.firefox = Browser.mozilla;

	return Browser;
});
define('cavalion.org/util/HtmlElement',['require','./Browser'],function(require) {

	var Browser = require("./Browser");

	var HtmlElement = {

		defaultComputedStyleObj : {
			getPropertyValue : function() {
			}
		},
		toSelectorCase : function(selector) {
			/**
			 * Taken from dojo
			 *
			 * @param {String}
			 *            selector
			 */
			return selector.replace(/([A-Z])/g, "-$1").toLowerCase();
		},
		toCamelCase : function(selector) {
			/**
			 * Taken from dojo
			 *
			 * @param {String}
			 *            selector
			 */
			var arr = selector.split("-"), cc = arr[0];
			for (var i = 1, l = arr.length; i < l; i++) {
				cc += arr[i].charAt(0).toUpperCase() + arr[i].substring(1);
			}
			return cc;
		},
		addClass : function(node, className) {
			if (node.className !== "") {
				node.className = node.className + " " + className;
			} else {
				node.className = className;
			}
		},
		addClasses : function(node, classes) {
			if (classes instanceof Array) {
				classes = classes.join(" ");
			}
			node.className = node.className + " " + classes;
		},
		removeClass : function(node, className) {
			var classes = node.className.split(" ");
			while ((i = classes.indexOf(className)) !== -1) {
				classes.splice(i, 1);
			}
			node.className = classes.join(" ");
		},
		removeClasses : function(node, classes) {
			/**
			 *
			 * @param node
			 * @param classes
			 */
			var classes_ = node.className.split(" ");
			classes.split(" ").forEach(function(className) {
				var i = classes_.indexOf(className);
				if (i !== -1) {
					classes_.splice(i, 1);
				}
			});
			node.className = classes_.join(" ");
		},
		replaceClass: function(node, find, replace) {
			/**
			 * @param node
			 * @param find
			 * @param replace
			 */
			var classes = node.className.split(" ");
			classes.map(function(cls) {
				return cls === find ? replace : cls;
			});
			node.className = classes.join(" ");
		},
		hasClass : function(node, className) {
			var cn = " " + node.className + " ";
			return cn.indexOf(" " + className + " ") !== -1;
		},
		toggleClass: function(node, className) {
			if(HtmlElement.hasClass(node, className)) {
				HtmlElement.removeClass(node, className);
			} else {
				HtmlElement.addClass(node, className);
			}
		},
		hasParent : function(node, parentNode) {
			node = node.parentNode;
			while (node !== null && node !== parentNode) {
				node = node.parentNode;
			}
			return node === parentNode;
		},
		clearSelection : function(element) {
			try {
				if (window.getSelection) {
					if (Browser.safari) {
						window.getSelection().collapse();
					} else {
						window.getSelection().removeAllRanges();
					}
				} else if (document.selection) {
					if (document.selection.empty) {
						document.selection.empty();
					} else if (document.selection.clear) {
						document.selection.clear();
					}
				}
				return true;
			} catch (e) {
				console.log(new Error("HtmlElement.clearSelection broken", e));
			}
			return false;
		},
		disableSelection : function(element) {
			// FIXME Write a foolproof one! push/pop webkitUserSelect value
			element = element || document.body;

			if (element['HtmlElement.disableSelectionCount'] === undefined) {
				element['HtmlElement.disableSelectionCount'] = 0;
			} else {
				element['HtmlElement.disableSelectionCount']++;
			}

			this.clearSelection(element);

			var h = Browser;
			if (h.mozilla) {
				element.style.MozUserSelect = "none";
			} else if (h.webkit) {
				// element.style.KhtmlUserSelect = "none";
				element.style['-webkit-user-select'] = "none";
				element.style['user-select'] = "none";
			} else if (h.ie) {
				element.unselectable = "on";
			} else {
				return false;
			}
			return true;
		},
		enableSelection : function(element) {
			element = element || document.body;

			if (element['HtmlElement.disableSelectionCount'] !== undefined) {
				if (--element['HtmlElement.disableSelectionCount'] === 0) {
					delete element['HtmlElement.disableSelectionCount'];
				}
			} else {
				throw new Error(
						"Incorrect usage, HtmlElement.disableSelection not called");
			}
			// TODO Shouldn't we return in case the counter > 0?
			var h = Browser;
			if (h.mozilla) {
				element.style.MozUserSelect = "";
			} else if (h.webkit) {
				// element.style.KhtmlUserSelect = "";
				element.style['-webkit-user-select'] = "";
				element.style['user-select'] = "";
			} else if (h.ie) {
				element.unselectable = "off";
			} else {
				return false;
			}
			return true;
		},
		getChildNode : function(node, index1 /* , ... , indexN */) {
			for (var i = 1; i < arguments.length && node !== null; ++i) {
				node = node.childNodes[arguments[i]] || null;
			}
			return node;
		},
		isVisible : function(el) {
			/**
			 * Credit: http://stackoverflow.com/a/15203639
			 *
			 * @param el
			 * @returns {Boolean}
			 */
			var eap, rect = el.getBoundingClientRect(), docEl = document.documentElement, vWidth = window.innerWidth
					|| docEl.clientWidth, vHeight = window.innerHeight
					|| docEl.clientHeight, efp = function(x, y) {
				return document.elementFromPoint(x, y);
			}, contains = "contains" in el ? "contains"
					: "compareDocumentPosition", has = contains == "contains" ? 1
					: 0x10;

			// Return false if it's not in the viewport
			if (rect.right < 0 || rect.bottom < 0 || rect.left > vWidth
					|| rect.top > vHeight)
				return false;

			// Return true if any of its four corners are visible
			return ((eap = efp(rect.left, rect.top)) == el
					|| el[contains](eap) == has
					|| (eap = efp(rect.right, rect.top)) == el
					|| el[contains](eap) == has
					|| (eap = efp(rect.right, rect.bottom)) == el
					|| el[contains](eap) == has
					|| (eap = efp(rect.left, rect.bottom)) == el || el[contains]
					(eap) == has);
		},
		getComputedStyle : function(node) {
			/**
			 * Taken from dojo
			 *
			 * @param {HtmlElement}
			 *            node
			 */
			if (node.style) {
				if (!Browser.ie && document.defaultView) {
					// Safari, Opera, Firefox
					try {
						var cs = document.defaultView.getComputedStyle(node,
								null);
						if (cs) {
							return cs;
						}
					} catch (e) {
						if (node.style.getPropertyValue) {
							return node.style;
						}
					}
				} else if (node.currentStyle) {
					// IE
					return {
						cs : node.currentStyle,
						getPropertyValue : function(cssSelector) {
							var property = HtmlElement.toCamelCase(cssSelector);
							return this.cs[property];
						}
					};
				}
				if (node.style.getPropertyValue) {
					return node.style;
				}
			}
			return HtmlElement.defaultComputedStyleObj;
			// throw new Error("Could not determine style object");
		},
		sumAncestorproperties : function(node, prop) {
			/**
			 *
			 * @param {HtmlElement}
			 *            node
			 * @param {String}
			 *            prop
			 */
			var retVal = 0;
			while (node !== null) {
				var val = node[prop];
				if (val !== undefined && val !== null) {
					retVal += val - 0;
				}
				node = node.parentNode;
			}
			return retVal;
		},
		getAbsolutePosition : function(node, includeScroll, computedStyle) {
			/**
			 *
			 * @param {HtmlElement}
			 *            node
			 * @param {Boolean}
			 *            includeScroll
			 */
			var h = Browser;
			var doc = node.document || node.ownerDocument;
			var db = doc.body;
			var ap = {
				x : 0,
				y : 0
			};
			if (node.getBoundingClientRect) {
				var bcr = node.getBoundingClientRect();
				if (!db) {
					return ap;
				}
				if (node !== db.parentNode) {
					// huu?
					if (h.ie) {
						ap.x = bcr.left - 2;
						ap.y = bcr.top - 2;
					} else {
						ap.x = bcr.left;
						ap.y = bcr.top;
					}
				}
			} else {
				// console.log("!getBoundingClientRect")
				if (node.offsetParent) {
					var endelement;
					if (h.safari
							&& node.style.getPropertyValue("position") === "absolute"
							&& (node.parentelement === db)) {
						endelement = db;
					} else {
						endelement = db.parentelement;
					}
					if (node.parentelement !== db) {
						ap.x -= this.sumAncestorProperties(node.parentNode,
								"scrollLeft");
						ap.y -= this.sumAncestorProperties(node.parentNode,
								"scrollTop");
					}
					do {
						var n = node.offsetLeft;
						ap.x += isNaN(n) ? 0 : n;
						var m = node.offsetTop;
						ap.y += isNaN(m) ? 0 : m;

						node = node.offsetParent;

						if (!h.opera && node !== null) {
							var cs = computedStyle
									|| HtmlElement.getComputedStyle(node);
							var bl = parseInt(cs
									.getPropertyValue("border-left-width"), 10) || 0;
							var bt = parseInt(cs
									.getPropertyValue("border-top-width"), 10) || 0;

							// huu?
							if (h.mozilla
									&& cs.getPropertyValue("overflow") === "auto") {
								bl *= 2;
								bt *= 2;
							}

							// console.logf(">> %d %d %d %d", n, m, bl, bt);
							ap.x += bl;
							ap.y += bt;
						} else {
							// console.logf(">> %d %d - -", n, m);
						}
					} while (node !== endelement && (node !== null));
				} else if (node.x && node.y) {
					ap.x += isNaN(node.x) ? 0 : node.x;
					ap.y += isNaN(node.y) ? 0 : node.y;
				}
			}
			if (node !== db.parentNode) {
				ap.x += window.pageXOffset || doc.documentElement.scrollLeft
						|| doc.body.scrollLeft || 0;
				ap.y += window.pageYOffset || doc.documentElement.scrollTop
						|| doc.body.scrollTop || 0;
			}
			return ap;
		},
		getAbsoluteRect : function(node, includeScroll) {
			/**
			 *
			 * @param node
			 * @param includeScroll
			 */
			var cs = HtmlElement.getComputedStyle(node);
			var ap = this.getAbsolutePosition(node, includeScroll === true, cs);

			var ow = node.offsetWidth;
			var oh = node.offsetHeight;

			var bl = parseInt(cs.getPropertyValue("border-left-width"), 10) || 0;
			var br = parseInt(cs.getPropertyValue("border-right-width"), 10) || 0;
			var bt = parseInt(cs.getPropertyValue("border-top-width"), 10) || 0;
			var bb = parseInt(cs.getPropertyValue("border-bottom-width"), 10) || 0;

			var ml = parseInt(cs.getPropertyValue("margin-left"), 10) || 0;
			var mr = parseInt(cs.getPropertyValue("margin-right"), 10) || 0;
			var mt = parseInt(cs.getPropertyValue("margin-top"), 10) || 0;
			var mb = parseInt(cs.getPropertyValue("margin-bottom"), 10) || 0;

			var pl = parseInt(cs.getPropertyValue("padding-left"), 10) || 0;
			var pr = parseInt(cs.getPropertyValue("padding-right"), 10) || 0;
			var pt = parseInt(cs.getPropertyValue("padding-top"), 10) || 0;
			var pb = parseInt(cs.getPropertyValue("padding-bottom"), 10) || 0;

			var r = {
				left : ap.x - ml,
				top : ap.y - mt,
				width : ow + mr + ml,
				height : oh + mb + mt
			};

			return r;
		},
		getClientRect : function(node, includeScroll) {
			/**
			 *
			 * @param {HtmlElement}
			 *            node
			 */
			var cs = HtmlElement.getComputedStyle(node);

			var cw = node.clientWidth;
			var ch = node.clientHeight;
			var ow = node.offsetWidth;
			var oh = node.offsetHeight;
			var sw = node.scrollWidth;
			var sh = node.scrollHeight;

			var pl = parseInt(cs.getPropertyValue("padding-left"), 10);
			var pr = parseInt(cs.getPropertyValue("padding-right"), 10);

			var pt = parseInt(cs.getPropertyValue("padding-top"), 10);
			var pb = parseInt(cs.getPropertyValue("padding-bottom"), 10);

			cw = sw < cw ? cw : sw;
			ch = sh < ch ? ch : sh;

			return {
				left : pl,
				top : pt,
				width : cw - pr,
				height : ch - pb
			};
		},
		getWidth : function(node) {
			return node.offsetWidth;
		},
		getHeight : function(node) {
			return node.offsetHeight;
		}
	};

	return HtmlElement;

});
/**
 * Event.js - Taken from dojo
 */
define('cavalion.org/util/Event',['require','js','./Browser'],function(require) {

	var js = require("js");
	var Browser = require("./Browser");

	var Event = {

		currentEvent: undefined,

		keys: {
			KEY_BACKSPACE: 8,
			KEY_TAB: 9,
			KEY_ENTER: 13,
			KEY_SHIFT: 16,
			KEY_CTRL: 17,
			KEY_ALT: 18,
			KEY_PAUSE: 19,
			KEY_CAPS_LOCK: 20,
			KEY_ESCAPE: 27,
			KEY_SPACE: 32,
			KEY_PAGE_UP: 33,
			KEY_PAGE_DOWN: 34,
			KEY_END: 35,
			KEY_HOME: 36,
			KEY_LEFT_ARROW: 37,
			KEY_UP_ARROW: 38,
			KEY_RIGHT_ARROW: 39,
			KEY_DOWN_ARROW: 40,
			KEY_INSERT: 45,
			KEY_DELETE: 46,
			KEY_LEFT_WINDOW: 91,
			KEY_RIGHT_WINDOW: 92,
			KEY_SELECT: 93,
			KEY_F1: 112,
			KEY_F2: 113,
			KEY_F3: 114,
			KEY_F4: 115,
			KEY_F5: 116,
			KEY_F6: 117,
			KEY_F7: 118,
			KEY_F8: 119,
			KEY_F9: 120,
			KEY_F10: 121,
			KEY_F11: 122,
			KEY_F12: 123,
			KEY_NUM_LOCK: 144,
			KEY_SCROLL_LOCK: 145
		},

		/**
		 *
		 * @param {Object} listener
		 * @param {Object} curTarget
		 */
		callListener: function(listener, curTarget) {
			if (typeof listener !== "function") {
				throw new Error("listener not a function: " + listener);
			}
			Event.currentEvent.currentTarget = curTarget;
			return listener.call(curTarget, Event.currentEvent);
		},

		/**
		 *
		 */
		stopPropagation: function() {
			Event.currentEvent.cancelBubble = true;
		},

		/**
		 *
		 */
		preventDefault: function() {
			Event.currentEvent.returnValue = false;
		},

		/**
		 * Creates a cross browser event object
		 *
		 * @param {Object} evt
		 * @param {Object} sender
		 */
		fix: function(evt, sender) {
			if (!evt && window.event) {
				evt = js.mixIn({}, window.event);
			}

			if (evt.type && (evt.type.indexOf("key") === 0)) {
				evt.keys = this.revKeys;
				for (var key in this.keys) {
					evt[key] = this.keys[key];
				}
				if (Browser.ie && (evt.type === "keypress")) {
					evt.charCode = evt.keyCode;
				}
			}
			if (Browser.ie) {
				if (!evt.target) {
					evt.target = evt.srcElement;
				}
				if (!evt.currentTarget) {
					evt.currentTarget = sender ? sender : evt.srcElement;
				}
				if (!evt.layerX) {
					evt.layerX = evt.offsetX;
				}
				if (!evt.layerY) {
					evt.layerY = evt.offsetY;
				}
				if (!evt.pageX) {
					evt.pageX = evt.clientX + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0);
				}
				if (!evt.pageY) {
					evt.pageY = evt.clientY + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0);
				}
				if (evt.type === "mouseover") {
					evt.relatedTarget = evt.fromElement;
				}
				if (evt.type === "mouseout") {
					evt.relatedTarget = evt.toElement;
				}
				if(evt.which === undefined) {
					evt.which = evt.button === 1 ? 1 : 3;
				}
				this.currentEvent = window.event;
				evt.callListener = this.callListener;
				evt.stopPropagation = this.stopPropagation;
				evt.preventDefault = this.preventDefault;

			}

			evt.keyModifiers = this.getKeyModifiers(evt, true);
			return evt;
		},

		/**
		 *
		 * @param evt
		 */
		getKeyModifiers: function(evt, metactrl) {
			var modifiers = [];
			if(evt.shiftKey) {
				modifiers.push("shift");
			}
			if(evt.altKey) {
				modifiers.push("alt");
			}
			if(!metactrl) {
				if(evt.metaKey) {
					modifiers.push("meta");
				}
				if(evt.ctrlKey) {
					modifiers.push("ctrl");
				}
			} else if(navigator.platform === "MacIntel") {
				if((evt.metactrlKey = (evt.metaKey === true))) {
					modifiers.push("metactrl");
				}
			} else if((evt.metactrlKey = (evt.ctrlKey === true))) {
				modifiers.push("metactrl");
			}
			//console.log(modifiers, evt.ctrlKey, evt.shiftKey, evt.altKey, evt.metaKey);
			return modifiers;
		},
		
		eventModifiersMatch: function(evt, modifiers) {
			console.warn("Event.eventModifiersMatch has been deprecated, " + 
				"use Event.modifiersMatch instead.");
		    return this.modifiersMatch(this.getKeyModifiers(evt, 
		    		modifiers.indexOf("metactrl") !== -1), modifiers);
		},

		modifiersMatch: function(evt, modifiers) {
			if(!(evt instanceof window.Event)) {
				console.warn("This particular usage has been deprecated");
				return this.modifiersMatchDeprecated(evt, modifiers);
			}
			var metactrl = modifiers.indexOf("metactrl") !== -1;
			var keymods = this.getKeyModifiers(evt, metactrl);
			return keymods.sort().join(",") === modifiers.sort().join(",");
		},
		
		modifiersMatchDeprecated: function(i1, i2) {
			if((i1.indexOf("ctrl") !== -1 || i1.indexOf("meta") !== -1) && (i = i2.indexOf("metactrl")) !== -1) {
				i2[i] = navigator.platform === "MacIntel" ? "meta" : "ctrl";
			} else if((i2.indexOf("ctrl") !== -1 || i2.indexOf("meta") !== -1) && (i = i1.indexOf("metactrl")) !== -1) {
				i1[i] = navigator.platform === "MacIntel" ? "meta" : "ctrl";
			}
			return i1.sort().join(",") === i2.sort().join(",");
		}
	};

	Event.revKeys = [];

	for (var key in Event.keys) {
		Event.revKeys[Event.keys[key]] = key;
	}

	return Event;
});
define('cavalion.org/console/Node',['require','js/Class','cavalion.org/util/Browser','cavalion.org/util/HtmlElement','cavalion.org/util/Event'],function(require) {

	var Class = require("js/Class");
	var Browser = require("cavalion.org/util/Browser");
	var HtmlElement = require("cavalion.org/util/HtmlElement");
	var Event = require("cavalion.org/util/Event");
	var start = Date.now();

	var Node = {
		prototype: {
			_classes: null,
			_value: null,
			_key: null,
			_node: null,
			
			constructor: function(value, key) {
				this._value = value;
				this._key = key;
				this._time = Date.now() - start;
			},
			createNode: function() {
				var node = document.createElement("div");
				node.className = "node";
				this.initialize(node);

				if(this._key === undefined) {
					node.innerHTML = this.innerHtmlMessage();
					this.initializeTime(node.childNodes[0]);
					this.initializeMessage(node.childNodes[1]);
				} else {
					node.innerHTML = this.innerHtmlKey();
					this.initializeTime(node.childNodes[0]);
					this.initializeKey(node.childNodes[1]);
					this.initializeValue(node.childNodes[2]);
				}

				if(this._classes !== null) {
					HtmlElement.addClasses(node, this._classes);
				}

				node._line = this;

				return node;
			},
			recreateNode: function() {
				var parentNode = this._node.parentNode;
				var reference = this._node.nextSibling;
				this._node.parentNode.removeChild(this._node);
				this._node = this.createNode();
				parentNode.insertBefore(this._node, reference);
			},
			innerHtmlMessage: function() {
				return "<div class='time'></div><div class='message'></div><div class='container'></div>";
			},
			innerHtmlKey: function() {
				return "<div class='time'></div><div class='key'></div>" +
						"<div class='value'></div><div class='container'></div>";
			},
			getNode: function() {
				if(this._node === null) {
					this._node = this.createNode();
				}
				return this._node;
			},
			isExpandable: function() {
				return false;
			},
			initialize: function(node) {
				if(Browser.webkit) {
					HtmlElement.addClass(node, "webkit");
				}
				if(this._key !== undefined && this._showTime !== true) {
					HtmlElement.addClass(node, "key");
				}
				if(this.isExpandable()) {
					HtmlElement.addClass(node, "expandable");
					node.ontouchstart = node.onclick = Node.click_expand.bind(this);
				}
			},
			initializeTime: function(node) {
				if(this._key !== undefined && this._showTime !== true) {
					node.style.display = "none";
				}
				node.innerHTML = String.format("%d", this._time);
				delete this._time;
			},
			initializeKey: function(node) {
				node.innerHTML = String.format("%H: ", this._key);
			},
			initializeValue: function(node) {
			},
			initializeMessage: function(node) {
				return this.initializeValue(node);
			},
			initializeContainer: function(node) {
			}
		},
		statics: {
			create: function() { /* stub, implemented in ./Printer */ },
			click_expand: function(evt) {
				evt = Event.fix(evt);

				var node = evt.target;
				while(node !== null && node.parentNode !== this._node) {
					node = node.parentNode;
				}

				if(node !== null && !HtmlElement.hasClass(node, "container")) {
					this.initializeContainer(this._node.childNodes[this._key === undefined ? 2 : 3]);
					HtmlElement.addClass(this._node, "expanded");
					this._node.ontouchstart = this._node.onclick = Node.click_toggle_expanded.bind(this);
				}
			},
			click_toggle_expanded: function(evt) {
				evt = Event.fix(evt);

				var node = evt.target;
				while(node !== null && node.parentNode !== this._node) {
					node = node.parentNode;
				}

				if(node !== null && !HtmlElement.hasClass(node, "container")) {
					if(HtmlElement.hasClass(this._node, "expanded")) {
						HtmlElement.removeClass(this._node, "expanded");
					} else {
						if(evt.altKey === true) {
							this.recreateNode();
							this.initializeContainer(this._node.childNodes[this._key === undefined ? 2 : 3]);
							HtmlElement.addClass(this._node, "expanded");
							this._node.ontouchstart = this._node.onclick = Node.click_toggle_expanded.bind(this);
						} else {
							HtmlElement.addClass(this._node, "expanded");
						}
					}
				}
			}
		}
	};

	return (Node = Class.define(require, Node));
});
define('cavalion.org/console/node/Object',['require','js/Class','js','cavalion.org/util/HtmlElement','../Node'],function(require) {

	var Class = require("js/Class");
	var js = require("js");

	var HtmlElement = require("cavalion.org/util/HtmlElement");

	var Node = require("../Node");

	var ObjectNode = {

		inherits: Node,

		prototype: {
			_classes: ["object"],

			/**
			 * @overrides ../Node.prototype.isExpandable
			 */
			isExpandable: function() {
			 	var keys = this.getKeys();
				return js.keys(keys.own).length + js.keys(keys.proto).length > 0;
			},

			/**
			 * @overrides ../Node.prototype.initializeValue
			 */
			initializeValue: function(node) {
/**
				if(this._value instanceof js.util.printerline.Obj) {
					node.innerHTML = String.format("(%H)", js.nameOf(this._value.$));
				} else {
*/
				node.innerHTML = String.format("%H", js.nameOf(this._value)) || this._value;
/**
				}
*/
			},

			/**
			 * @overrides ../Node.prototype.initializeContainer
			 */
			initializeContainer: function(node) {
				var obj = this.getObject();
				var keys = this.getKeys();

				function add(parentNode, keys, seperator) {
					var node;
					var i, n;
					var key;
					var range = 50;

					if(keys.length > range) {
						i = 0;
						obj = {};
						while(i < keys.length) {
							j = i + range;
							if(j > keys.length) {
								j = keys.length;
							}
							key = String.format("[%s...%s]", keys[i], keys[j - 1]);
							obj[key] = {};
							for(;i < j; ++i) {
								try {
									obj[key][keys[i]] = this._value[keys[i]];
								} catch(e) {
									obj[key][keys[i]] = e;
								}
							}
						}
						keys = js.keys(obj);
					}

					for(i = 0; i < keys.length; ++i) {
						try {
							key = keys[i];
							node = Node.create(obj[key], key).getNode();
							parentNode.appendChild(node);

							if(seperator === true && i === keys.length - 1) {
								HtmlElement.addClass(node, "border-bottom");
							}
						} catch(e) {
							console.error(key, obj[key], e.message, e);
						}
					}
				}

				var proto = js.keys(keys.proto).sort();

				add.apply(this, [node, js.keys(keys.own).sort(), proto.length > 0]);
				add.apply(this, [node, proto]);
			},

			/**
			 *
			 */
			getKeys: function() {
				var obj = this.getObject();
				var r = {
					own: {},
					proto: {}
				};

				var o = 0;
				var p = 0;

				for(var k in obj) {
					if(obj.hasOwnProperty === undefined || obj.hasOwnProperty(k)) {
						try {
							r.own[k] = obj[k];
//							r.proto[k] = obj[k];
							o++;
							p++;
						} catch(e) {
							r.own[k] = e;
						}
					} else {
						try {
							r.proto[k] = obj[k];
						} catch(e) {
							r.proto[k] = e;
						}
						p++;
					}
				}

				if(p === o) {
//					r.proto = {};
				}

				return r;
			},

			/**
			 *
			 */
			getObject: function() {
				return this._value;
			}
		}
	};

	return (ObjectNode = Class.define(require, ObjectNode));
});
define('cavalion.org/console/node/Array',["require", "js/defineClass", "../Node"], function(require, Array, Node) {

	return Array(require, {

		inherits: Node,

		prototype: {
			_classes: ["array"],

			/**
			 * @overrides ../Node.prototype.isExpandable
			 */
			isExpandable: function() {
				return this.getArray().length > 0;
			},

			/**
			 * @overrides ../Node.prototype.initializeMessage
			 */
			initializeValue: function(node) {
				var arr = this.getArray();
				node.innerHTML = String.format("Array[%d]", arr.length);
			},

			/**
			 * @overrides ../Node.prototype.initializeContainer
			 */
			initializeContainer: function(node) {
				var arr = this.getArray();
				var a, i, s;

				if(arr.length > 100) {
					a = [];//.concat(arr);
					arr.forEach(function(elem) { a.push(elem); });
					for(i = 0; a.length > 0; i += 100) {
						//arr.push(a.splice(0, 100));
						s = String.format("%d-%d", i, a.length > 100 ? i + 99 : i + a.length - 1);
						node.appendChild(Node.create(a.splice(0, 100), s).getNode());
					}
				} else {
					for(i = 0; i < arr.length; ++i) {
						node.appendChild(Node.create(arr[i], i).getNode());
					}
				}
			},

			/**
			 *
			 */
			getArray: function() {
				return this._value;
			}

		}
	});
});
define('cavalion.org/console/node/OnlyKey',['require','js/Class','./Object'],function(require) {

	var Class = require("js/Class");
	var ObjectNode = require("./Object");

	var OnlyKey = {

		inherits: ObjectNode,

		prototype: {

			/**
			 * @overrides ../Node.prototype.initializeContainer
			 */
			initializeKey: function(node) {
				node.innerHTML = String.format("%H", this._key);
			},

			/**
			 * @overrides ../Node.prototype.initializeContainer
			 */
			initializeValue: function(node) {
			}
		}
	};

	return (OnlyKey = Class.define(require, OnlyKey));
});

define('cavalion.org/console/node/MethodStack',['require','js/Class','../Node','./OnlyKey'],function(require) {

	var Class = require("js/Class");

	var Node = require("../Node");
	var OnlyKey = require("./OnlyKey");

	var MethodStackNode = {

		inherits: Node,

		prototype: {

			_classes: ["array"],

			/**
			 * @overrides ../Node.prototype.isExpandable
			 */
			isExpandable: function() {
				return this._value.length > 0;
			},

			/**
			 * @overrides ../Node.prototype.initializeMessage
			 */
			initializeValue: function(node) {
				node.innerHTML = String.format("%n", this._value);
			},

			/**
			 * @overrides ../Node.prototype.initializeContainer
			 */
			initializeContainer: function(node) {
				var arr = this._value;
				for(var i = arr.length - 1; i >= 0; --i) {
					node.appendChild(Node.create(arr[i], String.format("at %n", arr[i]), OnlyKey).getNode());
				}
			}
		}
	};

	return (MethodStackNode = Class.define(require, MethodStackNode));
});
define('cavalion.org/console/node/Number',['require','js/Class','../Node'],function(require) {

	var Class = require("js/Class");
	var Node = require("../Node");

	var Number = {

		inherits: Node,

		/**
		 *
		Number: function() {

		},
 		 */

		prototype: {

			_classes: ["number"],

			/**
			 * @overrides ../Node.prototype.initializeValue
			 */
			initializeValue: function(node) {
				node.innerHTML = String.format("%s", this._value);
			}
		}

	};

	return (Number = Class.define(require, Number));
});
define('cavalion.org/console/node/Undefined',['require','js/Class','../Node'],function(require) {

	var Class = require("js/Class");
	var Node = require("../Node");

	var Undefined = {

		inherits: Node,

		/**
		 *
		Undefined: function() {
		},
 		 */

		prototype: {
			_classes: ["undefined"],

			/**
			 * @overrides ../Node.prototype.initializeValue
			 */
			initializeValue: function(node) {
				node.innerHTML = "undefined";
			}
		}
	};

	return (Undefined = Class.define(require, Undefined));
});
define('cavalion.org/console/node/Null',['require','js/Class','../Node'],function(require) {

	var Class = require("js/Class");
	var Node = require("../Node");

	var Null = {

		inherits: Node,

		prototype: {

			_classes: ["null"],

			/**
			 * @overrides ../Node.prototype.initializeValue
			 */
			initializeValue: function(node) {
				node.innerHTML = "null";
			}
		}

	};

	return (Null = Class.define(require, Null));
});
define('cavalion.org/console/node/Boolean',["require", "js/defineClass", "../Node"], function(require, Boolean, Node) {

	return Boolean(require, {
		inherits: Node,
		prototype: {
			_classes: ["boolean"],

			/**
			 * @overrides ../Node.prototype.initializeValue
			 */
			initializeValue: function(node) {
				node.innerHTML = String.format("%s", this._value);
			}
		}
	});
});
define('cavalion.org/console/node/String',['require','js/Class','../Node'],function(require) {

	var Class = require("js/Class");
	var Node = require("../Node");

	var StringNode = {

		inherits: Node,

		prototype: {

			/**
			 *
	 		 */
			constructor: function() {
				var str = String.format("%H", this.getString()).replace(/\t/g, "    ").replace(/ /g, "&nbsp;");

				this._strings = [];
				str.split("\n").forEach(function(s) {
					if(s.length > 500) {
						while(s.length > 500) {
							this._strings.push(s.substring(0, 500));
							s = s.substring(500);
						}
					}
					this._strings.push(s);
				}, this);
			},

			_classes: ["string"],
			_strings: null,

			/**
			 * @overrides ../Node.prototype.isExpandable
			 */
			isExpandable: function() {
				return this._strings.length > 1;
			},

			/**
			 * @overrides ../Node.prototype.initializeValue
			 */
			initializeValue: function(node) {
				node.innerHTML = this._strings[0];
			},

			/**
			 * @overrides ../Node.prototype.initializeContainer
			 */
			initializeContainer: function(node) {
				var html = [];
				for(var i = 1; i < this._strings.length; ++i) {
					html.push(String.format("<div class='string'>%s</div>", this._strings[i]));
				}
				node.innerHTML = html.join("");
			},

			/**
			 *
			 */
			getString: function() {
				return this._value;
			}
		}
	};

	return (StringNode = Class.define(require, StringNode));
});
define('cavalion.org/console/node/Error',['require','js/Class','js','cavalion.org/util/HtmlElement','../Node','./OnlyKey','./MethodStack'],function(require) {

	var Class = require("js/Class");
	var js = require("js");

	var HtmlElement = require("cavalion.org/util/HtmlElement");

	var Node = require("../Node");
	var OnlyKeyNode = require("./OnlyKey");
	var MethodStackNode = require("./MethodStack");

	var ErrorNode = {

		inherits: Node,

		prototype: {
			_classes: ["error"],

			/**
			 * @overrides ../Node.prototype.isExpandable
			 */
			isExpandable: function() {
				return true;
			},

			/**
			 * @overrides ../Node.prototype.initializeValue
			 */
			initializeValue: function(parentNode) {
				parentNode.innerHTML = String.format("%H", this._value.message).
					replace(/\n/g, "<br>").
					replace(/\t/g, "    ").
					replace(/ /g, "&nbsp;");
			},

			/**
			 * @overrides ../Node.prototype.initializeContainer
			 */
			initializeContainer: function(parentNode) {
				var e = this._value;
				var node;

				while(e !== undefined) {
					node = Node.create(js.mixIn({stack:e.stack}, e), "detail", OnlyKeyNode).getNode();
					node.style.marginLeft = "20px";
					parentNode.appendChild(node);
					HtmlElement.addClass(node, "border-bottom");
					if(e.methodStack !== undefined) {
						node = document.createElement("div");
						node.style.paddingLeft = "20px";
						new MethodStackNode(e.methodStack).initializeContainer(node);
						parentNode.appendChild(node);
					} else {
						node = Node.create(null, "no source available", OnlyKeyNode).getNode();
						node.style.marginLeft = "20px";
						node.style.color = "silver";
						parentNode.appendChild(node);
					}
					if((e = e.cause) !== undefined) {
						node = document.createElement("div");
						node.className = "string";
						node.innerHTML = String.format("Caused by: %s", String.format("%H", e.message));
						parentNode.appendChild(node);
					}
				}
			}
		}
	};

	return (ErrorNode = Class.define(require, ErrorNode));
});
define('cavalion.org/console/node/Function',['require','js/defineClass','js','js/Method','../Node','./OnlyKey'],function(require) {

	var FunctionNode = require("js/defineClass");
	var js = require("js");
	var Method = require("js/Method");

	var Node = require("../Node");
	var OnlyKeyNode = require("./OnlyKey");

	return (FunctionNode = FunctionNode(require, {

		inherits: Node,

		prototype: {

			_classes: ["function"],
			_keys: null,

			/**
			 * @overrides ../Node.prototype.isExpandable
			 */
			isExpandable: function() {
				return true;
			},

			/**
			 * @overrides ../Node.prototype.initializeMessage
			 */
			initializeValue: function(node) {
				node.innerHTML = String.format("%H<span class='proto'> - %H</span>",
						this._value.toString().split("\n")[0],
						js.nameOf(this._value));
			},

			/**
			 * @overrides ../Node.prototype.initializeContainer
			 */
			initializeContainer: function(parentNode) {
				var div = document.createElement("div");
				div.className = "code";
				div.innerHTML = String.format("%H", js.b("" + Method.getInherited(Function.prototype.toString).apply(this._value, []))).
					replace(/\t/g, "    ").
					replace(/ /g, "&nbsp;").
					replace(/\n/g, "<br>");
				parentNode.appendChild(div);

				var node = Node.create(this._value, "detail", OnlyKeyNode).getNode();
				parentNode.appendChild(node);
			}
		}
	}));
});
define('cavalion.org/console/node/Deferred',['require','js/Class','js','cavalion.org/util/HtmlElement','../Node','./Object','./OnlyKey'],function(require) {

	var Class = require("js/Class");
	var js = require("js");

	var HtmlElement = require("cavalion.org/util/HtmlElement");

	var Node = require("../Node");
	var ObjectNode = require("./Object");
	var OnlyKeyNode = require("./OnlyKey");

	var Deferred = {

		inherits: ObjectNode,

		prototype: {

			/**
			 * @overrides ../Node.prototype.isExpandable
			 */
			isExpandable: function() {
				return this._value.fired !== -1;
			},

			/**
			 * @overrides ../Node.prototype.initializeValue
			 */
			initializeValue: function(node) {
				var thisObj = this;

				node.innerHTML = String.format("%H", js.nameOf(this._value));

				function cb(res) {
					node.innerHTML = String.format("<div style='display: inline-block;'>%H</div>: " +
							"<div style='display: inline-block;'></div>", js.nameOf(thisObj._value));
					thisObj._line = Node.create(res);
					thisObj._line.initializeValue(node.childNodes[2]);
					HtmlElement.addClass(node.parentNode, "expandable");
					node.parentNode.ontouchstart = node.parentNode.onclick = Node.click_expand.bind(thisObj);
				}

				function suc(res) {
					cb.apply(thisObj, arguments);
					node.childNodes[0].style.color = "green";
					return res;
				}

				function err(res) {
					cb.apply(thisObj, arguments);
					//node.childNodes[0].style.color = "red";
					HtmlElement.addClass(node.parentNode, "error");
					return res;
				}

				this._value.addCallbacks(suc, err);
			},

			/**
			 * @overrides ../Node.prototype.initializeContainer
			 */
			initializeContainer: function(node) {
				var line = Node.create(this._value, String.format("%n", this._value), OnlyKeyNode);
				node.appendChild(line.getNode());

				this._line.initializeContainer(node);

				if(node.childNodes.length > 1) {
					HtmlElement.addClass(line.getNode(), "border-bottom");
				}
			},

			/**
			 * @overrides js.util.printerline.Object.prototype.getObject
			 */
			getObject: function() {
				return this._value.results[this._value.fired];
			}
		}
	};

	return (Deferred = Class.define(require, Deferred));
});
define('cavalion.org/console/Printer',['require','js/Class','js/Deferred','js/Method','js','./Node','./node/Object','./node/Array','./node/MethodStack','./node/Number','./node/Undefined','./node/Null','./node/Boolean','./node/String','./node/Error','./node/Function','./node/Deferred'],function(require) {

	var Class = require("js/Class");
	var Deferred = require("js/Deferred");
	var Method = require("js/Method");
	var js = require("js");

	var Node = require("./Node");
	var ObjectNode = require("./node/Object");
	var ArrayNode = require("./node/Array");
	var MethodStackNode = require("./node/MethodStack");
	var NumberNode = require("./node/Number");
	var UndefinedNode = require("./node/Undefined");
	var NullNode = require("./node/Null");
	var BooleanNode = require("./node/Boolean");
	var StringNode = require("./node/String");
	var ErrorNode = require("./node/Error");
	var FunctionNode = require("./node/Function");
	var DeferredNode = require("./node/Deferred");

	js.override(Node, {
		create: function(value, key, NodeClass) {
		var line;

		if(NodeClass !== undefined) {
			line = new NodeClass(value, key);
		} else if(value instanceof Error) {
			line = new ErrorNode(value, key);
//			} else if(value instanceof js.CallStack) {
//				line = new js.util.printerline.CallStack(value, key);
		} else if(value instanceof Method.CallStack) {
			line = new MethodStackNode(value, key);
		} else if(value instanceof Array) {
			line = new ArrayNode(value, key);
		} else if(value instanceof Deferred) {
			line = new DeferredNode(value, key);
		} else {
			var type = typeof value;
			if(type === "string") {
				line = new StringNode(value, key);
			} else if(type === "undefined") {
				line = new UndefinedNode(value, key);
			} else if(type === "number") {
				line = new NumberNode(value, key);
			} else if(type === "boolean") {
				line = new BooleanNode(value, key);
			} else if(type === "object") {
				if(value === null) {
					line = new NullNode(value, key);
				} else {
					line = new ObjectNode(value, key);
				}
			} else if(type === "function") {
				line = new FunctionNode(value, key);
			} else {
				line = new StringNode(js.nameOf(value), key);
			}
		}

		return line;
	}
	});

	var Printer = {

		prototype: {
			_node: null,

			constructor: function(node) {
				this.setNode(node);
			},
			setNode: function(value) {
				this._node = value;
			},
			print: function() {
				var line;

				if(arguments.length === 1) {
					line = Node.create(arguments[0]);
				} else {
					var args = js.copy_args(arguments);
					var type = typeof args[1];

					if(args.length === 1) {
						line = Node.create(args[0]);
					} else if(args.length > 2) {
						var msg = args.shift();
						line = Node.create(args, msg);
						line._showTime = true;
					} else if(type !== null && (type === "object" || type === "function")) {
						line = Node.create(args[1], args[0]);
						line._showTime = true;
					} else {
						line = Node.create(args[1], args[0]);
						line._showTime = true;
					}
				}
				this._node.appendChild(line.getNode());
				this._node.scrollTop = this._node.scrollHeight;
			}
		}
	};

	return (Printer = Class.define(require, Printer));
});
/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/v4.5.9/LICENSE
 */
(function(t,r){"use strict";if(typeof define==="function"&&define.amd){define('es5-shim',r)}else if(typeof exports==="object"){module.exports=r()}else{t.returnExports=r()}})(this,function(){var t=Array;var r=t.prototype;var e=Object;var n=e.prototype;var i=Function;var a=i.prototype;var o=String;var f=o.prototype;var u=Number;var l=u.prototype;var s=r.slice;var c=r.splice;var v=r.push;var h=r.unshift;var p=r.concat;var y=r.join;var d=a.call;var g=a.apply;var w=Math.max;var b=Math.min;var T=n.toString;var m=typeof Symbol==="function"&&typeof Symbol.toStringTag==="symbol";var D;var S=Function.prototype.toString,x=/^\s*class /,O=function isES6ClassFn(t){try{var r=S.call(t);var e=r.replace(/\/\/.*\n/g,"");var n=e.replace(/\/\*[.\s\S]*\*\//g,"");var i=n.replace(/\n/gm," ").replace(/ {2}/g," ");return x.test(i)}catch(a){return false}},j=function tryFunctionObject(t){try{if(O(t)){return false}S.call(t);return true}catch(r){return false}},E="[object Function]",I="[object GeneratorFunction]",D=function isCallable(t){if(!t){return false}if(typeof t!=="function"&&typeof t!=="object"){return false}if(m){return j(t)}if(O(t)){return false}var r=T.call(t);return r===E||r===I};var M;var U=RegExp.prototype.exec,F=function tryRegexExec(t){try{U.call(t);return true}catch(r){return false}},N="[object RegExp]";M=function isRegex(t){if(typeof t!=="object"){return false}return m?F(t):T.call(t)===N};var C;var k=String.prototype.valueOf,A=function tryStringObject(t){try{k.call(t);return true}catch(r){return false}},R="[object String]";C=function isString(t){if(typeof t==="string"){return true}if(typeof t!=="object"){return false}return m?A(t):T.call(t)===R};var P=e.defineProperty&&function(){try{var t={};e.defineProperty(t,"x",{enumerable:false,value:t});for(var r in t){return false}return t.x===t}catch(n){return false}}();var $=function(t){var r;if(P){r=function(t,r,n,i){if(!i&&r in t){return}e.defineProperty(t,r,{configurable:true,enumerable:false,writable:true,value:n})}}else{r=function(t,r,e,n){if(!n&&r in t){return}t[r]=e}}return function defineProperties(e,n,i){for(var a in n){if(t.call(n,a)){r(e,a,n[a],i)}}}}(n.hasOwnProperty);var J=function isPrimitive(t){var r=typeof t;return t===null||r!=="object"&&r!=="function"};var Y=u.isNaN||function isActualNaN(t){return t!==t};var Z={ToInteger:function ToInteger(t){var r=+t;if(Y(r)){r=0}else if(r!==0&&r!==1/0&&r!==-(1/0)){r=(r>0||-1)*Math.floor(Math.abs(r))}return r},ToPrimitive:function ToPrimitive(t){var r,e,n;if(J(t)){return t}e=t.valueOf;if(D(e)){r=e.call(t);if(J(r)){return r}}n=t.toString;if(D(n)){r=n.call(t);if(J(r)){return r}}throw new TypeError},ToObject:function(t){if(t==null){throw new TypeError("can't convert "+t+" to object")}return e(t)},ToUint32:function ToUint32(t){return t>>>0}};var z=function Empty(){};$(a,{bind:function bind(t){var r=this;if(!D(r)){throw new TypeError("Function.prototype.bind called on incompatible "+r)}var n=s.call(arguments,1);var a;var o=function(){if(this instanceof a){var i=g.call(r,this,p.call(n,s.call(arguments)));if(e(i)===i){return i}return this}else{return g.call(r,t,p.call(n,s.call(arguments)))}};var f=w(0,r.length-n.length);var u=[];for(var l=0;l<f;l++){v.call(u,"$"+l)}a=i("binder","return function ("+y.call(u,",")+"){ return binder.apply(this, arguments); }")(o);if(r.prototype){z.prototype=r.prototype;a.prototype=new z;z.prototype=null}return a}});var G=d.bind(n.hasOwnProperty);var B=d.bind(n.toString);var H=d.bind(s);var W=g.bind(s);var L=d.bind(f.slice);var X=d.bind(f.split);var q=d.bind(f.indexOf);var K=d.bind(v);var Q=d.bind(n.propertyIsEnumerable);var V=d.bind(r.sort);var _=t.isArray||function isArray(t){return B(t)==="[object Array]"};var tt=[].unshift(0)!==1;$(r,{unshift:function(){h.apply(this,arguments);return this.length}},tt);$(t,{isArray:_});var rt=e("a");var et=rt[0]!=="a"||!(0 in rt);var nt=function properlyBoxed(t){var r=true;var e=true;var n=false;if(t){try{t.call("foo",function(t,e,n){if(typeof n!=="object"){r=false}});t.call([1],function(){"use strict";e=typeof this==="string"},"x")}catch(i){n=true}}return!!t&&!n&&r&&e};$(r,{forEach:function forEach(t){var r=Z.ToObject(this);var e=et&&C(this)?X(this,""):r;var n=-1;var i=Z.ToUint32(e.length);var a;if(arguments.length>1){a=arguments[1]}if(!D(t)){throw new TypeError("Array.prototype.forEach callback must be a function")}while(++n<i){if(n in e){if(typeof a==="undefined"){t(e[n],n,r)}else{t.call(a,e[n],n,r)}}}}},!nt(r.forEach));$(r,{map:function map(r){var e=Z.ToObject(this);var n=et&&C(this)?X(this,""):e;var i=Z.ToUint32(n.length);var a=t(i);var o;if(arguments.length>1){o=arguments[1]}if(!D(r)){throw new TypeError("Array.prototype.map callback must be a function")}for(var f=0;f<i;f++){if(f in n){if(typeof o==="undefined"){a[f]=r(n[f],f,e)}else{a[f]=r.call(o,n[f],f,e)}}}return a}},!nt(r.map));$(r,{filter:function filter(t){var r=Z.ToObject(this);var e=et&&C(this)?X(this,""):r;var n=Z.ToUint32(e.length);var i=[];var a;var o;if(arguments.length>1){o=arguments[1]}if(!D(t)){throw new TypeError("Array.prototype.filter callback must be a function")}for(var f=0;f<n;f++){if(f in e){a=e[f];if(typeof o==="undefined"?t(a,f,r):t.call(o,a,f,r)){K(i,a)}}}return i}},!nt(r.filter));$(r,{every:function every(t){var r=Z.ToObject(this);var e=et&&C(this)?X(this,""):r;var n=Z.ToUint32(e.length);var i;if(arguments.length>1){i=arguments[1]}if(!D(t)){throw new TypeError("Array.prototype.every callback must be a function")}for(var a=0;a<n;a++){if(a in e&&!(typeof i==="undefined"?t(e[a],a,r):t.call(i,e[a],a,r))){return false}}return true}},!nt(r.every));$(r,{some:function some(t){var r=Z.ToObject(this);var e=et&&C(this)?X(this,""):r;var n=Z.ToUint32(e.length);var i;if(arguments.length>1){i=arguments[1]}if(!D(t)){throw new TypeError("Array.prototype.some callback must be a function")}for(var a=0;a<n;a++){if(a in e&&(typeof i==="undefined"?t(e[a],a,r):t.call(i,e[a],a,r))){return true}}return false}},!nt(r.some));var it=false;if(r.reduce){it=typeof r.reduce.call("es5",function(t,r,e,n){return n})==="object"}$(r,{reduce:function reduce(t){var r=Z.ToObject(this);var e=et&&C(this)?X(this,""):r;var n=Z.ToUint32(e.length);if(!D(t)){throw new TypeError("Array.prototype.reduce callback must be a function")}if(n===0&&arguments.length===1){throw new TypeError("reduce of empty array with no initial value")}var i=0;var a;if(arguments.length>=2){a=arguments[1]}else{do{if(i in e){a=e[i++];break}if(++i>=n){throw new TypeError("reduce of empty array with no initial value")}}while(true)}for(;i<n;i++){if(i in e){a=t(a,e[i],i,r)}}return a}},!it);var at=false;if(r.reduceRight){at=typeof r.reduceRight.call("es5",function(t,r,e,n){return n})==="object"}$(r,{reduceRight:function reduceRight(t){var r=Z.ToObject(this);var e=et&&C(this)?X(this,""):r;var n=Z.ToUint32(e.length);if(!D(t)){throw new TypeError("Array.prototype.reduceRight callback must be a function")}if(n===0&&arguments.length===1){throw new TypeError("reduceRight of empty array with no initial value")}var i;var a=n-1;if(arguments.length>=2){i=arguments[1]}else{do{if(a in e){i=e[a--];break}if(--a<0){throw new TypeError("reduceRight of empty array with no initial value")}}while(true)}if(a<0){return i}do{if(a in e){i=t(i,e[a],a,r)}}while(a--);return i}},!at);var ot=r.indexOf&&[0,1].indexOf(1,2)!==-1;$(r,{indexOf:function indexOf(t){var r=et&&C(this)?X(this,""):Z.ToObject(this);var e=Z.ToUint32(r.length);if(e===0){return-1}var n=0;if(arguments.length>1){n=Z.ToInteger(arguments[1])}n=n>=0?n:w(0,e+n);for(;n<e;n++){if(n in r&&r[n]===t){return n}}return-1}},ot);var ft=r.lastIndexOf&&[0,1].lastIndexOf(0,-3)!==-1;$(r,{lastIndexOf:function lastIndexOf(t){var r=et&&C(this)?X(this,""):Z.ToObject(this);var e=Z.ToUint32(r.length);if(e===0){return-1}var n=e-1;if(arguments.length>1){n=b(n,Z.ToInteger(arguments[1]))}n=n>=0?n:e-Math.abs(n);for(;n>=0;n--){if(n in r&&t===r[n]){return n}}return-1}},ft);var ut=function(){var t=[1,2];var r=t.splice();return t.length===2&&_(r)&&r.length===0}();$(r,{splice:function splice(t,r){if(arguments.length===0){return[]}else{return c.apply(this,arguments)}}},!ut);var lt=function(){var t={};r.splice.call(t,0,0,1);return t.length===1}();$(r,{splice:function splice(t,r){if(arguments.length===0){return[]}var e=arguments;this.length=w(Z.ToInteger(this.length),0);if(arguments.length>0&&typeof r!=="number"){e=H(arguments);if(e.length<2){K(e,this.length-t)}else{e[1]=Z.ToInteger(r)}}return c.apply(this,e)}},!lt);var st=function(){var r=new t(1e5);r[8]="x";r.splice(1,1);return r.indexOf("x")===7}();var ct=function(){var t=256;var r=[];r[t]="a";r.splice(t+1,0,"b");return r[t]==="a"}();$(r,{splice:function splice(t,r){var e=Z.ToObject(this);var n=[];var i=Z.ToUint32(e.length);var a=Z.ToInteger(t);var f=a<0?w(i+a,0):b(a,i);var u=b(w(Z.ToInteger(r),0),i-f);var l=0;var s;while(l<u){s=o(f+l);if(G(e,s)){n[l]=e[s]}l+=1}var c=H(arguments,2);var v=c.length;var h;if(v<u){l=f;var p=i-u;while(l<p){s=o(l+u);h=o(l+v);if(G(e,s)){e[h]=e[s]}else{delete e[h]}l+=1}l=i;var y=i-u+v;while(l>y){delete e[l-1];l-=1}}else if(v>u){l=i-u;while(l>f){s=o(l+u-1);h=o(l+v-1);if(G(e,s)){e[h]=e[s]}else{delete e[h]}l-=1}}l=f;for(var d=0;d<c.length;++d){e[l]=c[d];l+=1}e.length=i-u+v;return n}},!st||!ct);var vt=r.join;var ht;try{ht=Array.prototype.join.call("123",",")!=="1,2,3"}catch(pt){ht=true}if(ht){$(r,{join:function join(t){var r=typeof t==="undefined"?",":t;return vt.call(C(this)?X(this,""):this,r)}},ht)}var yt=[1,2].join(undefined)!=="1,2";if(yt){$(r,{join:function join(t){var r=typeof t==="undefined"?",":t;return vt.call(this,r)}},yt)}var dt=function push(t){var r=Z.ToObject(this);var e=Z.ToUint32(r.length);var n=0;while(n<arguments.length){r[e+n]=arguments[n];n+=1}r.length=e+n;return e+n};var gt=function(){var t={};var r=Array.prototype.push.call(t,undefined);return r!==1||t.length!==1||typeof t[0]!=="undefined"||!G(t,0)}();$(r,{push:function push(t){if(_(this)){return v.apply(this,arguments)}return dt.apply(this,arguments)}},gt);var wt=function(){var t=[];var r=t.push(undefined);return r!==1||t.length!==1||typeof t[0]!=="undefined"||!G(t,0)}();$(r,{push:dt},wt);$(r,{slice:function(t,r){var e=C(this)?X(this,""):this;return W(e,arguments)}},et);var bt=function(){try{[1,2].sort(null);[1,2].sort({});return true}catch(t){}return false}();var Tt=function(){try{[1,2].sort(/a/);return false}catch(t){}return true}();var mt=function(){try{[1,2].sort(undefined);return true}catch(t){}return false}();$(r,{sort:function sort(t){if(typeof t==="undefined"){return V(this)}if(!D(t)){throw new TypeError("Array.prototype.sort callback must be a function")}return V(this,t)}},bt||!mt||!Tt);var Dt=!Q({toString:null},"toString");var St=Q(function(){},"prototype");var xt=!G("x","0");var Ot=function(t){var r=t.constructor;return r&&r.prototype===t};var jt={$window:true,$console:true,$parent:true,$self:true,$frame:true,$frames:true,$frameElement:true,$webkitIndexedDB:true,$webkitStorageInfo:true,$external:true};var Et=function(){if(typeof window==="undefined"){return false}for(var t in window){try{if(!jt["$"+t]&&G(window,t)&&window[t]!==null&&typeof window[t]==="object"){Ot(window[t])}}catch(r){return true}}return false}();var It=function(t){if(typeof window==="undefined"||!Et){return Ot(t)}try{return Ot(t)}catch(r){return false}};var Mt=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"];var Ut=Mt.length;var Ft=function isArguments(t){return B(t)==="[object Arguments]"};var Nt=function isArguments(t){return t!==null&&typeof t==="object"&&typeof t.length==="number"&&t.length>=0&&!_(t)&&D(t.callee)};var Ct=Ft(arguments)?Ft:Nt;$(e,{keys:function keys(t){var r=D(t);var e=Ct(t);var n=t!==null&&typeof t==="object";var i=n&&C(t);if(!n&&!r&&!e){throw new TypeError("Object.keys called on a non-object")}var a=[];var f=St&&r;if(i&&xt||e){for(var u=0;u<t.length;++u){K(a,o(u))}}if(!e){for(var l in t){if(!(f&&l==="prototype")&&G(t,l)){K(a,o(l))}}}if(Dt){var s=It(t);for(var c=0;c<Ut;c++){var v=Mt[c];if(!(s&&v==="constructor")&&G(t,v)){K(a,v)}}}return a}});var kt=e.keys&&function(){return e.keys(arguments).length===2}(1,2);var At=e.keys&&function(){var t=e.keys(arguments);return arguments.length!==1||t.length!==1||t[0]!==1}(1);var Rt=e.keys;$(e,{keys:function keys(t){if(Ct(t)){return Rt(H(t))}else{return Rt(t)}}},!kt||At);var Pt=new Date(-0xc782b5b342b24).getUTCMonth()!==0;var $t=new Date(-0x55d318d56a724);var Jt=new Date(14496624e5);var Yt=$t.toUTCString()!=="Mon, 01 Jan -45875 11:59:59 GMT";var Zt;var zt;var Gt=$t.getTimezoneOffset();if(Gt<-720){Zt=$t.toDateString()!=="Tue Jan 02 -45875";zt=!/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/.test(Jt.toString())}else{Zt=$t.toDateString()!=="Mon Jan 01 -45875";zt=!/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/.test(Jt.toString())}var Bt=d.bind(Date.prototype.getFullYear);var Ht=d.bind(Date.prototype.getMonth);var Wt=d.bind(Date.prototype.getDate);var Lt=d.bind(Date.prototype.getUTCFullYear);var Xt=d.bind(Date.prototype.getUTCMonth);var qt=d.bind(Date.prototype.getUTCDate);var Kt=d.bind(Date.prototype.getUTCDay);var Qt=d.bind(Date.prototype.getUTCHours);var Vt=d.bind(Date.prototype.getUTCMinutes);var _t=d.bind(Date.prototype.getUTCSeconds);var tr=d.bind(Date.prototype.getUTCMilliseconds);var rr=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];var er=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];var nr=function daysInMonth(t,r){return Wt(new Date(r,t,0))};$(Date.prototype,{getFullYear:function getFullYear(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=Bt(this);if(t<0&&Ht(this)>11){return t+1}return t},getMonth:function getMonth(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=Bt(this);var r=Ht(this);if(t<0&&r>11){return 0}return r},getDate:function getDate(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=Bt(this);var r=Ht(this);var e=Wt(this);if(t<0&&r>11){if(r===12){return e}var n=nr(0,t+1);return n-e+1}return e},getUTCFullYear:function getUTCFullYear(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=Lt(this);if(t<0&&Xt(this)>11){return t+1}return t},getUTCMonth:function getUTCMonth(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=Lt(this);var r=Xt(this);if(t<0&&r>11){return 0}return r},getUTCDate:function getUTCDate(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=Lt(this);var r=Xt(this);var e=qt(this);if(t<0&&r>11){if(r===12){return e}var n=nr(0,t+1);return n-e+1}return e}},Pt);$(Date.prototype,{toUTCString:function toUTCString(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=Kt(this);var r=qt(this);var e=Xt(this);var n=Lt(this);var i=Qt(this);var a=Vt(this);var o=_t(this);return rr[t]+", "+(r<10?"0"+r:r)+" "+er[e]+" "+n+" "+(i<10?"0"+i:i)+":"+(a<10?"0"+a:a)+":"+(o<10?"0"+o:o)+" GMT"}},Pt||Yt);$(Date.prototype,{toDateString:function toDateString(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=this.getDay();var r=this.getDate();var e=this.getMonth();var n=this.getFullYear();return rr[t]+" "+er[e]+" "+(r<10?"0"+r:r)+" "+n}},Pt||Zt);if(Pt||zt){Date.prototype.toString=function toString(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=this.getDay();var r=this.getDate();var e=this.getMonth();var n=this.getFullYear();var i=this.getHours();var a=this.getMinutes();var o=this.getSeconds();var f=this.getTimezoneOffset();var u=Math.floor(Math.abs(f)/60);var l=Math.floor(Math.abs(f)%60);return rr[t]+" "+er[e]+" "+(r<10?"0"+r:r)+" "+n+" "+(i<10?"0"+i:i)+":"+(a<10?"0"+a:a)+":"+(o<10?"0"+o:o)+" GMT"+(f>0?"-":"+")+(u<10?"0"+u:u)+(l<10?"0"+l:l)};if(P){e.defineProperty(Date.prototype,"toString",{configurable:true,enumerable:false,writable:true})}}var ir=-621987552e5;var ar="-000001";var or=Date.prototype.toISOString&&new Date(ir).toISOString().indexOf(ar)===-1;var fr=Date.prototype.toISOString&&new Date(-1).toISOString()!=="1969-12-31T23:59:59.999Z";var ur=d.bind(Date.prototype.getTime);$(Date.prototype,{toISOString:function toISOString(){if(!isFinite(this)||!isFinite(ur(this))){throw new RangeError("Date.prototype.toISOString called on non-finite value.")}var t=Lt(this);var r=Xt(this);t+=Math.floor(r/12);r=(r%12+12)%12;var e=[r+1,qt(this),Qt(this),Vt(this),_t(this)];t=(t<0?"-":t>9999?"+":"")+L("00000"+Math.abs(t),0<=t&&t<=9999?-4:-6);for(var n=0;n<e.length;++n){e[n]=L("00"+e[n],-2)}return t+"-"+H(e,0,2).join("-")+"T"+H(e,2).join(":")+"."+L("000"+tr(this),-3)+"Z"}},or||fr);var lr=function(){try{return Date.prototype.toJSON&&new Date(NaN).toJSON()===null&&new Date(ir).toJSON().indexOf(ar)!==-1&&Date.prototype.toJSON.call({toISOString:function(){return true}})}catch(t){return false}}();if(!lr){Date.prototype.toJSON=function toJSON(t){var r=e(this);var n=Z.ToPrimitive(r);if(typeof n==="number"&&!isFinite(n)){return null}var i=r.toISOString;if(!D(i)){throw new TypeError("toISOString property is not callable")}return i.call(r)}}var sr=Date.parse("+033658-09-27T01:46:40.000Z")===1e15;var cr=!isNaN(Date.parse("2012-04-04T24:00:00.500Z"))||!isNaN(Date.parse("2012-11-31T23:59:59.000Z"))||!isNaN(Date.parse("2012-12-31T23:59:60.000Z"));var vr=isNaN(Date.parse("2000-01-01T00:00:00.000Z"));if(vr||cr||!sr){var hr=Math.pow(2,31)-1;var pr=Y(new Date(1970,0,1,0,0,0,hr+1).getTime());Date=function(t){var r=function Date(e,n,i,a,f,u,l){var s=arguments.length;var c;if(this instanceof t){var v=u;var h=l;if(pr&&s>=7&&l>hr){var p=Math.floor(l/hr)*hr;var y=Math.floor(p/1e3);v+=y;h-=y*1e3}c=s===1&&o(e)===e?new t(r.parse(e)):s>=7?new t(e,n,i,a,f,v,h):s>=6?new t(e,n,i,a,f,v):s>=5?new t(e,n,i,a,f):s>=4?new t(e,n,i,a):s>=3?new t(e,n,i):s>=2?new t(e,n):s>=1?new t(e instanceof t?+e:e):new t}else{c=t.apply(this,arguments)}if(!J(c)){$(c,{constructor:r},true)}return c};var e=new RegExp("^"+"(\\d{4}|[+-]\\d{6})"+"(?:-(\\d{2})"+"(?:-(\\d{2})"+"(?:"+"T(\\d{2})"+":(\\d{2})"+"(?:"+":(\\d{2})"+"(?:(\\.\\d{1,}))?"+")?"+"("+"Z|"+"(?:"+"([-+])"+"(\\d{2})"+":(\\d{2})"+")"+")?)?)?)?"+"$");var n=[0,31,59,90,120,151,181,212,243,273,304,334,365];var i=function dayFromMonth(t,r){var e=r>1?1:0;return n[r]+Math.floor((t-1969+e)/4)-Math.floor((t-1901+e)/100)+Math.floor((t-1601+e)/400)+365*(t-1970)};var a=function toUTC(r){var e=0;var n=r;if(pr&&n>hr){var i=Math.floor(n/hr)*hr;var a=Math.floor(i/1e3);e+=a;n-=a*1e3}return u(new t(1970,0,1,0,0,e,n))};for(var f in t){if(G(t,f)){r[f]=t[f]}}$(r,{now:t.now,UTC:t.UTC},true);r.prototype=t.prototype;$(r.prototype,{constructor:r},true);var l=function parse(r){var n=e.exec(r);if(n){var o=u(n[1]),f=u(n[2]||1)-1,l=u(n[3]||1)-1,s=u(n[4]||0),c=u(n[5]||0),v=u(n[6]||0),h=Math.floor(u(n[7]||0)*1e3),p=Boolean(n[4]&&!n[8]),y=n[9]==="-"?1:-1,d=u(n[10]||0),g=u(n[11]||0),w;var b=c>0||v>0||h>0;if(s<(b?24:25)&&c<60&&v<60&&h<1e3&&f>-1&&f<12&&d<24&&g<60&&l>-1&&l<i(o,f+1)-i(o,f)){w=((i(o,f)+l)*24+s+d*y)*60;w=((w+c+g*y)*60+v)*1e3+h;if(p){w=a(w)}if(-864e13<=w&&w<=864e13){return w}}return NaN}return t.parse.apply(this,arguments)};$(r,{parse:l});return r}(Date)}if(!Date.now){Date.now=function now(){return(new Date).getTime()}}var yr=l.toFixed&&(8e-5.toFixed(3)!=="0.000"||.9.toFixed(0)!=="1"||1.255.toFixed(2)!=="1.25"||0xde0b6b3a7640080.toFixed(0)!=="1000000000000000128");var dr={base:1e7,size:6,data:[0,0,0,0,0,0],multiply:function multiply(t,r){var e=-1;var n=r;while(++e<dr.size){n+=t*dr.data[e];dr.data[e]=n%dr.base;n=Math.floor(n/dr.base)}},divide:function divide(t){var r=dr.size;var e=0;while(--r>=0){e+=dr.data[r];dr.data[r]=Math.floor(e/t);e=e%t*dr.base}},numToString:function numToString(){var t=dr.size;var r="";while(--t>=0){if(r!==""||t===0||dr.data[t]!==0){var e=o(dr.data[t]);if(r===""){r=e}else{r+=L("0000000",0,7-e.length)+e}}}return r},pow:function pow(t,r,e){return r===0?e:r%2===1?pow(t,r-1,e*t):pow(t*t,r/2,e)},log:function log(t){var r=0;var e=t;while(e>=4096){r+=12;e/=4096}while(e>=2){r+=1;e/=2}return r}};var gr=function toFixed(t){var r,e,n,i,a,f,l,s;r=u(t);r=Y(r)?0:Math.floor(r);if(r<0||r>20){throw new RangeError("Number.toFixed called with invalid number of decimals")}e=u(this);if(Y(e)){return"NaN"}if(e<=-1e21||e>=1e21){return o(e)}n="";if(e<0){n="-";e=-e}i="0";if(e>1e-21){a=dr.log(e*dr.pow(2,69,1))-69;f=a<0?e*dr.pow(2,-a,1):e/dr.pow(2,a,1);f*=4503599627370496;a=52-a;if(a>0){dr.multiply(0,f);l=r;while(l>=7){dr.multiply(1e7,0);l-=7}dr.multiply(dr.pow(10,l,1),0);l=a-1;while(l>=23){dr.divide(1<<23);l-=23}dr.divide(1<<l);dr.multiply(1,1);dr.divide(2);i=dr.numToString()}else{dr.multiply(0,f);dr.multiply(1<<-a,0);i=dr.numToString()+L("0.00000000000000000000",2,2+r)}}if(r>0){s=i.length;if(s<=r){i=n+L("0.0000000000000000000",0,r-s+2)+i}else{i=n+L(i,0,s-r)+"."+L(i,s-r)}}else{i=n+i}return i};$(l,{toFixed:gr},yr);var wr=function(){try{return 1..toPrecision(undefined)==="1"}catch(t){return true}}();var br=l.toPrecision;$(l,{toPrecision:function toPrecision(t){return typeof t==="undefined"?br.call(this):br.call(this,t)}},wr);if("ab".split(/(?:ab)*/).length!==2||".".split(/(.?)(.?)/).length!==4||"tesst".split(/(s)*/)[1]==="t"||"test".split(/(?:)/,-1).length!==4||"".split(/.?/).length||".".split(/()()/).length>1){(function(){var t=typeof/()??/.exec("")[1]==="undefined";var r=Math.pow(2,32)-1;f.split=function(e,n){var i=String(this);if(typeof e==="undefined"&&n===0){return[]}if(!M(e)){return X(this,e,n)}var a=[];var o=(e.ignoreCase?"i":"")+(e.multiline?"m":"")+(e.unicode?"u":"")+(e.sticky?"y":""),f=0,u,l,s,c;var h=new RegExp(e.source,o+"g");if(!t){u=new RegExp("^"+h.source+"$(?!\\s)",o)}var p=typeof n==="undefined"?r:Z.ToUint32(n);l=h.exec(i);while(l){s=l.index+l[0].length;if(s>f){K(a,L(i,f,l.index));if(!t&&l.length>1){l[0].replace(u,function(){for(var t=1;t<arguments.length-2;t++){if(typeof arguments[t]==="undefined"){l[t]=void 0}}})}if(l.length>1&&l.index<i.length){v.apply(a,H(l,1))}c=l[0].length;f=s;if(a.length>=p){break}}if(h.lastIndex===l.index){h.lastIndex++}l=h.exec(i)}if(f===i.length){if(c||!h.test("")){K(a,"")}}else{K(a,L(i,f))}return a.length>p?H(a,0,p):a}})()}else if("0".split(void 0,0).length){f.split=function split(t,r){if(typeof t==="undefined"&&r===0){return[]}return X(this,t,r)}}var Tr=f.replace;var mr=function(){var t=[];"x".replace(/x(.)?/g,function(r,e){K(t,e)});return t.length===1&&typeof t[0]==="undefined"}();if(!mr){f.replace=function replace(t,r){var e=D(r);var n=M(t)&&/\)[*?]/.test(t.source);if(!e||!n){return Tr.call(this,t,r)}else{var i=function(e){var n=arguments.length;var i=t.lastIndex;t.lastIndex=0;var a=t.exec(e)||[];t.lastIndex=i;K(a,arguments[n-2],arguments[n-1]);return r.apply(this,a)};return Tr.call(this,t,i)}}}var Dr=f.substr;var Sr="".substr&&"0b".substr(-1)!=="b";$(f,{substr:function substr(t,r){var e=t;if(t<0){e=w(this.length+t,0)}return Dr.call(this,e,r)}},Sr);var xr="	\n\x0B\f\r \xa0\u1680\u180e\u2000\u2001\u2002\u2003"+"\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028"+"\u2029\ufeff";var Or="\u200b";var jr="["+xr+"]";var Er=new RegExp("^"+jr+jr+"*");var Ir=new RegExp(jr+jr+"*$");var Mr=f.trim&&(xr.trim()||!Or.trim());$(f,{trim:function trim(){if(typeof this==="undefined"||this===null){throw new TypeError("can't convert "+this+" to object")}return o(this).replace(Er,"").replace(Ir,"")}},Mr);var Ur=d.bind(String.prototype.trim);var Fr=f.lastIndexOf&&"abc\u3042\u3044".lastIndexOf("\u3042\u3044",2)!==-1;$(f,{lastIndexOf:function lastIndexOf(t){if(typeof this==="undefined"||this===null){throw new TypeError("can't convert "+this+" to object")}var r=o(this);var e=o(t);var n=arguments.length>1?u(arguments[1]):NaN;var i=Y(n)?Infinity:Z.ToInteger(n);var a=b(w(i,0),r.length);var f=e.length;var l=a+f;while(l>0){l=w(0,l-f);var s=q(L(r,l,a+f),e);if(s!==-1){return l+s}}return-1}},Fr);var Nr=f.lastIndexOf;$(f,{lastIndexOf:function lastIndexOf(t){return Nr.apply(this,arguments)}},f.lastIndexOf.length!==1);if(parseInt(xr+"08")!==8||parseInt(xr+"0x16")!==22){parseInt=function(t){var r=/^[\-+]?0[xX]/;return function parseInt(e,n){var i=Ur(String(e));var a=u(n)||(r.test(i)?16:10);return t(i,a)}}(parseInt)}if(1/parseFloat("-0")!==-Infinity){parseFloat=function(t){return function parseFloat(r){var e=Ur(String(r));var n=t(e);return n===0&&L(e,0,1)==="-"?-0:n}}(parseFloat)}if(String(new RangeError("test"))!=="RangeError: test"){var Cr=function toString(){if(typeof this==="undefined"||this===null){throw new TypeError("can't convert "+this+" to object")}var t=this.name;if(typeof t==="undefined"){t="Error"}else if(typeof t!=="string"){t=o(t)}var r=this.message;if(typeof r==="undefined"){r=""}else if(typeof r!=="string"){r=o(r)}if(!t){return r}if(!r){return t}return t+": "+r};Error.prototype.toString=Cr}if(P){var kr=function(t,r){if(Q(t,r)){var e=Object.getOwnPropertyDescriptor(t,r);if(e.configurable){e.enumerable=false;Object.defineProperty(t,r,e)}}};kr(Error.prototype,"message");if(Error.prototype.message!==""){Error.prototype.message=""}kr(Error.prototype,"name")}if(String(/a/gim)!=="/a/gim"){var Ar=function toString(){var t="/"+this.source+"/";if(this.global){t+="g"}if(this.ignoreCase){t+="i"}if(this.multiline){t+="m"}return t};RegExp.prototype.toString=Ar}});
//# sourceMappingURL=es5-shim.map
;
/*!
  * https://github.com/paulmillr/es6-shim
  * @license es6-shim Copyright 2013-2016 by Paul Miller (http://paulmillr.com)
  *   and contributors,  MIT License
  * es6-shim: v0.35.1
  * see https://github.com/paulmillr/es6-shim/blob/0.35.1/LICENSE
  * Details and documentation:
  * https://github.com/paulmillr/es6-shim/
  */
(function(e,t){if(typeof define==="function"&&define.amd){define('es6-shim',t)}else if(typeof exports==="object"){module.exports=t()}else{e.returnExports=t()}})(this,function(){"use strict";var e=Function.call.bind(Function.apply);var t=Function.call.bind(Function.call);var r=Array.isArray;var n=Object.keys;var o=function notThunker(t){return function notThunk(){return!e(t,this,arguments)}};var i=function(e){try{e();return false}catch(e){return true}};var a=function valueOrFalseIfThrows(e){try{return e()}catch(e){return false}};var u=o(i);var f=function(){return!i(function(){Object.defineProperty({},"x",{get:function(){}})})};var s=!!Object.defineProperty&&f();var c=function foo(){}.name==="foo";var l=Function.call.bind(Array.prototype.forEach);var p=Function.call.bind(Array.prototype.reduce);var v=Function.call.bind(Array.prototype.filter);var y=Function.call.bind(Array.prototype.some);var h=function(e,t,r,n){if(!n&&t in e){return}if(s){Object.defineProperty(e,t,{configurable:true,enumerable:false,writable:true,value:r})}else{e[t]=r}};var b=function(e,t,r){l(n(t),function(n){var o=t[n];h(e,n,o,!!r)})};var g=Function.call.bind(Object.prototype.toString);var d=typeof/abc/==="function"?function IsCallableSlow(e){return typeof e==="function"&&g(e)==="[object Function]"}:function IsCallableFast(e){return typeof e==="function"};var m={getter:function(e,t,r){if(!s){throw new TypeError("getters require true ES5 support")}Object.defineProperty(e,t,{configurable:true,enumerable:false,get:r})},proxy:function(e,t,r){if(!s){throw new TypeError("getters require true ES5 support")}var n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(r,t,{configurable:n.configurable,enumerable:n.enumerable,get:function getKey(){return e[t]},set:function setKey(r){e[t]=r}})},redefine:function(e,t,r){if(s){var n=Object.getOwnPropertyDescriptor(e,t);n.value=r;Object.defineProperty(e,t,n)}else{e[t]=r}},defineByDescriptor:function(e,t,r){if(s){Object.defineProperty(e,t,r)}else if("value"in r){e[t]=r.value}},preserveToString:function(e,t){if(t&&d(t.toString)){h(e,"toString",t.toString.bind(t),true)}}};var O=Object.create||function(e,t){var r=function Prototype(){};r.prototype=e;var o=new r;if(typeof t!=="undefined"){n(t).forEach(function(e){m.defineByDescriptor(o,e,t[e])})}return o};var w=function(e,t){if(!Object.setPrototypeOf){return false}return a(function(){var r=function Subclass(t){var r=new e(t);Object.setPrototypeOf(r,Subclass.prototype);return r};Object.setPrototypeOf(r,e);r.prototype=O(e.prototype,{constructor:{value:r}});return t(r)})};var j=function(){if(typeof self!=="undefined"){return self}if(typeof window!=="undefined"){return window}if(typeof global!=="undefined"){return global}throw new Error("unable to locate global object")};var S=j();var T=S.isFinite;var I=Function.call.bind(String.prototype.indexOf);var E=Function.apply.bind(Array.prototype.indexOf);var P=Function.call.bind(Array.prototype.concat);var C=Function.call.bind(String.prototype.slice);var M=Function.call.bind(Array.prototype.push);var x=Function.apply.bind(Array.prototype.push);var N=Function.call.bind(Array.prototype.shift);var A=Math.max;var R=Math.min;var _=Math.floor;var k=Math.abs;var F=Math.exp;var L=Math.log;var D=Math.sqrt;var z=Function.call.bind(Object.prototype.hasOwnProperty);var q;var W=function(){};var G=S.Map;var H=G&&G.prototype["delete"];var V=G&&G.prototype.get;var B=G&&G.prototype.has;var U=G&&G.prototype.set;var $=S.Symbol||{};var J=$.species||"@@species";var X=Number.isNaN||function isNaN(e){return e!==e};var K=Number.isFinite||function isFinite(e){return typeof e==="number"&&T(e)};var Z=d(Math.sign)?Math.sign:function sign(e){var t=Number(e);if(t===0){return t}if(X(t)){return t}return t<0?-1:1};var Y=function isArguments(e){return g(e)==="[object Arguments]"};var Q=function isArguments(e){return e!==null&&typeof e==="object"&&typeof e.length==="number"&&e.length>=0&&g(e)!=="[object Array]"&&g(e.callee)==="[object Function]"};var ee=Y(arguments)?Y:Q;var te={primitive:function(e){return e===null||typeof e!=="function"&&typeof e!=="object"},string:function(e){return g(e)==="[object String]"},regex:function(e){return g(e)==="[object RegExp]"},symbol:function(e){return typeof S.Symbol==="function"&&typeof e==="symbol"}};var re=function overrideNative(e,t,r){var n=e[t];h(e,t,r,true);m.preserveToString(e[t],n)};var ne=typeof $==="function"&&typeof $["for"]==="function"&&te.symbol($());var oe=te.symbol($.iterator)?$.iterator:"_es6-shim iterator_";if(S.Set&&typeof(new S.Set)["@@iterator"]==="function"){oe="@@iterator"}if(!S.Reflect){h(S,"Reflect",{},true)}var ie=S.Reflect;var ae=String;var ue=typeof document==="undefined"||!document?null:document.all;var fe=ue==null?function isNullOrUndefined(e){return e==null}:function isNullOrUndefinedAndNotDocumentAll(e){return e==null&&e!==ue};var se={Call:function Call(t,r){var n=arguments.length>2?arguments[2]:[];if(!se.IsCallable(t)){throw new TypeError(t+" is not a function")}return e(t,r,n)},RequireObjectCoercible:function(e,t){if(fe(e)){throw new TypeError(t||"Cannot call method on "+e)}return e},TypeIsObject:function(e){if(e===void 0||e===null||e===true||e===false){return false}return typeof e==="function"||typeof e==="object"||e===ue},ToObject:function(e,t){return Object(se.RequireObjectCoercible(e,t))},IsCallable:d,IsConstructor:function(e){return se.IsCallable(e)},ToInt32:function(e){return se.ToNumber(e)>>0},ToUint32:function(e){return se.ToNumber(e)>>>0},ToNumber:function(e){if(g(e)==="[object Symbol]"){throw new TypeError("Cannot convert a Symbol value to a number")}return+e},ToInteger:function(e){var t=se.ToNumber(e);if(X(t)){return 0}if(t===0||!K(t)){return t}return(t>0?1:-1)*_(k(t))},ToLength:function(e){var t=se.ToInteger(e);if(t<=0){return 0}if(t>Number.MAX_SAFE_INTEGER){return Number.MAX_SAFE_INTEGER}return t},SameValue:function(e,t){if(e===t){if(e===0){return 1/e===1/t}return true}return X(e)&&X(t)},SameValueZero:function(e,t){return e===t||X(e)&&X(t)},IsIterable:function(e){return se.TypeIsObject(e)&&(typeof e[oe]!=="undefined"||ee(e))},GetIterator:function(e){if(ee(e)){return new q(e,"value")}var t=se.GetMethod(e,oe);if(!se.IsCallable(t)){throw new TypeError("value is not an iterable")}var r=se.Call(t,e);if(!se.TypeIsObject(r)){throw new TypeError("bad iterator")}return r},GetMethod:function(e,t){var r=se.ToObject(e)[t];if(fe(r)){return void 0}if(!se.IsCallable(r)){throw new TypeError("Method not callable: "+t)}return r},IteratorComplete:function(e){return!!e.done},IteratorClose:function(e,t){var r=se.GetMethod(e,"return");if(r===void 0){return}var n,o;try{n=se.Call(r,e)}catch(e){o=e}if(t){return}if(o){throw o}if(!se.TypeIsObject(n)){throw new TypeError("Iterator's return method returned a non-object.")}},IteratorNext:function(e){var t=arguments.length>1?e.next(arguments[1]):e.next();if(!se.TypeIsObject(t)){throw new TypeError("bad iterator")}return t},IteratorStep:function(e){var t=se.IteratorNext(e);var r=se.IteratorComplete(t);return r?false:t},Construct:function(e,t,r,n){var o=typeof r==="undefined"?e:r;if(!n&&ie.construct){return ie.construct(e,t,o)}var i=o.prototype;if(!se.TypeIsObject(i)){i=Object.prototype}var a=O(i);var u=se.Call(e,a,t);return se.TypeIsObject(u)?u:a},SpeciesConstructor:function(e,t){var r=e.constructor;if(r===void 0){return t}if(!se.TypeIsObject(r)){throw new TypeError("Bad constructor")}var n=r[J];if(fe(n)){return t}if(!se.IsConstructor(n)){throw new TypeError("Bad @@species")}return n},CreateHTML:function(e,t,r,n){var o=se.ToString(e);var i="<"+t;if(r!==""){var a=se.ToString(n);var u=a.replace(/"/g,"&quot;");i+=" "+r+'="'+u+'"'}var f=i+">";var s=f+o;return s+"</"+t+">"},IsRegExp:function IsRegExp(e){if(!se.TypeIsObject(e)){return false}var t=e[$.match];if(typeof t!=="undefined"){return!!t}return te.regex(e)},ToString:function ToString(e){return ae(e)}};if(s&&ne){var ce=function defineWellKnownSymbol(e){if(te.symbol($[e])){return $[e]}var t=$["for"]("Symbol."+e);Object.defineProperty($,e,{configurable:false,enumerable:false,writable:false,value:t});return t};if(!te.symbol($.search)){var le=ce("search");var pe=String.prototype.search;h(RegExp.prototype,le,function search(e){return se.Call(pe,e,[this])});var ve=function search(e){var t=se.RequireObjectCoercible(this);if(!fe(e)){var r=se.GetMethod(e,le);if(typeof r!=="undefined"){return se.Call(r,e,[t])}}return se.Call(pe,t,[se.ToString(e)])};re(String.prototype,"search",ve)}if(!te.symbol($.replace)){var ye=ce("replace");var he=String.prototype.replace;h(RegExp.prototype,ye,function replace(e,t){return se.Call(he,e,[this,t])});var be=function replace(e,t){var r=se.RequireObjectCoercible(this);if(!fe(e)){var n=se.GetMethod(e,ye);if(typeof n!=="undefined"){return se.Call(n,e,[r,t])}}return se.Call(he,r,[se.ToString(e),t])};re(String.prototype,"replace",be)}if(!te.symbol($.split)){var ge=ce("split");var de=String.prototype.split;h(RegExp.prototype,ge,function split(e,t){return se.Call(de,e,[this,t])});var me=function split(e,t){var r=se.RequireObjectCoercible(this);if(!fe(e)){var n=se.GetMethod(e,ge);if(typeof n!=="undefined"){return se.Call(n,e,[r,t])}}return se.Call(de,r,[se.ToString(e),t])};re(String.prototype,"split",me)}var Oe=te.symbol($.match);var we=Oe&&function(){var e={};e[$.match]=function(){return 42};return"a".match(e)!==42}();if(!Oe||we){var je=ce("match");var Se=String.prototype.match;h(RegExp.prototype,je,function match(e){return se.Call(Se,e,[this])});var Te=function match(e){var t=se.RequireObjectCoercible(this);if(!fe(e)){var r=se.GetMethod(e,je);if(typeof r!=="undefined"){return se.Call(r,e,[t])}}return se.Call(Se,t,[se.ToString(e)])};re(String.prototype,"match",Te)}}var Ie=function wrapConstructor(e,t,r){m.preserveToString(t,e);if(Object.setPrototypeOf){Object.setPrototypeOf(e,t)}if(s){l(Object.getOwnPropertyNames(e),function(n){if(n in W||r[n]){return}m.proxy(e,n,t)})}else{l(Object.keys(e),function(n){if(n in W||r[n]){return}t[n]=e[n]})}t.prototype=e.prototype;m.redefine(e.prototype,"constructor",t)};var Ee=function(){return this};var Pe=function(e){if(s&&!z(e,J)){m.getter(e,J,Ee)}};var Ce=function(e,t){var r=t||function iterator(){return this};h(e,oe,r);if(!e[oe]&&te.symbol(oe)){e[oe]=r}};var Me=function createDataProperty(e,t,r){if(s){Object.defineProperty(e,t,{configurable:true,enumerable:true,writable:true,value:r})}else{e[t]=r}};var xe=function createDataPropertyOrThrow(e,t,r){Me(e,t,r);if(!se.SameValue(e[t],r)){throw new TypeError("property is nonconfigurable")}};var Ne=function(e,t,r,n){if(!se.TypeIsObject(e)){throw new TypeError("Constructor requires `new`: "+t.name)}var o=t.prototype;if(!se.TypeIsObject(o)){o=r}var i=O(o);for(var a in n){if(z(n,a)){var u=n[a];h(i,a,u,true)}}return i};if(String.fromCodePoint&&String.fromCodePoint.length!==1){var Ae=String.fromCodePoint;re(String,"fromCodePoint",function fromCodePoint(e){return se.Call(Ae,this,arguments)})}var Re={fromCodePoint:function fromCodePoint(e){var t=[];var r;for(var n=0,o=arguments.length;n<o;n++){r=Number(arguments[n]);if(!se.SameValue(r,se.ToInteger(r))||r<0||r>1114111){throw new RangeError("Invalid code point "+r)}if(r<65536){M(t,String.fromCharCode(r))}else{r-=65536;M(t,String.fromCharCode((r>>10)+55296));M(t,String.fromCharCode(r%1024+56320))}}return t.join("")},raw:function raw(e){var t=se.ToObject(e,"bad callSite");var r=se.ToObject(t.raw,"bad raw value");var n=r.length;var o=se.ToLength(n);if(o<=0){return""}var i=[];var a=0;var u,f,s,c;while(a<o){u=se.ToString(a);s=se.ToString(r[u]);M(i,s);if(a+1>=o){break}f=a+1<arguments.length?arguments[a+1]:"";c=se.ToString(f);M(i,c);a+=1}return i.join("")}};if(String.raw&&String.raw({raw:{0:"x",1:"y",length:2}})!=="xy"){re(String,"raw",Re.raw)}b(String,Re);var _e=function repeat(e,t){if(t<1){return""}if(t%2){return repeat(e,t-1)+e}var r=repeat(e,t/2);return r+r};var ke=Infinity;var Fe={repeat:function repeat(e){var t=se.ToString(se.RequireObjectCoercible(this));var r=se.ToInteger(e);if(r<0||r>=ke){throw new RangeError("repeat count must be less than infinity and not overflow maximum string size")}return _e(t,r)},startsWith:function startsWith(e){var t=se.ToString(se.RequireObjectCoercible(this));if(se.IsRegExp(e)){throw new TypeError('Cannot call method "startsWith" with a regex')}var r=se.ToString(e);var n;if(arguments.length>1){n=arguments[1]}var o=A(se.ToInteger(n),0);return C(t,o,o+r.length)===r},endsWith:function endsWith(e){var t=se.ToString(se.RequireObjectCoercible(this));if(se.IsRegExp(e)){throw new TypeError('Cannot call method "endsWith" with a regex')}var r=se.ToString(e);var n=t.length;var o;if(arguments.length>1){o=arguments[1]}var i=typeof o==="undefined"?n:se.ToInteger(o);var a=R(A(i,0),n);return C(t,a-r.length,a)===r},includes:function includes(e){if(se.IsRegExp(e)){throw new TypeError('"includes" does not accept a RegExp')}var t=se.ToString(e);var r;if(arguments.length>1){r=arguments[1]}return I(this,t,r)!==-1},codePointAt:function codePointAt(e){var t=se.ToString(se.RequireObjectCoercible(this));var r=se.ToInteger(e);var n=t.length;if(r>=0&&r<n){var o=t.charCodeAt(r);var i=r+1===n;if(o<55296||o>56319||i){return o}var a=t.charCodeAt(r+1);if(a<56320||a>57343){return o}return(o-55296)*1024+(a-56320)+65536}}};if(String.prototype.includes&&"a".includes("a",Infinity)!==false){re(String.prototype,"includes",Fe.includes)}if(String.prototype.startsWith&&String.prototype.endsWith){var Le=i(function(){"/a/".startsWith(/a/)});var De=a(function(){return"abc".startsWith("a",Infinity)===false});if(!Le||!De){re(String.prototype,"startsWith",Fe.startsWith);re(String.prototype,"endsWith",Fe.endsWith)}}if(ne){var ze=a(function(){var e=/a/;e[$.match]=false;return"/a/".startsWith(e)});if(!ze){re(String.prototype,"startsWith",Fe.startsWith)}var qe=a(function(){var e=/a/;e[$.match]=false;return"/a/".endsWith(e)});if(!qe){re(String.prototype,"endsWith",Fe.endsWith)}var We=a(function(){var e=/a/;e[$.match]=false;return"/a/".includes(e)});if(!We){re(String.prototype,"includes",Fe.includes)}}b(String.prototype,Fe);var Ge=["\t\n\v\f\r \xa0\u1680\u180e\u2000\u2001\u2002\u2003","\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028","\u2029\ufeff"].join("");var He=new RegExp("(^["+Ge+"]+)|(["+Ge+"]+$)","g");var Ve=function trim(){return se.ToString(se.RequireObjectCoercible(this)).replace(He,"")};var Be=["\x85","\u200b","\ufffe"].join("");var Ue=new RegExp("["+Be+"]","g");var $e=/^[-+]0x[0-9a-f]+$/i;var Je=Be.trim().length!==Be.length;h(String.prototype,"trim",Ve,Je);var Xe=function(e){return{value:e,done:arguments.length===0}};var Ke=function(e){se.RequireObjectCoercible(e);this._s=se.ToString(e);this._i=0};Ke.prototype.next=function(){var e=this._s;var t=this._i;if(typeof e==="undefined"||t>=e.length){this._s=void 0;return Xe()}var r=e.charCodeAt(t);var n,o;if(r<55296||r>56319||t+1===e.length){o=1}else{n=e.charCodeAt(t+1);o=n<56320||n>57343?1:2}this._i=t+o;return Xe(e.substr(t,o))};Ce(Ke.prototype);Ce(String.prototype,function(){return new Ke(this)});var Ze={from:function from(e){var r=this;var n;if(arguments.length>1){n=arguments[1]}var o,i;if(typeof n==="undefined"){o=false}else{if(!se.IsCallable(n)){throw new TypeError("Array.from: when provided, the second argument must be a function")}if(arguments.length>2){i=arguments[2]}o=true}var a=typeof(ee(e)||se.GetMethod(e,oe))!=="undefined";var u,f,s;if(a){f=se.IsConstructor(r)?Object(new r):[];var c=se.GetIterator(e);var l,p;s=0;while(true){l=se.IteratorStep(c);if(l===false){break}p=l.value;try{if(o){p=typeof i==="undefined"?n(p,s):t(n,i,p,s)}f[s]=p}catch(e){se.IteratorClose(c,true);throw e}s+=1}u=s}else{var v=se.ToObject(e);u=se.ToLength(v.length);f=se.IsConstructor(r)?Object(new r(u)):new Array(u);var y;for(s=0;s<u;++s){y=v[s];if(o){y=typeof i==="undefined"?n(y,s):t(n,i,y,s)}xe(f,s,y)}}f.length=u;return f},of:function of(){var e=arguments.length;var t=this;var n=r(t)||!se.IsCallable(t)?new Array(e):se.Construct(t,[e]);for(var o=0;o<e;++o){xe(n,o,arguments[o])}n.length=e;return n}};b(Array,Ze);Pe(Array);q=function(e,t){this.i=0;this.array=e;this.kind=t};b(q.prototype,{next:function(){var e=this.i;var t=this.array;if(!(this instanceof q)){throw new TypeError("Not an ArrayIterator")}if(typeof t!=="undefined"){var r=se.ToLength(t.length);for(;e<r;e++){var n=this.kind;var o;if(n==="key"){o=e}else if(n==="value"){o=t[e]}else if(n==="entry"){o=[e,t[e]]}this.i=e+1;return Xe(o)}}this.array=void 0;return Xe()}});Ce(q.prototype);var Ye=Array.of===Ze.of||function(){var e=function Foo(e){this.length=e};e.prototype=[];var t=Array.of.apply(e,[1,2]);return t instanceof e&&t.length===2}();if(!Ye){re(Array,"of",Ze.of)}var Qe={copyWithin:function copyWithin(e,t){var r=se.ToObject(this);var n=se.ToLength(r.length);var o=se.ToInteger(e);var i=se.ToInteger(t);var a=o<0?A(n+o,0):R(o,n);var u=i<0?A(n+i,0):R(i,n);var f;if(arguments.length>2){f=arguments[2]}var s=typeof f==="undefined"?n:se.ToInteger(f);var c=s<0?A(n+s,0):R(s,n);var l=R(c-u,n-a);var p=1;if(u<a&&a<u+l){p=-1;u+=l-1;a+=l-1}while(l>0){if(u in r){r[a]=r[u]}else{delete r[a]}u+=p;a+=p;l-=1}return r},fill:function fill(e){var t;if(arguments.length>1){t=arguments[1]}var r;if(arguments.length>2){r=arguments[2]}var n=se.ToObject(this);var o=se.ToLength(n.length);t=se.ToInteger(typeof t==="undefined"?0:t);r=se.ToInteger(typeof r==="undefined"?o:r);var i=t<0?A(o+t,0):R(t,o);var a=r<0?o+r:r;for(var u=i;u<o&&u<a;++u){n[u]=e}return n},find:function find(e){var r=se.ToObject(this);var n=se.ToLength(r.length);if(!se.IsCallable(e)){throw new TypeError("Array#find: predicate must be a function")}var o=arguments.length>1?arguments[1]:null;for(var i=0,a;i<n;i++){a=r[i];if(o){if(t(e,o,a,i,r)){return a}}else if(e(a,i,r)){return a}}},findIndex:function findIndex(e){var r=se.ToObject(this);var n=se.ToLength(r.length);if(!se.IsCallable(e)){throw new TypeError("Array#findIndex: predicate must be a function")}var o=arguments.length>1?arguments[1]:null;for(var i=0;i<n;i++){if(o){if(t(e,o,r[i],i,r)){return i}}else if(e(r[i],i,r)){return i}}return-1},keys:function keys(){return new q(this,"key")},values:function values(){return new q(this,"value")},entries:function entries(){return new q(this,"entry")}};if(Array.prototype.keys&&!se.IsCallable([1].keys().next)){delete Array.prototype.keys}if(Array.prototype.entries&&!se.IsCallable([1].entries().next)){delete Array.prototype.entries}if(Array.prototype.keys&&Array.prototype.entries&&!Array.prototype.values&&Array.prototype[oe]){b(Array.prototype,{values:Array.prototype[oe]});if(te.symbol($.unscopables)){Array.prototype[$.unscopables].values=true}}if(c&&Array.prototype.values&&Array.prototype.values.name!=="values"){var et=Array.prototype.values;re(Array.prototype,"values",function values(){return se.Call(et,this,arguments)});h(Array.prototype,oe,Array.prototype.values,true)}b(Array.prototype,Qe);if(1/[true].indexOf(true,-0)<0){h(Array.prototype,"indexOf",function indexOf(e){var t=E(this,arguments);if(t===0&&1/t<0){return 0}return t},true)}Ce(Array.prototype,function(){return this.values()});if(Object.getPrototypeOf){Ce(Object.getPrototypeOf([].values()))}var tt=function(){return a(function(){return Array.from({length:-1}).length===0})}();var rt=function(){var e=Array.from([0].entries());return e.length===1&&r(e[0])&&e[0][0]===0&&e[0][1]===0}();if(!tt||!rt){re(Array,"from",Ze.from)}var nt=function(){return a(function(){return Array.from([0],void 0)})}();if(!nt){var ot=Array.from;re(Array,"from",function from(e){if(arguments.length>1&&typeof arguments[1]!=="undefined"){return se.Call(ot,this,arguments)}else{return t(ot,this,e)}})}var it=-(Math.pow(2,32)-1);var at=function(e,r){var n={length:it};n[r?(n.length>>>0)-1:0]=true;return a(function(){t(e,n,function(){throw new RangeError("should not reach here")},[]);return true})};if(!at(Array.prototype.forEach)){var ut=Array.prototype.forEach;re(Array.prototype,"forEach",function forEach(e){return se.Call(ut,this.length>=0?this:[],arguments)},true)}if(!at(Array.prototype.map)){var ft=Array.prototype.map;re(Array.prototype,"map",function map(e){return se.Call(ft,this.length>=0?this:[],arguments)},true)}if(!at(Array.prototype.filter)){var st=Array.prototype.filter;re(Array.prototype,"filter",function filter(e){return se.Call(st,this.length>=0?this:[],arguments)},true)}if(!at(Array.prototype.some)){var ct=Array.prototype.some;re(Array.prototype,"some",function some(e){return se.Call(ct,this.length>=0?this:[],arguments)},true)}if(!at(Array.prototype.every)){var lt=Array.prototype.every;re(Array.prototype,"every",function every(e){return se.Call(lt,this.length>=0?this:[],arguments)},true)}if(!at(Array.prototype.reduce)){var pt=Array.prototype.reduce;re(Array.prototype,"reduce",function reduce(e){return se.Call(pt,this.length>=0?this:[],arguments)},true)}if(!at(Array.prototype.reduceRight,true)){var vt=Array.prototype.reduceRight;re(Array.prototype,"reduceRight",function reduceRight(e){return se.Call(vt,this.length>=0?this:[],arguments)},true)}var yt=Number("0o10")!==8;var ht=Number("0b10")!==2;var bt=y(Be,function(e){return Number(e+0+e)===0});if(yt||ht||bt){var gt=Number;var dt=/^0b[01]+$/i;var mt=/^0o[0-7]+$/i;var Ot=dt.test.bind(dt);var wt=mt.test.bind(mt);var jt=function(e){var t;if(typeof e.valueOf==="function"){t=e.valueOf();if(te.primitive(t)){return t}}if(typeof e.toString==="function"){t=e.toString();if(te.primitive(t)){return t}}throw new TypeError("No default value")};var St=Ue.test.bind(Ue);var Tt=$e.test.bind($e);var It=function(){var e=function Number(t){var r;if(arguments.length>0){r=te.primitive(t)?t:jt(t,"number")}else{r=0}if(typeof r==="string"){r=se.Call(Ve,r);if(Ot(r)){r=parseInt(C(r,2),2)}else if(wt(r)){r=parseInt(C(r,2),8)}else if(St(r)||Tt(r)){r=NaN}}var n=this;var o=a(function(){gt.prototype.valueOf.call(n);return true});if(n instanceof e&&!o){return new gt(r)}return gt(r)};return e}();Ie(gt,It,{});b(It,{NaN:gt.NaN,MAX_VALUE:gt.MAX_VALUE,MIN_VALUE:gt.MIN_VALUE,NEGATIVE_INFINITY:gt.NEGATIVE_INFINITY,POSITIVE_INFINITY:gt.POSITIVE_INFINITY});Number=It;m.redefine(S,"Number",It)}var Et=Math.pow(2,53)-1;b(Number,{MAX_SAFE_INTEGER:Et,MIN_SAFE_INTEGER:-Et,EPSILON:2.220446049250313e-16,parseInt:S.parseInt,parseFloat:S.parseFloat,isFinite:K,isInteger:function isInteger(e){return K(e)&&se.ToInteger(e)===e},isSafeInteger:function isSafeInteger(e){return Number.isInteger(e)&&k(e)<=Number.MAX_SAFE_INTEGER},isNaN:X});h(Number,"parseInt",S.parseInt,Number.parseInt!==S.parseInt);if([,1].find(function(){return true})===1){re(Array.prototype,"find",Qe.find)}if([,1].findIndex(function(){return true})!==0){re(Array.prototype,"findIndex",Qe.findIndex)}var Pt=Function.bind.call(Function.bind,Object.prototype.propertyIsEnumerable);var Ct=function ensureEnumerable(e,t){if(s&&Pt(e,t)){Object.defineProperty(e,t,{enumerable:false})}};var Mt=function sliceArgs(){var e=Number(this);var t=arguments.length;var r=t-e;var n=new Array(r<0?0:r);for(var o=e;o<t;++o){n[o-e]=arguments[o]}return n};var xt=function assignTo(e){return function assignToSource(t,r){t[r]=e[r];return t}};var Nt=function(e,t){var r=n(Object(t));var o;if(se.IsCallable(Object.getOwnPropertySymbols)){o=v(Object.getOwnPropertySymbols(Object(t)),Pt(t))}return p(P(r,o||[]),xt(t),e)};var At={assign:function(e,t){var r=se.ToObject(e,"Cannot convert undefined or null to object");return p(se.Call(Mt,1,arguments),Nt,r)},is:function is(e,t){return se.SameValue(e,t)}};var Rt=Object.assign&&Object.preventExtensions&&function(){var e=Object.preventExtensions({1:2});try{Object.assign(e,"xy")}catch(t){return e[1]==="y"}}();if(Rt){re(Object,"assign",At.assign)}b(Object,At);if(s){var _t={setPrototypeOf:function(e,r){var n;var o=function(e,t){if(!se.TypeIsObject(e)){throw new TypeError("cannot set prototype on a non-object")}if(!(t===null||se.TypeIsObject(t))){throw new TypeError("can only set prototype to an object or null"+t)}};var i=function(e,r){o(e,r);t(n,e,r);return e};try{n=e.getOwnPropertyDescriptor(e.prototype,r).set;t(n,{},null)}catch(t){if(e.prototype!=={}[r]){return}n=function(e){this[r]=e};i.polyfill=i(i({},null),e.prototype)instanceof e}return i}(Object,"__proto__")};b(Object,_t)}if(Object.setPrototypeOf&&Object.getPrototypeOf&&Object.getPrototypeOf(Object.setPrototypeOf({},null))!==null&&Object.getPrototypeOf(Object.create(null))===null){(function(){var e=Object.create(null);var t=Object.getPrototypeOf;var r=Object.setPrototypeOf;Object.getPrototypeOf=function(r){var n=t(r);return n===e?null:n};Object.setPrototypeOf=function(t,n){var o=n===null?e:n;return r(t,o)};Object.setPrototypeOf.polyfill=false})()}var kt=!i(function(){Object.keys("foo")});if(!kt){var Ft=Object.keys;re(Object,"keys",function keys(e){return Ft(se.ToObject(e))});n=Object.keys}var Lt=i(function(){Object.keys(/a/g)});if(Lt){var Dt=Object.keys;re(Object,"keys",function keys(e){if(te.regex(e)){var t=[];for(var r in e){if(z(e,r)){M(t,r)}}return t}return Dt(e)});n=Object.keys}if(Object.getOwnPropertyNames){var zt=!i(function(){Object.getOwnPropertyNames("foo")});if(!zt){var qt=typeof window==="object"?Object.getOwnPropertyNames(window):[];var Wt=Object.getOwnPropertyNames;re(Object,"getOwnPropertyNames",function getOwnPropertyNames(e){var t=se.ToObject(e);if(g(t)==="[object Window]"){try{return Wt(t)}catch(e){return P([],qt)}}return Wt(t)})}}if(Object.getOwnPropertyDescriptor){var Gt=!i(function(){Object.getOwnPropertyDescriptor("foo","bar")});if(!Gt){var Ht=Object.getOwnPropertyDescriptor;re(Object,"getOwnPropertyDescriptor",function getOwnPropertyDescriptor(e,t){return Ht(se.ToObject(e),t)})}}if(Object.seal){var Vt=!i(function(){Object.seal("foo")});if(!Vt){var Bt=Object.seal;re(Object,"seal",function seal(e){if(!se.TypeIsObject(e)){return e}return Bt(e)})}}if(Object.isSealed){var Ut=!i(function(){Object.isSealed("foo")});if(!Ut){var $t=Object.isSealed;re(Object,"isSealed",function isSealed(e){if(!se.TypeIsObject(e)){return true}return $t(e)})}}if(Object.freeze){var Jt=!i(function(){Object.freeze("foo")});if(!Jt){var Xt=Object.freeze;re(Object,"freeze",function freeze(e){if(!se.TypeIsObject(e)){return e}return Xt(e)})}}if(Object.isFrozen){var Kt=!i(function(){Object.isFrozen("foo")});if(!Kt){var Zt=Object.isFrozen;re(Object,"isFrozen",function isFrozen(e){if(!se.TypeIsObject(e)){return true}return Zt(e)})}}if(Object.preventExtensions){var Yt=!i(function(){Object.preventExtensions("foo")});if(!Yt){var Qt=Object.preventExtensions;re(Object,"preventExtensions",function preventExtensions(e){if(!se.TypeIsObject(e)){return e}return Qt(e)})}}if(Object.isExtensible){var er=!i(function(){Object.isExtensible("foo")});if(!er){var tr=Object.isExtensible;re(Object,"isExtensible",function isExtensible(e){if(!se.TypeIsObject(e)){return false}return tr(e)})}}if(Object.getPrototypeOf){var rr=!i(function(){Object.getPrototypeOf("foo")});if(!rr){var nr=Object.getPrototypeOf;re(Object,"getPrototypeOf",function getPrototypeOf(e){return nr(se.ToObject(e))})}}var or=s&&function(){var e=Object.getOwnPropertyDescriptor(RegExp.prototype,"flags");return e&&se.IsCallable(e.get)}();if(s&&!or){var ir=function flags(){if(!se.TypeIsObject(this)){throw new TypeError("Method called on incompatible type: must be an object.")}var e="";if(this.global){e+="g"}if(this.ignoreCase){e+="i"}if(this.multiline){e+="m"}if(this.unicode){e+="u"}if(this.sticky){e+="y"}return e};m.getter(RegExp.prototype,"flags",ir)}var ar=s&&a(function(){return String(new RegExp(/a/g,"i"))==="/a/i"});var ur=ne&&s&&function(){var e=/./;e[$.match]=false;return RegExp(e)===e}();var fr=a(function(){return RegExp.prototype.toString.call({source:"abc"})==="/abc/"});var sr=fr&&a(function(){return RegExp.prototype.toString.call({source:"a",flags:"b"})==="/a/b"});if(!fr||!sr){var cr=RegExp.prototype.toString;h(RegExp.prototype,"toString",function toString(){var e=se.RequireObjectCoercible(this);if(te.regex(e)){return t(cr,e)}var r=ae(e.source);var n=ae(e.flags);return"/"+r+"/"+n},true);m.preserveToString(RegExp.prototype.toString,cr)}if(s&&(!ar||ur)){var lr=Object.getOwnPropertyDescriptor(RegExp.prototype,"flags").get;var pr=Object.getOwnPropertyDescriptor(RegExp.prototype,"source")||{};var vr=function(){return this.source};var yr=se.IsCallable(pr.get)?pr.get:vr;var hr=RegExp;var br=function(){return function RegExp(e,t){var r=se.IsRegExp(e);var n=this instanceof RegExp;if(!n&&r&&typeof t==="undefined"&&e.constructor===RegExp){return e}var o=e;var i=t;if(te.regex(e)){o=se.Call(yr,e);i=typeof t==="undefined"?se.Call(lr,e):t;return new RegExp(o,i)}else if(r){o=e.source;i=typeof t==="undefined"?e.flags:t}return new hr(e,t)}}();Ie(hr,br,{$input:true});RegExp=br;m.redefine(S,"RegExp",br)}if(s){var gr={input:"$_",lastMatch:"$&",lastParen:"$+",leftContext:"$`",rightContext:"$'"};l(n(gr),function(e){if(e in RegExp&&!(gr[e]in RegExp)){m.getter(RegExp,gr[e],function get(){return RegExp[e]})}})}Pe(RegExp);var dr=1/Number.EPSILON;var mr=function roundTiesToEven(e){return e+dr-dr};var Or=Math.pow(2,-23);var wr=Math.pow(2,127)*(2-Or);var jr=Math.pow(2,-126);var Sr=Math.E;var Tr=Math.LOG2E;var Ir=Math.LOG10E;var Er=Number.prototype.clz;delete Number.prototype.clz;var Pr={acosh:function acosh(e){var t=Number(e);if(X(t)||e<1){return NaN}if(t===1){return 0}if(t===Infinity){return t}return L(t/Sr+D(t+1)*D(t-1)/Sr)+1},asinh:function asinh(e){var t=Number(e);if(t===0||!T(t)){return t}return t<0?-asinh(-t):L(t+D(t*t+1))},atanh:function atanh(e){var t=Number(e);if(X(t)||t<-1||t>1){return NaN}if(t===-1){return-Infinity}if(t===1){return Infinity}if(t===0){return t}return.5*L((1+t)/(1-t))},cbrt:function cbrt(e){var t=Number(e);if(t===0){return t}var r=t<0;var n;if(r){t=-t}if(t===Infinity){n=Infinity}else{n=F(L(t)/3);n=(t/(n*n)+2*n)/3}return r?-n:n},clz32:function clz32(e){var t=Number(e);var r=se.ToUint32(t);if(r===0){return 32}return Er?se.Call(Er,r):31-_(L(r+.5)*Tr)},cosh:function cosh(e){var t=Number(e);if(t===0){return 1}if(X(t)){return NaN}if(!T(t)){return Infinity}if(t<0){t=-t}if(t>21){return F(t)/2}return(F(t)+F(-t))/2},expm1:function expm1(e){var t=Number(e);if(t===-Infinity){return-1}if(!T(t)||t===0){return t}if(k(t)>.5){return F(t)-1}var r=t;var n=0;var o=1;while(n+r!==n){n+=r;o+=1;r*=t/o}return n},hypot:function hypot(e,t){var r=0;var n=0;for(var o=0;o<arguments.length;++o){var i=k(Number(arguments[o]));if(n<i){r*=n/i*(n/i);r+=1;n=i}else{r+=i>0?i/n*(i/n):i}}return n===Infinity?Infinity:n*D(r)},log2:function log2(e){return L(e)*Tr},log10:function log10(e){return L(e)*Ir},log1p:function log1p(e){var t=Number(e);if(t<-1||X(t)){return NaN}if(t===0||t===Infinity){return t}if(t===-1){return-Infinity}return 1+t-1===0?t:t*(L(1+t)/(1+t-1))},sign:Z,sinh:function sinh(e){var t=Number(e);if(!T(t)||t===0){return t}if(k(t)<1){return(Math.expm1(t)-Math.expm1(-t))/2}return(F(t-1)-F(-t-1))*Sr/2},tanh:function tanh(e){var t=Number(e);if(X(t)||t===0){return t}if(t>=20){return 1}if(t<=-20){return-1}return(Math.expm1(t)-Math.expm1(-t))/(F(t)+F(-t))},trunc:function trunc(e){var t=Number(e);return t<0?-_(-t):_(t)},imul:function imul(e,t){var r=se.ToUint32(e);var n=se.ToUint32(t);var o=r>>>16&65535;var i=r&65535;var a=n>>>16&65535;var u=n&65535;return i*u+(o*u+i*a<<16>>>0)|0},fround:function fround(e){var t=Number(e);if(t===0||t===Infinity||t===-Infinity||X(t)){return t}var r=Z(t);var n=k(t);if(n<jr){return r*mr(n/jr/Or)*jr*Or}var o=(1+Or/Number.EPSILON)*n;var i=o-(o-n);if(i>wr||X(i)){return r*Infinity}return r*i}};b(Math,Pr);h(Math,"log1p",Pr.log1p,Math.log1p(-1e-17)!==-1e-17);h(Math,"asinh",Pr.asinh,Math.asinh(-1e7)!==-Math.asinh(1e7));h(Math,"tanh",Pr.tanh,Math.tanh(-2e-17)!==-2e-17);h(Math,"acosh",Pr.acosh,Math.acosh(Number.MAX_VALUE)===Infinity);h(Math,"cbrt",Pr.cbrt,Math.abs(1-Math.cbrt(1e-300)/1e-100)/Number.EPSILON>8);h(Math,"sinh",Pr.sinh,Math.sinh(-2e-17)!==-2e-17);var Cr=Math.expm1(10);h(Math,"expm1",Pr.expm1,Cr>22025.465794806718||Cr<22025.465794806718);var Mr=Math.round;var xr=Math.round(.5-Number.EPSILON/4)===0&&Math.round(-.5+Number.EPSILON/3.99)===1;var Nr=dr+1;var Ar=2*dr-1;var Rr=[Nr,Ar].every(function(e){return Math.round(e)===e});h(Math,"round",function round(e){var t=_(e);var r=t===-1?-0:t+1;
return e-t<.5?t:r},!xr||!Rr);m.preserveToString(Math.round,Mr);var _r=Math.imul;if(Math.imul(4294967295,5)!==-5){Math.imul=Pr.imul;m.preserveToString(Math.imul,_r)}if(Math.imul.length!==2){re(Math,"imul",function imul(e,t){return se.Call(_r,Math,arguments)})}var kr=function(){var e=S.setTimeout;if(typeof e!=="function"&&typeof e!=="object"){return}se.IsPromise=function(e){if(!se.TypeIsObject(e)){return false}if(typeof e._promise==="undefined"){return false}return true};var r=function(e){if(!se.IsConstructor(e)){throw new TypeError("Bad promise constructor")}var t=this;var r=function(e,r){if(t.resolve!==void 0||t.reject!==void 0){throw new TypeError("Bad Promise implementation!")}t.resolve=e;t.reject=r};t.resolve=void 0;t.reject=void 0;t.promise=new e(r);if(!(se.IsCallable(t.resolve)&&se.IsCallable(t.reject))){throw new TypeError("Bad promise constructor")}};var n;if(typeof window!=="undefined"&&se.IsCallable(window.postMessage)){n=function(){var e=[];var t="zero-timeout-message";var r=function(r){M(e,r);window.postMessage(t,"*")};var n=function(r){if(r.source===window&&r.data===t){r.stopPropagation();if(e.length===0){return}var n=N(e);n()}};window.addEventListener("message",n,true);return r}}var o=function(){var e=S.Promise;var t=e&&e.resolve&&e.resolve();return t&&function(e){return t.then(e)}};var i=se.IsCallable(S.setImmediate)?S.setImmediate:typeof process==="object"&&process.nextTick?process.nextTick:o()||(se.IsCallable(n)?n():function(t){e(t,0)});var a=function(e){return e};var u=function(e){throw e};var f=0;var s=1;var c=2;var l=0;var p=1;var v=2;var y={};var h=function(e,t,r){i(function(){g(e,t,r)})};var g=function(e,t,r){var n,o;if(t===y){return e(r)}try{n=e(r);o=t.resolve}catch(e){n=e;o=t.reject}o(n)};var d=function(e,t){var r=e._promise;var n=r.reactionLength;if(n>0){h(r.fulfillReactionHandler0,r.reactionCapability0,t);r.fulfillReactionHandler0=void 0;r.rejectReactions0=void 0;r.reactionCapability0=void 0;if(n>1){for(var o=1,i=0;o<n;o++,i+=3){h(r[i+l],r[i+v],t);e[i+l]=void 0;e[i+p]=void 0;e[i+v]=void 0}}}r.result=t;r.state=s;r.reactionLength=0};var m=function(e,t){var r=e._promise;var n=r.reactionLength;if(n>0){h(r.rejectReactionHandler0,r.reactionCapability0,t);r.fulfillReactionHandler0=void 0;r.rejectReactions0=void 0;r.reactionCapability0=void 0;if(n>1){for(var o=1,i=0;o<n;o++,i+=3){h(r[i+p],r[i+v],t);e[i+l]=void 0;e[i+p]=void 0;e[i+v]=void 0}}}r.result=t;r.state=c;r.reactionLength=0};var O=function(e){var t=false;var r=function(r){var n;if(t){return}t=true;if(r===e){return m(e,new TypeError("Self resolution"))}if(!se.TypeIsObject(r)){return d(e,r)}try{n=r.then}catch(t){return m(e,t)}if(!se.IsCallable(n)){return d(e,r)}i(function(){j(e,r,n)})};var n=function(r){if(t){return}t=true;return m(e,r)};return{resolve:r,reject:n}};var w=function(e,r,n,o){if(e===I){t(e,r,n,o,y)}else{t(e,r,n,o)}};var j=function(e,t,r){var n=O(e);var o=n.resolve;var i=n.reject;try{w(r,t,o,i)}catch(e){i(e)}};var T,I;var E=function(){var e=function Promise(t){if(!(this instanceof e)){throw new TypeError('Constructor Promise requires "new"')}if(this&&this._promise){throw new TypeError("Bad construction")}if(!se.IsCallable(t)){throw new TypeError("not a valid resolver")}var r=Ne(this,e,T,{_promise:{result:void 0,state:f,reactionLength:0,fulfillReactionHandler0:void 0,rejectReactionHandler0:void 0,reactionCapability0:void 0}});var n=O(r);var o=n.reject;try{t(n.resolve,o)}catch(e){o(e)}return r};return e}();T=E.prototype;var P=function(e,t,r,n){var o=false;return function(i){if(o){return}o=true;t[e]=i;if(--n.count===0){var a=r.resolve;a(t)}}};var C=function(e,t,r){var n=e.iterator;var o=[];var i={count:1};var a,u;var f=0;while(true){try{a=se.IteratorStep(n);if(a===false){e.done=true;break}u=a.value}catch(t){e.done=true;throw t}o[f]=void 0;var s=t.resolve(u);var c=P(f,o,r,i);i.count+=1;w(s.then,s,c,r.reject);f+=1}if(--i.count===0){var l=r.resolve;l(o)}return r.promise};var x=function(e,t,r){var n=e.iterator;var o,i,a;while(true){try{o=se.IteratorStep(n);if(o===false){e.done=true;break}i=o.value}catch(t){e.done=true;throw t}a=t.resolve(i);w(a.then,a,r.resolve,r.reject)}return r.promise};b(E,{all:function all(e){var t=this;if(!se.TypeIsObject(t)){throw new TypeError("Promise is not object")}var n=new r(t);var o,i;try{o=se.GetIterator(e);i={iterator:o,done:false};return C(i,t,n)}catch(e){var a=e;if(i&&!i.done){try{se.IteratorClose(o,true)}catch(e){a=e}}var u=n.reject;u(a);return n.promise}},race:function race(e){var t=this;if(!se.TypeIsObject(t)){throw new TypeError("Promise is not object")}var n=new r(t);var o,i;try{o=se.GetIterator(e);i={iterator:o,done:false};return x(i,t,n)}catch(e){var a=e;if(i&&!i.done){try{se.IteratorClose(o,true)}catch(e){a=e}}var u=n.reject;u(a);return n.promise}},reject:function reject(e){var t=this;if(!se.TypeIsObject(t)){throw new TypeError("Bad promise constructor")}var n=new r(t);var o=n.reject;o(e);return n.promise},resolve:function resolve(e){var t=this;if(!se.TypeIsObject(t)){throw new TypeError("Bad promise constructor")}if(se.IsPromise(e)){var n=e.constructor;if(n===t){return e}}var o=new r(t);var i=o.resolve;i(e);return o.promise}});b(T,{catch:function(e){return this.then(null,e)},then:function then(e,t){var n=this;if(!se.IsPromise(n)){throw new TypeError("not a promise")}var o=se.SpeciesConstructor(n,E);var i;var b=arguments.length>2&&arguments[2]===y;if(b&&o===E){i=y}else{i=new r(o)}var g=se.IsCallable(e)?e:a;var d=se.IsCallable(t)?t:u;var m=n._promise;var O;if(m.state===f){if(m.reactionLength===0){m.fulfillReactionHandler0=g;m.rejectReactionHandler0=d;m.reactionCapability0=i}else{var w=3*(m.reactionLength-1);m[w+l]=g;m[w+p]=d;m[w+v]=i}m.reactionLength+=1}else if(m.state===s){O=m.result;h(g,i,O)}else if(m.state===c){O=m.result;h(d,i,O)}else{throw new TypeError("unexpected Promise state")}return i.promise}});y=new r(E);I=T.then;return E}();if(S.Promise){delete S.Promise.accept;delete S.Promise.defer;delete S.Promise.prototype.chain}if(typeof kr==="function"){b(S,{Promise:kr});var Fr=w(S.Promise,function(e){return e.resolve(42).then(function(){})instanceof e});var Lr=!i(function(){S.Promise.reject(42).then(null,5).then(null,W)});var Dr=i(function(){S.Promise.call(3,W)});var zr=function(e){var t=e.resolve(5);t.constructor={};var r=e.resolve(t);try{r.then(null,W).then(null,W)}catch(e){return true}return t===r}(S.Promise);var qr=s&&function(){var e=0;var t=Object.defineProperty({},"then",{get:function(){e+=1}});Promise.resolve(t);return e===1}();var Wr=function BadResolverPromise(e){var t=new Promise(e);e(3,function(){});this.then=t.then;this.constructor=BadResolverPromise};Wr.prototype=Promise.prototype;Wr.all=Promise.all;var Gr=a(function(){return!!Wr.all([1,2])});if(!Fr||!Lr||!Dr||zr||!qr||Gr){Promise=kr;re(S,"Promise",kr)}if(Promise.all.length!==1){var Hr=Promise.all;re(Promise,"all",function all(e){return se.Call(Hr,this,arguments)})}if(Promise.race.length!==1){var Vr=Promise.race;re(Promise,"race",function race(e){return se.Call(Vr,this,arguments)})}if(Promise.resolve.length!==1){var Br=Promise.resolve;re(Promise,"resolve",function resolve(e){return se.Call(Br,this,arguments)})}if(Promise.reject.length!==1){var Ur=Promise.reject;re(Promise,"reject",function reject(e){return se.Call(Ur,this,arguments)})}Ct(Promise,"all");Ct(Promise,"race");Ct(Promise,"resolve");Ct(Promise,"reject");Pe(Promise)}var $r=function(e){var t=n(p(e,function(e,t){e[t]=true;return e},{}));return e.join(":")===t.join(":")};var Jr=$r(["z","a","bb"]);var Xr=$r(["z",1,"a","3",2]);if(s){var Kr=function fastkey(e,t){if(!t&&!Jr){return null}if(fe(e)){return"^"+se.ToString(e)}else if(typeof e==="string"){return"$"+e}else if(typeof e==="number"){if(!Xr){return"n"+e}return e}else if(typeof e==="boolean"){return"b"+e}return null};var Zr=function emptyObject(){return Object.create?Object.create(null):{}};var Yr=function addIterableToMap(e,n,o){if(r(o)||te.string(o)){l(o,function(e){if(!se.TypeIsObject(e)){throw new TypeError("Iterator value "+e+" is not an entry object")}n.set(e[0],e[1])})}else if(o instanceof e){t(e.prototype.forEach,o,function(e,t){n.set(t,e)})}else{var i,a;if(!fe(o)){a=n.set;if(!se.IsCallable(a)){throw new TypeError("bad map")}i=se.GetIterator(o)}if(typeof i!=="undefined"){while(true){var u=se.IteratorStep(i);if(u===false){break}var f=u.value;try{if(!se.TypeIsObject(f)){throw new TypeError("Iterator value "+f+" is not an entry object")}t(a,n,f[0],f[1])}catch(e){se.IteratorClose(i,true);throw e}}}}};var Qr=function addIterableToSet(e,n,o){if(r(o)||te.string(o)){l(o,function(e){n.add(e)})}else if(o instanceof e){t(e.prototype.forEach,o,function(e){n.add(e)})}else{var i,a;if(!fe(o)){a=n.add;if(!se.IsCallable(a)){throw new TypeError("bad set")}i=se.GetIterator(o)}if(typeof i!=="undefined"){while(true){var u=se.IteratorStep(i);if(u===false){break}var f=u.value;try{t(a,n,f)}catch(e){se.IteratorClose(i,true);throw e}}}}};var en={Map:function(){var e={};var r=function MapEntry(e,t){this.key=e;this.value=t;this.next=null;this.prev=null};r.prototype.isRemoved=function isRemoved(){return this.key===e};var n=function isMap(e){return!!e._es6map};var o=function requireMapSlot(e,t){if(!se.TypeIsObject(e)||!n(e)){throw new TypeError("Method Map.prototype."+t+" called on incompatible receiver "+se.ToString(e))}};var i=function MapIterator(e,t){o(e,"[[MapIterator]]");this.head=e._head;this.i=this.head;this.kind=t};i.prototype={next:function next(){var e=this.i;var t=this.kind;var r=this.head;if(typeof this.i==="undefined"){return Xe()}while(e.isRemoved()&&e!==r){e=e.prev}var n;while(e.next!==r){e=e.next;if(!e.isRemoved()){if(t==="key"){n=e.key}else if(t==="value"){n=e.value}else{n=[e.key,e.value]}this.i=e;return Xe(n)}}this.i=void 0;return Xe()}};Ce(i.prototype);var a;var u=function Map(){if(!(this instanceof Map)){throw new TypeError('Constructor Map requires "new"')}if(this&&this._es6map){throw new TypeError("Bad construction")}var e=Ne(this,Map,a,{_es6map:true,_head:null,_map:G?new G:null,_size:0,_storage:Zr()});var t=new r(null,null);t.next=t.prev=t;e._head=t;if(arguments.length>0){Yr(Map,e,arguments[0])}return e};a=u.prototype;m.getter(a,"size",function(){if(typeof this._size==="undefined"){throw new TypeError("size method called on incompatible Map")}return this._size});b(a,{get:function get(e){o(this,"get");var t;var r=Kr(e,true);if(r!==null){t=this._storage[r];if(t){return t.value}else{return}}if(this._map){t=V.call(this._map,e);if(t){return t.value}else{return}}var n=this._head;var i=n;while((i=i.next)!==n){if(se.SameValueZero(i.key,e)){return i.value}}},has:function has(e){o(this,"has");var t=Kr(e,true);if(t!==null){return typeof this._storage[t]!=="undefined"}if(this._map){return B.call(this._map,e)}var r=this._head;var n=r;while((n=n.next)!==r){if(se.SameValueZero(n.key,e)){return true}}return false},set:function set(e,t){o(this,"set");var n=this._head;var i=n;var a;var u=Kr(e,true);if(u!==null){if(typeof this._storage[u]!=="undefined"){this._storage[u].value=t;return this}else{a=this._storage[u]=new r(e,t);i=n.prev}}else if(this._map){if(B.call(this._map,e)){V.call(this._map,e).value=t}else{a=new r(e,t);U.call(this._map,e,a);i=n.prev}}while((i=i.next)!==n){if(se.SameValueZero(i.key,e)){i.value=t;return this}}a=a||new r(e,t);if(se.SameValue(-0,e)){a.key=+0}a.next=this._head;a.prev=this._head.prev;a.prev.next=a;a.next.prev=a;this._size+=1;return this},delete:function(t){o(this,"delete");var r=this._head;var n=r;var i=Kr(t,true);if(i!==null){if(typeof this._storage[i]==="undefined"){return false}n=this._storage[i].prev;delete this._storage[i]}else if(this._map){if(!B.call(this._map,t)){return false}n=V.call(this._map,t).prev;H.call(this._map,t)}while((n=n.next)!==r){if(se.SameValueZero(n.key,t)){n.key=e;n.value=e;n.prev.next=n.next;n.next.prev=n.prev;this._size-=1;return true}}return false},clear:function clear(){o(this,"clear");this._map=G?new G:null;this._size=0;this._storage=Zr();var t=this._head;var r=t;var n=r.next;while((r=n)!==t){r.key=e;r.value=e;n=r.next;r.next=r.prev=t}t.next=t.prev=t},keys:function keys(){o(this,"keys");return new i(this,"key")},values:function values(){o(this,"values");return new i(this,"value")},entries:function entries(){o(this,"entries");return new i(this,"key+value")},forEach:function forEach(e){o(this,"forEach");var r=arguments.length>1?arguments[1]:null;var n=this.entries();for(var i=n.next();!i.done;i=n.next()){if(r){t(e,r,i.value[1],i.value[0],this)}else{e(i.value[1],i.value[0],this)}}}});Ce(a,a.entries);return u}(),Set:function(){var e=function isSet(e){return e._es6set&&typeof e._storage!=="undefined"};var r=function requireSetSlot(t,r){if(!se.TypeIsObject(t)||!e(t)){throw new TypeError("Set.prototype."+r+" called on incompatible receiver "+se.ToString(t))}};var o;var i=function Set(){if(!(this instanceof Set)){throw new TypeError('Constructor Set requires "new"')}if(this&&this._es6set){throw new TypeError("Bad construction")}var e=Ne(this,Set,o,{_es6set:true,"[[SetData]]":null,_storage:Zr()});if(!e._es6set){throw new TypeError("bad set")}if(arguments.length>0){Qr(Set,e,arguments[0])}return e};o=i.prototype;var a=function(e){var t=e;if(t==="^null"){return null}else if(t==="^undefined"){return void 0}else{var r=t.charAt(0);if(r==="$"){return C(t,1)}else if(r==="n"){return+C(t,1)}else if(r==="b"){return t==="btrue"}}return+t};var u=function ensureMap(e){if(!e["[[SetData]]"]){var t=new en.Map;e["[[SetData]]"]=t;l(n(e._storage),function(e){var r=a(e);t.set(r,r)});e["[[SetData]]"]=t}e._storage=null};m.getter(i.prototype,"size",function(){r(this,"size");if(this._storage){return n(this._storage).length}u(this);return this["[[SetData]]"].size});b(i.prototype,{has:function has(e){r(this,"has");var t;if(this._storage&&(t=Kr(e))!==null){return!!this._storage[t]}u(this);return this["[[SetData]]"].has(e)},add:function add(e){r(this,"add");var t;if(this._storage&&(t=Kr(e))!==null){this._storage[t]=true;return this}u(this);this["[[SetData]]"].set(e,e);return this},delete:function(e){r(this,"delete");var t;if(this._storage&&(t=Kr(e))!==null){var n=z(this._storage,t);return delete this._storage[t]&&n}u(this);return this["[[SetData]]"]["delete"](e)},clear:function clear(){r(this,"clear");if(this._storage){this._storage=Zr()}if(this["[[SetData]]"]){this["[[SetData]]"].clear()}},values:function values(){r(this,"values");u(this);return this["[[SetData]]"].values()},entries:function entries(){r(this,"entries");u(this);return this["[[SetData]]"].entries()},forEach:function forEach(e){r(this,"forEach");var n=arguments.length>1?arguments[1]:null;var o=this;u(o);this["[[SetData]]"].forEach(function(r,i){if(n){t(e,n,i,i,o)}else{e(i,i,o)}})}});h(i.prototype,"keys",i.prototype.values,true);Ce(i.prototype,i.prototype.values);return i}()};if(S.Map||S.Set){var tn=a(function(){return new Map([[1,2]]).get(1)===2});if(!tn){S.Map=function Map(){if(!(this instanceof Map)){throw new TypeError('Constructor Map requires "new"')}var e=new G;if(arguments.length>0){Yr(Map,e,arguments[0])}delete e.constructor;Object.setPrototypeOf(e,S.Map.prototype);return e};S.Map.prototype=O(G.prototype);h(S.Map.prototype,"constructor",S.Map,true);m.preserveToString(S.Map,G)}var rn=new Map;var nn=function(){var e=new Map([[1,0],[2,0],[3,0],[4,0]]);e.set(-0,e);return e.get(0)===e&&e.get(-0)===e&&e.has(0)&&e.has(-0)}();var on=rn.set(1,2)===rn;if(!nn||!on){re(Map.prototype,"set",function set(e,r){t(U,this,e===0?0:e,r);return this})}if(!nn){b(Map.prototype,{get:function get(e){return t(V,this,e===0?0:e)},has:function has(e){return t(B,this,e===0?0:e)}},true);m.preserveToString(Map.prototype.get,V);m.preserveToString(Map.prototype.has,B)}var an=new Set;var un=function(e){e["delete"](0);e.add(-0);return!e.has(0)}(an);var fn=an.add(1)===an;if(!un||!fn){var sn=Set.prototype.add;Set.prototype.add=function add(e){t(sn,this,e===0?0:e);return this};m.preserveToString(Set.prototype.add,sn)}if(!un){var cn=Set.prototype.has;Set.prototype.has=function has(e){return t(cn,this,e===0?0:e)};m.preserveToString(Set.prototype.has,cn);var ln=Set.prototype["delete"];Set.prototype["delete"]=function SetDelete(e){return t(ln,this,e===0?0:e)};m.preserveToString(Set.prototype["delete"],ln)}var pn=w(S.Map,function(e){var t=new e([]);t.set(42,42);return t instanceof e});var vn=Object.setPrototypeOf&&!pn;var yn=function(){try{return!(S.Map()instanceof S.Map)}catch(e){return e instanceof TypeError}}();if(S.Map.length!==0||vn||!yn){S.Map=function Map(){if(!(this instanceof Map)){throw new TypeError('Constructor Map requires "new"')}var e=new G;if(arguments.length>0){Yr(Map,e,arguments[0])}delete e.constructor;Object.setPrototypeOf(e,Map.prototype);return e};S.Map.prototype=G.prototype;h(S.Map.prototype,"constructor",S.Map,true);m.preserveToString(S.Map,G)}var hn=w(S.Set,function(e){var t=new e([]);t.add(42,42);return t instanceof e});var bn=Object.setPrototypeOf&&!hn;var gn=function(){try{return!(S.Set()instanceof S.Set)}catch(e){return e instanceof TypeError}}();if(S.Set.length!==0||bn||!gn){var dn=S.Set;S.Set=function Set(){if(!(this instanceof Set)){throw new TypeError('Constructor Set requires "new"')}var e=new dn;if(arguments.length>0){Qr(Set,e,arguments[0])}delete e.constructor;Object.setPrototypeOf(e,Set.prototype);return e};S.Set.prototype=dn.prototype;h(S.Set.prototype,"constructor",S.Set,true);m.preserveToString(S.Set,dn)}var mn=new S.Map;var On=!a(function(){return mn.keys().next().done});if(typeof S.Map.prototype.clear!=="function"||(new S.Set).size!==0||mn.size!==0||typeof S.Map.prototype.keys!=="function"||typeof S.Set.prototype.keys!=="function"||typeof S.Map.prototype.forEach!=="function"||typeof S.Set.prototype.forEach!=="function"||u(S.Map)||u(S.Set)||typeof mn.keys().next!=="function"||On||!pn){b(S,{Map:en.Map,Set:en.Set},true)}if(S.Set.prototype.keys!==S.Set.prototype.values){h(S.Set.prototype,"keys",S.Set.prototype.values,true)}Ce(Object.getPrototypeOf((new S.Map).keys()));Ce(Object.getPrototypeOf((new S.Set).keys()));if(c&&S.Set.prototype.has.name!=="has"){var wn=S.Set.prototype.has;re(S.Set.prototype,"has",function has(e){return t(wn,this,e)})}}b(S,en);Pe(S.Map);Pe(S.Set)}var jn=function throwUnlessTargetIsObject(e){if(!se.TypeIsObject(e)){throw new TypeError("target must be an object")}};var Sn={apply:function apply(){return se.Call(se.Call,null,arguments)},construct:function construct(e,t){if(!se.IsConstructor(e)){throw new TypeError("First argument must be a constructor.")}var r=arguments.length>2?arguments[2]:e;if(!se.IsConstructor(r)){throw new TypeError("new.target must be a constructor.")}return se.Construct(e,t,r,"internal")},deleteProperty:function deleteProperty(e,t){jn(e);if(s){var r=Object.getOwnPropertyDescriptor(e,t);if(r&&!r.configurable){return false}}return delete e[t]},has:function has(e,t){jn(e);return t in e}};if(Object.getOwnPropertyNames){Object.assign(Sn,{ownKeys:function ownKeys(e){jn(e);var t=Object.getOwnPropertyNames(e);if(se.IsCallable(Object.getOwnPropertySymbols)){x(t,Object.getOwnPropertySymbols(e))}return t}})}var Tn=function ConvertExceptionToBoolean(e){return!i(e)};if(Object.preventExtensions){Object.assign(Sn,{isExtensible:function isExtensible(e){jn(e);return Object.isExtensible(e)},preventExtensions:function preventExtensions(e){jn(e);return Tn(function(){Object.preventExtensions(e)})}})}if(s){var In=function get(e,t,r){var n=Object.getOwnPropertyDescriptor(e,t);if(!n){var o=Object.getPrototypeOf(e);if(o===null){return void 0}return In(o,t,r)}if("value"in n){return n.value}if(n.get){return se.Call(n.get,r)}return void 0};var En=function set(e,r,n,o){var i=Object.getOwnPropertyDescriptor(e,r);if(!i){var a=Object.getPrototypeOf(e);if(a!==null){return En(a,r,n,o)}i={value:void 0,writable:true,enumerable:true,configurable:true}}if("value"in i){if(!i.writable){return false}if(!se.TypeIsObject(o)){return false}var u=Object.getOwnPropertyDescriptor(o,r);if(u){return ie.defineProperty(o,r,{value:n})}else{return ie.defineProperty(o,r,{value:n,writable:true,enumerable:true,configurable:true})}}if(i.set){t(i.set,o,n);return true}return false};Object.assign(Sn,{defineProperty:function defineProperty(e,t,r){jn(e);return Tn(function(){Object.defineProperty(e,t,r)})},getOwnPropertyDescriptor:function getOwnPropertyDescriptor(e,t){jn(e);return Object.getOwnPropertyDescriptor(e,t)},get:function get(e,t){jn(e);var r=arguments.length>2?arguments[2]:e;return In(e,t,r)},set:function set(e,t,r){jn(e);var n=arguments.length>3?arguments[3]:e;return En(e,t,r,n)}})}if(Object.getPrototypeOf){var Pn=Object.getPrototypeOf;Sn.getPrototypeOf=function getPrototypeOf(e){jn(e);return Pn(e)}}if(Object.setPrototypeOf&&Sn.getPrototypeOf){var Cn=function(e,t){var r=t;while(r){if(e===r){return true}r=Sn.getPrototypeOf(r)}return false};Object.assign(Sn,{setPrototypeOf:function setPrototypeOf(e,t){jn(e);if(t!==null&&!se.TypeIsObject(t)){throw new TypeError("proto must be an object or null")}if(t===ie.getPrototypeOf(e)){return true}if(ie.isExtensible&&!ie.isExtensible(e)){return false}if(Cn(e,t)){return false}Object.setPrototypeOf(e,t);return true}})}var Mn=function(e,t){if(!se.IsCallable(S.Reflect[e])){h(S.Reflect,e,t)}else{var r=a(function(){S.Reflect[e](1);S.Reflect[e](NaN);S.Reflect[e](true);return true});if(r){re(S.Reflect,e,t)}}};Object.keys(Sn).forEach(function(e){Mn(e,Sn[e])});var xn=S.Reflect.getPrototypeOf;if(c&&xn&&xn.name!=="getPrototypeOf"){re(S.Reflect,"getPrototypeOf",function getPrototypeOf(e){return t(xn,S.Reflect,e)})}if(S.Reflect.setPrototypeOf){if(a(function(){S.Reflect.setPrototypeOf(1,{});return true})){re(S.Reflect,"setPrototypeOf",Sn.setPrototypeOf)}}if(S.Reflect.defineProperty){if(!a(function(){var e=!S.Reflect.defineProperty(1,"test",{value:1});var t=typeof Object.preventExtensions!=="function"||!S.Reflect.defineProperty(Object.preventExtensions({}),"test",{});return e&&t})){re(S.Reflect,"defineProperty",Sn.defineProperty)}}if(S.Reflect.construct){if(!a(function(){var e=function F(){};return S.Reflect.construct(function(){},[],e)instanceof e})){re(S.Reflect,"construct",Sn.construct)}}if(String(new Date(NaN))!=="Invalid Date"){var Nn=Date.prototype.toString;var An=function toString(){var e=+this;if(e!==e){return"Invalid Date"}return se.Call(Nn,this)};re(Date.prototype,"toString",An)}var Rn={anchor:function anchor(e){return se.CreateHTML(this,"a","name",e)},big:function big(){return se.CreateHTML(this,"big","","")},blink:function blink(){return se.CreateHTML(this,"blink","","")},bold:function bold(){return se.CreateHTML(this,"b","","")},fixed:function fixed(){return se.CreateHTML(this,"tt","","")},fontcolor:function fontcolor(e){return se.CreateHTML(this,"font","color",e)},fontsize:function fontsize(e){return se.CreateHTML(this,"font","size",e)},italics:function italics(){return se.CreateHTML(this,"i","","")},link:function link(e){return se.CreateHTML(this,"a","href",e)},small:function small(){return se.CreateHTML(this,"small","","")},strike:function strike(){return se.CreateHTML(this,"strike","","")},sub:function sub(){return se.CreateHTML(this,"sub","","")},sup:function sub(){return se.CreateHTML(this,"sup","","")}};l(Object.keys(Rn),function(e){var r=String.prototype[e];var n=false;if(se.IsCallable(r)){var o=t(r,"",' " ');var i=P([],o.match(/"/g)).length;n=o!==o.toLowerCase()||i>2}else{n=true}if(n){re(String.prototype,e,Rn[e])}});var _n=function(){if(!ne){return false}var e=typeof JSON==="object"&&typeof JSON.stringify==="function"?JSON.stringify:null;if(!e){return false}if(typeof e($())!=="undefined"){return true}if(e([$()])!=="[null]"){return true}var t={a:$()};t[$()]=true;if(e(t)!=="{}"){return true}return false}();var kn=a(function(){if(!ne){return true}return JSON.stringify(Object($()))==="{}"&&JSON.stringify([Object($())])==="[{}]"});if(_n||!kn){var Fn=JSON.stringify;re(JSON,"stringify",function stringify(e){if(typeof e==="symbol"){return}var n;if(arguments.length>1){n=arguments[1]}var o=[e];if(!r(n)){var i=se.IsCallable(n)?n:null;var a=function(e,r){var n=i?t(i,this,e,r):r;if(typeof n!=="symbol"){if(te.symbol(n)){return xt({})(n)}else{return n}}};o.push(a)}else{o.push(n)}if(arguments.length>2){o.push(arguments[2])}return Fn.apply(this,o)})}return S});
//# sourceMappingURL=es6-shim.map
;
(function t(e,r,n){function i(p,u){if(!r[p]){if(!e[p]){var a=typeof require=="function"&&require;if(!u&&a)return a(p,!0);if(o)return o(p,!0);var l=new Error("Cannot find module '"+p+"'");throw l.code="MODULE_NOT_FOUND",l}var s=r[p]={exports:{}};e[p][0].call(s.exports,function(t){var r=e[p][1][t];return i(r?r:t)},s,s.exports,t,e,r,n)}return r[p].exports}var o=typeof require=="function"&&require;for(var p=0;p<n.length;p++)i(n[p]);return i})({1:[function(t,e,r){"use strict";var n=t("./Array.prototype");e.exports={prototype:n,shim:function t(){n.shim()}}},{"./Array.prototype":3}],2:[function(t,e,r){"use strict";e.exports=t("array-includes")},{"array-includes":14}],3:[function(t,e,r){"use strict";var n=t("./Array.prototype.includes");e.exports={includes:n,shim:function t(){n.shim()}}},{"./Array.prototype.includes":2}],4:[function(t,e,r){"use strict";var n=t("object.getownpropertydescriptors");var i=t("object.entries");var o=t("object.values");e.exports={entries:i,getOwnPropertyDescriptors:n,shim:function t(){n.shim();i.shim();o.shim()},values:o}},{"object.entries":38,"object.getownpropertydescriptors":64,"object.values":89}],5:[function(t,e,r){"use strict";var n=t("./String.prototype");e.exports={prototype:n,shim:function t(){n.shim()}}},{"./String.prototype":7}],6:[function(t,e,r){"use strict";e.exports=t("string-at")},{"string-at":114}],7:[function(t,e,r){"use strict";var n=t("./String.prototype.at");var i=t("./String.prototype.padStart");var o=t("./String.prototype.padEnd");var p=t("./String.prototype.trimLeft");var u=t("./String.prototype.trimRight");e.exports={at:n,padStart:i,padEnd:o,trimLeft:p,trimRight:u,shim:function t(){n.shim();i.shim();o.shim();p.shim();u.shim()}}},{"./String.prototype.at":6,"./String.prototype.padEnd":8,"./String.prototype.padStart":9,"./String.prototype.trimLeft":10,"./String.prototype.trimRight":11}],8:[function(t,e,r){"use strict";e.exports=t("string.prototype.padend")},{"string.prototype.padend":137}],9:[function(t,e,r){"use strict";e.exports=t("string.prototype.padstart")},{"string.prototype.padstart":162}],10:[function(t,e,r){"use strict";e.exports=t("string.prototype.trimleft")},{"string.prototype.trimleft":187}],11:[function(t,e,r){"use strict";e.exports=t("string.prototype.trimright")},{"string.prototype.trimright":197}],12:[function(t,e,r){/*!
 * https://github.com/es-shims/es7-shim
 * @license es7-shim Copyright 2014 by contributors, MIT License
 * see https://github.com/es-shims/es7-shim/blob/master/LICENSE
 */
var n=t("./Array");var i=t("./Object");var o=t("./String");e.exports={Array:n,Object:i,String:o,shim:function t(){n.shim();i.shim();o.shim()}}},{"./Array":1,"./Object":4,"./String":5}],13:[function(t,e,r){(function(r){"use strict";var n=t("es-abstract/es6");var i=Number.isNaN||function(t){return t!==t};var o=Number.isFinite||function(t){return typeof t==="number"&&r.isFinite(t)};var p=Array.prototype.indexOf;e.exports=function t(e){var r=arguments.length>1?n.ToInteger(arguments[1]):0;if(p&&!i(e)&&o(r)&&typeof e!=="undefined"){return p.apply(this,arguments)>-1}var u=n.ToObject(this);var a=n.ToLength(u.length);if(a===0){return false}var l=r>=0?r:Math.max(0,a+r);while(l<a){if(n.SameValueZero(e,u[l])){return true}l+=1}return false}}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"es-abstract/es6":17}],14:[function(t,e,r){"use strict";var n=t("define-properties");var i=t("es-abstract/es6");var o=t("./implementation");var p=t("./polyfill");var u=p();var a=t("./shim");var l=Array.prototype.slice;var s=function t(e,r){i.RequireObjectCoercible(e);return u.apply(e,l.call(arguments,1))};n(s,{implementation:o,getPolyfill:p,shim:a});e.exports=s},{"./implementation":13,"./polyfill":35,"./shim":36,"define-properties":15,"es-abstract/es6":17}],15:[function(t,e,r){"use strict";var n=t("object-keys");var i=t("foreach");var o=typeof Symbol==="function"&&typeof Symbol()==="symbol";var p=Object.prototype.toString;var u=function(t){return typeof t==="function"&&p.call(t)==="[object Function]"};var a=function(){var t={};try{Object.defineProperty(t,"x",{enumerable:false,value:t});for(var e in t){return false}return t.x===t}catch(t){return false}};var l=Object.defineProperty&&a();var s=function(t,e,r,n){if(e in t&&(!u(n)||!n())){return}if(l){Object.defineProperty(t,e,{configurable:true,enumerable:false,value:r,writable:true})}else{t[e]=r}};var c=function(t,e){var r=arguments.length>2?arguments[2]:{};var p=n(e);if(o){p=p.concat(Object.getOwnPropertySymbols(e))}i(p,function(n){s(t,n,e[n],r[n])})};c.supportsDescriptors=!!l;e.exports=c},{foreach:26,"object-keys":33}],16:[function(t,e,r){"use strict";var n=Number.isNaN||function(t){return t!==t};var i=t("./helpers/isFinite");var o=t("./helpers/sign");var p=t("./helpers/mod");var u=t("is-callable");var a=t("es-to-primitive/es5");var l={ToPrimitive:a,ToBoolean:function t(e){return Boolean(e)},ToNumber:function t(e){return Number(e)},ToInteger:function t(e){var r=this.ToNumber(e);if(n(r)){return 0}if(r===0||!i(r)){return r}return o(r)*Math.floor(Math.abs(r))},ToInt32:function t(e){return this.ToNumber(e)>>0},ToUint32:function t(e){return this.ToNumber(e)>>>0},ToUint16:function t(e){var r=this.ToNumber(e);if(n(r)||r===0||!i(r)){return 0}var u=o(r)*Math.floor(Math.abs(r));return p(u,65536)},ToString:function t(e){return String(e)},ToObject:function t(e){this.CheckObjectCoercible(e);return Object(e)},CheckObjectCoercible:function t(e,r){if(e==null){throw new TypeError(r||"Cannot call method on "+e)}return e},IsCallable:u,SameValue:function t(e,r){if(e===r){if(e===0){return 1/e===1/r}return true}return n(e)&&n(r)}};e.exports=l},{"./helpers/isFinite":19,"./helpers/mod":21,"./helpers/sign":22,"es-to-primitive/es5":23,"is-callable":29}],17:[function(t,e,r){"use strict";var n=Object.prototype.toString;var i=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol";var o=i?Symbol.prototype.toString:n;var p=Number.isNaN||function(t){return t!==t};var u=t("./helpers/isFinite");var a=Number.MAX_SAFE_INTEGER||Math.pow(2,53)-1;var l=t("./helpers/assign");var s=t("./helpers/sign");var c=t("./helpers/mod");var f=t("./helpers/isPrimitive");var y=t("es-to-primitive/es6");var v=parseInt;var m=t("function-bind");var b=m.call(Function.call,String.prototype.slice);var d=m.call(Function.call,RegExp.prototype.test,/^0b[01]+$/i);var h=m.call(Function.call,RegExp.prototype.test,/^0o[0-7]+$/i);var g=["\x85","\u200b","\ufffe"].join("");var S=new RegExp("["+g+"]","g");var j=m.call(Function.call,RegExp.prototype.test,S);var x=/^[\-\+]0x[0-9a-f]+$/i;var O=m.call(Function.call,RegExp.prototype.test,x);var w=["\t\n\v\f\r \xa0\u1680\u180e\u2000\u2001\u2002\u2003","\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028","\u2029\ufeff"].join("");var T=new RegExp("(^["+w+"]+)|(["+w+"]+$)","g");var F=m.call(Function.call,String.prototype.replace);var P=function(t){return F(t,T,"")};var E=t("./es5");var N=t("is-regex");var A=l(l({},E),{Call:function t(e,r){var n=arguments.length>2?arguments[2]:[];if(!this.IsCallable(e)){throw new TypeError(e+" is not a function")}return e.apply(r,n)},ToPrimitive:y,ToNumber:function t(e){var r=f(e)?e:y(e,"number");if(typeof r==="symbol"){throw new TypeError("Cannot convert a Symbol value to a number")}if(typeof r==="string"){if(d(r)){return this.ToNumber(v(b(r,2),2))}else if(h(r)){return this.ToNumber(v(b(r,2),8))}else if(j(r)||O(r)){return NaN}else{var n=P(r);if(n!==r){return this.ToNumber(n)}}}return Number(r)},ToInt16:function t(e){var r=this.ToUint16(e);return r>=32768?r-65536:r},ToInt8:function t(e){var r=this.ToUint8(e);return r>=128?r-256:r},ToUint8:function t(e){var r=this.ToNumber(e);if(p(r)||r===0||!u(r)){return 0}var n=s(r)*Math.floor(Math.abs(r));return c(n,256)},ToUint8Clamp:function t(e){var r=this.ToNumber(e);if(p(r)||r<=0){return 0}if(r>=255){return 255}var n=Math.floor(e);if(n+.5<r){return n+1}if(r<n+.5){return n}if(n%2!==0){return n+1}return n},ToString:function t(e){if(typeof e==="symbol"){throw new TypeError("Cannot convert a Symbol value to a string")}return String(e)},ToObject:function t(e){this.RequireObjectCoercible(e);return Object(e)},ToPropertyKey:function t(e){var r=this.ToPrimitive(e,String);return typeof r==="symbol"?o.call(r):this.ToString(r)},ToLength:function t(e){var r=this.ToInteger(e);if(r<=0){return 0}if(r>a){return a}return r},CanonicalNumericIndexString:function t(e){if(n.call(e)!=="[object String]"){throw new TypeError("must be a string")}if(e==="-0"){return-0}var r=this.ToNumber(e);if(this.SameValue(this.ToString(r),e)){return r}},RequireObjectCoercible:E.CheckObjectCoercible,IsArray:Array.isArray||function t(e){return n.call(e)==="[object Array]"},IsConstructor:function t(e){return this.IsCallable(e)},IsExtensible:function t(e){if(!Object.preventExtensions){return true}if(f(e)){return false}return Object.isExtensible(e)},IsInteger:function t(e){if(typeof e!=="number"||p(e)||!u(e)){return false}var r=Math.abs(e);return Math.floor(r)===r},IsPropertyKey:function t(e){return typeof e==="string"||typeof e==="symbol"},IsRegExp:function t(e){if(!e||typeof e!=="object"){return false}if(i){var r=RegExp[Symbol.match];if(typeof r!=="undefined"){return E.ToBoolean(r)}}return N(e)},SameValueZero:function t(e,r){return e===r||p(e)&&p(r)}});delete A.CheckObjectCoercible;e.exports=A},{"./es5":16,"./helpers/assign":18,"./helpers/isFinite":19,"./helpers/isPrimitive":20,"./helpers/mod":21,"./helpers/sign":22,"es-to-primitive/es6":24,"function-bind":28,"is-regex":31}],18:[function(t,e,r){var n=Object.prototype.hasOwnProperty;e.exports=Object.assign||function t(e,r){for(var i in r){if(n.call(r,i)){e[i]=r[i]}}return e}},{}],19:[function(t,e,r){var n=Number.isNaN||function(t){return t!==t};e.exports=Number.isFinite||function(t){return typeof t==="number"&&!n(t)&&t!==Infinity&&t!==-Infinity}},{}],20:[function(t,e,r){e.exports=function t(e){return e===null||typeof e!=="function"&&typeof e!=="object"}},{}],21:[function(t,e,r){e.exports=function t(e,r){var n=e%r;return Math.floor(n>=0?n:n+r)}},{}],22:[function(t,e,r){e.exports=function t(e){return e>=0?1:-1}},{}],23:[function(t,e,r){"use strict";var n=Object.prototype.toString;var i=t("./helpers/isPrimitive");var o=t("is-callable");var p={"[[DefaultValue]]":function(t,e){var r=e||(n.call(t)==="[object Date]"?String:Number);if(r===String||r===Number){var p=r===String?["toString","valueOf"]:["valueOf","toString"];var u,a;for(a=0;a<p.length;++a){if(o(t[p[a]])){u=t[p[a]]();if(i(u)){return u}}}throw new TypeError("No default value")}throw new TypeError("invalid [[DefaultValue]] hint supplied")}};e.exports=function t(e,r){if(i(e)){return e}return p["[[DefaultValue]]"](e,r)}},{"./helpers/isPrimitive":25,"is-callable":29}],24:[function(t,e,r){"use strict";var n=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol";var i=t("./helpers/isPrimitive");var o=t("is-callable");var p=t("is-date-object");var u=t("is-symbol");var a=function t(e,r){if(typeof e==="undefined"||e===null){throw new TypeError("Cannot call method on "+e)}if(typeof r!=="string"||r!=="number"&&r!=="string"){throw new TypeError('hint must be "string" or "number"')}var n=r==="string"?["toString","valueOf"]:["valueOf","toString"];var p,u,a;for(a=0;a<n.length;++a){p=e[n[a]];if(o(p)){u=p.call(e);if(i(u)){return u}}}throw new TypeError("No default value")};var l=function t(e,r){var n=e[r];if(n!==null&&typeof n!=="undefined"){if(!o(n)){throw new TypeError(n+" returned for property "+r+" of object "+e+" is not a function")}return n}};e.exports=function t(e,r){if(i(e)){return e}var o="default";if(arguments.length>1){if(r===String){o="string"}else if(r===Number){o="number"}}var s;if(n){if(Symbol.toPrimitive){s=l(e,Symbol.toPrimitive)}else if(u(e)){s=Symbol.prototype.valueOf}}if(typeof s!=="undefined"){var c=s.call(e,o);if(i(c)){return c}throw new TypeError("unable to convert exotic object to primitive")}if(o==="default"&&(p(e)||u(e))){o="string"}return a(e,o==="default"?"number":o)}},{"./helpers/isPrimitive":25,"is-callable":29,"is-date-object":30,"is-symbol":32}],25:[function(t,e,r){arguments[4][20][0].apply(r,arguments)},{dup:20}],26:[function(t,e,r){var n=Object.prototype.hasOwnProperty;var i=Object.prototype.toString;e.exports=function t(e,r,o){if(i.call(r)!=="[object Function]"){throw new TypeError("iterator must be a function")}var p=e.length;if(p===+p){for(var u=0;u<p;u++){r.call(o,e[u],u,e)}}else{for(var a in e){if(n.call(e,a)){r.call(o,e[a],a,e)}}}}},{}],27:[function(t,e,r){var n="Function.prototype.bind called on incompatible ";var i=Array.prototype.slice;var o=Object.prototype.toString;var p="[object Function]";e.exports=function t(e){var r=this;if(typeof r!=="function"||o.call(r)!==p){throw new TypeError(n+r)}var u=i.call(arguments,1);var a;var l=function(){if(this instanceof a){var t=r.apply(this,u.concat(i.call(arguments)));if(Object(t)===t){return t}return this}else{return r.apply(e,u.concat(i.call(arguments)))}};var s=Math.max(0,r.length-u.length);var c=[];for(var f=0;f<s;f++){c.push("$"+f)}a=Function("binder","return function ("+c.join(",")+"){ return binder.apply(this,arguments); }")(l);if(r.prototype){var y=function t(){};y.prototype=r.prototype;a.prototype=new y;y.prototype=null}return a}},{}],28:[function(t,e,r){var n=t("./implementation");e.exports=Function.prototype.bind||n},{"./implementation":27}],29:[function(t,e,r){"use strict";var n=Function.prototype.toString;var i=/^\s*class /;var o=function t(e){try{var r=n.call(e);var o=r.replace(/\/\/.*\n/g,"");var p=o.replace(/\/\*[.\s\S]*\*\//g,"");var u=p.replace(/\n/gm," ").replace(/ {2}/g," ");return i.test(u)}catch(t){return false}};var p=function t(e){try{if(o(e)){return false}n.call(e);return true}catch(t){return false}};var u=Object.prototype.toString;var a="[object Function]";var l="[object GeneratorFunction]";var s=typeof Symbol==="function"&&typeof Symbol.toStringTag==="symbol";e.exports=function t(e){if(!e){return false}if(typeof e!=="function"&&typeof e!=="object"){return false}if(s){return p(e)}if(o(e)){return false}var r=u.call(e);return r===a||r===l}},{}],30:[function(t,e,r){"use strict";var n=Date.prototype.getDay;var i=function t(e){try{n.call(e);return true}catch(t){return false}};var o=Object.prototype.toString;var p="[object Date]";var u=typeof Symbol==="function"&&typeof Symbol.toStringTag==="symbol";e.exports=function t(e){if(typeof e!=="object"||e===null){return false}return u?i(e):o.call(e)===p}},{}],31:[function(t,e,r){"use strict";var n=RegExp.prototype.exec;var i=function t(e){try{n.call(e);return true}catch(t){return false}};var o=Object.prototype.toString;var p="[object RegExp]";var u=typeof Symbol==="function"&&typeof Symbol.toStringTag==="symbol";e.exports=function t(e){if(typeof e!=="object"){return false}return u?i(e):o.call(e)===p}},{}],32:[function(t,e,r){"use strict";var n=Object.prototype.toString;var i=typeof Symbol==="function"&&typeof Symbol()==="symbol";if(i){var o=Symbol.prototype.toString;var p=/^Symbol\(.*\)$/;var u=function t(e){if(typeof e.valueOf()!=="symbol"){return false}return p.test(o.call(e))};e.exports=function t(e){if(typeof e==="symbol"){return true}if(n.call(e)!=="[object Symbol]"){return false}try{return u(e)}catch(t){return false}}}else{e.exports=function t(e){return false}}},{}],33:[function(t,e,r){"use strict";var n=Object.prototype.hasOwnProperty;var i=Object.prototype.toString;var o=Array.prototype.slice;var p=t("./isArguments");var u=!{toString:null}.propertyIsEnumerable("toString");var a=function(){}.propertyIsEnumerable("prototype");var l=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"];var s=function(t){var e=t.constructor;return e&&e.prototype===t};var c={$console:true,$frame:true,$frameElement:true,$frames:true,$parent:true,$self:true,$webkitIndexedDB:true,$webkitStorageInfo:true,$window:true};var f=function(){if(typeof window==="undefined"){return false}for(var t in window){try{if(!c["$"+t]&&n.call(window,t)&&window[t]!==null&&typeof window[t]==="object"){try{s(window[t])}catch(t){return true}}}catch(t){return true}}return false}();var y=function(t){if(typeof window==="undefined"||!f){return s(t)}try{return s(t)}catch(t){return false}};var v=function t(e){var r=e!==null&&typeof e==="object";var o=i.call(e)==="[object Function]";var s=p(e);var c=r&&i.call(e)==="[object String]";var f=[];if(!r&&!o&&!s){throw new TypeError("Object.keys called on a non-object")}var v=a&&o;if(c&&e.length>0&&!n.call(e,0)){for(var m=0;m<e.length;++m){f.push(String(m))}}if(s&&e.length>0){for(var b=0;b<e.length;++b){f.push(String(b))}}else{for(var d in e){if(!(v&&d==="prototype")&&n.call(e,d)){f.push(String(d))}}}if(u){var h=y(e);for(var g=0;g<l.length;++g){if(!(h&&l[g]==="constructor")&&n.call(e,l[g])){f.push(l[g])}}}return f};v.shim=function t(){if(Object.keys){var e=function(){return(Object.keys(arguments)||"").length===2}(1,2);if(!e){var r=Object.keys;Object.keys=function t(e){if(p(e)){return r(o.call(e))}else{return r(e)}}}}else{Object.keys=v}return Object.keys||v};e.exports=v},{"./isArguments":34}],34:[function(t,e,r){"use strict";var n=Object.prototype.toString;e.exports=function t(e){var r=n.call(e);var i=r==="[object Arguments]";if(!i){i=r!=="[object Array]"&&e!==null&&typeof e==="object"&&typeof e.length==="number"&&e.length>=0&&n.call(e.callee)==="[object Function]"}return i}},{}],35:[function(t,e,r){"use strict";var n=t("./implementation");e.exports=function t(){return Array.prototype.includes||n}},{"./implementation":13}],36:[function(t,e,r){"use strict";var n=t("define-properties");var i=t("./polyfill");e.exports=function t(){var e=i();if(Array.prototype.includes!==e){n(Array.prototype,{includes:e})}return e}},{"./polyfill":35,"define-properties":15}],37:[function(t,e,r){"use strict";var n=t("es-abstract/es7");var i=t("has");var o=t("function-bind");var p=o.call(Function.call,Object.prototype.propertyIsEnumerable);e.exports=function t(e){var r=n.RequireObjectCoercible(e);var o=[];for(var u in r){if(i(r,u)&&p(r,u)){o.push([u,r[u]])}}return o}},{"es-abstract/es7":42,"function-bind":53,has:54}],38:[function(t,e,r){"use strict";var n=t("define-properties");var i=t("./implementation");var o=t("./polyfill");var p=t("./shim");n(i,{getPolyfill:o,implementation:i,shim:p});e.exports=i},{"./implementation":37,"./polyfill":61,"./shim":62,"define-properties":39}],39:[function(t,e,r){arguments[4][15][0].apply(r,arguments)},{dup:15,foreach:51,"object-keys":59}],40:[function(t,e,r){arguments[4][16][0].apply(r,arguments)},{"./helpers/isFinite":44,"./helpers/mod":46,"./helpers/sign":47,dup:16,"es-to-primitive/es5":48,"is-callable":55}],41:[function(t,e,r){arguments[4][17][0].apply(r,arguments)},{"./es5":40,"./helpers/assign":43,"./helpers/isFinite":44,"./helpers/isPrimitive":45,"./helpers/mod":46,"./helpers/sign":47,dup:17,"es-to-primitive/es6":49,"function-bind":53,"is-regex":57}],42:[function(t,e,r){"use strict";var n=t("./es6");var i=t("./helpers/assign");var o=i(n,{SameValueNonNumber:function t(e,r){if(typeof e==="number"||typeof e!==typeof r){throw new TypeError("SameValueNonNumber requires two non-number values of the same type.")}return this.SameValue(e,r)}});e.exports=o},{"./es6":41,"./helpers/assign":43}],43:[function(t,e,r){arguments[4][18][0].apply(r,arguments)},{dup:18}],44:[function(t,e,r){arguments[4][19][0].apply(r,arguments)},{dup:19}],45:[function(t,e,r){arguments[4][20][0].apply(r,arguments)},{dup:20}],46:[function(t,e,r){arguments[4][21][0].apply(r,arguments)},{dup:21}],47:[function(t,e,r){arguments[4][22][0].apply(r,arguments)},{dup:22}],48:[function(t,e,r){arguments[4][23][0].apply(r,arguments)},{"./helpers/isPrimitive":50,dup:23,"is-callable":55}],49:[function(t,e,r){arguments[4][24][0].apply(r,arguments)},{"./helpers/isPrimitive":50,dup:24,"is-callable":55,"is-date-object":56,"is-symbol":58}],50:[function(t,e,r){arguments[4][20][0].apply(r,arguments)},{dup:20}],51:[function(t,e,r){arguments[4][26][0].apply(r,arguments)},{dup:26}],52:[function(t,e,r){arguments[4][27][0].apply(r,arguments)},{dup:27}],53:[function(t,e,r){arguments[4][28][0].apply(r,arguments)},{"./implementation":52,dup:28}],54:[function(t,e,r){var n=t("function-bind");e.exports=n.call(Function.call,Object.prototype.hasOwnProperty)},{"function-bind":53}],55:[function(t,e,r){arguments[4][29][0].apply(r,arguments)},{dup:29}],56:[function(t,e,r){arguments[4][30][0].apply(r,arguments)},{dup:30}],57:[function(t,e,r){arguments[4][31][0].apply(r,arguments)},{dup:31}],58:[function(t,e,r){arguments[4][32][0].apply(r,arguments)},{dup:32}],59:[function(t,e,r){arguments[4][33][0].apply(r,arguments)},{"./isArguments":60,dup:33}],60:[function(t,e,r){arguments[4][34][0].apply(r,arguments)},{dup:34}],61:[function(t,e,r){"use strict";var n=t("./implementation");e.exports=function t(){return typeof Object.entries==="function"?Object.entries:n}},{"./implementation":37}],62:[function(t,e,r){"use strict";var n=t("./polyfill");var i=t("define-properties");e.exports=function t(){var e=n();i(Object,{entries:e},{entries:function(){return Object.entries!==e}});return e}},{"./polyfill":61,"define-properties":39}],63:[function(t,e,r){"use strict";var n=t("es-abstract/es7");var i=Object.defineProperty;var o=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getOwnPropertySymbols;var a=Function.call.bind(Array.prototype.concat);var l=Function.call.bind(Array.prototype.reduce);var s=u?function(t){return a(p(t),u(t))}:p;var c=n.IsCallable(o)&&n.IsCallable(p);var f=function t(e,r,n){if(i&&r in e){i(e,r,{configurable:true,enumerable:true,value:n,writable:true})}else{e[r]=n}};e.exports=function t(e){n.RequireObjectCoercible(e);if(!c){throw new TypeError("getOwnPropertyDescriptors requires Object.getOwnPropertyDescriptor")}var r=n.ToObject(e);return l(s(r),function(t,e){f(t,e,o(r,e));return t},{})}},{"es-abstract/es7":68}],64:[function(t,e,r){arguments[4][38][0].apply(r,arguments)},{"./implementation":63,"./polyfill":86,"./shim":87,"define-properties":65,dup:38}],65:[function(t,e,r){arguments[4][15][0].apply(r,arguments)},{dup:15,foreach:77,"object-keys":84}],66:[function(t,e,r){arguments[4][16][0].apply(r,arguments)},{"./helpers/isFinite":70,"./helpers/mod":72,"./helpers/sign":73,dup:16,"es-to-primitive/es5":74,"is-callable":80}],67:[function(t,e,r){arguments[4][17][0].apply(r,arguments)},{"./es5":66,"./helpers/assign":69,"./helpers/isFinite":70,"./helpers/isPrimitive":71,"./helpers/mod":72,"./helpers/sign":73,dup:17,"es-to-primitive/es6":75,"function-bind":79,"is-regex":82}],68:[function(t,e,r){arguments[4][42][0].apply(r,arguments)},{"./es6":67,"./helpers/assign":69,dup:42}],69:[function(t,e,r){arguments[4][18][0].apply(r,arguments)},{dup:18}],70:[function(t,e,r){arguments[4][19][0].apply(r,arguments)},{dup:19}],71:[function(t,e,r){arguments[4][20][0].apply(r,arguments)},{dup:20}],72:[function(t,e,r){arguments[4][21][0].apply(r,arguments)},{dup:21}],73:[function(t,e,r){arguments[4][22][0].apply(r,arguments)},{dup:22}],74:[function(t,e,r){arguments[4][23][0].apply(r,arguments)},{"./helpers/isPrimitive":76,dup:23,"is-callable":80}],75:[function(t,e,r){arguments[4][24][0].apply(r,arguments)},{"./helpers/isPrimitive":76,dup:24,"is-callable":80,"is-date-object":81,"is-symbol":83}],76:[function(t,e,r){arguments[4][20][0].apply(r,arguments)},{dup:20}],77:[function(t,e,r){arguments[4][26][0].apply(r,arguments)},{dup:26}],78:[function(t,e,r){arguments[4][27][0].apply(r,arguments)},{dup:27}],79:[function(t,e,r){arguments[4][28][0].apply(r,arguments)},{"./implementation":78,dup:28}],80:[function(t,e,r){arguments[4][29][0].apply(r,arguments)},{dup:29}],81:[function(t,e,r){arguments[4][30][0].apply(r,arguments)},{dup:30}],82:[function(t,e,r){arguments[4][31][0].apply(r,arguments)},{dup:31}],83:[function(t,e,r){arguments[4][32][0].apply(r,arguments)},{dup:32}],84:[function(t,e,r){arguments[4][33][0].apply(r,arguments)},{"./isArguments":85,dup:33}],85:[function(t,e,r){arguments[4][34][0].apply(r,arguments)},{dup:34}],86:[function(t,e,r){"use strict";var n=t("./implementation");e.exports=function t(){return typeof Object.getOwnPropertyDescriptors==="function"?Object.getOwnPropertyDescriptors:n}},{"./implementation":63}],87:[function(t,e,r){"use strict";var n=t("./polyfill");var i=t("define-properties");e.exports=function t(){var e=n();i(Object,{getOwnPropertyDescriptors:e},{getOwnPropertyDescriptors:function(){return Object.getOwnPropertyDescriptors!==e}});return e}},{"./polyfill":86,"define-properties":65}],88:[function(t,e,r){"use strict";var n=t("es-abstract/es7");var i=t("has");var o=t("function-bind");var p=o.call(Function.call,Object.prototype.propertyIsEnumerable);e.exports=function t(e){var r=n.RequireObjectCoercible(e);var o=[];for(var u in r){if(i(r,u)&&p(r,u)){o.push(r[u])}}return o}},{"es-abstract/es7":93,"function-bind":104,has:105}],89:[function(t,e,r){arguments[4][38][0].apply(r,arguments)},{"./implementation":88,"./polyfill":112,"./shim":113,"define-properties":90,dup:38}],90:[function(t,e,r){arguments[4][15][0].apply(r,arguments)},{dup:15,foreach:102,"object-keys":110}],91:[function(t,e,r){arguments[4][16][0].apply(r,arguments)},{"./helpers/isFinite":95,"./helpers/mod":97,"./helpers/sign":98,dup:16,"es-to-primitive/es5":99,"is-callable":106}],92:[function(t,e,r){arguments[4][17][0].apply(r,arguments)},{"./es5":91,"./helpers/assign":94,"./helpers/isFinite":95,"./helpers/isPrimitive":96,"./helpers/mod":97,"./helpers/sign":98,dup:17,"es-to-primitive/es6":100,"function-bind":104,"is-regex":108}],93:[function(t,e,r){arguments[4][42][0].apply(r,arguments)},{"./es6":92,"./helpers/assign":94,dup:42}],94:[function(t,e,r){arguments[4][18][0].apply(r,arguments)},{dup:18}],95:[function(t,e,r){arguments[4][19][0].apply(r,arguments)},{dup:19}],96:[function(t,e,r){arguments[4][20][0].apply(r,arguments)},{dup:20}],97:[function(t,e,r){arguments[4][21][0].apply(r,arguments)},{dup:21}],98:[function(t,e,r){arguments[4][22][0].apply(r,arguments)},{dup:22}],99:[function(t,e,r){arguments[4][23][0].apply(r,arguments)},{"./helpers/isPrimitive":101,dup:23,"is-callable":106}],100:[function(t,e,r){arguments[4][24][0].apply(r,arguments)},{"./helpers/isPrimitive":101,dup:24,"is-callable":106,"is-date-object":107,"is-symbol":109}],101:[function(t,e,r){arguments[4][20][0].apply(r,arguments)},{dup:20}],102:[function(t,e,r){arguments[4][26][0].apply(r,arguments)},{dup:26}],103:[function(t,e,r){arguments[4][27][0].apply(r,arguments)},{dup:27}],104:[function(t,e,r){arguments[4][28][0].apply(r,arguments)},{"./implementation":103,dup:28}],105:[function(t,e,r){arguments[4][54][0].apply(r,arguments)},{dup:54,"function-bind":104}],106:[function(t,e,r){arguments[4][29][0].apply(r,arguments)},{dup:29}],107:[function(t,e,r){arguments[4][30][0].apply(r,arguments)},{dup:30}],108:[function(t,e,r){arguments[4][31][0].apply(r,arguments)},{dup:31}],109:[function(t,e,r){arguments[4][32][0].apply(r,arguments)},{dup:32}],110:[function(t,e,r){arguments[4][33][0].apply(r,arguments)},{"./isArguments":111,dup:33}],111:[function(t,e,r){arguments[4][34][0].apply(r,arguments)},{dup:34}],112:[function(t,e,r){"use strict";var n=t("./implementation");e.exports=function t(){return typeof Object.values==="function"?Object.values:n}},{"./implementation":88}],113:[function(t,e,r){"use strict";var n=t("./polyfill");var i=t("define-properties");e.exports=function t(){var e=n();i(Object,{values:e},{values:function(){return Object.values!==e}});return e}},{"./polyfill":112,"define-properties":90}],114:[function(t,e,r){"use strict";var n=t("define-properties");var i=t("es-abstract/es7");var o=t("function-bind");var p=function t(e){i.RequireObjectCoercible(this);var r=i.ToObject(this);var n=i.ToString(r);var o=i.ToInteger(e);var p=n.length;if(o<0||o>=p){return""}var u=n.charCodeAt(o);var a;var l=o+1;var s=1;var c=u>=55296&&u<=56319;if(c&&p>l){a=n.charCodeAt(l);if(a>=56320&&a<=57343){s=2}}return n.slice(o,o+s)};var u=o.call(Function.call,p);n(u,{method:p,shim:function t(){n(String.prototype,{at:p});return String.prototype.at}});e.exports=u},{"define-properties":115,"es-abstract/es7":118,"function-bind":129}],115:[function(t,e,r){arguments[4][15][0].apply(r,arguments)},{dup:15,foreach:127,"object-keys":134}],116:[function(t,e,r){arguments[4][16][0].apply(r,arguments)},{"./helpers/isFinite":120,"./helpers/mod":122,"./helpers/sign":123,dup:16,"es-to-primitive/es5":124,"is-callable":130}],117:[function(t,e,r){arguments[4][17][0].apply(r,arguments)},{"./es5":116,"./helpers/assign":119,"./helpers/isFinite":120,"./helpers/isPrimitive":121,"./helpers/mod":122,"./helpers/sign":123,dup:17,"es-to-primitive/es6":125,"function-bind":129,"is-regex":132}],118:[function(t,e,r){arguments[4][42][0].apply(r,arguments)},{"./es6":117,"./helpers/assign":119,dup:42}],119:[function(t,e,r){arguments[4][18][0].apply(r,arguments)},{dup:18}],120:[function(t,e,r){arguments[4][19][0].apply(r,arguments)},{dup:19}],121:[function(t,e,r){arguments[4][20][0].apply(r,arguments)},{dup:20}],122:[function(t,e,r){arguments[4][21][0].apply(r,arguments)},{dup:21}],123:[function(t,e,r){arguments[4][22][0].apply(r,arguments)},{dup:22}],124:[function(t,e,r){arguments[4][23][0].apply(r,arguments)},{"./helpers/isPrimitive":126,dup:23,"is-callable":130}],125:[function(t,e,r){arguments[4][24][0].apply(r,arguments)},{"./helpers/isPrimitive":126,dup:24,"is-callable":130,"is-date-object":131,"is-symbol":133}],126:[function(t,e,r){arguments[4][20][0].apply(r,arguments)},{dup:20}],127:[function(t,e,r){arguments[4][26][0].apply(r,arguments)},{dup:26}],128:[function(t,e,r){arguments[4][27][0].apply(r,arguments)},{dup:27}],129:[function(t,e,r){arguments[4][28][0].apply(r,arguments)},{"./implementation":128,dup:28}],130:[function(t,e,r){arguments[4][29][0].apply(r,arguments)},{dup:29}],131:[function(t,e,r){arguments[4][30][0].apply(r,arguments)},{dup:30}],132:[function(t,e,r){arguments[4][31][0].apply(r,arguments)},{dup:31}],133:[function(t,e,r){arguments[4][32][0].apply(r,arguments)},{dup:32}],134:[function(t,e,r){arguments[4][33][0].apply(r,arguments)},{"./isArguments":135,dup:33}],135:[function(t,e,r){arguments[4][34][0].apply(r,arguments)},{dup:34}],136:[function(t,e,r){"use strict";var n=t("function-bind");var i=t("es-abstract/es7");var o=n.call(Function.call,String.prototype.slice);e.exports=function t(e){var r=i.RequireObjectCoercible(this);var n=i.ToString(r);var p=i.ToLength(n.length);var u;if(arguments.length>1){u=arguments[1]}var a=typeof u==="undefined"?"":i.ToString(u);if(a===""){a=" "}var l=i.ToLength(e);if(l<=p){return n}var s=l-p;while(a.length<s){var c=a.length;var f=s-c;a+=c>f?o(a,0,f):a}var y=a.length>s?o(a,0,s):a;return n+y}},{"es-abstract/es7":141,"function-bind":152}],137:[function(t,e,r){"use strict";var n=t("function-bind");var i=t("define-properties");var o=t("es-abstract/es7");var p=t("./implementation");var u=t("./polyfill");var a=t("./shim");var l=n.call(Function.apply,p);var s=function t(e,r){o.RequireObjectCoercible(e);var n=[r];if(arguments.length>2){n.push(arguments[2])}return l(e,n)};i(s,{getPolyfill:u,implementation:p,shim:a});e.exports=s},{"./implementation":136,"./polyfill":159,"./shim":160,"define-properties":138,"es-abstract/es7":141,"function-bind":152}],138:[function(t,e,r){arguments[4][15][0].apply(r,arguments)},{dup:15,foreach:150,"object-keys":157}],139:[function(t,e,r){arguments[4][16][0].apply(r,arguments)},{"./helpers/isFinite":143,"./helpers/mod":145,"./helpers/sign":146,dup:16,"es-to-primitive/es5":147,"is-callable":153}],140:[function(t,e,r){arguments[4][17][0].apply(r,arguments)},{"./es5":139,"./helpers/assign":142,"./helpers/isFinite":143,"./helpers/isPrimitive":144,"./helpers/mod":145,"./helpers/sign":146,dup:17,"es-to-primitive/es6":148,"function-bind":152,"is-regex":155}],141:[function(t,e,r){arguments[4][42][0].apply(r,arguments)},{"./es6":140,"./helpers/assign":142,dup:42}],142:[function(t,e,r){arguments[4][18][0].apply(r,arguments)},{dup:18}],143:[function(t,e,r){arguments[4][19][0].apply(r,arguments)},{dup:19}],144:[function(t,e,r){arguments[4][20][0].apply(r,arguments)},{dup:20}],145:[function(t,e,r){arguments[4][21][0].apply(r,arguments)},{dup:21}],146:[function(t,e,r){arguments[4][22][0].apply(r,arguments)},{dup:22}],147:[function(t,e,r){arguments[4][23][0].apply(r,arguments)},{"./helpers/isPrimitive":149,dup:23,"is-callable":153}],148:[function(t,e,r){arguments[4][24][0].apply(r,arguments)},{"./helpers/isPrimitive":149,dup:24,"is-callable":153,"is-date-object":154,"is-symbol":156}],149:[function(t,e,r){arguments[4][20][0].apply(r,arguments)},{dup:20}],150:[function(t,e,r){arguments[4][26][0].apply(r,arguments)},{dup:26}],151:[function(t,e,r){arguments[4][27][0].apply(r,arguments)},{dup:27}],152:[function(t,e,r){arguments[4][28][0].apply(r,arguments)},{"./implementation":151,dup:28}],153:[function(t,e,r){arguments[4][29][0].apply(r,arguments)},{dup:29}],154:[function(t,e,r){arguments[4][30][0].apply(r,arguments)},{dup:30}],155:[function(t,e,r){arguments[4][31][0].apply(r,arguments)},{dup:31}],156:[function(t,e,r){arguments[4][32][0].apply(r,arguments)},{dup:32}],157:[function(t,e,r){arguments[4][33][0].apply(r,arguments)},{"./isArguments":158,dup:33}],158:[function(t,e,r){arguments[4][34][0].apply(r,arguments)},{dup:34}],159:[function(t,e,r){"use strict";var n=t("./implementation");e.exports=function t(){return typeof String.prototype.padEnd==="function"?String.prototype.padEnd:n}},{"./implementation":136}],160:[function(t,e,r){"use strict";var n=t("./polyfill");var i=t("define-properties");e.exports=function t(){var e=n();i(String.prototype,{padEnd:e},{padEnd:function(){return String.prototype.padEnd!==e}});return e}},{"./polyfill":159,"define-properties":138}],161:[function(t,e,r){"use strict";var n=t("function-bind");var i=t("es-abstract/es7");var o=n.call(Function.call,String.prototype.slice);e.exports=function t(e){var r=i.RequireObjectCoercible(this);var n=i.ToString(r);var p=i.ToLength(n.length);var u;if(arguments.length>1){u=arguments[1]}var a=typeof u==="undefined"?"":i.ToString(u);if(a===""){a=" "}var l=i.ToLength(e);if(l<=p){return n}var s=l-p;while(a.length<s){var c=a.length;var f=s-c;a+=c>f?o(a,0,f):a}var y=a.length>s?o(a,0,s):a;return y+n}},{"es-abstract/es7":166,"function-bind":177}],162:[function(t,e,r){"use strict";var n=t("function-bind");var i=t("define-properties");var o=t("es-abstract/es7");var p=t("./implementation");var u=t("./polyfill");var a=t("./shim");var l=n.call(Function.apply,p);var s=function t(e,r){o.RequireObjectCoercible(e);var n=[r];if(arguments.length>2){
n.push(arguments[2])}return l(e,n)};i(s,{getPolyfill:u,implementation:p,shim:a});e.exports=s},{"./implementation":161,"./polyfill":184,"./shim":185,"define-properties":163,"es-abstract/es7":166,"function-bind":177}],163:[function(t,e,r){arguments[4][15][0].apply(r,arguments)},{dup:15,foreach:175,"object-keys":182}],164:[function(t,e,r){arguments[4][16][0].apply(r,arguments)},{"./helpers/isFinite":168,"./helpers/mod":170,"./helpers/sign":171,dup:16,"es-to-primitive/es5":172,"is-callable":178}],165:[function(t,e,r){arguments[4][17][0].apply(r,arguments)},{"./es5":164,"./helpers/assign":167,"./helpers/isFinite":168,"./helpers/isPrimitive":169,"./helpers/mod":170,"./helpers/sign":171,dup:17,"es-to-primitive/es6":173,"function-bind":177,"is-regex":180}],166:[function(t,e,r){arguments[4][42][0].apply(r,arguments)},{"./es6":165,"./helpers/assign":167,dup:42}],167:[function(t,e,r){arguments[4][18][0].apply(r,arguments)},{dup:18}],168:[function(t,e,r){arguments[4][19][0].apply(r,arguments)},{dup:19}],169:[function(t,e,r){arguments[4][20][0].apply(r,arguments)},{dup:20}],170:[function(t,e,r){arguments[4][21][0].apply(r,arguments)},{dup:21}],171:[function(t,e,r){arguments[4][22][0].apply(r,arguments)},{dup:22}],172:[function(t,e,r){arguments[4][23][0].apply(r,arguments)},{"./helpers/isPrimitive":174,dup:23,"is-callable":178}],173:[function(t,e,r){arguments[4][24][0].apply(r,arguments)},{"./helpers/isPrimitive":174,dup:24,"is-callable":178,"is-date-object":179,"is-symbol":181}],174:[function(t,e,r){arguments[4][20][0].apply(r,arguments)},{dup:20}],175:[function(t,e,r){arguments[4][26][0].apply(r,arguments)},{dup:26}],176:[function(t,e,r){arguments[4][27][0].apply(r,arguments)},{dup:27}],177:[function(t,e,r){arguments[4][28][0].apply(r,arguments)},{"./implementation":176,dup:28}],178:[function(t,e,r){arguments[4][29][0].apply(r,arguments)},{dup:29}],179:[function(t,e,r){arguments[4][30][0].apply(r,arguments)},{dup:30}],180:[function(t,e,r){arguments[4][31][0].apply(r,arguments)},{dup:31}],181:[function(t,e,r){arguments[4][32][0].apply(r,arguments)},{dup:32}],182:[function(t,e,r){arguments[4][33][0].apply(r,arguments)},{"./isArguments":183,dup:33}],183:[function(t,e,r){arguments[4][34][0].apply(r,arguments)},{dup:34}],184:[function(t,e,r){"use strict";var n=t("./implementation");e.exports=function t(){return typeof String.prototype.padStart==="function"?String.prototype.padStart:n}},{"./implementation":161}],185:[function(t,e,r){"use strict";var n=t("./polyfill");var i=t("define-properties");e.exports=function t(){var e=n();i(String.prototype,{padStart:e},{padStart:function(){return String.prototype.padStart!==e}});return e}},{"./polyfill":184,"define-properties":163}],186:[function(t,e,r){"use strict";var n=t("function-bind");var i=n.call(Function.call,String.prototype.replace);var o=/^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;e.exports=function t(){return i(this,o,"")}},{"function-bind":191}],187:[function(t,e,r){"use strict";var n=t("function-bind");var i=t("define-properties");var o=t("./implementation");var p=t("./polyfill");var u=t("./shim");var a=n.call(Function.call,p());i(a,{getPolyfill:p,implementation:o,shim:u});e.exports=a},{"./implementation":186,"./polyfill":194,"./shim":195,"define-properties":188,"function-bind":191}],188:[function(t,e,r){arguments[4][15][0].apply(r,arguments)},{dup:15,foreach:189,"object-keys":192}],189:[function(t,e,r){arguments[4][26][0].apply(r,arguments)},{dup:26}],190:[function(t,e,r){arguments[4][27][0].apply(r,arguments)},{dup:27}],191:[function(t,e,r){arguments[4][28][0].apply(r,arguments)},{"./implementation":190,dup:28}],192:[function(t,e,r){arguments[4][33][0].apply(r,arguments)},{"./isArguments":193,dup:33}],193:[function(t,e,r){arguments[4][34][0].apply(r,arguments)},{dup:34}],194:[function(t,e,r){"use strict";var n=t("./implementation");e.exports=function t(){if(!String.prototype.trimLeft){return n}var e="\u200b";if(e.trimLeft()!==e){return n}return String.prototype.trimLeft}},{"./implementation":186}],195:[function(t,e,r){"use strict";var n=t("define-properties");var i=t("./polyfill");e.exports=function t(){var e=i();n(String.prototype,{trimLeft:e},{trimLeft:function(){return String.prototype.trimLeft!==e}});return e}},{"./polyfill":194,"define-properties":188}],196:[function(t,e,r){"use strict";var n=t("function-bind");var i=n.call(Function.call,String.prototype.replace);var o=/[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;e.exports=function t(){return i(this,o,"")}},{"function-bind":201}],197:[function(t,e,r){arguments[4][187][0].apply(r,arguments)},{"./implementation":196,"./polyfill":204,"./shim":205,"define-properties":198,dup:187,"function-bind":201}],198:[function(t,e,r){arguments[4][15][0].apply(r,arguments)},{dup:15,foreach:199,"object-keys":202}],199:[function(t,e,r){arguments[4][26][0].apply(r,arguments)},{dup:26}],200:[function(t,e,r){arguments[4][27][0].apply(r,arguments)},{dup:27}],201:[function(t,e,r){arguments[4][28][0].apply(r,arguments)},{"./implementation":200,dup:28}],202:[function(t,e,r){arguments[4][33][0].apply(r,arguments)},{"./isArguments":203,dup:33}],203:[function(t,e,r){arguments[4][34][0].apply(r,arguments)},{dup:34}],204:[function(t,e,r){"use strict";var n=t("./implementation");e.exports=function t(){if(!String.prototype.trimRight){return n}var e="\u200b";if(e.trimRight()!==e){return n}return String.prototype.trimRight}},{"./implementation":196}],205:[function(t,e,r){"use strict";var n=t("define-properties");var i=t("./polyfill");e.exports=function t(){var e=i();n(String.prototype,{trimRight:e},{trimRight:function(){return String.prototype.trimRight!==e}});return e}},{"./polyfill":204,"define-properties":198}],206:[function(t,e,r){"use strict";e.exports=t("./es7-shim").shim()},{"./es7-shim":12}]},{},[206]);
//# sourceMappingURL=dist/es7-shim.map
;
define("es7-shim", function(){});

define('js/Property',['require','./defineClass','./_js','./Type','./Enum','./Class'],function(require) {

	var Property = require("./defineClass");
	var js = require("./_js");

	var Type = require("./Type");
	var Enum = require("./Enum");
	var Class = require("./Class");
//	var PropertyEditor = require("./PropertyEditor");

	var get_impl = "__get";
	var set_impl = "__set";

	var UNDEFINED = {};

	var referencedClasses = [];

	return (Property = Property(require, {

		prototype: {

			/**
			 *
			 */
			constructor: function(declaringClass, name, decl) {
				this._declaringClass = declaringClass;
				this._name = name;

				Property.initialize(this, decl);
			},

			_defaultValue: undefined,
			_editorClass: null,
			_editorInfo: null,
			_fixUp: false,
			_strict: false,//true,
			_getter: undefined,
			_setter: undefined,
			_reference: undefined,
			_decl: undefined,
			_name: undefined,
			_type: undefined,
			_declaringClass: undefined,

			_assignable: undefined,
			_enabled: undefined,
			_stored: undefined,
			_visible: undefined,

			/**
			 * @overrides Object.prototype.toString
			 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString
			 */
			toString: function() {
				return String.format("[property %n::%s#%d]",
						this._declaringClass, this._name, this.hashCode());
			},

			/**
			 * Returns the name of the calling property
			 */
			getName: function() {
				return this._name;
			},

			/**
			 * Returns the type of the calling property
			 */
			getType: function() {
				return this._type;
			},

			/**
			 * Returns the class declaring the calling property
			 */
			getDeclaringClass: function() {
				return this._declaringClass;
			},

			/**
			 *
			 */
			getPropertyClass: function() {
				throw new Error("Unknown class");
			},

			/**
			 * Returns the PropertyEditor derived class which this property should be edited with
			 */
			getEditorClass: function() {
				if(this._editorClass === null) {
					var type = this.getType();
					if(type === Type.CLASS) {
						this._editorClass = PropertyEditor.getClassByType(this._type);
					} else {
						this._editorClass = PropertyEditor.getClassByType(type);
					}
				} else if(typeof(this._editorClass) === "string") {
// TODO
					this._editorClass = require(this._editorClass);
				}
				return this._editorClass;
			},

			/**
			 *
			 */
			getEditorInfo: function(path) {
				return path === undefined ? this._editorInfo : js.get(path, this._editorInfo || {});
			},

			/**
			 * Indicates whether the property value is a reference to a named instance
			 */
			isReference: function() {
				return this._reference === true;
			},

			/**
			 * Indicates whether the property value should be set after the resource is entirely read
			 */
			needsFixUp: function() {
				return this._fixUp === true;
			},

			/**
			 * Returns the default value for the property for the instance -obj-
			 */
			getDefaultValue: function(obj) {
				return this._defaultValue;
			},

			/**
			 *
			 * @param obj
			 */
			isAssignable: function(obj) {
				if(this._assignable === false || this._stored === false || this._enabled === false) {
					return false;
				}
				return true;
			},

			/**
			 * Indicates whether the property is enabled for the instance -obj-
			 */
			isEnabled: function(obj) {
				return this._enabled !== false;
			},

			/**
			 * Indicates whether the property is visiblefor the instance -obj-
			 */
			isVisible: function(obj) {
				return this._visible !== false;
			},

			/**
			 * Indicates whether the value of the property of -obj- should be stored
			 */
			isStored: function(obj) {
				return !this.hasDefaultValue(obj);
			},

			/**
			 * Indicates whether type checking is enabled for setting the properties value
			 */
			isStrict: function() {
				return this._strict;
			},

			/**
			 *
			 */
			isReadOnly: function() {
				return this.__set === Property.prototype.__set;
			},

			/**
			 * Returns whether the value of the property of -obj- reflects its default value
			 */
			hasDefaultValue: function(obj) {
				var value = this.get(obj);
				var def = this.getDefaultValue(obj);
				var inh = org.cavalion.comp.Component.getInheritedPropertyValue(obj, this._name);
// TODO
				return inh === undefined ? equals(value, def) : equals(value, inh);
			},

			/**
			 * Returns whether the value of the property of -obj- reflects its inherited value
			 */
			hasInheritedValue: function(obj) {
// TODO
				return org.cavalion.comp.Component.getInheritedPropertyValue(obj, this._name) === this.__get(obj);
				//return equals(org.cavalion.comp.Component.getInheritedPropertyValue(obj, this._name), this.__get(obj), true);
			},

			/**
			 * Returns the value of the property for the instance -obj-
			 */
			get: function(obj) {
				return this.__get(obj);
			},

			/**
			 *
			 */
			__get: function(obj) {
				throw new Error("No getter defined");
			},

			/**
			 * Set the value of the property for the instance -obj-
			 */
			set: function(obj, value) {
				return this.__set(obj, value);
			},

			/**
			 *
			 */
			__set: function(obj, value) {
				throw new Error("No setter defined");
			}

		},

		statics: {

			/**
			 *
			 */
			isReferencedClass: function(cls) {
				if(Class.isConstructor(cls)) {
					if(referencedClasses.indexOf(cls) !== -1) {
						return true;
					}
					return this.isReferencedClass(Class.getClassObj(cls).inherits);
				}
				return false;
			},


			/**
			 *
			 */
			registerReferencedClass: function(cls) {
				if(Class.isConstructor(cls)) {
					referencedClasses.push(cls);
				} else {
					throw new Error(String.format("%s is not a class constructor"));
				}
			},

			/**
			 *
			 */
			initialize: function(property, prop) {

				var ctor = property._declaringClass;
				var name = property._name;

				if(prop instanceof Property) {
					prop = prop._decl;
				}

				property._decl = js.mixIn({}, prop);

				/*
				 *	Getter
				 */
				if(prop.get === undefined) {
					property._getter = String.format("_%s", name);
					property[get_impl] = Property.Getter.MEMBER;
				} else if(prop.get === Function) {
					property._getter = String.format("get%s", String.camelize(name));
					property[get_impl] = Property.Getter.METHOD;
				} else if(typeof prop.get === "function") {
					property._getter = prop.get;
					property[get_impl] = Property.Getter.INLINE;
				} else if(typeof prop.get === "string") {
					property._getter = prop.get;
					property[get_impl] = Property.Getter.METHOD;
				}

				/*
				 *	Setter
				 */
				if(prop.set === undefined) {
					property._setter = String.format("_%s", name);
					property[set_impl] = Property.Setter.MEMBER;
				} else if(prop.set === Function) {
					property._setter = String.format("set%s", String.camelize(name));
					property[set_impl] = Property.Setter.METHOD;
				} else if(typeof prop.set === "function") {
					property._setter = prop.set;
					property[set_impl] = Property.Setter.INLINE;
				} else if(typeof prop.set === "string") {
					property._setter = prop.set;
					property[set_impl] = Property.Setter.METHOD;
				}

				/*
				 *	Default
				 */
				if(prop.def === Function) {
					property._defaultValue = String.format("has%sDefaultValue", String.camelize(name));
					property.getDefaultValue = Property.GetDefaultValue.METHOD;
					prop.def = undefined;
				} else if(typeof prop.def === "function") {
					property._defaultValue = prop.def;
					property.getDefaultValue = Property.GetDefaultValue.INLINE;
					prop.def = undefined;
				} else if(js.keys(prop).indexOf("def") === -1) {
					//hostenv.printf("%s does not have default value, assuming _%s", name, name);
					// really undefined
					property._defaultValue = ctor.prototype[String.format("_%s", name)];
				} else {
					property._defaultValue = prop.def === undefined ? UNDEFINED : prop.def;
				}

				/*
				 * Type
				 */
				if(prop.type === undefined) {
					prop.type = Type.byValue(prop.def);
				}

				if(prop.type === Type.UNDEFINED) {
					console.warn(String.format("Can not determine type of property %n::%s",
							property._declaringClass, name));
				}
/**	TODO
				if(typeof prop.type === "string") {
					prop.type = js.lang.Class.require(prop.type)._ctor;
				}
*/
				if(prop.type instanceof Array) {
					prop.type = new Enum(String.format("%n.%s",
							property._declaringClass, name.toUpperCase()), prop.type);
				}

				if(prop.type instanceof Enum) {
					property._type = prop.type;
					property.getType = Type.ENUM.get;
					property.getPropertyClass = function() {
						return this._type;
					};
					if(property._defaultValue === undefined) {
						console.log(String.format("%n._%s %s", ctor, name, property._defaultValue));
						property._defaultValue = prop.type.getKeys()[0];
					}
				} else {
					if(Class.isConstructor(prop.type)) {
						if(Property.isReferencedClass(prop.type)) {
							property._reference = true;
						}
						property._type = prop.type;
						property.getType = Type.CLASS.get;
						// FIXME Move away from here...
						property.getPropertyClass = function() {
							return this._type;
						};
					} else if(Type.isType(prop.type)) {
						property._type = prop.type;
						property.getPropertyClass = prop.type.get;
					} else {
						throw new Error(String.format("Illegal property type %n (%n.%s)", prop.type, ctor, name));
					}
				}

				if(prop.editor !== undefined) {
					property._editorClass = prop.editor;
				}

				if(prop.editorInfo !== undefined) {
					property._editorInfo = prop.editorInfo;
				}

				if(property._defaultValue === undefined) {
//					console.warn(String.format("Can not determine default value for property %n::%s",
//							property._declaringClass, name));
/** TODO
					property._defaultValue = property._type.defaultValue;
*/
				} else if(property._defaultValue === UNDEFINED) {
					property._defaultValue = undefined;
				}

				/*
				 *	FixUp
				 */
				if(prop.fixUp !== undefined) {
					property._fixUp = prop.fixUp;
				}

				/*
				 *	Assignable
				 */
				if(prop.assignable === Function) {
					property._assignable = String.format("is%sAssignable", String.camelize(name));
					property.isAssignable = Property.IsAssignable.METHOD;
				} else if(prop.assignable !== undefined) {
					property._assignable = prop.assignable;
					if(typeof prop.assignable === "boolean") {
						property.isAssignable = Property.IsAssignable.VALUE;
					} else if(typeof prop.assignable === "function") {
						property.isAssignable = Property.IsAssignable.INLINE;
					} else if(typeof prop.assignable === "string") {
						property.isAssignable = Property.IsAssignable.METHOD;
					}
				}

				/*
				 *	Stored
				 */
				if(prop.stored === Function) {
					property._stored = String.format("is%sStored", String.camelize(name));
					property.isStored = Property.IsStored.METHOD;
				} else if(prop.stored !== undefined) {
					property._stored = prop.stored;
					if(typeof prop.stored === "boolean") {
						property.isStored = Property.IsStored.VALUE;
					} else if(typeof prop.stored === "function") {
						property.isStored = Property.IsStored.INLINE;
					} else if(typeof prop.stored === "string") {
						property.isStored = Property.IsStored.METHOD;
					}
				}

				/*
				 *	Enabled
				 */
				if(prop.enabled === Function) {
					property._enabled = String.format("is%sEnabled", String.camelize(name));
					property.isEnabled = Property.IsEnabled.METHOD;
				} else if(prop.enabled !== undefined) {
					property._enabled = prop.enabled;
					if(typeof prop.enabled === "boolean") {
						property.isEnabled = Property.IsEnabled.VALUE;
					} else if(typeof prop.enabled === "function") {
						property.isEnabled = Property.IsEnabled.INLINE;
					} else if(typeof prop.enabled === "string") {
						property.isEnabled = Property.IsEnabled.METHOD;
					}
				}

				/*
				 *	Visible
				 */
				if(prop.visible === Function) {
					property._visible = String.format("is%sVisible", String.camelize(name));
					property.isVisible = Property.IsVisible.METHOD;
				} else if(prop.visible !== undefined) {
					property._visible = prop.visible;
					if(typeof prop.visible === "boolean") {
						property.isVisible = Property.IsVisible.VALUE;
					} else if(typeof prop.visible === "function") {
						property.isVisible = Property.IsVisible.INLINE;
					} else if(typeof prop.visible === "string") {
						property.isVisible = Property.IsVisible.METHOD;
					}
				}
			},

			GetDefaultValue: {

				/**
				 *
				 */
				VALUE: function(obj) {
					return this._defaultValue;
				},

				/**
				 *
				 */
				METHOD: function(obj) {
					return obj[this._defaultValue]();
				},

				/**
				 *
				 */
				INLINE: function(obj) {
					return this._defaultValue.apply(obj, []);
				}
			},

			Getter: {

				/**
				 *
				 */
				MEMBER: function(obj) {
					return obj[this._getter];
				},

				/**
				 *
				 */
				METHOD: function(obj) {
					return obj[this._getter]();
				},

				/**
				 *
				 */
				INLINE: function(obj) {
					return this._getter.apply(obj, []);
				}
			},

			IsAssignable: {

				/**
				 *
				 */
				VALUE: function(obj) {
					return this._assignable;
				},

				/**
				 *
				 */
				METHOD: function(obj) {
					return obj[this._assignable](obj);
				},

				/**
				 *
				 */
				INLINE: function(obj) {
					return this._assignable.apply(this, [obj]);
				}
			},

			IsEnabled: {

				/**
				 *
				 */
				VALUE: function(obj) {
					return this._enabled;
				},

				/**
				 *
				 */
				METHOD: function(obj) {
					return obj[this._enabled]();
				},

				/**
				 *
				 */
				INLINE: function(obj) {
					return this._enabled.apply(obj, []);
				}
			},

			IsStored: {

				/**
				 *
				 */
				VALUE: function(obj) {
					return this.hasDefaultValue(obj) ? false : this._stored;
				},

				/**
				 *
				 */
				METHOD: function(obj) {
					return this.hasDefaultValue(obj) ? false : obj[this._stored](obj);
				},

				/**
				 *
				 */
				INLINE: function(obj) {
					return this.hasDefaultValue(obj) ? false : this._stored.apply(this, [obj]);
				}
			},

			IsVisible: {

				/**
				 *
				 */
				VALUE: function(obj) {
					return this._visible;
				},

				/**
				 *
				 */
				METHOD: function(obj) {
					return obj[this._visible]();
				},

				/**
				 *
				 */
				INLINE: function(obj) {
					return this._visible.apply(obj, []);
				}
			},

			Setter: {

				/**
				 *
				 */
				MEMBER: function(obj, value) {
					if(this._strict === true && !Type.isCompatible(this._type, value)) {
						throw new TypeError(String.format("%s is not a valid %s", value, this._type));
					}
					return (obj[this._setter] = value);
				},

				/**
				 *
				 */
				METHOD: function(obj, value) {
					return obj[this._setter](value);
				},

				/**
				 *
				 */
				INLINE: function(obj, value) {
					return this._setter.apply(obj, [value]);
				}
			}
		}

	}));
});
define('vcl/Listeners',['require','js/defineClass','js','js/Method'],function(require) {

	var Listeners = require("js/defineClass");
	var js = require("js");
	var Method = require("js/Method");

	return Listeners(require, {

		prototype: {

			/**
			 *
			 */
			constructor: function(owner, listeners) {
				this._owner = owner;
				this._listeners = {};

				if(owner.hasOwnProperty("destroy")) {
					Method.connect(owner, "destroy", this, "destroyed", "before");
				}

				for(var k in listeners) {
					this.add(k, listeners[k]);
				}
			},

			_owner: null,
			_listeners: null,

			/**
			 *
			 * @param cache
			 */
			destroyed: function(cache) {
				Method.disconnect(this._owner, "destroy", this, "destroyed");

				var names = js.keys(this._listeners);
				for(var n = 0; n < names.length; ++n) {
					var name = names[n];
					var lis = this._listeners[name];
					for(var l = 0; l < lis.length; ++l) {
						Method.disconnect(this._owner, name, lis[l], "callback");
					}
				}

				this._listeners = {};

				// In case the owner will be cached, remove this/these (listeners) from the owner
				// Cached/destroyed owners need to setup their listeners again when reinvoked from the cache
				if(cache !== false && this._owner._listeners === this) {
					delete this._owner._listeners;
				}
			},

			/**
			 *
			 */
			getListener: function(k, callback) {
				var lis = this._listeners[k];
				for(var i = 0, l = lis.length; i < l; ++i) {
					var obj = lis[i];
					if(obj.method === callback) {
						return lis[i];
					}
				}
				throw new Error("Unknown listener");
			},

			/**
			 *
			 */
			getListenerInfo: function(li) {
				for(var k in this._listeners) {
					var lis = this._listeners[k];
					var index = this._listeners[k].indexOf(li);
					if(index !== -1) {
						return {name: k, index: index};
					}
				}
				throw new Error("Unknown listener");
			},

			/**
			 *
			 */
			call: function(name, args) {
			    /*- Copy this._listeners since it might change during callbacks */
				[].concat(this._listeners[name] || []).forEach(function(li) {
					li.method.apply(li.context, args);
				});
			},

			/**
			 *
			 */
			add: function(name, li, type) {
				if(this._listeners[name] === undefined) {
					this._listeners[name] = [];
				}

				if(typeof li !== "object") {
					li = {
						context: this._owner,
						method: li,
						callback: function() {
							this.method.apply(this.context, arguments);
						}
					};
				}

				if(typeof this._owner[name] === "function") {
					if(name === "destroy") {
						if([undefined, "before", "_before"].indexOf(type) === -1) {
							throw new Error("Listen to destroy with type=[_before]");
						}

						// move destroyed to the end of the list, so that other
						// destroy hooks are being called first
						Method.disconnect(this._owner, "destroy", this, "destroyed");
						Method.connect(this._owner, name, li, "callback", type || "before");
						Method.connect(this._owner, "destroy", this, "destroyed", "before");

					} else {
						Method.connect(this._owner, name, li, "callback", type || "after");
					}
					li.connected = true;
				}

				this._listeners[name].push(li);
				return li;
			},

			/**
			 *
			 */
			remove: function(li) {
				var info = this.getListenerInfo(li);
				var lis = this._listeners[info.name];

				if(li.connected) {
					Method.disconnect(this._owner, info.name, li, "callback");
				}

				lis.splice(info.index, 1);
				if(lis.length === 0) {
					delete this._listeners[info.name];
				}
			},

			/**
			 *
			 */
			getOwner: function() {
				return this._owner;
			}
		}
	});
});

define('js/mixInRecursive',["js/mixIn"], function(mixIn) {

	/**
	 * @param dest optional, defaults to {}
	 * @param src
	 * @param mustHaveOwnProperty optional, default is true
	 */
	return function mixInRecursive(dest, src, mustHaveOwnProperty) {
		return mixIn(dest, src, mustHaveOwnProperty, true);
	};
});

// Generated by CoffeeScript 1.9.3
define('node_modules/css-selector-parser/lib/CssSelectorParser',[],function() {

    var ParseContext, doubleQuotesEscapeChars, identReplacements,
    identReplacementsRev, identSpecialChars, isAttrMatchOperator,
    isDecimal, isHex, isIdent, isIdentStart, singleQuoteEscapeChars,
    strReplacementsRev;

    function CssSelectorParser() {
      this.pseudos = {};
      this.attrEqualityMods = {};
      this.ruleNestingOperators = {};
      this.substitutesEnabled = false;
    }

    CssSelectorParser.prototype.registerSelectorPseudos = function(name) {
      var j, len;
      for (j = 0, len = arguments.length; j < len; j++) {
        name = arguments[j];
        this.pseudos[name] = "selector";
      }
      return this;
    };

    CssSelectorParser.prototype.unregisterSelectorPseudos = function(name) {
      var j, len;
      for (j = 0, len = arguments.length; j < len; j++) {
        name = arguments[j];
        delete this.pseudos[name];
      }
      return this;
    };

    CssSelectorParser.prototype.registerNestingOperators = function(op) {
      var j, len;
      for (j = 0, len = arguments.length; j < len; j++) {
        op = arguments[j];
        this.ruleNestingOperators[op] = true;
      }
      return this;
    };

    CssSelectorParser.prototype.unregisterNestingOperators = function(op) {
      var j, len;
      for (j = 0, len = arguments.length; j < len; j++) {
        op = arguments[j];
        delete this.ruleNestingOperators[op];
      }
      return this;
    };

    CssSelectorParser.prototype.registerAttrEqualityMods = function(mod) {
      var j, len;
      for (j = 0, len = arguments.length; j < len; j++) {
        mod = arguments[j];
        this.attrEqualityMods[mod] = true;
      }
      return this;
    };

    CssSelectorParser.prototype.unregisterAttrEqualityMods = function(mod) {
      var j, len;
      for (j = 0, len = arguments.length; j < len; j++) {
        mod = arguments[j];
        delete this.attrEqualityMods[mod];
      }
      return this;
    };

    CssSelectorParser.prototype.enableSubstitutes = function() {
      this.substitutesEnabled = true;
      return this;
    };

    CssSelectorParser.prototype.disableSubstitutes = function() {
      this.substitutesEnabled = false;
      return this;
    };

    isIdentStart = function(c) {
      return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
    };

    isIdent = function(c) {
      return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c === '-' || c === '_';
    };

    isHex = function(c) {
      return (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F') || (c >= '0' && c <= '9');
    };

    isDecimal = function(c) {
      return c >= '0' && c <= '9';
    };

    isAttrMatchOperator = function(c) {
      return c === '=' || c === '^' || c === '$' || c === '*' || c === '~';
    };

    identSpecialChars = {
      '!': true,
      '"': true,
      '#': true,
      '$': true,
      '%': true,
      '&': true,
      '\'': true,
      '(': true,
      ')': true,
      '*': true,
      '+': true,
      ',': true,
      '.': true,
      '/': true,
      ';': true,
      '<': true,
      '=': true,
      '>': true,
      '?': true,
      '@': true,
      '[': true,
      '\\': true,
      ']': true,
      '^': true,
      '`': true,
      '{': true,
      '|': true,
      '}': true,
      '~': true
    };

    identReplacements = {
      'n': '\n',
      'r': '\r',
      't': '\t',
      ' ': ' ',
      'f': '\f',
      'v': '\v'
    };

    identReplacementsRev = {
      '\n': '\\n',
      '\r': '\\r',
      '\t': '\\t',
      ' ': '\\ ',
      '\f': '\\f',
      '\v': '\\v'
    };

    strReplacementsRev = {
      '\n': '\\n',
      '\r': '\\r',
      '\t': '\\t',
      '\f': '\\f',
      '\v': '\\v'
    };

    singleQuoteEscapeChars = {
      n: '\n',
      r: '\r',
      t: '\t',
      f: '\f',
      '\\': '\\',
      '\'': '\''
    };

    doubleQuotesEscapeChars = {
      n: '\n',
      r: '\r',
      t: '\t',
      f: '\f',
      '\\': '\\',
      '"': '"'
    };

    ParseContext = function(str, p, pseudos, attrEqualityMods, ruleNestingOperators, substitutesEnabled) {
      var c, getIdent, getStr, l, skipWhitespace;
      l = str.length;
      c = null;
      getStr = function(quote, escapeTable) {
        var esc, hex, result;
        result = '';
        p++;
        c = str.charAt(p);
        while (p < l) {
          if (c === quote) {
            p++;
            return result;
          } else if (c === '\\') {
            p++;
            c = str.charAt(p);
            if (c === quote) {
              result += quote;
            } else if (esc = escapeTable[c]) {
              result += esc;
            } else if (isHex(c)) {
              hex = c;
              p++;
              c = str.charAt(p);
              while (isHex(c)) {
                hex += c;
                p++;
                c = str.charAt(p);
              }
              if (c === ' ') {
                p++;
                c = str.charAt(p);
              }
              result += String.fromCharCode(parseInt(hex, 16));
              continue;
            } else {
              result += c;
            }
          } else {
            result += c;
          }
          p++;
          c = str.charAt(p);
        }
        return result;
      };
      getIdent = function() {
        var hex, r, result;
        result = '';
        c = str.charAt(p);
        while (p < l) {
          if (isIdent(c)) {
            result += c;
          } else if (c === '\\') {
            p++;
            c = str.charAt(p);
            if (identSpecialChars[c]) {
              result += c;
            } else if (r = identReplacements[c]) {
              result += r;
            } else if (isHex(c)) {
              hex = c;
              p++;
              c = str.charAt(p);
              while (isHex(c)) {
                hex += c;
                p++;
                c = str.charAt(p);
              }
              if (c === ' ') {
                p++;
                c = str.charAt(p);
              }
              result += String.fromCharCode(parseInt(hex, 16));
              continue;
            } else {
              result += c;
            }
          } else {
            return result;
          }
          p++;
          c = str.charAt(p);
        }
        return result;
      };
      skipWhitespace = function() {
        var result;
        c = str.charAt(p);
        result = false;
        while (c === ' ' || c === "\t" || c === "\n" || c === "\r" || c === "\f") {
          result = true;
          p++;
          c = str.charAt(p);
        }
        return result;
      };
      this.parse = function() {
        var res;
        res = this.parseSelector();
        if (p < l) {
          throw Error('Rule expected but "' + str.charAt(p) + '" found.');
        }
        return res;
      };
      this.parseSelector = function() {
        var res, selector;
        selector = res = this.parseSingleSelector();
        c = str.charAt(p);
        while (c === ',') {
          p++;
          skipWhitespace();
          if (res.type !== 'selectors') {
            res = {
              type: 'selectors',
              selectors: [selector]
            };
          }
          selector = this.parseSingleSelector();
          if (!selector) {
            throw Error('Rule expected after ",".');
          }
          res.selectors.push(selector);
        }
        return res;
      };
      this.parseSingleSelector = function() {
        var currentRule, op, rule, selector;
        skipWhitespace();
        selector = {
          type: 'ruleSet'
        };
        rule = this.parseRule();
        if (!rule) {
          return null;
        }
        currentRule = selector;
        while (rule) {
          rule.type = 'rule';
          currentRule.rule = rule;
          currentRule = rule;
          skipWhitespace();
          c = str.charAt(p);
          if (p >= l || c === ',' || c === ')') {
            break;
          }
          if (ruleNestingOperators[c]) {
            op = c;
            p++;
            skipWhitespace();
            rule = this.parseRule();
            if (!rule) {
              throw Error('Rule expected after "' + op + '".');
            }
            rule.nestingOperator = op;
          } else {
            rule = this.parseRule();
            if (rule) {
              rule.nestingOperator = null;
            }
          }
        }
        return selector;
      };
      this.parseRule = function() {
        var attr, attrValue, escapedCharacter, followingCharacter, id, operator, pseudo, pseudoName, rule, value;
        rule = null;
        while (p < l) {
          c = str.charAt(p);
          if (c === '*') {
            p++;
            (rule = rule || {}).tagName = '*';
          } else if (isIdentStart(c) || c === '\\') {
            (rule = rule || {}).tagName = getIdent();
          } else if (c === '.') {
            p++;
            rule = rule || {};
            (rule.classNames = rule.classNames || []).push(getIdent());
          } else if (c === '#') {
            p++;
            c = str.charAt(p);
            id = '';
            while (c === '\\' || isIdent(c)) {
              if (c === '\\') {
                p++;
                if (p >= l) {
                  throw Error('Expected symbol but end of file reached.');
                }
                escapedCharacter = str.charAt(p);
                while (p < l && escapedCharacter === '0') {
                  p++;
                  escapedCharacter = str.charAt(p);
                }
                if (escapedCharacter === '3') {
                  p++;
                  if (p < l) {
                    id += str.charAt(p);
                    p++;
                    followingCharacter = str.charAt(p);
                    if (followingCharacter === ' ') {
                      p++;
                      if (p < l) {
                        id += str.charAt(p);
                      }
                    } else {
                      id += followingCharacter;
                    }
                  }
                } else {
                  id += escapedCharacter;
                }
              } else {
                id += c;
              }
              p++;
              c = str.charAt(p);
            }
            (rule = rule || {}).id = id;
          } else if (c === '[') {
            p++;
            skipWhitespace();
            attr = {
              name: getIdent()
            };
            skipWhitespace();
            if (c === ']') {
              p++;
            } else {
              operator = '';
              if (attrEqualityMods[c]) {
                operator = c;
                p++;
                c = str.charAt(p);
              }
              if (p >= l) {
                throw Error('Expected "=" but end of file reached.');
              }
              if (c !== '=') {
                throw Error('Expected "=" but "' + c + '" found.');
              }
              attr.operator = operator + '=';
              p++;
              skipWhitespace();
              attrValue = '';
              attr.valueType = 'string';
              if (c === '"') {
                attrValue = getStr('"', doubleQuotesEscapeChars);
              } else if (c === '\'') {
                attrValue = getStr('\'', singleQuoteEscapeChars);
              } else if (substitutesEnabled && c === '$') {
                p++;
                attrValue = getIdent();
                attr.valueType = 'substitute';
              } else {
                while (p < l) {
                  if (c === ']') {
                    break;
                  }
                  attrValue += c;
                  p++;
                  c = str.charAt(p);
                }
                attrValue = attrValue.trim();
              }
              skipWhitespace();
              if (p >= l) {
                throw Error('Expected "]" but end of file reached.');
              }
              if (c !== ']') {
                throw Error('Expected "]" but "' + c + '" found.');
              }
              p++;
              attr.value = attrValue;
            }
            rule = rule || {};
            (rule.attrs = rule.attrs || []).push(attr);
          } else if (c === ':') {
            p++;
            pseudoName = getIdent();
            pseudo = {
              name: pseudoName
            };
            if (c === '(') {
              p++;
              value = '';
              skipWhitespace();
              if (pseudos[pseudoName] === 'selector') {
                pseudo.valueType = 'selector';
                value = this.parseSelector();
              } else {
                pseudo.valueType = 'string';
                if (c === '"') {
                  value = getStr('"', doubleQuotesEscapeChars);
                } else if (c === '\'') {
                  value = getStr('\'', singleQuoteEscapeChars);
                } else if (substitutesEnabled && c === '$') {
                  p++;
                  value = getIdent();
                  pseudo.valueType = 'substitute';
                } else {
                  while (p < l) {
                    if (c === ')') {
                      break;
                    }
                    value += c;
                    p++;
                    c = str.charAt(p);
                  }
                  value = value.trim();
                }
                skipWhitespace();
              }
              if (p >= l) {
                throw Error('Expected ")" but end of file reached.');
              }
              if (c !== ')') {
                throw Error('Expected ")" but "' + c + '" found.');
              }
              p++;
              pseudo.value = value;
            }
            rule = rule || {};
            (rule.pseudos = rule.pseudos || []).push(pseudo);
          } else {
            break;
          }
        }
        return rule;
      };
      return this;
    };

    CssSelectorParser.prototype.parse = function(str) {
      var context;
      context = new ParseContext(str, 0, this.pseudos, this.attrEqualityMods, this.ruleNestingOperators, this.substitutesEnabled);
      return context.parse();
    };

    CssSelectorParser.prototype.escapeIdentifier = function(s) {
      var c, cc, extraCharCode, i, l, r, result;
      result = '';
      i = 0;
      l = s.length;
      while (i < l) {
        c = s.charAt(i);
        if (identSpecialChars[c]) {
          result += '\\' + c;
        } else if (r = identReplacementsRev[c]) {
          result += r;
        } else if ((cc = c.charCodeAt(0)) && (cc < 32 || cc > 126)) {
          if ((cc & 0xF800) === 0xD800) {
            extraCharCode = s.charCodeAt(i++);
            if ((cc & 0xFC00) !== 0xD800 || (extraCharCode & 0xFC00) !== 0xDC00) {
              throw Error('UCS-2(decode): illegal sequence');
            }
            cc = ((cc & 0x3FF) << 10) + (extraCharCode & 0x3FF) + 0x10000;
          }
          result += '\\' + cc.toString(16) + ' ';
        } else {
          result += c;
        }
        i++;
      }
      return result;
    };

    CssSelectorParser.prototype.escapeId = function(s) {
      var first;
      first = s[0];
      if (isDecimal(first)) {
        return "\\3" + (this.escapeIdentifier(first)) + " " + (this.escapeIdentifier(s.slice(1)));
      }
      return this.escapeIdentifier(s);
    };

    CssSelectorParser.prototype.escapeStr = function(s) {
      var c, i, l, r, result;
      result = '';
      i = 0;
      l = s.length;
      while (i < l) {
        c = s.charAt(i);
        if (c === '"') {
          c = '\\"';
        } else if (c === '\\') {
          c = '\\\\';
        } else if (r = strReplacementsRev[c]) {
          c = r;
        }
        result += c;
        i++;
      }
      return "\"" + result + "\"";
    };

    CssSelectorParser.prototype.render = function(path) {
      var renderEntity;
      renderEntity = (function(_this) {
        return function(entity) {
          var currentEntity, parts, res;
          res = '';
          switch (entity.type) {
            case 'ruleSet':
              currentEntity = entity.rule;
              parts = [];
              while (currentEntity) {
                if (currentEntity.nestingOperator) {
                  parts.push(currentEntity.nestingOperator);
                }
                parts.push(renderEntity(currentEntity));
                currentEntity = currentEntity.rule;
              }
              res = parts.join(' ');
              break;
            case 'selectors':
              res = entity.selectors.map(renderEntity).join(', ');
              break;
            case 'rule':
              if (entity.tagName) {
                if (entity.tagName === '*') {
                  res = '*';
                } else {
                  res = _this.escapeIdentifier(entity.tagName);
                }
              }
              if (entity.id) {
                res += "#" + (_this.escapeId(entity.id));
              }
              if (entity.classNames) {
                res += (entity.classNames.map(function(cn) {
                  return "." + (_this.escapeIdentifier(cn));
                })).join('');
              }
              if (entity.attrs) {
                res += (entity.attrs.map(function(attr) {
                  if (attr.operator) {
                    if (attr.valueType === 'substitute') {
                      return "[" + (_this.escapeIdentifier(attr.name)) + attr.operator + "$" + attr.value + "]";
                    } else {
                      return "[" + (_this.escapeIdentifier(attr.name)) + attr.operator + (_this.escapeStr(attr.value)) + "]";
                    }
                  } else {
                    return "[" + (_this.escapeIdentifier(attr.name)) + "]";
                  }
                })).join('');
              }
              if (entity.pseudos) {
                res += (entity.pseudos.map(function(pseudo) {
                  if (pseudo.valueType) {
                    if (pseudo.valueType === 'selector') {
                      return ":" + (_this.escapeIdentifier(pseudo.name)) + "(" + (renderEntity(pseudo.value)) + ")";
                    } else if (pseudo.valueType === 'substitute') {
                      return ":" + (_this.escapeIdentifier(pseudo.name)) + "($" + pseudo.value + ")";
                    } else {
                      return ":" + (_this.escapeIdentifier(pseudo.name)) + "(" + (_this.escapeStr(pseudo.value)) + ")";
                    }
                  } else {
                    return ":" + (_this.escapeIdentifier(pseudo.name));
                  }
                })).join('');
              }
              break;
            default:
              throw Error('Unknown entity type: "' + entity.type(+'".'));
          }
          return res;
        };
      })(this);
      return renderEntity(path);
    };

    return CssSelectorParser;

});
define('vcl/Component.query',["CssSelectorParser"], function(CssSelectorParser) {
	
	var PARENT_HIERARCHY_OPERATOR = "<";
	var Component;

    function Result() {}
    
    Result.prototype = [];
    
    /*- TODO find out which methods of Component, Control, Action to mixin */
    
    "on,un,listen,unlisten,connect,disconnect,execute,show,hide,render,\
dispatch,emit,fire,once,selectNext,selectPrevious"
		.split(",").forEach(function(name) {
	        Result.prototype[name] = function() {
	            for(var i = 0; i < this.length; ++i) {
	                if(typeof this[i][name] === "function") {
	                    this[i][name].apply(this[i], arguments);
	                }
	            }
	            return this;
	        };
    });
    
    Result.prototype.focus = function() {
            for(var i = 0; i < this.length; ++i) {
                if(typeof this[i].setFocused === "function") {
                    this[i].setFocused(true);
                }
            }
            return this;
    };
    
    Result.prototype.each = Result.prototype.forEach;
    
    function match_uri(rule, component) {
        var uri = component._uri;//getUri();
        return ((rule.exact && uri === rule.uri) ||
            (uri.split(".")[0] + "<").indexOf(rule.uri + "<") === 0);
    }
    function match_ctor(rule, component) {
        if(rule.ctor === "*") {
            return true;
        }
        return component.constructor === rule.ctor;
    }
    function match_classNames(rule, component) {
    	Component = Component || require("vcl/Component");
    	
    	var classes = Component.getKeysByUri(component.getUri()).classes;
        return rule.classNames.every(function(className) {
        	return classes.indexOf(className) !== -1;
        });            
    }
    function match_id(rule, component) {
        var hashCode = parseInt(rule.id, 10);
        if(!isNaN(hashCode)) {
            return component.hashCode() === hashCode;
        }
        return component._name === rule.id;
    }
    function match_pseudos(rule, component, context, all) {
        return rule.pseudos.every(function(pseudo) {
            if(pseudo.name === "this") {
                return component === context;
            } else if(pseudo.name === "root") {
                return component.isRootComponent();
            } else if(pseudo.name === "selected") {
                return component.isSelected && 
                	(component.isSelected() === (pseudo.value !== "false"));
            } else if(pseudo.name === "uri") {
            	var value = pseudo.value.split(",");
	            return match_uri({exact: value[1] === "exact", 
	            	uri: value[0].replace(/\\\//g, "/")}, component);
            } else if(pseudo.name === "childOf") {
            	return component._parent && 
            			component._parent._name === pseudo.value;
            } else if(pseudo.name === "app") {
            	return component.app();
            } else if(pseudo.name === "instanceof") {
            	return component instanceof require(pseudo.value.replace(/\\\//g, "/"));
            }
            
            var value;
            if(pseudo.value === ".") {
                value = context;
            } else if(pseudo.value.charAt(0) === "#") {
                value = parseInt(pseudo.value.substring(1), 10);
                if(isNaN) {
                	var name = pseudo.value.substring(1);
                	value = all.filter(function(comp) {
                		return comp.getName() === name;
                	});
                } else {
                	value = require("vcl/Component").all[value];
                }
            } else {
                value = js.get(pseudo.value, context);
            }
            
            if(pseudo.name === "owner-of") {
            	if(value instanceof Array) {
            		return value.every(function(elem) {
            			return component.isOwnerOf(elem);
            		});
            	}
                return component.isOwnerOf(value);
            } else if(pseudo.name === "is") {
                return component === value;
            }
            return false; 
        });
    }
    function match_properties(rule, component) {
        return rule.attrs.every(function(attr) {
            if(attr.name !== "uri") {
                var prop = component.defineProperties()[attr.name];
                var value = prop.get(component);
                switch(attr.operator) {
                    case "=":
                        return ("" + value) === ("" + attr.value);
                    
                    default:
                        return false;
                }
            }
            return match_uri({uri: attr.value.replace(/\\\//g, "/")}, component);
        });
    }
    function match(rule, component, operator, context, all) {
    	if(operator === ">") {
    		console.warn("DEPRECATED operator >");
    		operator = PARENT_HIERARCHY_OPERATOR;
    	}
        if(operator === null) {
        	/*- owner hierarchy */
            while(component._owner) {
                if(match(rule, component._owner, undefined, context)) {
                    return true;
                }
                component = component._owner;
            }
            return false;
        } else if(operator === PARENT_HIERARCHY_OPERATOR) {
        	/*- parent hierarchy */
            while(component._parent) {
                if(match(rule, component._parent, undefined, context)) {
                    return true;
                }
                component = component._parent;
            }
            return false;
        	
        } else if(operator === "first-owner-must-match") {
        	/* owner must match */
            return match(rule, component._owner, undefined, context);
        }
        
        return component !== null &&
            (!rule.uri || match_uri(rule, component)) &&
            (!rule.ctor || match_ctor(rule, component)) &&
            (!rule.classNames || match_classNames(rule, component)) &&
            (!rule.id || match_id(rule, component)) &&
            (!rule.pseudos || match_pseudos(rule, component, context, all)) &&
            (!rule.attrs || match_properties(rule, component));
    }
    function parse(selector) {
        var parser = new CssSelectorParser();
        parser.registerNestingOperators(">");
        parser.registerNestingOperators(PARENT_HIERARCHY_OPERATOR);
        
        tree = parser.parse(selector
            .replace(/<([^>]*)>/g, "\\<$1\\>")
            .replace(/\//g, "\\/"));

        var rules = [], rule = tree.rule;
        while(rule) {
            if(rule.tagName && rule.tagName.indexOf("<") !== -1) {
                rule.uri = rule.tagName;
                if(!(rule.exact = rule.uri.indexOf("<>") === -1)) {
                    rule.uri = rule.uri.split("<")[0];
                }
                delete rule.tagName;
            } else if(rule.tagName && rule.tagName !== "*") {
                rule.ctor = require(rule.tagName);
                delete rule.tagName;
            } else if(rule.tagName === "*") {
                rule.ctor = "*";
            }
            rules.push(rule);
            rule = rule.rule;
        }
        return rules;
    }

    return function(selector, context, all) {
        var rules = parse(selector);
        var operator;
        var components = [].concat(all);
        
        rules.reverse().forEach(function(rule) {
            components = components.reduce(function(arr, component) {
                if(match(rule, component, operator, context, components)) {
                    arr.push(component);
                }
                return arr;
            }, new Result());
            operator = rule.nestingOperator;
        });
        
        return components;
    };
    
});
define('vcl/Component',['require','js/defineClass','js/Type','js/Property','./Listeners','js/referenceClass!./Factory','js','js/mixInRecursive','./Component.query'],function (require) {

    var Component = require("js/defineClass");
    var Type = require("js/Type");
    var Property = require("js/Property");
    var Listeners = require("./Listeners");
    var Factory = require("js/referenceClass!./Factory");
    var js = require("js");
    var mixInR = require("js/mixInRecursive");
    var query = require("./Component.query");

    var ILLEGAL_COMPONENT_NAME_CHARS = "/";
    var ILLEGAL_COMPONENT_URI_CHARS = "/";

    var all = [];

    Component = Component(require, {
        prototype: {
            // properties
            _name: "",
            _top: 0,
            _left: 0,
            _components: null,
            _owner: null,
            _uri: "",
            // runtime
            _params: null,
            _vars: null,
            _listeners: null,
            _timeouts: null,
            _loading: false,
            _designerHook: null,
            _isRoot: false,
            // events
            _onLoad: null,
            _onDestroy: null,
            _onDispatchChildEvent: null,
            _onReceiveParams: null,
            _onMessage: null,

            constructor: function (owner, uri, isRoot) {
	            /**
	             *
	             * @param owner
	             * @param uri
	             * @param isRoot
	             */
                if (owner !== undefined) {
                    this.setOwner(owner);
                }
                if (uri !== undefined) {
                    this._uri = uri;
                }
                if (isRoot) {
                    this._isRoot = isRoot;
                }
                all.push(this);
            },
            toString: function () {
	            /**
	             * @overrides Object.prototype.toString
	             */
                if (this.hasOwnProperty("_name")) {
                    return String.format("%n#%s#%d", this.constructor, this._name, this.hashCode());
                }
                return String.format("%n#%d", this.constructor, this.hashCode());
            },
            destroy: function () {
	            /**
	             *
	             */
                all.splice(all.indexOf(this), 1);

                // FIXME destroying !== loading
                this.beginLoading();
                try {
                    this.dispatch("destroy");
                    this.destroyComponents();
                    this.setOwner(null);

                    this.clearTimeouts();
                } finally {
                    this.endLoading();
                }

                return this.inherited(arguments);
            },
            ondestroy: function () {
	            /**
	             *
	             */
                this.fire("onDestroy", arguments);
            },
            destroyComponents: function () {
	            /**
	             *
	             */
                if (this.hasOwnProperty("_components")) {
                    // avoiding a while(this._components.length > 0) {} loop
                    var comps = [].concat(this._components);
                    for (var i = 0, l = comps.length; i < l; ++i) {
                        if (comps[i]._owner === this) {
                            comps[i].destroy();
                        }
                    }
                }
            },
            dispatch: function (name, evt) {
	            /**
	             *
	             */
                if (evt === undefined) {
                    evt = {
                        type: name
                    };
                }

                if (this._loading === false) {
                    var f = this["on" + name];
                    var args = js.copy_args(arguments);
                    args.shift();

                    var enabled = this.isEventEnabled(name, evt, f, args);
                    if (typeof f === "function" && enabled === true) {
                        return f.apply(this, args);
                    } else {
                        if (enabled === false) {
                            /*- might not want preventDefault? */
                            if (typeof evt.preventDefault === "function") {
                                // evt.preventDefault();
                            }
                        }
                        return false;
                    }
                }
            },
            dispatchChildEvent: function (component, name, evt, f, args) {
	            /**
	             * Returns whether the child -component- may receive the event
	             */
                if (this._onDispatchChildEvent !== null) {
                    if (this.fire("onDispatchChildEvent", arguments) === false) {
                        return false;
                    }
                }
                return true;
            },
            isEventEnabled: function (name, evt, f, args) {
	            /**
	             *
	             * @param name
	             * @param evt
	             * @param f
	             * @param args
	             * @returns
	             */
                var designer = this.getDesignerHook();
                if (designer !== null) {
                    return designer.dispatchEvent(this, name, evt, f, args);
                }
                return true;
            },
            loaded: function () {
                this.fire("onLoad", arguments);
                if (this.hasOwnProperty("_components")) {
	            	var args = js.copy_args(arguments);
                    var this_uri = this._uri;
                    this._components.forEach(function (c) {
                        c.loaded.apply(c, args);
                    });
                }
            },
            fire: function (name, args, force, _undefined) {
	            /**
	             *
	             * @param name
	             * @param args
	             * @param force
	             * @returns
	             */
                if (force !== true && (this.isLoading() || this.isDesigning())) {
                    // do not execute event when component is being loaded or
                    // designed
                    return;
                }

                var mth, r = _undefined;
                name = "_" + name;

                if (typeof(mth = this[name]) === "function") {
                    r = mth.apply(this, args);
                }

                return r;
            },
            log: function () {
	            /**
	             *
	             */
                var caller = arguments.callee.caller;
                var args = js.copy_args(arguments);
                if (caller) {
                    for (var k in this) {
                        if (this[k] === caller) {
                            if (k.indexOf("_on") === 0) {
                                k = k.substring(1);
                            }
                            args.unshift(k);
                            break;
                        }
                    }
                }
                this.bubble.apply(this, ["log", args]);
            },
            bubble: function (name, msg) {
	            /**
	             *
	             */
                this.sendMessage(name, msg, this, true);
            },
            sendMessage: function (name, msg, sender, allowBubble) {
	            /**
	             *
	             */
                if (this.fire("onMessage", [name, msg, sender || this, allowBubble]) === undefined) {
                    if (allowBubble !== false) {
                        return this._owner ? this._owner.sendMessage(
                        name, msg, sender || this, allowBubble) : undefined;
                    }
                }
            },
            setTimeout: function (name, f, ms, args) {
	            /**
	             *
	             * @param name
	             *            Used to identify the timeout. Successive calls will
	             *            cancel a previous timeout with the same name.
	             * @param f
	             *            {String/Function} Identifies the function which should
	             *            be called when at least ms has passed. Optional, when
	             *            omitted it defaults to the same value as name. A
	             *            string value to identify a member function or simply a
	             *            reference to a function.
	             * @param ms
	             *            {Number} Number of milliseconds
	             * @param args
	             *            {Array} Array of arguments to be passed to the
	             *            function.
	             * @returns The return value of js.setTimeout
	             * @seealso js.setTimeout, window.setTimeout
	             */
                var h, me = this;
                if (!this.hasOwnProperty("_timeouts")) {
                    this._timeouts = {};
                }
                
                if(typeof name === "object" && typeof name.f === "function") {
                    return this.setTimeout(name.name, name.f, name.ms, name.args);
                }

                // f is optional (where it defaults to the same value as name),
                // so in that case the arguments shift
                if (typeof f === "number") {
                    args = ms;
                    ms = f;
                    f = name;
                }
                
// console.debug("setTimeout", name, [this, arguments]);
                
                // If f turns out to be a string, assume it identifies a member
                // function of the calling Component
                if (typeof f === "string") {
                    f = this[f];
                    if (typeof f !== "function") {
                        throw new Error("Need a function");
                    }
                    // When args is not specified, simply bind the function
                    if (args === undefined) {
                        f = f.bind(this);
                    } else {
                        // ...else create a wrapper function and pass the
                        // arguments via Function.prototype.apply()
                        h = f;
                        f = function () {
                            return h.apply(me, args);
                        };
                    }
                } else if (args !== undefined) {
                    h = f;
                    f = function () {
                        return h.apply(window, args);
                    };
                }

                if (typeof f !== "function") {
                    throw new Error("Need a function");
                }

                function g() {
                    delete me._timeouts[name];
                    f();
                }

                this.clearTimeout(name);

                return (this._timeouts[name] = js.setTimeout(g, ms, this._timeouts[name]));
            },
            clearTimeout: function (name) {
	            /**
	             *
	             */
                if (this.hasOwnProperty("_timeouts")) {
                    var timeout = this._timeouts[name];
                    delete this._timeouts[name];
                    return js.clearTimeout(timeout);
                }
            },
            clearTimeouts: function () {
	            /**
	             *
	             */
                for (var key in this._timeouts) {
                    if (this._timeouts.hasOwnProperty(key)) {
                        js.clearTimeout(this._timeouts[key]);
                    }
                }
                this._timeouts = null;
            },
            connect: function (listeners) {
	            /**
	             *
	             */
                return this.on.apply(this, [listeners, true]);
            },
            disconnect: function (listeners) {
	            /**
	             *
	             */
                return this.un.apply(this, arguments);
            },
            emit: function (name, args) {
	            /**
	             * Emits an event to listeners
	             */
                name = "on" + name;

                if (! (args instanceof Array) && !(args && args.callee)) {
                    //console.trace("emit non-array");
                    args = js.copy_args(arguments);
                    args.shift();
                } else {
                    //console.log("emit array", args)
                }

                if (this.hasOwnProperty("_listeners")) {
                    this._listeners.call(name, args);
                }
            },
            once: function (name, f, asIs) {
                var lis = this.on(name, function () {
                    this.un(lis);
                    return f.apply(this, arguments);
                }, asIs);
                return lis;
            },
            on: function (listeners, asIs) {
	            /**
	             *
	             * @param listeners
	             */
                if (this.hasOwnProperty("_listeners") === false) {
                    this._listeners = new Listeners(this);
                }

                if (typeof listeners === "string") {
                    /*- Parameters are: name, f, asIs */
                    var obj = {};
                    obj[listeners] = asIs;
                    listeners = obj;
                    asIs = arguments[2];
                }

                var r = {};
                for (var k in listeners) {
                    var f = listeners[k];
                    if (asIs !== true && k.substring(0, 2) !== "on") {
                        k = "on" + k;
                    }
                    r[k] = this._listeners.add(k, f);
                }
                return r;
            },
            un: function (listeners) {
	            /**
	             *
	             * @param listeners
	             */
                if (this.hasOwnProperty("_listeners") === false) {
                    //throw new Error("No listeners");
                    console.warn("No listeners");
                    return;
                }

                if (typeof listeners === "string") {
                    // Parameters in this form are: name. f, asIs
                    var obj = {};
                    obj[listeners] = this._listeners.getListener("on" + listeners, arguments[1]);
                    listeners = obj;
                }

                for (var k in listeners) {
                    this._listeners.remove(listeners[k]);
                }

                if (Object.keys(this._listeners._listeners).length === 0) {
                    delete this._listeners;
                }
            },
            isLoading: function () {
	            /**
	             * Returns true when the component is in 'loading state'.
	             */
                return this.hasOwnProperty("_loading") || (this._owner !== null ? this._owner.isLoading() : false);
            },
            beginLoading: function () {
	            /**
	             *
	             */
                if (this._loading === false) {
                    this._loading = [];
                }
                this._loading.push(Date.now());
            },
            endLoading: function () {
	            /**
	             *
	             */
                if (this._loading === false) {
                    throw new Error("Not loading");
                }
                var time = this._loading.pop();
                if (this._loading.length === 0) {
                    delete this._loading;
                }
                return Date.now() - time;
            },
            isDesigning: function () {
	            /**
	             * Returns true whether the component is in 'designing state'.
	             */
                return this.getDesignerHook() !== null;
            },
            getDesignerHook: function () {
	            /**
	             *
	             */
                return this._designerHook || (this._owner !== null ? this._owner.getDesignerHook() : null);
            },
            setDesignerHook: function (value) {
	            /**
	             *
	             */
                if (this.isDesigning() && value !== null) {
                    throw new Error("Already designing");
                }
                this._designerHook = value;
            },
            isRootComponent: function () {
	            /**
	             *
	             */
                return this._isRoot;
            },
            inheritsFrom: function (root) {
	            /**
	             *
	             */
                if (!root.isRootComponent()) {
                    return false;
                }
                return this._uri !== "" && this._uri !== root.getUri();
            },
            revertPropertyValue: function (name) {
	            /**
	             *
	             */
                var property = this.defineProperties()[name];
                property.set(this, this.getPropertyValue(name));
            },
            getPropertyValue: function (name) {
	            /**
	             *
	             */
                return this['@properties'] ? this['@properties'][name] : undefined;
            },
            getVars: function () {
	            /**
	             * Returns the -vars- object associated with the calling component.
	             *
	             * @return Object
	             */
                if (this._vars === null) {
                    this._vars = {};
                }
                return this._vars;
            },
            setVars: function (value) {
	            /**
	             *
	             */
            	if(typeof value === "string") {
            		value = js.str2obj(value);
            	}
                if (this.isLoading()) {
                    this._vars = mixInR(this._vars || {},
                    value);
                } else {
                    this._vars = value;
                }
                return this._vars;
            },
            mixInVars: function (value) {
	            /**
	             *
	             */
                var vars = this.getVars();
                for (var k in value) {
                    vars[k] = value[k];
                }
                return vars;
            },
            hasVar: function (key) {
	            /**
	             *
	             */
                return this._vars && this._vars.hasOwnProperty(key);
            },
            getVar: function (namePath, fallback_to_owner, defaultValue) {
	            /**
	             *
	             */
                if (defaultValue) {
                    this._vars = this._vars || {};
                }

                var r = this._vars !== null ? js.get(namePath, this._vars, defaultValue) : undefined;
                if (r === undefined && fallback_to_owner === true && this._owner !== null) {
                    r = this._owner.getVar(namePath, true, defaultValue);
                }
                return r;
            },
            setVar: function (namePath, value) {
	            /**
	             *
	             */
                if (this._vars === null) {
                    this._vars = {};
                }
                return js.set(namePath, value, this._vars);
            },
            removeVar: function (name) {
	            /**
	             *
	             */
                var r;
                if (name.indexOf(".") !== -1) {
                    name = name.split(".");
                    var prop = name.pop();
                    r = [this.getVar(name.join("."))];
                    r.push(r[0][prop]);
                    delete r[0][prop];
                    r = r.pop();
                } else if (this._vars !== null) {
                    r = this._vars[name];
                    delete this._vars[name];
                }
                return r;
            },
            getAppVar: function () {
	            /**
	             *
	             */
                var app = this.getApp();
                return app.getVar.apply(app, arguments);
            },
            setAppVar: function () {
	            /**
	             *
	             */
                var app = this.getApp();
                return app.setVar.apply(app, arguments);
            },
            apply: function (name, args, callback) {
	            /**
	             *
	             */
                return this.applyVar(name, args || [], true, this, callback);
            },
            applyVar: function (name, args, fallback_to_owner, thisObj, callback) {
	            /**
	             * @param fallback_to_owner - default false
	             */
                var f = this.getVar(name), r;
                if (typeof f !== "function") {
                    if (this._owner === null || fallback_to_owner !== true) {
                        if (fallback_to_owner === "silent") {
                            return;
                        }
                    }
                    return this._owner.applyVar(name, args, true, thisObj, callback);
                }
                if (! (args instanceof Array)) {
                    args = [args];
                }
                r = f.apply(thisObj || this, args);
                return typeof callback === "function" ? callback.apply(thisObj || this, [r]) : r;
            },
            findComponent: function (name) {
	            /**
	             * Returns the owned component named -name-
	             */
                if (this.hasOwnProperty("_components")) {
                    for (var i = 0, l = this._components.length; i < l; ++i) {
                        if (this._components[i]._name === name) {
                            return this._components[i];
                        }
                    }
                }
                return null;
            },
            isParentOf: function(component) {
            	/* overridden in ./Control */
            	return false;
            },
            isOwnerOf: function(component) {
	            /**
	             * Returns true when the calling component (indirectly) owns the
	             * specified component.
	             */
                while(component._owner !== null) {
                    if(component._owner === this) {
                        return true;
                    }
                    component = component._owner;
                }
                return false;
            },
            query1: function () {
                console.error("Should not be called anymore");
                return (this.query.apply(this, arguments) || [])[0];
            },
            query: function (selector, ctor) {
                console.error("ARGH query must be qsa");
                
                var r;
                if (selector === "@owner") {
                    var args = js.copy_args(arguments);
                    args.shift();
                    r = this.findOwner.apply(this, args);
                } else if (selector === "@scope") {
                    var args = js.copy_args(arguments);
                    args.shift();
                    r = this.getScope.apply(this, args);
                } else {
                    r = this;
                    if (selector.charAt(0) === "/") {
                        while (r._owner) {
                            r = r._owner;
                        }
                        selector = selector.substring(1);
                    }
                    // console.trace("Component.query", {
                    //     'this': this,
                    //     args: arguments
                    // });
                    if (selector.length > 0) {
                        selector = selector.split("/");
                        while (r !== null && selector.length > 0) {
                            r = r.getScope()[selector.shift().split("[").shift()];
                        }
                    }

                    // check whether the ctor matches
                    if (ctor && !(r instanceof ctor)) {
                        r = null;
                    } else {
                        r = [r];
                    }
                }

                return r;
            },
            up: function(selector, allowAll) {
	            /*- Queries all components for the given selector and filters out
	                those matches which are an owner of the calling component. The
	                result closest match (in the owner hierarchy) is returned, or 
	                all matched components are returned, sorted by 'closeness'. */
                var me = this;
                var all = query(selector || ":root", this, Component.all)
                    .map(function(owner) {
            			return {owner: owner, distance: me.distanceToOwner(owner)};
            		})
            		.filter(function(elem) {
            			return elem.owner !== this && elem.distance > 0;
            		})
            		.sort(function(elem1, elem2) {
            			return elem1.distance - elem2.distance;
            		})
            		.map(function(elem) {
            			return elem.owner;
            		});
        		
        		return allowAll ? all : all[0] || null;
            },
	        down: function(selector) {
	            /*- Return the first element of a call to ::qsa with the same
	                selector arguments or null when nothing matches. */
                return this.qsa(selector)[0] || null;
            },
            scope: function() {
	            /*- Search in the current scope. The scope being defined by the 
	                owning component of the calling component, or the calling 
	                component itself if it is a root component. */
                if(arguments.length === 0) {
                    return this.getScope();
                }
                return this.getScope()[arguments[0]];
            },
            qsa: function(selector, context) {
                var me = this, parent = selector.trim().charAt(0) === "<";
                return query(String.format("#%d %s", this.hashCode(), selector), 
                    context || this, 
                    all.reduce(function(arr, comp) {
                        if(	(parent === true	&& me.isParentOf(comp)) || 
                        	(parent === false	&& me.isOwnerOf(comp))
                        ) {
                        	arr.push(comp);
                        }
                        return arr;
                    }, [])
                );
            },
            qs: function(selector, context) {
                return this.qsa(selector, context)[0] || null;
            },

            findOwner: function (ctor, uri, base) {
	            /**
	             * Finds the first root component in the owner hierarchy, which is an instanceof
	             * ctor (optional) and which uri matches the specified uri (optional) in case it.
	             * If base is not false, uris are reduced to the implicit base (default behaviour).
	             *
	             * @param ctor A reference to a constructor (optinal)
	             * @param uri An uri (optional, string)
	             * @param base If not false, uris are reduced to the implicit base
	             */
                
                console.warn("Component.prototype.findOwner will be deprecated");
                
                if (typeof ctor === "string" || ctor instanceof RegExp) {
                    base = uri;
                    uri = ctor;
                    ctor = undefined;
                }

                var owner = this._owner;
                while (owner !== null) {
                    if (!ctor || owner instanceof ctor) {
                        if (uri instanceof RegExp && uri.test(owner.getUri())) {
                            return owner;
                        }
                        if (!uri || uri === (base !== false ? owner.getUri().split("<")[0] : owner.getUri())) {
                            return owner;
                        }
                    }
                    owner = owner._owner;
                }
                return null;
            },
            getScope: function (parentScope) {
	            /**
	             *
	             */
                var scope = {};

                if (parentScope === undefined && this._isRoot === true) {
                    parentScope = false;
                }

                if (this._owner !== null && parentScope !== false) {
                    scope = this._owner.getScope(parentScope !== true);
                }
                scope['@owner'] = parentScope !== false ? this._owner || this : this;
                if (this.hasOwnProperty("_components")) {
                    for (var i = 0, l = this._components.length; i < l; ++i) {
                        var component = this._components[i];
                        if (component.getName() !== "") {
                            scope[component.getName()] = component;
                        }
                    }
                }
                scope['@this'] = this;
                if (!scope.hasOwnProperty("@app")) {
                    scope['@app'] = this.getApp();
                }
                return scope;
            },
            getOwner: function () {
	            /**
	             * Returns the owner of a component
	             */
                if (arguments.length) {
                    return this.findOwner.apply(this, arguments);
                }
                return this._owner;
            },
            setOwner: function (value) {
	            /**
	             *
	             */
                if (this._owner !== value) {
                    if (this._owner !== null) {
                        this._owner.removeComponent(this);
                    }
                    if (value !== null) {
                        value.insertComponent(this);
                    }
                }
            },
            getApp: function () {
	            /**
	             *
	             */
                var r = this;
                while (r._owner) {
                    r = r._owner;
                }
                return r; // && r instanceof require("vcl/Application") ? r : null;
            },
           
            app: function() {
                return this.getApp();
            },

            getIsRoot: function () {
	            /**
	             *
	             * @returns {Boolean}
	             */
                console.warn("Component.prototype.getIsRoot is deprecated, use isRootComponent() instead");
                return this._isRoot;
            },
            setIsRoot: function (value) {
	            /**
	             *
	             * @param value
	             */
                if (!this.isLoading() && (this._owner !== null || this._uri !== "")) {
                    throw new Error("Can not set isRoot now");
                }
                if (value === true) {
                    this._isRoot = true;
                } else {
                    delete this._isRoot;
                }
            },
    		distanceToParentComponent: function(parent) {
    			var r = 1, cmp = this.getParentComponent();
    			while(cmp && cmp !== parent) {
    				cmp = cmp.getParentComponent();
    				r++;
    			}
    			return cmp === parent ? r : 0;
    		},
    		distanceToOwner: function(owner) {
    			var r = 1, cmp = this.getOwner();
    			while(cmp && cmp !== owner) {
    				cmp = cmp.getOwner();
    				r++;
    			}
    			return cmp === owner ? r : 0;
    		},
            getParentComponent: function () {
	            /**
	             * Returns the parent of a component
	             */
                return null;
            },
            setParentComponent: function (value) {},
            getChildren: function (func, root) {
	            /**
	             *
	             */
                if (this.hasOwnProperty("_components") && root === this) {
                    this._components.forEach(function (component) {
                        var pc = component.getParentComponent();
                        if (pc === null || pc === this) {
                            func(component);
                        }
                    },
                    this);
                }
            },
            nameComponent: function (component, newName) {
	            /**
	             * Renames the component. If a component named -newName- is owned by
	             * the calling component or the calling components owner, this
	             * method raises an exception. Component names are case- sensitive.
	             */
                if (newName !== "" && this.findComponent(newName) !== null) {
                	/*- Allowing multiple components with the same name. So
                	scope() will become unreliable. Replacements are of the likes 
                	of up(), down() qs, and qsa should become the tools */
                	
                    //throw (new Error(String.format("A component named '%s' already exists.", newName)));
                }
                if (this._owner !== null && component === this) {
                    this._owner.nameComponent(component, newName);
                } else {
                    component._name = newName;
                    if (component.isDesigning()) {
                        component.getDesignerHook().modified(component, "name");
                    }
                }
            },
            getName: function () {
	            /**
	             *
	             */
                return this._name;
            },
            setName: function (value) {
	            /**
	             *
	             */
                if (this._name !== value) {
                    this.nameComponent(this, value);
                }
            },
            getParam: function (namePath) {
	            /**
	             *
	             */
                return js.get(namePath, this._params || {});
            },
            getParams: function () {
	            /**
	             *
	             */
                return this._params;
            },
            setParams: function (value) {
	            /**
	             *
	             */
                this._params = value;
                if (value !== null) {
                    // null is nothing
                    this.fire("onReceiveParams", arguments);
                }
            },
            insertComponent: function (component) {
	            /**
	             *
	             */
                if (!this.hasOwnProperty("_components")) {
                    this._components = [];
                }
                if (component._name !== "" && this.findComponent(component.getName()) !== null) {
                    throw new Error(String.format("A component named '%s' already exists.", component.getName()));
                }
                component._owner = this;
                this._components.push(component);
            },
            removeComponent: function (component) {
	            /**
	             *
	             */
                // if(this.hasOwnProperty("_components")) {
                this._components.splice(this._components.indexOf(component), 1);
                component._owner = null;
                // }
            },
            getStorageKey: function(forKey) {
            	var app = this.getApp();
            	if(app) {
            		return app.getStorageKey([this, forKey]);
            	}
            },
            readStorage: function (key, callback, errback) {
	            /**
	             *
	             */
                var r = localStorage.getItem(this.getStorageKey(key));
                if (typeof callback === "function") {
                    callback.apply(this, [r]);
                }
            },
            writeStorage: function (key, value, callback, errback) {
	            /**
	             *
	             */
                try {
                    var item = this.getStorageKey(key);
                    var r = localStorage.setItem(item, value);
                    if (typeof callback === "function") {
                        callback.apply(this, [r]);
                    }
                } catch(e) {
                    if (typeof errback === "function") {
                        errback.apply(this, [e]);
                    }
                }
            },
            getUriInfo: function () {
	            /**
	             *  Returns an object describing the attributes of the uri of the calling component
	             */
                return Component.getKeysByUri(this._uri);
            },
            getUri: function () {
                if (this.isRootComponent()) {
                    return this._uri;
                }

                if (this._owner && this._name) {
                    return String.format("%s/%s", this._owner.getUri(), this._name);
                }

                return !this._owner || this.hasOwnProperty("_uri") ? this._uri : this._owner.getUri();
            },
            setUri: function (value) {
	            /**
	             *
	             */
                this._uri = value;
            },
            getNamespace: function () {
	            /**
	             *
	             */
                return Component.getKeysByUri(this.getUri()).namespace;
            },
            getSpecializer: function (removeClasses) {
	            /**
	             *
	             */
                return Component.getKeysByUri(this._uri || this.getUri()).specializer;
            },
            getPropertyValue: function (name) {
	            /**
	             *
	             */
                return this['@properties'][name];
            },
            hasPropertyValue: function (name) {
	            /**
	             *
	             */
                return this['@properties'][name] !== undefined;
            }
        },
        statics: {
            all: all,
            nameComponent: function (component, name) {
	            /**
	             *
	             */
                if (component._owner === null) {
                    throw new Error("No owner");
                }

                if (name !== undefined && component._owner.findComponent(name) === null) {
                    return component.setName(name);
                }

                var i = 0;
                base = name || component.getClass().getName().split(".").pop().toLowerCase();
                name = String.format("%s%d", base, ++i);
                while (component._owner.findComponent(name)) {
                    name = String.format("%s%d", base, ++i);
                }
                component.setName(name);
                return name;
            },
            getUriByKeys: function (keys) {
	            /**
	             *
	             */

                var className = keys.className || (keys.classes ? keys.classes.join(" ") : "");
                var specializer = keys.specializer ? keys.specializer : keys.template ? keys.namespace || "" : "";
                var name = keys.name || "";
                var uri;
                if (className !== "") {
                    className = String.format(".%s", className.split(" ").join("."));
                }

                if (name.indexOf(".") === -1) {
                    name = "";
                } else {
                    name = "." + name;
                }

                if (keys.specializer_classes instanceof Array && keys.specializer_classes.length) {
                    specializer += String.format(".%s", keys.specializer_classes.join("."));
                }

                if (keys.template) {
                    uri = String.format("%s<%s>%s%s", keys.template, specializer, name, className);
                } else {
                    uri = String.format("%s%s%s%s", keys.namespace, keys.namespace ? "/" : "", keys.name, className);
                }

                return uri;
            },
            getImplicitBaseByUri: function (uri, loop) {
	            /**
	             *
	             */
                if (loop === true) {
                    var arr = [];
                    while (uri !== null) {
                        arr.push(uri);
                        uri = Component.getImplicitBaseByUri(uri);
                    }
                    return arr;
                }

                var keys = Component.getKeysByUri(uri);

                // ui/forms/persistence/View
                if (keys.specializer === "" && keys.classes.length === 0) {
                    if (uri.indexOf("<>") !== -1) {
                        return uri.split("<")[0];
                    }
                    return null;
                }

                // ui/forms/persistence/View<X>.a
                if (keys.classes.length > 0) {
                    delete keys.classes;
                    return Component.getUriByKeys(keys);
                }

                // ui/forms/persistence/View<X.b>.a
                if (keys.specializer_classes.length > 0) {
                    delete keys.specializer_classes;
                    return Component.getUriByKeys(keys);
                }

                // ui/forms/persistence/View<X.a>
                if (keys.specializer !== "") {
                    if (keys.specializer.indexOf(".") !== -1) {
                        if ((keys.specializer = keys.specializer.split(".")[0]) !== "") {
                            return Component.getUriByKeys(keys);
                        }
                        // ui/forms/persistence/View<X/Y>
                    } else if (keys.specializer.indexOf("/") !== -1 || keys.specializer.indexOf(":") !== -1) {
                        keys.specializer = keys.specializer.split("/");
                        if (keys.specializer.length === 1) {
                            keys.specializer = keys.specializer[0].split(":");
                        }
                        keys.specializer.pop();
                        if ((keys.specializer = keys.specializer.join("/")) !== "") {
                            return Component.getUriByKeys(keys);
                        }
                    }
                }

                // ui/forms/persistence/View<X>
                return keys.template;
            },
            getImplicitBasesByUri: function (uri) {
	            /**
	             *
	             */
                var base = Component.getImplicitBaseByUri(uri);
                var r = [];

                if (base !== null) {
                    var keys = Component.getKeysByUri(uri);
                    var classes = keys.classes;
                    var spec_classes = keys.specializer_classes;
                    if (classes.length > 1) {
                        // [A] Each class expands
                        classes.forEach(function (cls) {
                            keys.classes = [cls];
                            r.push(Component.getUriByKeys(keys));
                        });
                    } else if (classes.length === 1) {
                        if (spec_classes.length > 1) {
                            // [B] Each specializer_class expands
                            spec_classes.forEach(function (cls) {
                                keys.specializer_classes = [cls];
                                r.push(Component.getUriByKeys(keys));
                            });
                        } else if (spec_classes.length === 1) {
                            // [C]
                            delete keys.specializer_classes;
                            r.push(Component.getUriByKeys(keys));
                        } else if (keys.specializer) {
                            // [D] keys.classes.length === 1 && keys.specializer
                            delete keys.template;
                            delete keys.specializer;
                            r.push(Component.getUriByKeys(keys));
                        } else if (uri.indexOf(Factory.PREFIX_PROTOTYPES) !== 0) {
                            // [H] keys.classes.length === 1 && !keys.specializer && !prototypes/
                            r.push(String.format("%s%s", Factory.PREFIX_PROTOTYPES, uri));
                        } else {
                            // [J] equals [G], continue on prototypes/ prefix
                        }
                    } else if (spec_classes.length > 1) {
                        // [E] Each specializer_class expands
                        spec_classes.forEach(function (cls) {
                            keys.specializer_classes = [cls];
                            r.push(Component.getUriByKeys(keys));
                        });
                    } else if (spec_classes.length === 1) {
                        // [F]
                        delete keys.specializer_classes;
                        r.push(Component.getUriByKeys(keys));
                    } else if (keys.specializer) {
                        /*- [G] nothing todo here since there are no (spec_)classes
                         * and the implicit base is already pushed */
                    } else {
                        console.warn("Thought this was unreachable code");
                    }

                    // Always inherit the implicit base
                    r.push(base);

                } else if (uri.indexOf(Factory.PREFIX_PROTOTYPES) !== 0) {
                    r.push(String.format("%s%s", Factory.PREFIX_PROTOTYPES, uri));
                } else {
                    // [I] it ends here, there is no implicit base for uri
                }
                return r;
            },
            getImplicitSourceByUri: function (uri) {
	            /**
	             *
	             */
                var uris = Component.getImplicitBasesByUri(uri);
                if (uris.length === 0) {
                    if (uri.indexOf(Factory.PREFIX_PROTOTYPES) !== 0) {
                        uris.push(String.format("%s%s", Factory.PREFIX_PROTOTYPES, uri));
                    }
                }

                uris.sort(function (u1, u2) {
                    // WRONG: 304 App.desktop --> $(["App", "vcl/prototypes/App.desktop"]);
                    // RIGHT: 304 App.desktop --> $(["vcl/prototypes/App.desktop", "App"]);
                    u1 = u1.indexOf(".scaffold");
                    u2 = u2.indexOf(".scaffold");
                    return u1 < u2 ? -1 : 1;
                });

                return String.format("$([\"" + uris.join("\", \"") + "\"]);");
            },
            getKeysByUri: function (uri) {
	            /**
	             *
	             */
                var r = {};

                uri = uri.split("<");
                if (uri.length === 2) {
                    r.template = uri[0];
                    r.namespace = uri[0].split(".")[0].split("/");
                    r.name = r.namespace.pop();
                    r.namespace = r.namespace.join("/");

                    uri = uri[1].split(">");
                    if ((r.specializer = uri.shift()) === "") {
                        r.template = "";
                    }
                    r.classes = uri.shift().split(".");
                    if (r.classes[0] === "") {
                        r.classes.shift();
                    }
                } else {
                    // Only last part can have a dot (.) indicating classes
                    r.classes = uri[0].split("/").pop().split(".");
                    r.classes.shift();

                    uri = uri[0].substring(0, uri[0].length - r.classes.join(".").length - 1);

                    r.template = "";
                    r.specializer = "";

                    r.namespace = uri.split("/");
                    r.name = r.namespace.pop();
                    r.namespace = r.namespace.join("/");
                }

                if (r.specializer) {
                    r.specializer = r.specializer.split(".");
                    r.specializer_classes = r.specializer.splice(1);
                    r.specializer = r.specializer.pop();
                } else {
                    r.specializer_classes = [];
                }

                return r;
            },
            load: function (name, parentRequire, load, config) {
	            /**
	             * @overrides http://requirejs.org/docs/plugins.html#apiload
	             */
                console.log(name);
            }
        },
        properties: {
            "components": {
                type: Type.ARRAY,
                assignable: false,
                visible: false,
                stored: false
            },
            "owner": {
                type: Type.OBJECT,
                assignable: false,
                visible: false,
                stored: false
            },
            "uri": {
                type: Type.STRING,
                get: Function,
                // visible: false,
                assignable: false,
                // editor: ComponentUri,
                enabled: false,
                stored: false
            },
            "left": {
                type: Type.INTEGER,
                visible: false
            },
            "top": {
                type: Type.INTEGER,
                visible: false
            },
            "vars": {
                type: Type.OBJECT,
                set: Function
            },
            "name": {
                set: Function,
                type: Type.STRING,
                // editor: ComponentName,
                stored: false
            },
            "prototype": {
                set: function(value) {
                    this.override(value);
                },
                type: Type.OBJECT
            },
            "onLoad": {
                type: Type.EVENT
            },
            "onDestroy": {
                type: Type.EVENT
            },
            "onDispatchChildEvent": {
                type: Type.EVENT
            },
            "onMessage": {
                type: Type.EVENT
            }
        }
    });

    Property.registerReferencedClass(Component);

    return Component;
});
define('vcl/Factory.parse',['require','js/Deferred','vcl/Component','vcl/Factory','vcl/Factory'],function(require) {
	
	var Deferred = require("js/Deferred");
	
	function PropertyValue(uri) {
		this.uri = uri;
	}
	PropertyValue.prototype.resolve = function(factory, component, name) {
		var r = new Deferred();
		
		require([factory.resolveUri(this.uri)], 
			function(res) {
				r.callback(res);
			}, 
			function(err) {
				r.errback(err);
			}
		);
		
		return r;
	};

	function parse() {
	    
	    function mapArrFn(arr, fn) {
	        return arr.map(function(item) {
	            if(item instanceof Array) {
	                item = fn.apply(this, item);
	            }
	            return item;
	        });
	    }

		/**
		 *
		 */
		function $(inherits, name, properties, children) {
			if(typeof inherits === "string" && inherits.charAt(0) === "@") {
				return new PropertyValue(inherits.substring(1));
			}
			
			if(typeof name !== "string") {
				children = properties;
				properties = name;
				name = "";
			}
			if(properties instanceof Array) {
				children = properties;
				properties = {};
			}
			if(typeof inherits === "string") {
				inherits = inherits.split("#");
				if(inherits.length === 2) {
					name = inherits[1];
				}
				inherits = inherits[0];
				if(inherits.endsWith("<>")) {
					inherits = [inherits.split("<").shift()];
				}
			}
			return {
				inherits: inherits instanceof Array ? inherits : undefined,
				className: typeof inherits === "string" ? inherits : undefined,
				name: name,
				properties: properties || {},
				children: mapArrFn(children || [], arguments.callee)
			};
		}

		/**
		 *
		 */
		function $i(name, properties, children) {
			if(properties instanceof Array) {
				children = properties;
				properties = {};
			}
			return {
				name: name,
				properties: properties || {},
				children: mapArrFn(children || [], arguments.callee)
			};
		}

		/* jshint: eval */		
		var r = eval(arguments[0]);
		if(r instanceof Array) {
		    r = $.apply(this, r);
		}
		return r;
	}
	function impl(source, uri, normalize) {

		var Component = require("vcl/Component");
		var Factory = require("vcl/Factory");

		var tree = {
			root: [],
			classes: [],
			factories: [],
			keys: Component.getKeysByUri(uri)
		};

		function walk(node) {
		/**
		 * Dependencies are two-fold:
		 * 	- factoriesmp
		 * 	- classes
		 *
		 * @param node
		 *            The scope being walked
		 */
			// Are we inheriting prototypes?
			if(node.inherits instanceof Array) {
				// Test for $([])
				if(node.inherits.length === 0) {
					node.inherits = Component.getImplicitBasesByUri(uri);
				}

				// Test for syntax sugar: $([["{uri}"]])
				if(node.inherits[0] instanceof Array) {
					node.inherits = node.inherits[0];
					node.inherits.forEach(function(item, i) {
						var prefix = require("vcl/Factory").PREFIX_PROTOTYPES;
						if(item.indexOf(prefix) === 0) {
							alert(1);
						}
						node.inherits[i] = String.format("%s%s", prefix, item);
					});
				}

				node.inherits.forEach(function(item, i) {
					node.inherits[i] = item = normalize(uri, item);
					item = String.format("vcl/Factory!%s", item);
					if(tree.factories.indexOf(item) === -1) {
						tree.factories.push(item);
					}
				});
				
				/*- #777 */
				node.uri = node.inherits[0];
			}
			if(typeof node.className === "string") {
				node.className = normalize(uri, node.className);
				if(tree.classes.indexOf(node.className) === -1) {
					tree.classes.push(node.className);
				}
			}
			node.children.forEach(function(node) {
				walk(node);
			});
		}
		function adjust(root) {
			walk(root);
		}
		function devtoolsFriendly(uri) {
            if(uri.indexOf(Factory.PREFIX_PROTOTYPES) === 0) {
                uri = uri.substring(Factory.PREFIX_PROTOTYPES.length);
            }
            uri = uri.split("<");
			if(uri.length === 2) {
				uri[1] = uri[1].split("/").join(".");
				uri = uri.join("<");
			}
			return uri;
		}

		source = String.format("%s\n//# sourceURL=http://vcl-%s/%s.js", source,
		    uri.indexOf(Factory.PREFIX_PROTOTYPES) === 0 ? "prototypes" : "comps",
		    devtoolsFriendly(uri));
		tree.root = parse(source);
		tree.root && adjust(tree.root);
		return tree;
	}
	
	impl.PropertyValue = PropertyValue;
	
	return impl;
});
define('vcl/Factory',['require','js/defineClass','js/Class','js/Type','js/Method','./Component','js/Deferred','./Factory.parse','js'],function(require) {

	/*-	The letters refer to specific cases in ./Component.getImplicitBasesByUri

		[A] ui/entities/Query<Channel.by:a.by:b>.A.B
		[E]		ui/entities/Query<Channel.by:a.by:b>
		[G]			ui/entities/Query<Channel>
		[F]			ui/entities/Query<Channel.by:a>
		[G]				ui/entities/Query<Channel>
		[I]					ui/entities/Query
		[J]						prototypes/entities/Query
									!!!
		[F]			ui/entities/Query<Channel.by:b> --> ...
		[B]		ui/entities/Query<Channel.by:a.by:b>.A
		[E]			ui/entities/Query<Channel.by:a.by:b> --> ...
		[C]			ui/entities/Query<Channel.by:a>.A
		[F]				ui/entities/Query<Channel.by:a> --> ...
		[D]				ui/entities/Query<Channel>.A
		[G]					ui/entities/Query<Channel> --> ...
		[H]					ui/entities/Query.A
		[I]						ui/entities/Query --> ...
		[K]						prototypes/entities/Query.A
		[J]							prototypes/entities/Query --> ...
		[C]			ui/entities/Query<Channel.by:a>.A --> ...
		[B]		ui/entities/Query<Channel.by:a.by:b>.B
		[E]			ui/entities/Query<Channel.by:a.by:b> --> ...
		[C]			ui/entities/Query<Channel.by:a>.B --> ...
	
		[I]		ui/entities/Query
		[H]		ui/entities/Query.A
		[A]*	ui/entities/Query.A.B
		[G]		ui/entities/Query<Channel>
		[D]		ui/entities/Query<Channel>.A
		[A]*	ui/entities/Query<Channel>.A.B
		[F]		ui/entities/Query<Channel.by:a>
		[C]		ui/entities/Query<Channel.by:a>.A
		[A]*	ui/entities/Query<Channel.by:a>.A.B
		[E]		ui/entities/Query<Channel.by:a.by:b>
		[B]		ui/entities/Query<Channel.by:a.by:b>.A
		[A]		ui/entities/Query<Channel.by:a.by:b>.A.B

		[A]	ui/entities/Query.custom.lang:du --> ...
			ui/entities/Query<Channel.new>
	*/

	var Factory = require("js/defineClass");
	var Class = require("js/Class");
	var Type = require("js/Type");
	var Method = require("js/Method");
	var Component = require("./Component");
	var Deferred = require("js/Deferred");
	var parse = require("./Factory.parse");
	var js = require("js");
	var PropertyValue = parse.PropertyValue;

	var namespaces = js.mixIn(Factory.DEFAULT_NAMESPACES);

	function walk(node, f) {
		f(node);
		node.children && node.children.forEach(function(node) {
			walk(node, f);
		});
	}
	function getClassName(className) {
		if(className.indexOf(":") !== -1) {
			className = className.split(":");
			if(namespaces[className[0]] === undefined) {
				throw new Error(String.format("Unknown namespace %s (%s)",
						className[0], js.keys(namespaces)));
			}
			className = String.format("%s/%s",
					namespaces[className[0]], className[1]);
		}
		return className;
	}
	function getFactoryUri(name) {
		return String.format("vcl/Factory!%s", name);
	}

	return (Factory = Factory(require, {
		prototype: {
			_parentRequire: null,
			_uri: "",
			_root: null,
			_sourceUri: null,

			constructor: function(parentRequire, uri, sourceUri) {
				this._parentRequire = parentRequire;
				this._uri = uri;
				sourceUri && (this._sourceUri = sourceUri);
			},
			toString: function() {
                return String.format("%n#%s#%d", this.constructor, this._uri, 
                	this.hashCode());
			},
			getCtor: function() {
				return this._root.ctor;
			},
			resolveUri: function(uri) {
				if(uri.startsWith(".")) {
					uri = String.format("%s$/%s", Factory.makeUri(this._uri), 
						uri);
				}
				return "text!" + uri;
			},
			load: function(source, success, failure) {
                if(source.charAt(0) === "\"") {
    				/*- Parse require section */
                    var i = source.indexOf("\";");
                    if(i !== -1) {
                        deps = source.substring(1, i).replace(/\s/g, "");
                        deps = deps.split(",");
                        
                        /*- require all dependecies */
                        var me = this;
                        return this._parentRequire(deps, function() {
                            me.doLoad(source, success, failure);
                        }, failure);
                    }
                }
                return this.doLoad(source, success, failure);
			},
			doLoad: function(source, success, failure) {

				var me = this;
				var require = me._parentRequire;

				/*- Parse the source into a JS structure */
				var tree = parse(source, me._uri, js.normalize);
				/*- Make sure there is always something to require */
				tree.factories.push("module");
				tree.classes.push("module");
				
				/*- TODO deprecated temporary hack in order to require classes */
				if(tree.root.properties['@require'] !== undefined) {
					tree.classes.push.apply(tree.classes, 
						tree.root.properties['@require']);
					delete tree.root.properties['@require'];
					console.warn("@require will be deprecated - " + me._uri);
				}

				/*- namespace support */
				var ns = tree.root.properties['@namespaces'];
				if(typeof ns === "string") {
					ns = js.str2obj(ns);
				}
				if(ns !== undefined) {
					js.mixIn(namespaces, tree.root.properties['@namespaces']);
				}
				tree.classes.forEach(function(className, index) {
					tree.classes[index] = getClassName(className);
				});

				me._root = tree.root;
				/*- Load all the factories that are need to constructor the 
					component associated with the Factory */
				Factory.require(tree.factories, function() {
					/*- Make sure all the needed classes are loaded */
					require(tree.classes, function() {
						var propVals = [];
						/*- Walk every node set it's constructor and gather PropertyValue instances */
						
						// TODO Quick and dirty, needs refactoring, accessing privates
						var classes = Component.getKeysByUri(me._uri).classes;
						if(classes.indexOf("scaffold") !== -1) {
							var props = tree.root.properties, f;
							if(props.onLoad && !props['@scaffold']) {
								console.log(me._uri, "DEPRECATED onLoad in .scaffold resource");
								props['@scaffold'] = props.onLoad;
								delete props.onLoad;
							}
						}
						
						walk(tree.root, function(node) {
							if(typeof node.className === "string") {
								node.ctor = require(getClassName(node.className));
							} else if(node.inherits instanceof Array) {
								node.factories = [];
								for(var i = 0; i < node.inherits.length; ++i) {
									var factory = require(getFactoryUri(node.inherits[i]));
									node.factories.push(factory);
									if(node.ctor === undefined) {
										node.ctor = factory.getCtor();
									}
								}
							}
							for(var k in node.properties) {
								if(node.properties[k] instanceof PropertyValue) {
									propVals.push([node, k, node.properties[k]]);
								}
							}
						});
						
						if(propVals.length > 0) {
							me.handlePropertyValues(propVals)
								.addCallback(success);
						} else {
							success();
						}
					}, failure);
				}, failure);
			},
			newInstance: function(owner, uri, options) {
			/*- Instantiates the component based upon the structure parsed */
                var component;

				if(this._root.ctor === undefined) {
					/* Bad news */
					throw new Error(String.format("This component class does " +
						"not know its constructor (%s)", this._uri));
				}

				if(uri !== undefined) {
                    if(uri.charAt(0) === "#") {
                    	console.debug("This is not used anymore right?");
                        uri = this._uri + uri;
                    }
				} else {
                    uri = this._uri;
				}

				// FIXME find a more elegant manner
				var this_uri = this._uri;
				this._uri = uri;

				try {
					var fixUps = [];
					var applied = [];

                    component = new this._root.ctor();//(owner, this._uri, true);

					/*- TODO/FEATURE Do this in the end and support nested 
						components, so that only 1 @override key/value-pair
						is needed per source file */
    				if(this._root.properties.hasOwnProperty("@override")) {
    					component.override(this._root.properties['@override']);
    					delete this._root.properties['@override'];
    				}

                    component.beginLoading();
                    component.setUri(this._uri);
                    component.setName(this._root.name);
                    component.setIsRoot(true);
                    component.setOwner(owner || null);

					this.apply(component, component, this._root, applied, fixUps);

					fixUps.forEach(function(ref, i) {
						var v;
						if(ref.value && (ref.value.charAt(0) === "#")) {
							v = component.qs(ref.value);
						} else {
							v = (ref.value && ref.component.scope()[ref.value]);
						}
						if(v !== null) {
							if(!(v instanceof Component)) {
								console.warn(String.format("Component %s referenced by %n.%s does not exist",
								 		ref.value, ref.component, ref.property.getName()));
								 return;
							}
							if(!(v instanceof ref.property._type)) {
								throw new Error(String.format("Property %n.%s should reference a %s (not %n)",
										ref.component, ref.property.getName(), ref.property._type, v));
							}
						}
						ref.property.set(ref.component, v);
					});

				} finally {
					component.endLoading();
					this._uri = this_uri;
				}

                // FIXME #173 Ugly construction
                if(options && typeof options.loaded === "function") {
                    options.loaded(component);
                } else {
				    component.loaded();
                }
				return component;
			},
			apply: function(root, component, node, applied, fixUps) {
				/**
				 * Applies a node definition on an (readily) constructed component.
				 * This method is to be called automatically via newInstance and
				 * apply itself.
				 *
				 * @param root The root component being constructed/factoried
				 * @param component The component to apply the node on
				 * @param node Optional, defaults to _root. Identifies the name,
				 *            properties and children of the component
				 * @param applied Array, keeps track of which factories have already
				 *            been applied on the component (any factory can and
				 *            should only be applied once).
				 * @param fixUps
				 */
				var me = this;
				node = node || this._root;
				applied.push(this);
				
				if(node.factories instanceof Array) {
					// This node inherits other component(s)
					node.factories.forEach(function(factory) {
						// A component can be inherited only once...
						if(applied.indexOf(factory) === -1) {
							factory.apply(component, component, null, applied, fixUps);
							me.factoryApplied(factory, root, component, node, applied, fixUps);
						}
					});
				}
				
				this.setProperties(component, node, fixUps);

				var parent = component;
				node.children.forEach(function(node) {
					var component;
					if(node.ctor !== undefined) {
						component = new (node.ctor)();
						component.setOwner(root);
						component.setParentComponent(parent);
						component.setName(node.name);
						component.setUri(node.uri || me._uri);
					} else {
						// First check the current scope (parent)
						if((component = parent.getScope()[node.name]) === undefined) {
							component = root.findComponent(node.name);
						}
						if(component === null) {
							console.warn(String.format("Inherited component %s not found (%s)", node.name, me._uri));
							return;
						}
					}

					me.apply(root, component, node, [], fixUps);
				});
			},
			factoryApplied: function(factory, root, component, node, applied, fixUps) {
				/* Callback for when a factory is applied */
				
				// TODO Hook scaffold. Quick and dirty, needs refactoring, accessing privates
				var classes = Component.getKeysByUri(factory._uri).classes;
				if(classes.indexOf("scaffold") !== -1) {
	
					var props = factory._root.properties, f;
					if(typeof (f = props['@scaffold']) === "function") {
						console.log("factoryApplied", "@", js.nameOf(component), component._uri, ">>>", js.nameOf(factory));
						// console.debug("scaffolding #" + component.hashCode(), [component._uri, factory._uri]);
						try {
							f.apply(component, []);
						} catch(e) {
							console.error("Error while scaffolding "+ js.nameOf(component), e);
						}
					}
				}
				
			},
			handlePropertyValues: function(propVals) {
				var r = new Deferred(), me = this, count = propVals.length;
				
				function done() {
					if(--count === 0) {
						r.callback();
					}
				}
				
				var modules = propVals.map(function(propValue) {
					var node = propValue[0], name = propValue[1];
					propValue = propValue.pop();
					
					propValue.resolve(me, node, name)
						.addCallback(function(value) {
							node.properties[name] = value;
							done();
						});
				});
				
				return r;
			},
			setProperties: function(component, node, fixUps) {
				component['@properties'] = js.extend(component['@properties'] || {}, node.properties);
				//component['@properties']['@uri'] = this._uri;
				component['@factory'] = this;

				var properties = component.defineProperties(), property;
				for( var k in node.properties) {
					if(k === "@scaffold") continue;
					
					if(node.properties[k] instanceof parse.PropertyValue) {
						console.log(">>>", node.properties[k]);
						continue;
					}
					
					if((property = properties[k]) === undefined) {
						console.warn(String.format("Property %n.%s does not exist - %n\nuri: %s",
								component.constructor, k, component, component._uri));
					} else {
						var value = node.properties[k];
						this.setPropertyValue(property, component, value, fixUps);
					}
				}
			},
			setPropertyValue: function(property, component, value, fixUps) {
			/**
			 *
			 * @param property
			 * @param component
			 * @param value
			 * @param fixUps
			 */
				if(property.isReference()) {
					fixUps.push({
						property: property,
						component: component,
						value: value
					});
				} else {
					if(property._type === Type.EVENT) {
						if(typeof value === "string") {
							value = eval(String.format("({f:%s})", value)).f
						}
						if(typeof value === "function") {
							Method.setName(value, String.format("%n.%s", 
								component, property._name));
							Method.setInherited(value, property.get(component, 
								value));
							value = Method.trace(value);
						} else {
							value = undefined;
						}
					}
					if(value !== undefined) {
						property.set(component, value);
					} else {
						console.warn(String.format("Property %s of %s not set to undefined", property, component), component);
					}
				}
			}
		},
		statics: {
			POSTFIX_SPECIALIZED: "$/",
			PREFIX_PROTOTYPES: "vcl/prototypes/", //TODO vcl-prototypes/
			PREFIX_APP: "vcl-comps/",
			DEFAULT_NAMESPACES: {
//				"vcl": "cavalion.org/vcl"
			},

			load: function(name, parentRequire, load, config) {
			/**
			 * @overrides http://requirejs.org/docs/plugins.html#apiload
			 */
				var sourceUri = Factory.makeTextUri(name);

				function f(source) {
					var factory = new Factory(parentRequire, name, sourceUri);
					factory.load(source, function() {
						load(factory);
					});
				}

				parentRequire([sourceUri], function(source) {
					f(source);
				}, function(err) {
					// Source not found, assume it...
					var source = Component.getImplicitSourceByUri(name);
					if(source === "$([\"\"]);") {
						source = "$(\"vcl/Component\", \"dead-end\");";
					}
					//console.log("304", name, "-->", source);
					f(source);
				});
			},
			resolveUri: function(uri) {
				if(uri.substring(uri.length - 2, uri.length) === "<>") {
/**/				console.warn(uri);
					uri = uri.split("!");
					if(uri.length === 1) {
						uri = String.format("%s%s", Factory.PREFIX_PROTOTYPES, 
							uri[0].substring(0, uri[0].length - 2));
					} else {
						uri = String.format("%s!%s%s", uri[0], 
							Factory.PREFIX_PROTOTYPES, uri[1].split("<")[0]);
					}
				} else {
					var keys = Component.getKeysByUri(uri);
					if(keys.template && keys.specializer) {
						uri = String.format("%s%s%s", keys.template, 
							Factory.POSTFIX_SPECIALIZED, keys.specializer);
						if(keys.classes.length) {
							uri += ("." + keys.classes.join("."));
						}
					} else if(keys.classes.length) {
						uri = String.format("%s%s%s.%s", keys.namespace, 
							keys.namespace ? "/" : "", keys.name, 
							keys.classes.join("."));
					} else {
						//throw new Error("Did not expect this " + uri);
					}
				}
			    if(uri.indexOf(Factory.PREFIX_PROTOTYPES) !== 0) {
			        uri = Factory.PREFIX_APP + uri;
			    }
				return uri;
			},
			makeUri: function(uri) {
				/*- DEPRECATED/RENAMED resolveUri */
				return this.resolveUri(uri);
			},
			makeTextUri: function(uri, suffix) {
				uri = "text!" + this.makeUri(uri);
				suffix = arguments.length === 2 ? suffix : ".js";
				return !uri.endsWith(suffix) ? uri + suffix : uri;
			},
			unreq: function(name) {
			    var factory;
			    try {
			        factory = require(String.format("vcl/Factory!%s", name));
			    } catch(e) {
			        return;
			    }

				requirejs.undef(String.format("vcl/Factory!%s", factory._uri));
				requirejs.undef(Factory.makeTextUri(factory._uri));

			    var factories = factory._root.inherits;
			    factories && factories.forEach(function(name) {
			        Factory.unreq(name);
			    });
			},
			require: function(name, callback, failback) {
				var ocallback = callback;
				if(ocallback && typeof name === "string") {
					callback = function() {
						//console.log("200 " + name);
						return ocallback.apply(this, arguments);
					};
				}

				if(typeof name === "string") {
//					console.log("+" + String.format("cavalion.org/vcl/Factory!%s", name));
					return require([String.format("vcl/Factory!%s", name)], 
						callback, failback);
				}

				var count = name.length;
				var thisObj = this;

				for(var i = 0; i < name.length; ++i) {
					(function(i){
						require([name[i]], function(module) {
							name[i] = module;
							if(--count === 0) {
								callback.apply(thisObj, name);
							}
						}, function(err) {
							name[i] = err;
							if(--count === 0) {
								callback.apply(thisObj, name);
							}
						});
					}(i));
				}
			},
			getFactoryUri: getFactoryUri
		}

	}));
});
define('cavalion.org/util/net/Url',["require", "js/defineClass"], function(require, Url) {
	return (Url = Url(require, {
		prototype: {
			_strUrl: "",
			_query: null,
			_params: [], // careful prototype value
			_names: [], // careful prototype value
			_hash: null,
			constructor: function(strUrl) {
				if(strUrl === undefined) {
					strUrl = window.location.toString();
				}

				this._strUrl = (strUrl = strUrl.split("#"))[0];
				if(strUrl.length > 1) {
					this._hash = strUrl[1];
				}
				if(this._strUrl.indexOf("?") !== -1) {
					this._query = this._strUrl.substring(this._strUrl.indexOf("?") + 1);
					this.parseParams();
				}
			},
			parseParams: function() {
				var query = this._query.split("&");
				var part;
				var name, value;

				this._params = [];
				this._names = [];

				for(var i = 0, l = query.length; i < l; ++i) {
					part = query[i].split("=");
					if(part.length === 1) {
						name = "";
						value = window.unescape(part[0]);
					} else {
						name = window.unescape(part[0]);
						value = window.unescape(part[1]);
					}
					this._params.push({
						name: name,
						value: value
					});
					if(this._names.indexOf(name) === -1) {
						this._names.push(name);
					}
				}
			},
			getAuthority: function() {
				if(this._authority === undefined) {
					this._authority = this._strUrl.split("/");
					this._authority.shift();
					while(this._authority[0] !== undefined && this._authority[0].length === 0) {
						this._authority.shift();
					}
					this._authority = this._authority[0];
				}
				return this._authority;
			},
			getProtocol: function() {
				if(this._protocol === undefined) {
					this._protocol = this._strUrl.split(":")[0];
				}
				return this._protocol;
			},
			getPort: function() {
				return parseInt(this.getAuthority().split(":")[1] || 80, 10);
			},
			getHost: function() {
				return this.getAuthority().split(":")[0];
			},
			getPath: function() {
				if(this._path === undefined) {
					this._path = this._strUrl.split("/");
					this._path.shift();
					while(this._path[0] !== undefined && this._path[0].length === 0) {
						this._path.shift();
					}
					this._path.shift();
					this._path = this._path.join("/");
				}
				return this._path;
			},
			getQuery: function() {
				return this._query;
			},
			getFileName: function() {
			},
			getRef: function() {
				return this.getHash();
			},
			getHash: function() {
				return this._hash;
			},
			getParamValue: function(name) {
				if(this._params !== null) {
					for(var i = 0, l = this._params.length; i < l; ++i) {
						if(this._params[i].name === name) {
							return this._params[i].value;
						}
					}
				}
			},
			getParamValues: function(name) {
				var r = [];
				if(this._params !== null) {
					for(var i = 0, l = this._params.length; i < l; ++i) {
						if(name === undefined || this._params[i].name === name) {
							r.push(this._params[i].value);
						}
					}
				}
				return r;
			},
			getParamNames: function() {
				return this._names;
			},
			hasParam: function(name) {
				return this._names.indexOf(name) !== -1;
			}
		},
		statics: {
			toUrlParamValueFactories: {},
			obj2qs: function (obj) {
			/**
			 * Converts the keys and values of an object to a query string which can be used in a url
			 *
			 * @param obj
			 * @returns
			 */
			    var str = [];
			    for (var k in obj) {
			    	var v = obj[k];

//			    	if(v instanceof js.lang.Object) {
//			    		v = this.toUrlParamValue(v, v.getClass());
//			    	}

			        if (v !== undefined) {
			            str.push(String.format("%s=%s",
			            		window.escape(k).replace(/\+/g, "%2B"),
			            		("" + window.escape(v)).replace(/\+/g, "%2B")));
			        }
			    }
			    return str.join("&");
			},
			registerToUrlParamValueFactory: function(cls, f) {
				if(Class.isConstructor(cls)) {
					cls = Class.byConstructor(cls);
				}
				this.toUrlParamValueFactories[cls.getName()] = f;
			},
			toUrlParamValue: function(object, cls) {
			/**
			 *
			 * @param object
			 */
				var f = this.toUrlParamValueFactories[cls.getName()], spr;
				if(f !== undefined) {
					return f(object);
				} else if((spr = cls.getSuperClass()) !== undefined) {
					return this.toUrlParamValue(object, spr);
				}
				return object;
			}
		}
	}));
});
define('cavalion.org/console/node/vcl/Component',['require','js/defineClass','vcl/Component','../Object','cavalion.org/console/Node','js'],function(require) {

	var ComponentNode = require("js/defineClass");
	var Component = require("vcl/Component");
	var ObjectNode = require("../Object");
	var Node = require("cavalion.org/console/Node");
	var js = require("js");

	/*- FIXME Introduce some registration infra at Node */
	js.override(Node, "create", function(value, key, NodeClass) {
		if(NodeClass === undefined && value instanceof Component) {
			/*- Yee, use the specific Component impl */
			return new ComponentNode(value, key);
		}
		return js.inherited(this, arguments);
	});

	return (ComponentNode = ComponentNode(require, {

		inherits: ObjectNode,

		prototype: {
			_classes: ["object"],

			/**
			 * @overrides ../Node.prototype.initializeValue
			 */
			initializeValue: function(node) {
				// node.innerHTML = String.format("%H<span class='uri'> - %H</span>",
				// 		js.nameOf(this._value), this._value.getUri());
				node.innerHTML = String.format(
						"%H<span class='uri'> - %H</span>",
						js.nameOf(this._value), 
						this._value._uri);
			}
		}
	}));
});
require.config({
	paths: {
		"bower_components": "/shared/vcl/bower_components", // nogo!
		"node_modules": "/shared/vcl/node_modules", // nogo!!
		
		"jslib": "/shared/vcl/lib",
		"js": "/shared/vcl/lib/cavalion.org/js",
		"cavalion.org": "/shared/vcl/lib/cavalion.org",
		"persistence": "/shared/vcl/lib/cavalion.org/persistence2",
		"entities": "/shared/vcl/lib/cavalion.org/entities",
		"features": "/shared/vcl/lib/cavalion.org/features",
		"vcl": "/shared/vcl/lib/cavalion.org/vcl",
		"jquery": "/shared/vcl/lib/jquery.com/jquery-2.1.0.min",
        "util": "/shared/vcl/lib/cavalion.org/util",
        "es5-shim": "../src/node_modules/es5-shim/es5-shim.min",
        "es6-shim": "../src/node_modules/es6-shim/es6-shim.min",
        "es7-shim": "../src/node_modules/es7-shim/dist/es7-shim.min",
        "array.prototype.find": "../src/node_modules/array.prototype.find/shim"
 	}, 
	map: {
		'*': {
			"ace": "bower_components/ace/lib/ace",

			"Framework7": "bower_components/Framework7",
			"Framework7.plugins": "bower_components/Framework7.plugins",
			"linqjs": "bower_components/linqjs/linq",
	        "font-awesome": "bower_components/font-awesome",
	        "Object.observe": "bower_components/object.observe/dist/object-observe.js",
	        "markdown": "bower_components/markdown",
	        
			"CssSelectorParser": "node_modules/css-selector-parser/lib/CssSelectorParser",
		
			"chartjs.org": "jslib/chartjs.org",
			"dygraphs.com": "jslib/dygraphs.com/1.0.1",
			
			// "leaflet": "jslib/leafletjs.com/leaflet-0.7.2",
			// "leaflet.markercluster": "bower_components/leaflet.markercluster",
			"leaflet": "jslib/leafletjs.com/leaflet-1.0.1",
			"leaflet.measure": "bower_components/leaflet.measure",
			"leaflet.awesome-markers": "bower_components/leaflet.awesome-markers",
			"leaflet.markercluster": "node_modules/leaflet.markercluster",
			"leaflet.wmts": "jslib/leafletjs.com/leaflet.wmts",
			
		    "less": "bower_components/less/dist/less",
		    
			"epsg": "jslib/proj4js.org/epsg",
			"proj4": "bower_components/proj4/dist/proj4-src",
			"proj4leaflet": "jslib/proj4js.org/proj4leaflet-1.0",
			
			"ol": "jslib/openlayers.org/ol-boot",
			
			/*- bangers! */
			"text": "jslib/text",
			"stylesheet": "jslib/stylesheet",
			"relscript": "jslib/relscript"
		}
	}
});

define('main',['require','cavalion.org/console/Printer','es5-shim','es6-shim','es7-shim','vcl/Component','vcl/Factory','cavalion.org/util/net/Url','cavalion.org/console/node/vcl/Component'],function(require) {
	/** main main **/
	require("cavalion.org/console/Printer");
	require("es5-shim");
	require("es6-shim");
	require("es7-shim");

	var Component = require("vcl/Component");
	var Factory = require("vcl/Factory");
	var Url = require("cavalion.org/util/net/Url");
	var ComponentNode = require("cavalion.org/console/node/vcl/Component");

	var app, url = new Url();
	
	if((app = url.getParamValue("app"))) {
		if(app && app.indexOf("/") === -1) {
		    app += "/App.v1.desktop";
		} else if(!app) {
	        app = "App.v1.desktop";
	    }
	} else {
		app = url.getParamValues().filter(function(s) { 
			return s !== "debug"; });
		app += "/App";
	}

	Factory.require(app, function(factory) {
		factory.newInstance();
	});
});

/*

        App/client.formUri -> devtools/Main
            Main.workspaces-tabs - workspaces -> devtools/Workspace

        devtools/Main:

        devtools/Workspace:
            sidebar -- [devtools/Sidebar]
                navigator -- [devtools/Navigator]
                    tree -- vcl/ui/Tree
                inspector -- [devtools/Inspector]
                search --- [devtools/Search]
            editors -- [devtools/Editors]
                tabs -- vcl/ui/Tabs
                host -- vcl/ui/Panel
                editor0..n -- [devtools/Editor<{ext}>]


*/
;
/*
 *  Based on code from:
 *
 * XRegExp 1.5.0
 * (c) 2007-2010 Steven Levithan
 * MIT License
 * <http://xregexp.com>
 * Provides an augmented, extensible, cross-browser implementation of regular expressions,
 * including support for additional syntax, flags, and methods
 */
 
define('bower_components/ace/lib/ace/lib/regexp',['require','exports','module'],function(require, exports, module) {
"use strict";

    //---------------------------------
    //  Private variables
    //---------------------------------

    var real = {
            exec: RegExp.prototype.exec,
            test: RegExp.prototype.test,
            match: String.prototype.match,
            replace: String.prototype.replace,
            split: String.prototype.split
        },
        compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined, // check `exec` handling of nonparticipating capturing groups
        compliantLastIndexIncrement = function () {
            var x = /^/g;
            real.test.call(x, "");
            return !x.lastIndex;
        }();

    if (compliantLastIndexIncrement && compliantExecNpcg)
        return;

    //---------------------------------
    //  Overriden native methods
    //---------------------------------

    // Adds named capture support (with backreferences returned as `result.name`), and fixes two
    // cross-browser issues per ES3:
    // - Captured values for nonparticipating capturing groups should be returned as `undefined`,
    //   rather than the empty string.
    // - `lastIndex` should not be incremented after zero-length matches.
    RegExp.prototype.exec = function (str) {
        var match = real.exec.apply(this, arguments),
            name, r2;
        if ( typeof(str) == 'string' && match) {
            // Fix browsers whose `exec` methods don't consistently return `undefined` for
            // nonparticipating capturing groups
            if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
                // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed
                // matching due to characters outside the match
                real.replace.call(str.slice(match.index), r2, function () {
                    for (var i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined)
                            match[i] = undefined;
                    }
                });
            }
            // Attach named capture properties
            if (this._xregexp && this._xregexp.captureNames) {
                for (var i = 1; i < match.length; i++) {
                    name = this._xregexp.captureNames[i - 1];
                    if (name)
                       match[name] = match[i];
                }
            }
            // Fix browsers that increment `lastIndex` after zero-length matches
            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
        }
        return match;
    };

    // Don't override `test` if it won't change anything
    if (!compliantLastIndexIncrement) {
        // Fix browser bug in native method
        RegExp.prototype.test = function (str) {
            // Use the native `exec` to skip some processing overhead, even though the overriden
            // `exec` would take care of the `lastIndex` fix
            var match = real.exec.call(this, str);
            // Fix browsers that increment `lastIndex` after zero-length matches
            if (match && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
            return !!match;
        };
    }

    //---------------------------------
    //  Private helper functions
    //---------------------------------

    function getNativeFlags (regex) {
        return (regex.global     ? "g" : "") +
               (regex.ignoreCase ? "i" : "") +
               (regex.multiline  ? "m" : "") +
               (regex.extended   ? "x" : "") + // Proposed for ES4; included in AS3
               (regex.sticky     ? "y" : "");
    }

    function indexOf (array, item, from) {
        if (Array.prototype.indexOf) // Use the native array method if available
            return array.indexOf(item, from);
        for (var i = from || 0; i < array.length; i++) {
            if (array[i] === item)
                return i;
        }
        return -1;
    }

});

// https://github.com/kriskowal/es5-shim
// Copyright 2009-2012 by contributors, MIT License

define('bower_components/ace/lib/ace/lib/es5-shim',['require','exports','module'],function(require, exports, module) {

/*
 * Brings an environment as close to ECMAScript 5 compliance
 * as is possible with the facilities of erstwhile engines.
 *
 * Annotated ES5: http://es5.github.com/ (specific links below)
 * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
 * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
 */

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (typeof target != "function") {
            throw new TypeError("Function.prototype.bind called on incompatible " + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var bound = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(slice.call(arguments))
                );

            }

        };
        if(target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }
        // XXX bound.length is never writable, so don't even try
        //
        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.
        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    };
}

// Shortcut to an often accessed properties, in order to avoid multiple
// dereference that costs universally.
// _Please note: Shortcuts are defined after `Function.prototype.bind` as we
// us it in defining shortcuts.
var call = Function.prototype.call;
var prototypeOfArray = Array.prototype;
var prototypeOfObject = Object.prototype;
var slice = prototypeOfArray.slice;
// Having a toString local variable name breaks in Opera so use _toString.
var _toString = call.bind(prototypeOfObject.toString);
var owns = call.bind(prototypeOfObject.hasOwnProperty);

// If JS engine supports accessors creating shortcuts.
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors;
if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
}

//
// Array
// =====
//

// ES5 15.4.4.12
// http://es5.github.com/#x15.4.4.12
// Default value for second param
// [bugfix, ielt9, old browsers]
// IE < 9 bug: [1,2].splice(0).join("") == "" but should be "12"
if ([1,2].splice(0).length != 2) {
    if(function() { // test IE < 9 to splice bug - see issue #138
        function makeArray(l) {
            var a = new Array(l+2);
            a[0] = a[1] = 0;
            return a;
        }
        var array = [], lengthBefore;
        
        array.splice.apply(array, makeArray(20));
        array.splice.apply(array, makeArray(26));

        lengthBefore = array.length; //46
        array.splice(5, 0, "XXX"); // add one element

        lengthBefore + 1 == array.length

        if (lengthBefore + 1 == array.length) {
            return true;// has right splice implementation without bugs
        }
        // else {
        // IE8 bug
        // }
    }()) {//IE 6/7
        var array_splice = Array.prototype.splice;
        Array.prototype.splice = function(start, deleteCount) {
            if (!arguments.length) {
                return [];
            } else {
                return array_splice.apply(this, [
                    start === void 0 ? 0 : start,
                    deleteCount === void 0 ? (this.length - start) : deleteCount
                ].concat(slice.call(arguments, 2)))
            }
        };
    } else {//IE8
        // taken from http://docs.sencha.com/ext-js/4-1/source/Array2.html
        Array.prototype.splice = function(pos, removeCount){
            var length = this.length;
            if (pos > 0) {
                if (pos > length)
                    pos = length;
            } else if (pos == void 0) {
                pos = 0;
            } else if (pos < 0) {
                pos = Math.max(length + pos, 0);
            }

            if (!(pos+removeCount < length))
                removeCount = length - pos;

            var removed = this.slice(pos, pos+removeCount);
            var insert = slice.call(arguments, 2);
            var add = insert.length;            

            // we try to use Array.push when we can for efficiency...
            if (pos === length) {
                if (add) {
                    this.push.apply(this, insert);
                }
            } else {
                var remove = Math.min(removeCount, length - pos);
                var tailOldPos = pos + remove;
                var tailNewPos = tailOldPos + add - remove;
                var tailCount = length - tailOldPos;
                var lengthAfterRemove = length - remove;

                if (tailNewPos < tailOldPos) { // case A
                    for (var i = 0; i < tailCount; ++i) {
                        this[tailNewPos+i] = this[tailOldPos+i];
                    }
                } else if (tailNewPos > tailOldPos) { // case B
                    for (i = tailCount; i--; ) {
                        this[tailNewPos+i] = this[tailOldPos+i];
                    }
                } // else, add == remove (nothing to do)

                if (add && pos === lengthAfterRemove) {
                    this.length = lengthAfterRemove; // truncate array
                    this.push.apply(this, insert);
                } else {
                    this.length = lengthAfterRemove + add; // reserves space
                    for (i = 0; i < add; ++i) {
                        this[pos+i] = insert[i];
                    }
                }
            }
            return removed;
        };
    }
}

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
if (!Array.isArray) {
    Array.isArray = function isArray(obj) {
        return _toString(obj) == "[object Array]";
    };
}

// The IsCallable() check in the Array functions
// has been replaced with a strict check on the
// internal class of the object to trap cases where
// the provided function was actually a regular
// expression literal, which in V8 and
// JavaScriptCore is a typeof "function".  Only in
// V8 are regular expression literals permitted as
// reduce parameters, so it is desirable in the
// general case for the shim to match the more
// strict and common behavior of rejecting regular
// expressions.

// ES5 15.4.4.18
// http://es5.github.com/#x15.4.4.18
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach

// Check failure of by-index access of string characters (IE < 9)
// and failure of `0 in boxedString` (Rhino)
var boxedString = Object("a"),
    splitString = boxedString[0] != "a" || !(0 in boxedString);

if (!Array.prototype.forEach) {
    Array.prototype.forEach = function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    };
}

// ES5 15.4.4.19
// http://es5.github.com/#x15.4.4.19
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
if (!Array.prototype.map) {
    Array.prototype.map = function map(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            result = Array(length),
            thisp = arguments[1];

        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self)
                result[i] = fun.call(thisp, self[i], i, object);
        }
        return result;
    };
}

// ES5 15.4.4.20
// http://es5.github.com/#x15.4.4.20
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
if (!Array.prototype.filter) {
    Array.prototype.filter = function filter(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                    object,
            length = self.length >>> 0,
            result = [],
            value,
            thisp = arguments[1];

        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self) {
                value = self[i];
                if (fun.call(thisp, value, i, object)) {
                    result.push(value);
                }
            }
        }
        return result;
    };
}

// ES5 15.4.4.16
// http://es5.github.com/#x15.4.4.16
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
if (!Array.prototype.every) {
    Array.prototype.every = function every(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            thisp = arguments[1];

        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self && !fun.call(thisp, self[i], i, object)) {
                return false;
            }
        }
        return true;
    };
}

// ES5 15.4.4.17
// http://es5.github.com/#x15.4.4.17
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
if (!Array.prototype.some) {
    Array.prototype.some = function some(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            thisp = arguments[1];

        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, object)) {
                return true;
            }
        }
        return false;
    };
}

// ES5 15.4.4.21
// http://es5.github.com/#x15.4.4.21
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
if (!Array.prototype.reduce) {
    Array.prototype.reduce = function reduce(fun /*, initial*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        // no value to return if no initial value and an empty array
        if (!length && arguments.length == 1) {
            throw new TypeError("reduce of empty array with no initial value");
        }

        var i = 0;
        var result;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i++];
                    break;
                }

                // if array contains no values, no initial value to return
                if (++i >= length) {
                    throw new TypeError("reduce of empty array with no initial value");
                }
            } while (true);
        }

        for (; i < length; i++) {
            if (i in self) {
                result = fun.call(void 0, result, self[i], i, object);
            }
        }

        return result;
    };
}

// ES5 15.4.4.22
// http://es5.github.com/#x15.4.4.22
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
if (!Array.prototype.reduceRight) {
    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        // no value to return if no initial value, empty array
        if (!length && arguments.length == 1) {
            throw new TypeError("reduceRight of empty array with no initial value");
        }

        var result, i = length - 1;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i--];
                    break;
                }

                // if array contains no values, no initial value to return
                if (--i < 0) {
                    throw new TypeError("reduceRight of empty array with no initial value");
                }
            } while (true);
        }

        do {
            if (i in this) {
                result = fun.call(void 0, result, self[i], i, object);
            }
        } while (i--);

        return result;
    };
}

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    };
}

// ES5 15.4.4.15
// http://es5.github.com/#x15.4.4.15
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
        var self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }
        var i = length - 1;
        if (arguments.length > 1) {
            i = Math.min(i, toInteger(arguments[1]));
        }
        // handle negative indices
        i = i >= 0 ? i : length - Math.abs(i);
        for (; i >= 0; i--) {
            if (i in self && sought === self[i]) {
                return i;
            }
        }
        return -1;
    };
}

//
// Object
// ======
//

// ES5 15.2.3.2
// http://es5.github.com/#x15.2.3.2
if (!Object.getPrototypeOf) {
    // https://github.com/kriskowal/es5-shim/issues#issue/2
    // http://ejohn.org/blog/objectgetprototypeof/
    // recommended by fschaefer on github
    Object.getPrototypeOf = function getPrototypeOf(object) {
        return object.__proto__ || (
            object.constructor ?
            object.constructor.prototype :
            prototypeOfObject
        );
    };
}

// ES5 15.2.3.3
// http://es5.github.com/#x15.2.3.3
if (!Object.getOwnPropertyDescriptor) {
    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +
                         "non-object: ";
    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT + object);
        // If object does not owns property return undefined immediately.
        if (!owns(object, property))
            return;

        var descriptor, getter, setter;

        // If object has a property then it's for sure both `enumerable` and
        // `configurable`.
        descriptor =  { enumerable: true, configurable: true };

        // If JS engine supports accessor properties then property may be a
        // getter or setter.
        if (supportsAccessors) {
            // Unfortunately `__lookupGetter__` will return a getter even
            // if object has own non getter property along with a same named
            // inherited getter. To avoid misbehavior we temporary remove
            // `__proto__` so that `__lookupGetter__` will return getter only
            // if it's owned by an object.
            var prototype = object.__proto__;
            object.__proto__ = prototypeOfObject;

            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);

            // Once we have getter and setter we can put values back.
            object.__proto__ = prototype;

            if (getter || setter) {
                if (getter) descriptor.get = getter;
                if (setter) descriptor.set = setter;

                // If it was accessor property we're done and return here
                // in order to avoid adding `value` to the descriptor.
                return descriptor;
            }
        }

        // If we got this far we know that object has an own property that is
        // not an accessor so we set it as a value and return descriptor.
        descriptor.value = object[property];
        return descriptor;
    };
}

// ES5 15.2.3.4
// http://es5.github.com/#x15.2.3.4
if (!Object.getOwnPropertyNames) {
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
        return Object.keys(object);
    };
}

// ES5 15.2.3.5
// http://es5.github.com/#x15.2.3.5
if (!Object.create) {
    var createEmpty;
    if (Object.prototype.__proto__ === null) {
        createEmpty = function () {
            return { "__proto__": null };
        };
    } else {
        // In old IE __proto__ can't be used to manually set `null`
        createEmpty = function () {
            var empty = {};
            for (var i in empty)
                empty[i] = null;
            empty.constructor =
            empty.hasOwnProperty =
            empty.propertyIsEnumerable =
            empty.isPrototypeOf =
            empty.toLocaleString =
            empty.toString =
            empty.valueOf =
            empty.__proto__ = null;
            return empty;
        }
    }

    Object.create = function create(prototype, properties) {
        var object;
        if (prototype === null) {
            object = createEmpty();
        } else {
            if (typeof prototype != "object")
                throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
            var Type = function () {};
            Type.prototype = prototype;
            object = new Type();
            // IE has no built-in implementation of `Object.getPrototypeOf`
            // neither `__proto__`, but this manually setting `__proto__` will
            // guarantee that `Object.getPrototypeOf` will work as expected with
            // objects created using `Object.create`
            object.__proto__ = prototype;
        }
        if (properties !== void 0)
            Object.defineProperties(object, properties);
        return object;
    };
}

// ES5 15.2.3.6
// http://es5.github.com/#x15.2.3.6

// Patch for WebKit and IE8 standard mode
// Designed by hax <hax.github.com>
// related issue: https://github.com/kriskowal/es5-shim/issues#issue/5
// IE8 Reference:
//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
// WebKit Bugs:
//     https://bugs.webkit.org/show_bug.cgi?id=36423

function doesDefinePropertyWork(object) {
    try {
        Object.defineProperty(object, "sentinel", {});
        return "sentinel" in object;
    } catch (exception) {
        // returns falsy
    }
}

// check whether defineProperty works if it's given. Otherwise,
// shim partially.
if (Object.defineProperty) {
    var definePropertyWorksOnObject = doesDefinePropertyWork({});
    var definePropertyWorksOnDom = typeof document == "undefined" ||
        doesDefinePropertyWork(document.createElement("div"));
    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
        var definePropertyFallback = Object.defineProperty;
    }
}

if (!Object.defineProperty || definePropertyFallback) {
    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: "
    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
                                      "on this javascript engine";

    Object.defineProperty = function defineProperty(object, property, descriptor) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
        if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);

        // make a valiant attempt to use the real defineProperty
        // for I8's DOM elements.
        if (definePropertyFallback) {
            try {
                return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {
                // try the shim if the real one doesn't work
            }
        }

        // If it's a data property.
        if (owns(descriptor, "value")) {
            // fail silently if "writable", "enumerable", or "configurable"
            // are requested but not supported
            /*
            // alternate approach:
            if ( // can't implement these features; allow false but not true
                !(owns(descriptor, "writable") ? descriptor.writable : true) ||
                !(owns(descriptor, "enumerable") ? descriptor.enumerable : true) ||
                !(owns(descriptor, "configurable") ? descriptor.configurable : true)
            )
                throw new RangeError(
                    "This implementation of Object.defineProperty does not " +
                    "support configurable, enumerable, or writable."
                );
            */

            if (supportsAccessors && (lookupGetter(object, property) ||
                                      lookupSetter(object, property)))
            {
                // As accessors are supported only on engines implementing
                // `__proto__` we can safely override `__proto__` while defining
                // a property to make sure that we don't hit an inherited
                // accessor.
                var prototype = object.__proto__;
                object.__proto__ = prototypeOfObject;
                // Deleting a property anyway since getter / setter may be
                // defined on object itself.
                delete object[property];
                object[property] = descriptor.value;
                // Setting original `__proto__` back now.
                object.__proto__ = prototype;
            } else {
                object[property] = descriptor.value;
            }
        } else {
            if (!supportsAccessors)
                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            // If we got that far then getters and setters can be defined !!
            if (owns(descriptor, "get"))
                defineGetter(object, property, descriptor.get);
            if (owns(descriptor, "set"))
                defineSetter(object, property, descriptor.set);
        }

        return object;
    };
}

// ES5 15.2.3.7
// http://es5.github.com/#x15.2.3.7
if (!Object.defineProperties) {
    Object.defineProperties = function defineProperties(object, properties) {
        for (var property in properties) {
            if (owns(properties, property))
                Object.defineProperty(object, property, properties[property]);
        }
        return object;
    };
}

// ES5 15.2.3.8
// http://es5.github.com/#x15.2.3.8
if (!Object.seal) {
    Object.seal = function seal(object) {
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}

// ES5 15.2.3.9
// http://es5.github.com/#x15.2.3.9
if (!Object.freeze) {
    Object.freeze = function freeze(object) {
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}

// detect a Rhino bug and patch it
try {
    Object.freeze(function () {});
} catch (exception) {
    Object.freeze = (function freeze(freezeObject) {
        return function freeze(object) {
            if (typeof object == "function") {
                return object;
            } else {
                return freezeObject(object);
            }
        };
    })(Object.freeze);
}

// ES5 15.2.3.10
// http://es5.github.com/#x15.2.3.10
if (!Object.preventExtensions) {
    Object.preventExtensions = function preventExtensions(object) {
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}

// ES5 15.2.3.11
// http://es5.github.com/#x15.2.3.11
if (!Object.isSealed) {
    Object.isSealed = function isSealed(object) {
        return false;
    };
}

// ES5 15.2.3.12
// http://es5.github.com/#x15.2.3.12
if (!Object.isFrozen) {
    Object.isFrozen = function isFrozen(object) {
        return false;
    };
}

// ES5 15.2.3.13
// http://es5.github.com/#x15.2.3.13
if (!Object.isExtensible) {
    Object.isExtensible = function isExtensible(object) {
        // 1. If Type(O) is not Object throw a TypeError exception.
        if (Object(object) === object) {
            throw new TypeError(); // TODO message
        }
        // 2. Return the Boolean value of the [[Extensible]] internal property of O.
        var name = '';
        while (owns(object, name)) {
            name += '?';
        }
        object[name] = true;
        var returnValue = owns(object, name);
        delete object[name];
        return returnValue;
    };
}

// ES5 15.2.3.14
// http://es5.github.com/#x15.2.3.14
if (!Object.keys) {
    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
    var hasDontEnumBug = true,
        dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
        ],
        dontEnumsLength = dontEnums.length;

    for (var key in {"toString": null}) {
        hasDontEnumBug = false;
    }

    Object.keys = function keys(object) {

        if (
            (typeof object != "object" && typeof object != "function") ||
            object === null
        ) {
            throw new TypeError("Object.keys called on a non-object");
        }

        var keys = [];
        for (var name in object) {
            if (owns(object, name)) {
                keys.push(name);
            }
        }

        if (hasDontEnumBug) {
            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                var dontEnum = dontEnums[i];
                if (owns(object, dontEnum)) {
                    keys.push(dontEnum);
                }
            }
        }
        return keys;
    };

}

//
// most of es5-shim Date section is removed since ace doesn't need it, it is too intrusive and it causes problems for users
// ====
//

// ES5 15.9.4.4
// http://es5.github.com/#x15.9.4.4
if (!Date.now) {
    Date.now = function now() {
        return new Date().getTime();
    };
}


//
// String
// ======
//

// ES5 15.5.4.20
// http://es5.github.com/#x15.5.4.20
var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
    "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
    "\u2029\uFEFF";
if (!String.prototype.trim || ws.trim()) {
    // http://blog.stevenlevithan.com/archives/faster-trim-javascript
    // http://perfectionkills.com/whitespace-deviations/
    ws = "[" + ws + "]";
    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
        trimEndRegexp = new RegExp(ws + ws + "*$");
    String.prototype.trim = function trim() {
        return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
    };
}

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(n) {
    n = +n;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function isPrimitive(input) {
    var type = typeof input;
    return (
        input === null ||
        type === "undefined" ||
        type === "boolean" ||
        type === "number" ||
        type === "string"
    );
}

function toPrimitive(input) {
    var val, valueOf, toString;
    if (isPrimitive(input)) {
        return input;
    }
    valueOf = input.valueOf;
    if (typeof valueOf === "function") {
        val = valueOf.call(input);
        if (isPrimitive(val)) {
            return val;
        }
    }
    toString = input.toString;
    if (typeof toString === "function") {
        val = toString.call(input);
        if (isPrimitive(val)) {
            return val;
        }
    }
    throw new TypeError();
}

// ES5 9.9
// http://es5.github.com/#x9.9
var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert "+o+" to object");
    }
    return Object(o);
};

});

// vim:set ts=4 sts=4 sw=4 st:
// -- kriskowal Kris Kowal Copyright (C) 2009-2010 MIT License
// -- tlrobinson Tom Robinson Copyright (C) 2009-2010 MIT License (Narwhal Project)
// -- dantman Daniel Friesen Copyright(C) 2010 XXX No License Specified
// -- fschaefer Florian Schfer Copyright (C) 2010 MIT License
// -- Irakli Gozalishvili Copyright (C) 2010 MIT License

/*!
    Copyright (c) 2009, 280 North Inc. http://280north.com/
    MIT License. http://github.com/280north/narwhal/blob/master/README.md
*/

define('bower_components/ace/lib/ace/lib/fixoldbrowsers',['require','exports','module','./regexp','./es5-shim'],function(require, exports, module) {
"use strict";

require("./regexp");
require("./es5-shim");

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/lib/dom',['require','exports','module'],function(require, exports, module) {
"use strict";

var XHTML_NS = "http://www.w3.org/1999/xhtml";

exports.getDocumentHead = function(doc) {
    if (!doc)
        doc = document;
    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
}

exports.createElement = function(tag, ns) {
    return document.createElementNS ?
           document.createElementNS(ns || XHTML_NS, tag) :
           document.createElement(tag);
};

exports.hasCssClass = function(el, name) {
    var classes = (el.className + "").split(/\s+/g);
    return classes.indexOf(name) !== -1;
};

/*
* Add a CSS class to the list of classes on the given node
*/
exports.addCssClass = function(el, name) {
    if (!exports.hasCssClass(el, name)) {
        el.className += " " + name;
    }
};

/*
* Remove a CSS class from the list of classes on the given node
*/
exports.removeCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g);
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        classes.splice(index, 1);
    }
    el.className = classes.join(" ");
};

exports.toggleCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g), add = true;
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        add = false;
        classes.splice(index, 1);
    }
    if (add)
        classes.push(name);

    el.className = classes.join(" ");
    return add;
};


/*
 * Add or remove a CSS class from the list of classes on the given node
 * depending on the value of <tt>include</tt>
 */
exports.setCssClass = function(node, className, include) {
    if (include) {
        exports.addCssClass(node, className);
    } else {
        exports.removeCssClass(node, className);
    }
};

exports.hasCssString = function(id, doc) {
    var index = 0, sheets;
    doc = doc || document;

    if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
        while (index < sheets.length)
            if (sheets[index++].owningElement.id === id) return true;
    } else if ((sheets = doc.getElementsByTagName("style"))) {
        while (index < sheets.length)
            if (sheets[index++].id === id) return true;
    }

    return false;
};

exports.importCssString = function importCssString(cssText, id, doc) {
    doc = doc || document;
    // If style is already imported return immediately.
    if (id && exports.hasCssString(id, doc))
        return null;
    
    var style;
    
    if (id)
        cssText += "\n/*# sourceURL=ace/css/" + id + " */";
    
    if (doc.createStyleSheet) {
        style = doc.createStyleSheet();
        style.cssText = cssText;
        if (id)
            style.owningElement.id = id;
    } else {
        style = exports.createElement("style");
        style.appendChild(doc.createTextNode(cssText));
        if (id)
            style.id = id;

        exports.getDocumentHead(doc).appendChild(style);
    }
};

exports.importCssStylsheet = function(uri, doc) {
    if (doc.createStyleSheet) {
        doc.createStyleSheet(uri);
    } else {
        var link = exports.createElement('link');
        link.rel = 'stylesheet';
        link.href = uri;

        exports.getDocumentHead(doc).appendChild(link);
    }
};

exports.getInnerWidth = function(element) {
    return (
        parseInt(exports.computedStyle(element, "paddingLeft"), 10) +
        parseInt(exports.computedStyle(element, "paddingRight"), 10) + 
        element.clientWidth
    );
};

exports.getInnerHeight = function(element) {
    return (
        parseInt(exports.computedStyle(element, "paddingTop"), 10) +
        parseInt(exports.computedStyle(element, "paddingBottom"), 10) +
        element.clientHeight
    );
};

exports.scrollbarWidth = function(document) {
    var inner = exports.createElement("ace_inner");
    inner.style.width = "100%";
    inner.style.minWidth = "0px";
    inner.style.height = "200px";
    inner.style.display = "block";

    var outer = exports.createElement("ace_outer");
    var style = outer.style;

    style.position = "absolute";
    style.left = "-10000px";
    style.overflow = "hidden";
    style.width = "200px";
    style.minWidth = "0px";
    style.height = "150px";
    style.display = "block";

    outer.appendChild(inner);

    var body = document.documentElement;
    body.appendChild(outer);

    var noScrollbar = inner.offsetWidth;

    style.overflow = "scroll";
    var withScrollbar = inner.offsetWidth;

    if (noScrollbar == withScrollbar) {
        withScrollbar = outer.clientWidth;
    }

    body.removeChild(outer);

    return noScrollbar-withScrollbar;
};

if (typeof document == "undefined") {
    exports.importCssString = function() {};
    return;
}

if (window.pageYOffset !== undefined) {
    exports.getPageScrollTop = function() {
        return window.pageYOffset;
    };

    exports.getPageScrollLeft = function() {
        return window.pageXOffset;
    };
}
else {
    exports.getPageScrollTop = function() {
        return document.body.scrollTop;
    };

    exports.getPageScrollLeft = function() {
        return document.body.scrollLeft;
    };
}

if (window.getComputedStyle)
    exports.computedStyle = function(element, style) {
        if (style)
            return (window.getComputedStyle(element, "") || {})[style] || "";
        return window.getComputedStyle(element, "") || {};
    };
else
    exports.computedStyle = function(element, style) {
        if (style)
            return element.currentStyle[style];
        return element.currentStyle;
    };

/*
 * Optimized set innerHTML. This is faster than plain innerHTML if the element
 * already contains a lot of child elements.
 *
 * See http://blog.stevenlevithan.com/archives/faster-than-innerhtml for details
 */
exports.setInnerHtml = function(el, innerHtml) {
    var element = el.cloneNode(false);//document.createElement("div");
    element.innerHTML = innerHtml;
    el.parentNode.replaceChild(element, el);
    return element;
};

if ("textContent" in document.documentElement) {
    exports.setInnerText = function(el, innerText) {
        el.textContent = innerText;
    };

    exports.getInnerText = function(el) {
        return el.textContent;
    };
}
else {
    exports.setInnerText = function(el, innerText) {
        el.innerText = innerText;
    };

    exports.getInnerText = function(el) {
        return el.innerText;
    };
}

exports.getParentWindow = function(document) {
    return document.defaultView || document.parentWindow;
};

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/lib/oop',['require','exports','module'],function(require, exports, module) {
"use strict";

exports.inherits = function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};

exports.mixin = function(obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
    return obj;
};

exports.implement = function(proto, mixin) {
    exports.mixin(proto, mixin);
};

});

/*! @license
==========================================================================
SproutCore -- JavaScript Application Framework
copyright 2006-2009, Sprout Systems Inc., Apple Inc. and contributors.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

SproutCore and the SproutCore logo are trademarks of Sprout Systems, Inc.

For more information about SproutCore, visit http://www.sproutcore.com


==========================================================================
@license */

// Most of the following code is taken from SproutCore with a few changes.

define('bower_components/ace/lib/ace/lib/keys',['require','exports','module','./fixoldbrowsers','./oop'],function(require, exports, module) {
"use strict";

require("./fixoldbrowsers");

var oop = require("./oop");

/*
 * Helper functions and hashes for key handling.
 */
var Keys = (function() {
    var ret = {
        MODIFIER_KEYS: {
            16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'
        },

        KEY_MODS: {
            "ctrl": 1, "alt": 2, "option" : 2, "shift": 4,
            "super": 8, "meta": 8, "command": 8, "cmd": 8
        },

        FUNCTION_KEYS : {
            8  : "Backspace",
            9  : "Tab",
            13 : "Return",
            19 : "Pause",
            27 : "Esc",
            32 : "Space",
            33 : "PageUp",
            34 : "PageDown",
            35 : "End",
            36 : "Home",
            37 : "Left",
            38 : "Up",
            39 : "Right",
            40 : "Down",
            44 : "Print",
            45 : "Insert",
            46 : "Delete",
            96 : "Numpad0",
            97 : "Numpad1",
            98 : "Numpad2",
            99 : "Numpad3",
            100: "Numpad4",
            101: "Numpad5",
            102: "Numpad6",
            103: "Numpad7",
            104: "Numpad8",
            105: "Numpad9",
            '-13': "NumpadEnter",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "Numlock",
            145: "Scrolllock"
        },

        PRINTABLE_KEYS: {
           32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',
           54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',
           66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',
           73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',
           80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',
           87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',
          186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
          219: '[', 220: '\\',221: ']', 222: "'", 111: '/', 106: '*'
        }
    };

    // A reverse map of FUNCTION_KEYS
    var name, i;
    for (i in ret.FUNCTION_KEYS) {
        name = ret.FUNCTION_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
    }

    // A reverse map of PRINTABLE_KEYS
    for (i in ret.PRINTABLE_KEYS) {
        name = ret.PRINTABLE_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
    }

    // Add the MODIFIER_KEYS, FUNCTION_KEYS and PRINTABLE_KEYS to the KEY
    // variables as well.
    oop.mixin(ret, ret.MODIFIER_KEYS);
    oop.mixin(ret, ret.PRINTABLE_KEYS);
    oop.mixin(ret, ret.FUNCTION_KEYS);

    // aliases
    ret.enter = ret["return"];
    ret.escape = ret.esc;
    ret.del = ret["delete"];

    // workaround for firefox bug
    ret[173] = '-';
    
    (function() {
        var mods = ["cmd", "ctrl", "alt", "shift"];
        for (var i = Math.pow(2, mods.length); i--;) {            
            ret.KEY_MODS[i] = mods.filter(function(x) {
                return i & ret.KEY_MODS[x];
            }).join("-") + "-";
        }
    })();

    ret.KEY_MODS[0] = "";
    ret.KEY_MODS[-1] = "input-";

    return ret;
})();
oop.mixin(exports, Keys);

exports.keyCodeToString = function(keyCode) {
    // Language-switching keystroke in Chrome/Linux emits keyCode 0.
    var keyString = Keys[keyCode];
    if (typeof keyString != "string")
        keyString = String.fromCharCode(keyCode);
    return keyString.toLowerCase();
};

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/lib/useragent',['require','exports','module'],function(require, exports, module) {
"use strict";

/*
 * I hate doing this, but we need some way to determine if the user is on a Mac
 * The reason is that users have different expectations of their key combinations.
 *
 * Take copy as an example, Mac people expect to use CMD or APPLE + C
 * Windows folks expect to use CTRL + C
 */
exports.OS = {
    LINUX: "LINUX",
    MAC: "MAC",
    WINDOWS: "WINDOWS"
};

/*
 * Return an exports.OS constant
 */
exports.getOS = function() {
    if (exports.isMac) {
        return exports.OS.MAC;
    } else if (exports.isLinux) {
        return exports.OS.LINUX;
    } else {
        return exports.OS.WINDOWS;
    }
};

// this can be called in non browser environments (e.g. from ace/requirejs/text)
if (typeof navigator != "object")
    return;

var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
var ua = navigator.userAgent;

// Is the user using a browser that identifies itself as Windows
exports.isWin = (os == "win");

// Is the user using a browser that identifies itself as Mac OS
exports.isMac = (os == "mac");

// Is the user using a browser that identifies itself as Linux
exports.isLinux = (os == "linux");

// Windows Store JavaScript apps (aka Metro apps written in HTML5 and JavaScript) do not use the "Microsoft Internet Explorer" string in their user agent, but "MSAppHost" instead.
exports.isIE = 
    (navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0)
    ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1])
    : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]); // for ie
    
exports.isOldIE = exports.isIE && exports.isIE < 9;

// Is this Firefox or related?
exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";

// oldGecko == rev < 2.0 
exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv:(\d+)/)||[])[1], 10) < 4;

// Is this Opera 
exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";

// Is the user using a browser that identifies itself as WebKit 
exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

exports.isIPad = ua.indexOf("iPad") >= 0;

exports.isTouchPad = ua.indexOf("TouchPad") >= 0;

exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/lib/event',['require','exports','module','./keys','./useragent'],function(require, exports, module) {
"use strict";

var keys = require("./keys");
var useragent = require("./useragent");

var pressedKeys = null;
var ts = 0;

exports.addListener = function(elem, type, callback) {
    if (elem.addEventListener) {
        return elem.addEventListener(type, callback, false);
    }
    if (elem.attachEvent) {
        var wrapper = function() {
            callback.call(elem, window.event);
        };
        callback._wrapper = wrapper;
        elem.attachEvent("on" + type, wrapper);
    }
};

exports.removeListener = function(elem, type, callback) {
    if (elem.removeEventListener) {
        return elem.removeEventListener(type, callback, false);
    }
    if (elem.detachEvent) {
        elem.detachEvent("on" + type, callback._wrapper || callback);
    }
};

/*
* Prevents propagation and clobbers the default action of the passed event
*/
exports.stopEvent = function(e) {
    exports.stopPropagation(e);
    exports.preventDefault(e);
    return false;
};

exports.stopPropagation = function(e) {
    if (e.stopPropagation)
        e.stopPropagation();
    else
        e.cancelBubble = true;
};

exports.preventDefault = function(e) {
    if (e.preventDefault)
        e.preventDefault();
    else
        e.returnValue = false;
};

/*
 * @return {Number} 0 for left button, 1 for middle button, 2 for right button
 */
exports.getButton = function(e) {
    if (e.type == "dblclick")
        return 0;
    if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
        return 2;

    // DOM Event
    if (e.preventDefault) {
        return e.button;
    }
    // old IE
    else {
        return {1:0, 2:2, 4:1}[e.button];
    }
};

exports.capture = function(el, eventHandler, releaseCaptureHandler) {
    function onMouseUp(e) {
        eventHandler && eventHandler(e);
        releaseCaptureHandler && releaseCaptureHandler(e);

        exports.removeListener(document, "mousemove", eventHandler, true);
        exports.removeListener(document, "mouseup", onMouseUp, true);
        exports.removeListener(document, "dragstart", onMouseUp, true);
    }

    exports.addListener(document, "mousemove", eventHandler, true);
    exports.addListener(document, "mouseup", onMouseUp, true);
    exports.addListener(document, "dragstart", onMouseUp, true);
    
    return onMouseUp;
};

exports.addTouchMoveListener = function (el, callback) {
    if ("ontouchmove" in el) {
        var startx, starty;
        exports.addListener(el, "touchstart", function (e) {
            var touchObj = e.changedTouches[0];
            startx = touchObj.clientX;
            starty = touchObj.clientY;
        });
        exports.addListener(el, "touchmove", function (e) {
            var factor = 1,
            touchObj = e.changedTouches[0];

            e.wheelX = -(touchObj.clientX - startx) / factor;
            e.wheelY = -(touchObj.clientY - starty) / factor;

            startx = touchObj.clientX;
            starty = touchObj.clientY;

            callback(e);
        });
    } 
};

exports.addMouseWheelListener = function(el, callback) {
    if ("onmousewheel" in el) {
        exports.addListener(el, "mousewheel", function(e) {
            var factor = 8;
            if (e.wheelDeltaX !== undefined) {
                e.wheelX = -e.wheelDeltaX / factor;
                e.wheelY = -e.wheelDeltaY / factor;
            } else {
                e.wheelX = 0;
                e.wheelY = -e.wheelDelta / factor;
            }
            callback(e);
        });
    } else if ("onwheel" in el) {
        exports.addListener(el, "wheel",  function(e) {
            var factor = 0.35;
            switch (e.deltaMode) {
                case e.DOM_DELTA_PIXEL:
                    e.wheelX = e.deltaX * factor || 0;
                    e.wheelY = e.deltaY * factor || 0;
                    break;
                case e.DOM_DELTA_LINE:
                case e.DOM_DELTA_PAGE:
                    e.wheelX = (e.deltaX || 0) * 5;
                    e.wheelY = (e.deltaY || 0) * 5;
                    break;
            }
            
            callback(e);
        });
    } else {
        exports.addListener(el, "DOMMouseScroll", function(e) {
            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
                e.wheelX = (e.detail || 0) * 5;
                e.wheelY = 0;
            } else {
                e.wheelX = 0;
                e.wheelY = (e.detail || 0) * 5;
            }
            callback(e);
        });
    }
};

exports.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName) {
    var clicks = 0;
    var startX, startY, timer; 
    var eventNames = {
        2: "dblclick",
        3: "tripleclick",
        4: "quadclick"
    };

    function onMousedown(e) {
        if (exports.getButton(e) !== 0) {
            clicks = 0;
        } else if (e.detail > 1) {
            clicks++;
            if (clicks > 4)
                clicks = 1;
        } else {
            clicks = 1;
        }
        if (useragent.isIE) {
            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
            if (!timer || isNewClick)
                clicks = 1;
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);

            if (clicks == 1) {
                startX = e.clientX;
                startY = e.clientY;
            }
        }
        
        e._clicks = clicks;

        eventHandler[callbackName]("mousedown", e);

        if (clicks > 4)
            clicks = 0;
        else if (clicks > 1)
            return eventHandler[callbackName](eventNames[clicks], e);
    }
    function onDblclick(e) {
        clicks = 2;
        if (timer)
            clearTimeout(timer);
        timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);
        eventHandler[callbackName]("mousedown", e);
        eventHandler[callbackName](eventNames[clicks], e);
    }
    if (!Array.isArray(elements))
        elements = [elements];
    elements.forEach(function(el) {
        exports.addListener(el, "mousedown", onMousedown);
        if (useragent.isOldIE)
            exports.addListener(el, "dblclick", onDblclick);
    });
};

var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window)
    ? function(e) {
        return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
    }
    : function(e) {
        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
    };

exports.getModifierString = function(e) {
    return keys.KEY_MODS[getModifierHash(e)];
};

function normalizeCommandKeys(callback, e, keyCode) {
    var hashId = getModifierHash(e);

    if (!useragent.isMac && pressedKeys) {
        if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
            hashId |= 8;
        if (pressedKeys.altGr) {
            if ((3 & hashId) != 3)
                pressedKeys.altGr = 0;
            else
                return;
        }
        if (keyCode === 18 || keyCode === 17) {
            var location = "location" in e ? e.location : e.keyLocation;
            if (keyCode === 17 && location === 1) {
                if (pressedKeys[keyCode] == 1)
                    ts = e.timeStamp;
            } else if (keyCode === 18 && hashId === 3 && location === 2) {
                var dt = e.timeStamp - ts;
                if (dt < 50)
                    pressedKeys.altGr = true;
            }
        }
    }
    
    if (keyCode in keys.MODIFIER_KEYS) {
        keyCode = -1;
    }

    // keyCode of right command is 93 on mac and 92 on windows.
    // keyCode of left command key is 91
    if (hashId & 8 && (keyCode >= 91 && keyCode <= 93)) {
        keyCode = -1;
    }
    
    if (!hashId && keyCode === 13) {
        var location = "location" in e ? e.location : e.keyLocation;
        if (location === 3) {
            callback(e, hashId, -keyCode);
            if (e.defaultPrevented)
                return;
        }
    }
    
    if (useragent.isChromeOS && hashId & 8) {
        callback(e, hashId, keyCode);
        if (e.defaultPrevented)
            return;
        else
            hashId &= ~8;
    }

    // If there is no hashId and the keyCode is not a function key, then
    // we don't call the callback as we don't handle a command key here
    // (it's a normal key/character input).
    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
        return false;
    }
    
    return callback(e, hashId, keyCode);
}


exports.addCommandKeyListener = function(el, callback) {
    var addListener = exports.addListener;
    if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
        // Old versions of Gecko aka. Firefox < 4.0 didn't repeat the keydown
        // event if the user pressed the key for a longer time. Instead, the
        // keydown event was fired once and later on only the keypress event.
        // To emulate the 'right' keydown behavior, the keyCode of the initial
        // keyDown event is stored and in the following keypress events the
        // stores keyCode is used to emulate a keyDown event.
        var lastKeyDownKeyCode = null;
        addListener(el, "keydown", function(e) {
            lastKeyDownKeyCode = e.keyCode;
        });
        addListener(el, "keypress", function(e) {
            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
        });
    } else {
        var lastDefaultPrevented = null;

        addListener(el, "keydown", function(e) {
            pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
            var result = normalizeCommandKeys(callback, e, e.keyCode);
            lastDefaultPrevented = e.defaultPrevented;
            return result;
        });

        addListener(el, "keypress", function(e) {
            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                exports.stopEvent(e);
                lastDefaultPrevented = null;
            }
        });

        addListener(el, "keyup", function(e) {
            pressedKeys[e.keyCode] = null;
        });

        if (!pressedKeys) {
            resetPressedKeys();
            addListener(window, "focus", resetPressedKeys);
        }
    }
};
function resetPressedKeys() {
    // console.log("resetting")
    pressedKeys = Object.create(null);
}

if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
    var postMessageId = 1;
    exports.nextTick = function(callback, win) {
        win = win || window;
        var messageName = "zero-timeout-message-" + postMessageId;
        exports.addListener(win, "message", function listener(e) {
            if (e.data == messageName) {
                exports.stopPropagation(e);
                exports.removeListener(win, "message", listener);
                callback();
            }
        });
        win.postMessage(messageName, "*");
    };
}


exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame
    || window.mozRequestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.msRequestAnimationFrame
    || window.oRequestAnimationFrame);

if (exports.nextFrame)
    exports.nextFrame = exports.nextFrame.bind(window);
else
    exports.nextFrame = function(callback) {
        setTimeout(callback, 17);
    };
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/lib/lang',['require','exports','module'],function(require, exports, module) {
"use strict";

exports.last = function(a) {
    return a[a.length - 1];
};

exports.stringReverse = function(string) {
    return string.split("").reverse().join("");
};

exports.stringRepeat = function (string, count) {
    var result = '';
    while (count > 0) {
        if (count & 1)
            result += string;

        if (count >>= 1)
            string += string;
    }
    return result;
};

var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;

exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, '');
};

exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, '');
};

exports.copyObject = function(obj) {
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};

exports.copyArray = function(array){
    var copy = [];
    for (var i=0, l=array.length; i<l; i++) {
        if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject(array[i]);
        else 
            copy[i] = array[i];
    }
    return copy;
};

exports.deepCopy = function deepCopy(obj) {
    if (typeof obj !== "object" || !obj)
        return obj;
    var copy;
    if (Array.isArray(obj)) {
        copy = [];
        for (var key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
        }
        return copy;
    }
    if (Object.prototype.toString.call(obj) !== "[object Object]")
        return obj;
    
    copy = {};
    for (var key in obj)
        copy[key] = deepCopy(obj[key]);
    return copy;
};

exports.arrayToMap = function(arr) {
    var map = {};
    for (var i=0; i<arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;

};

exports.createMap = function(props) {
    var map = Object.create(null);
    for (var i in props) {
        map[i] = props[i];
    }
    return map;
};

/*
 * splice out of 'array' anything that === 'value'
 */
exports.arrayRemove = function(array, value) {
  for (var i = 0; i <= array.length; i++) {
    if (value === array[i]) {
      array.splice(i, 1);
    }
  }
};

exports.escapeRegExp = function(str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
};

exports.escapeHTML = function(str) {
    return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
};

exports.getMatchOffsets = function(string, regExp) {
    var matches = [];

    string.replace(regExp, function(str) {
        matches.push({
            offset: arguments[arguments.length-2],
            length: str.length
        });
    });

    return matches;
};

/* deprecated */
exports.deferredCall = function(fcn) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var deferred = function(timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };

    deferred.schedule = deferred;

    deferred.call = function() {
        this.cancel();
        fcn();
        return deferred;
    };

    deferred.cancel = function() {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };
    
    deferred.isPending = function() {
        return timer;
    };

    return deferred;
};


exports.delayedCall = function(fcn, defaultTimeout) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var _self = function(timeout) {
        if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
    };

    _self.delay = function(timeout) {
        timer && clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;

    _self.call = function() {
        this.cancel();
        fcn();
    };

    _self.cancel = function() {
        timer && clearTimeout(timer);
        timer = null;
    };

    _self.isPending = function() {
        return timer;
    };

    return _self;
};
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/keyboard/textinput',['require','exports','module','../lib/event','../lib/useragent','../lib/dom','../lib/lang'],function(require, exports, module) {
"use strict";

var event = require("../lib/event");
var useragent = require("../lib/useragent");
var dom = require("../lib/dom");
var lang = require("../lib/lang");
var BROKEN_SETDATA = useragent.isChrome < 18;
var USE_IE_MIME_TYPE =  useragent.isIE;

var TextInput = function(parentNode, host) {
    var text = dom.createElement("textarea");
    text.className = "ace_text-input";

    if (useragent.isTouchPad)
        text.setAttribute("x-palm-disable-auto-cap", true);

    text.setAttribute("wrap", "off");
    text.setAttribute("autocorrect", "off");
    text.setAttribute("autocapitalize", "off");
    text.setAttribute("spellcheck", false);

    text.style.opacity = "0";
    if (useragent.isOldIE) text.style.top = "-1000px";
    parentNode.insertBefore(text, parentNode.firstChild);

    var PLACEHOLDER = "\x01\x01";

    var copied = false;
    var pasted = false;
    var inComposition = false;
    var tempStyle = '';
    var isSelectionEmpty = true;

    // FOCUS
    // ie9 throws error if document.activeElement is accessed too soon
    try { var isFocused = document.activeElement === text; } catch(e) {}
    
    event.addListener(text, "blur", function(e) {
        host.onBlur(e);
        isFocused = false;
    });
    event.addListener(text, "focus", function(e) {
        isFocused = true;
        host.onFocus(e);
        resetSelection();
    });
    this.focus = function() {
        if (tempStyle) return text.focus();
        var top = text.style.top;
        text.style.position = "fixed";
        text.style.top = "0px";
        text.focus();
        setTimeout(function() {
            text.style.position = "";
            if (text.style.top == "0px")
                text.style.top = top;
        }, 0);
    };
    this.blur = function() {
        text.blur();
    };
    this.isFocused = function() {
        return isFocused;
    };

    // modifying selection of blured textarea can focus it (chrome mac/linux)
    var syncSelection = lang.delayedCall(function() {
        isFocused && resetSelection(isSelectionEmpty);
    });
    var syncValue = lang.delayedCall(function() {
         if (!inComposition) {
            text.value = PLACEHOLDER;
            isFocused && resetSelection();
         }
    });

    function resetSelection(isEmpty) {
        if (inComposition)
            return;
        
        // this prevents infinite recursion on safari 8 
        // see https://github.com/ajaxorg/ace/issues/2114
        inComposition = true;
        
        if (inputHandler) {
            selectionStart = 0;
            selectionEnd = isEmpty ? 0 : text.value.length - 1;
        } else {
            var selectionStart = isEmpty ? 2 : 1;
            var selectionEnd = 2;
        }
        // on firefox this throws if textarea is hidden
        try {
            text.setSelectionRange(selectionStart, selectionEnd);
        } catch(e){}
        
        inComposition = false;
    }

    function resetValue() {
        if (inComposition)
            return;
        text.value = PLACEHOLDER;
        //http://code.google.com/p/chromium/issues/detail?id=76516
        if (useragent.isWebKit)
            syncValue.schedule();
    }

    useragent.isWebKit || host.addEventListener('changeSelection', function() {
        if (host.selection.isEmpty() != isSelectionEmpty) {
            isSelectionEmpty = !isSelectionEmpty;
            syncSelection.schedule();
        }
    });

    resetValue();
    if (isFocused)
        host.onFocus();


    var isAllSelected = function(text) {
        return text.selectionStart === 0 && text.selectionEnd === text.value.length;
    };
    // IE8 does not support setSelectionRange
    if (!text.setSelectionRange && text.createTextRange) {
        text.setSelectionRange = function(selectionStart, selectionEnd) {
            var range = this.createTextRange();
            range.collapse(true);
            range.moveStart('character', selectionStart);
            range.moveEnd('character', selectionEnd);
            range.select();
        };
        isAllSelected = function(text) {
            try {
                var range = text.ownerDocument.selection.createRange();
            }catch(e) {}
            if (!range || range.parentElement() != text) return false;
                return range.text == text.value;
        }
    }
    if (useragent.isOldIE) {
        var inPropertyChange = false;
        var onPropertyChange = function(e){
            if (inPropertyChange)
                return;
            var data = text.value;
            if (inComposition || !data || data == PLACEHOLDER)
                return;
            // can happen either after delete or during insert operation
            if (e && data == PLACEHOLDER[0])
                return syncProperty.schedule();

            sendText(data);
            // ie8 calls propertychange handlers synchronously!
            inPropertyChange = true;
            resetValue();
            inPropertyChange = false;
        };
        var syncProperty = lang.delayedCall(onPropertyChange);
        event.addListener(text, "propertychange", onPropertyChange);

        var keytable = { 13:1, 27:1 };
        event.addListener(text, "keyup", function (e) {
            if (inComposition && (!text.value || keytable[e.keyCode]))
                setTimeout(onCompositionEnd, 0);
            if ((text.value.charCodeAt(0)||0) < 129) {
                return syncProperty.call();
            }
            inComposition ? onCompositionUpdate() : onCompositionStart();
        });
        // when user presses backspace after focusing the editor 
        // propertychange isn't called for the next character
        event.addListener(text, "keydown", function (e) {
            syncProperty.schedule(50);
        });
    }

    var onSelect = function(e) {
        if (copied) {
            copied = false;
        } else if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
        } else if (inputHandler) {
            resetSelection(host.selection.isEmpty());
        }
    };

    var inputHandler = null;
    this.setInputHandler = function(cb) {inputHandler = cb};
    this.getInputHandler = function() {return inputHandler};
    var afterContextMenu = false;
    
    var sendText = function(data) {
        if (inputHandler) {
            data = inputHandler(data);
            inputHandler = null;
        }
        if (pasted) {
            resetSelection();
            if (data)
                host.onPaste(data);
            pasted = false;
        } else if (data == PLACEHOLDER.charAt(0)) {
            if (afterContextMenu)
                host.execCommand("del", {source: "ace"});
            else // some versions of android do not fire keydown when pressing backspace
                host.execCommand("backspace", {source: "ace"});
        } else {
            if (data.substring(0, 2) == PLACEHOLDER)
                data = data.substr(2);
            else if (data.charAt(0) == PLACEHOLDER.charAt(0))
                data = data.substr(1);
            else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                data = data.slice(0, -1);
            // can happen if undo in textarea isn't stopped
            if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                data = data.slice(0, -1);
            
            if (data)
                host.onTextInput(data);
        }
        if (afterContextMenu)
            afterContextMenu = false;
    };
    var onInput = function(e) {
        // console.log("onInput", inComposition)
        if (inComposition)
            return;
        var data = text.value;
        sendText(data);
        resetValue();
    };
    
    var handleClipboardData = function(e, data, forceIEMime) {
        var clipboardData = e.clipboardData || window.clipboardData;
        if (!clipboardData || BROKEN_SETDATA)
            return;
        // using "Text" doesn't work on old webkit but ie needs it
        var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
        try {
            if (data) {
                // Safari 5 has clipboardData object, but does not handle setData()
                return clipboardData.setData(mime, data) !== false;
            } else {
                return clipboardData.getData(mime);
            }
        } catch(e) {
            if (!forceIEMime)
                return handleClipboardData(e, data, true);
        }
    };

    var doCopy = function(e, isCut) {
        var data = host.getCopyText();
        if (!data)
            return event.preventDefault(e);

        if (handleClipboardData(e, data)) {
            isCut ? host.onCut() : host.onCopy();
            event.preventDefault(e);
        } else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function(){
                copied = false;
                resetValue();
                resetSelection();
                isCut ? host.onCut() : host.onCopy();
            });
        }
    };
    
    var onCut = function(e) {
        doCopy(e, true);
    };
    
    var onCopy = function(e) {
        doCopy(e, false);
    };
    
    var onPaste = function(e) {
        var data = handleClipboardData(e);
        if (typeof data == "string") {
            if (data)
                host.onPaste(data, e);
            if (useragent.isIE)
                setTimeout(resetSelection);
            event.preventDefault(e);
        }
        else {
            text.value = "";
            pasted = true;
        }
    };

    event.addCommandKeyListener(text, host.onCommandKey.bind(host));

    event.addListener(text, "select", onSelect);

    event.addListener(text, "input", onInput);

    event.addListener(text, "cut", onCut);
    event.addListener(text, "copy", onCopy);
    event.addListener(text, "paste", onPaste);


    // Opera has no clipboard events
    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)){
        event.addListener(parentNode, "keydown", function(e) {
            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
                return;

            switch (e.keyCode) {
                case 67:
                    onCopy(e);
                    break;
                case 86:
                    onPaste(e);
                    break;
                case 88:
                    onCut(e);
                    break;
            }
        });
    }


    // COMPOSITION
    var onCompositionStart = function(e) {
        if (inComposition || !host.onCompositionStart || host.$readOnly) 
            return;
        // console.log("onCompositionStart", inComposition)
        inComposition = {};
        inComposition.canUndo = host.session.$undoManager;
        host.onCompositionStart();
        setTimeout(onCompositionUpdate, 0);
        host.on("mousedown", onCompositionEnd);
        if (inComposition.canUndo && !host.selection.isEmpty()) {
            host.insert("");
            host.session.markUndoGroup();
            host.selection.clearSelection();
        }
        host.session.markUndoGroup();
    };

    var onCompositionUpdate = function() {
        // console.log("onCompositionUpdate", inComposition && JSON.stringify(text.value))
        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
            return;
        var val = text.value.replace(/\x01/g, "");
        if (inComposition.lastValue === val) return;
        
        host.onCompositionUpdate(val);
        if (inComposition.lastValue)
            host.undo();
        if (inComposition.canUndo)
            inComposition.lastValue = val;
        if (inComposition.lastValue) {
            var r = host.selection.getRange();
            host.insert(inComposition.lastValue);
            host.session.markUndoGroup();
            inComposition.range = host.selection.getRange();
            host.selection.setRange(r);
            host.selection.clearSelection();
        }
    };

    var onCompositionEnd = function(e) {
        if (!host.onCompositionEnd || host.$readOnly) return;
        // console.log("onCompositionEnd", inComposition &&inComposition.lastValue)
        var c = inComposition;
        inComposition = false;
        var timer = setTimeout(function() {
            timer = null;
            var str = text.value.replace(/\x01/g, "");
            // console.log(str, c.lastValue)
            if (inComposition)
                return;
            else if (str == c.lastValue)
                resetValue();
            else if (!c.lastValue && str) {
                resetValue();
                sendText(str);
            }
        });
        inputHandler = function compositionInputHandler(str) {
            // console.log("onCompositionEnd", str, c.lastValue)
            if (timer)
                clearTimeout(timer);
            str = str.replace(/\x01/g, "");
            if (str == c.lastValue)
                return "";
            if (c.lastValue && timer)
                host.undo();
            return str;
        };
        host.onCompositionEnd();
        host.removeListener("mousedown", onCompositionEnd);
        if (e.type == "compositionend" && c.range) {
            host.selection.setRange(c.range);
        }
        // Workaround for #3027, #3045, #3097, #3100
        if (useragent.isChrome && useragent.isChrome >= 53) {
          onInput();
        }
    };
    
    

    var syncComposition = lang.delayedCall(onCompositionUpdate, 50);

    event.addListener(text, "compositionstart", onCompositionStart);
    if (useragent.isGecko) {
        event.addListener(text, "text", function(){syncComposition.schedule()});
    } else {
        event.addListener(text, "keyup", function(){syncComposition.schedule()});
        event.addListener(text, "keydown", function(){syncComposition.schedule()});
    }
    event.addListener(text, "compositionend", onCompositionEnd);

    this.getElement = function() {
        return text;
    };

    this.setReadOnly = function(readOnly) {
       text.readOnly = readOnly;
    };

    this.onContextMenu = function(e) {
        afterContextMenu = true;
        resetSelection(host.selection.isEmpty());
        host._emit("nativecontextmenu", {target: host, domEvent: e});
        this.moveToMouse(e, true);
    };
    
    this.moveToMouse = function(e, bringToFront) {
        if (!bringToFront && useragent.isOldIE)
            return;
        if (!tempStyle)
            tempStyle = text.style.cssText;
        text.style.cssText = (bringToFront ? "z-index:100000;" : "")
            + "height:" + text.style.height + ";"
            + (useragent.isIE ? "opacity:0.1;" : "");

        var rect = host.container.getBoundingClientRect();
        var style = dom.computedStyle(host.container);
        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
        var maxTop = rect.bottom - top - text.clientHeight -2;
        var move = function(e) {
            text.style.left = e.clientX - left - 2 + "px";
            text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
        }; 
        move(e);

        if (e.type != "mousedown")
            return;

        if (host.renderer.$keepTextAreaAtCursor)
            host.renderer.$keepTextAreaAtCursor = null;

        clearTimeout(closeTimeout);
        // on windows context menu is opened after mouseup
        if (useragent.isWin && !useragent.isOldIE)
            event.capture(host.container, move, onContextMenuClose);
    };

    this.onContextMenuClose = onContextMenuClose;
    var closeTimeout;
    function onContextMenuClose() {
        clearTimeout(closeTimeout);
        closeTimeout = setTimeout(function () {
            if (tempStyle) {
                text.style.cssText = tempStyle;
                tempStyle = '';
            }
            if (host.renderer.$keepTextAreaAtCursor == null) {
                host.renderer.$keepTextAreaAtCursor = true;
                host.renderer.$moveTextAreaToCursor();
            }
        }, useragent.isOldIE ? 200 : 0);
    }

    var onContextMenu = function(e) {
        host.textInput.onContextMenu(e);
        onContextMenuClose();
    };
    event.addListener(text, "mouseup", onContextMenu);
    event.addListener(text, "mousedown", function(e) {
        e.preventDefault();
        onContextMenuClose();
    });
    event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
    event.addListener(text, "contextmenu", onContextMenu);
};

exports.TextInput = TextInput;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mouse/default_handlers',['require','exports','module','../lib/dom','../lib/event','../lib/useragent'],function(require, exports, module) {
"use strict";

var dom = require("../lib/dom");
var event = require("../lib/event");
var useragent = require("../lib/useragent");

var DRAG_OFFSET = 0; // pixels

function DefaultHandlers(mouseHandler) {
    mouseHandler.$clickSelection = null;

    var editor = mouseHandler.editor;
    editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
    editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
    editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
    editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
    editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
    editor.setDefaultHandler("touchmove", this.onTouchMove.bind(mouseHandler));

    var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
        "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

    exports.forEach(function(x) {
        mouseHandler[x] = this[x];
    }, this);

    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
}

(function() {

    this.onMouseDown = function(ev) {
        var inSelection = ev.inSelection();
        var pos = ev.getDocumentPosition();
        this.mousedownEvent = ev;
        var editor = this.editor;

        var button = ev.getButton();
        if (button !== 0) {
            var selectionRange = editor.getSelectionRange();
            var selectionEmpty = selectionRange.isEmpty();
            editor.$blockScrolling++;
            if (selectionEmpty || button == 1)
                editor.selection.moveToPosition(pos);
            editor.$blockScrolling--;
            // 2: contextmenu, 1: linux paste
            if (button == 2)
                editor.textInput.onContextMenu(ev.domEvent);
            return; // stopping event here breaks contextmenu on ff mac
        }

        this.mousedownEvent.time = Date.now();
        // if this click caused the editor to be focused should not clear the
        // selection
        if (inSelection && !editor.isFocused()) {
            editor.focus();
            if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
                this.setState("focusWait");
                this.captureMouse(ev);
                return;
            }
        }

        this.captureMouse(ev);
        this.startSelect(pos, ev.domEvent._clicks > 1);
        return ev.preventDefault();
    };

    this.startSelect = function(pos, waitForClickSelection) {
        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
        var editor = this.editor;
        // allow double/triple click handlers to change selection
        editor.$blockScrolling++;
        if (this.mousedownEvent.getShiftKey())
            editor.selection.selectToPosition(pos);
        else if (!waitForClickSelection)
            editor.selection.moveToPosition(pos);
        if (!waitForClickSelection)
            this.select();
        if (editor.renderer.scroller.setCapture) {
            editor.renderer.scroller.setCapture();
        }
        editor.setStyle("ace_selecting");
        this.setState("select");
        editor.$blockScrolling--;
    };

    this.select = function() {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        editor.$blockScrolling++;
        if (this.$clickSelection) {
            var cmp = this.$clickSelection.comparePoint(cursor);

            if (cmp == -1) {
                anchor = this.$clickSelection.end;
            } else if (cmp == 1) {
                anchor = this.$clickSelection.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.$blockScrolling--;
        editor.renderer.scrollCursorIntoView();
    };

    this.extendSelectionBy = function(unitName) {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        var range = editor.selection[unitName](cursor.row, cursor.column);
        editor.$blockScrolling++;
        if (this.$clickSelection) {
            var cmpStart = this.$clickSelection.comparePoint(range.start);
            var cmpEnd = this.$clickSelection.comparePoint(range.end);

            if (cmpStart == -1 && cmpEnd <= 0) {
                anchor = this.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                    cursor = range.start;
            } else if (cmpEnd == 1 && cmpStart >= 0) {
                anchor = this.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                    cursor = range.end;
            } else if (cmpStart == -1 && cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.$blockScrolling--;
        editor.renderer.scrollCursorIntoView();
    };

    this.selectEnd =
    this.selectAllEnd =
    this.selectByWordsEnd =
    this.selectByLinesEnd = function() {
        this.$clickSelection = null;
        this.editor.unsetStyle("ace_selecting");
        if (this.editor.renderer.scroller.releaseCapture) {
            this.editor.renderer.scroller.releaseCapture();
        }
    };

    this.focusWait = function() {
        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
        var time = Date.now();

        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout)
            this.startSelect(this.mousedownEvent.getDocumentPosition());
    };

    this.onDoubleClick = function(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        var session = editor.session;

        var range = session.getBracketRange(pos);
        if (range) {
            if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
            }
            this.setState("select");
        } else {
            range = editor.selection.getWordRange(pos.row, pos.column);
            this.setState("selectByWords");
        }
        this.$clickSelection = range;
        this.select();
    };

    this.onTripleClick = function(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;

        this.setState("selectByLines");
        var range = editor.getSelectionRange();
        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
            this.$clickSelection = editor.selection.getLineRange(range.start.row);
            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
        } else {
            this.$clickSelection = editor.selection.getLineRange(pos.row);
        }
        this.select();
    };

    this.onQuadClick = function(ev) {
        var editor = this.editor;

        editor.selectAll();
        this.$clickSelection = editor.getSelectionRange();
        this.setState("selectAll");
    };

    this.onMouseWheel = function(ev) {
        if (ev.getAccelKey())
            return;

        //shift wheel to horiz scroll
        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
            ev.wheelX = ev.wheelY;
            ev.wheelY = 0;
        }

        var t = ev.domEvent.timeStamp;
        var dt = t - (this.$lastScrollTime||0);
        
        var editor = this.editor;
        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
        if (isScrolable || dt < 200) {
            this.$lastScrollTime = t;
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
        }
    };
    
    this.onTouchMove = function (ev) {
        var t = ev.domEvent.timeStamp;
        var dt = t - (this.$lastScrollTime || 0);

        var editor = this.editor;
        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
        if (isScrolable || dt < 200) {
            this.$lastScrollTime = t;
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
        }
    };

}).call(DefaultHandlers.prototype);

exports.DefaultHandlers = DefaultHandlers;

function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

function calcRangeOrientation(range, cursor) {
    if (range.start.row == range.end.row)
        var cmp = 2 * cursor.column - range.start.column - range.end.column;
    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
        var cmp = cursor.column - 4;
    else
        var cmp = 2 * cursor.row - range.start.row - range.end.row;

    if (cmp < 0)
        return {cursor: range.start, anchor: range.end};
    else
        return {cursor: range.end, anchor: range.start};
}

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/tooltip',['require','exports','module','./lib/oop','./lib/dom'],function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var dom = require("./lib/dom");

/**
 * @class Tooltip
 **/

/**
 * @param {Element} parentNode
 *
 * @constructor
 **/
function Tooltip (parentNode) {
    this.isOpen = false;
    this.$element = null;
    this.$parentNode = parentNode;
}

(function() {
    this.$init = function() {
        this.$element = dom.createElement("div");
        this.$element.className = "ace_tooltip";
        this.$element.style.display = "none";
        this.$parentNode.appendChild(this.$element);
        return this.$element;
    };

    /**
     * @returns {Element}
     **/
    this.getElement = function() {
        return this.$element || this.$init();
    };

    /**
     * @param {String} text
     **/
    this.setText = function(text) {
        dom.setInnerText(this.getElement(), text);
    };

    /**
     * @param {String} html
     **/
    this.setHtml = function(html) {
        this.getElement().innerHTML = html;
    };

    /**
     * @param {Number} x
     * @param {Number} y
     **/
    this.setPosition = function(x, y) {
        this.getElement().style.left = x + "px";
        this.getElement().style.top = y + "px";
    };

    /**
     * @param {String} className
     **/
    this.setClassName = function(className) {
        dom.addCssClass(this.getElement(), className);
    };

    /**
     * @param {String} text
     * @param {Number} x
     * @param {Number} y
     **/
    this.show = function(text, x, y) {
        if (text != null)
            this.setText(text);
        if (x != null && y != null)
            this.setPosition(x, y);
        if (!this.isOpen) {
            this.getElement().style.display = "block";
            this.isOpen = true;
        }
    };

    this.hide = function() {
        if (this.isOpen) {
            this.getElement().style.display = "none";
            this.isOpen = false;
        }
    };

    /**
     * @returns {Number}
     **/
    this.getHeight = function() {
        return this.getElement().offsetHeight;
    };

    /**
     * @returns {Number}
     **/
    this.getWidth = function() {
        return this.getElement().offsetWidth;
    };

}).call(Tooltip.prototype);

exports.Tooltip = Tooltip;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mouse/default_gutter_handler',['require','exports','module','../lib/dom','../lib/oop','../lib/event','../tooltip'],function(require, exports, module) {
"use strict";
var dom = require("../lib/dom");
var oop = require("../lib/oop");
var event = require("../lib/event");
var Tooltip = require("../tooltip").Tooltip;

function GutterHandler(mouseHandler) {
    var editor = mouseHandler.editor;
    var gutter = editor.renderer.$gutterLayer;
    var tooltip = new GutterTooltip(editor.container);

    mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
        if (!editor.isFocused() || e.getButton() != 0)
            return;
        var gutterRegion = gutter.getRegion(e);

        if (gutterRegion == "foldWidgets")
            return;

        var row = e.getDocumentPosition().row;
        var selection = editor.session.selection;

        if (e.getShiftKey())
            selection.selectTo(row, 0);
        else {
            if (e.domEvent.detail == 2) {
                editor.selectAll();
                return e.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
        }
        mouseHandler.setState("selectByLines");
        mouseHandler.captureMouse(e);
        return e.preventDefault();
    });


    var tooltipTimeout, mouseEvent, tooltipAnnotation;

    function showTooltip() {
        var row = mouseEvent.getDocumentPosition().row;
        var annotation = gutter.$annotations[row];
        if (!annotation)
            return hideTooltip();

        var maxRow = editor.session.getLength();
        if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
                return hideTooltip();
        }

        if (tooltipAnnotation == annotation)
            return;
        tooltipAnnotation = annotation.text.join("<br/>");

        tooltip.setHtml(tooltipAnnotation);
        tooltip.show();
        editor._signal("showGutterTooltip", tooltip);
        editor.on("mousewheel", hideTooltip);

        if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
        } else {
            var gutterElement = mouseEvent.domEvent.target;
            var rect = gutterElement.getBoundingClientRect();
            var style = tooltip.getElement().style;
            style.left = rect.right + "px";
            style.top = rect.bottom + "px";
        }
    }

    function hideTooltip() {
        if (tooltipTimeout)
            tooltipTimeout = clearTimeout(tooltipTimeout);
        if (tooltipAnnotation) {
            tooltip.hide();
            tooltipAnnotation = null;
            editor._signal("hideGutterTooltip", tooltip);
            editor.removeEventListener("mousewheel", hideTooltip);
        }
    }

    function moveTooltip(e) {
        tooltip.setPosition(e.x, e.y);
    }

    mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
        var target = e.domEvent.target || e.domEvent.srcElement;
        if (dom.hasCssClass(target, "ace_fold-widget"))
            return hideTooltip();

        if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
            moveTooltip(e);

        mouseEvent = e;
        if (tooltipTimeout)
            return;
        tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed)
                showTooltip();
            else
                hideTooltip();
        }, 50);
    });

    event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
        mouseEvent = null;
        if (!tooltipAnnotation || tooltipTimeout)
            return;

        tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            hideTooltip();
        }, 50);
    });
    
    editor.on("changeSession", hideTooltip);
}

function GutterTooltip(parentNode) {
    Tooltip.call(this, parentNode);
}

oop.inherits(GutterTooltip, Tooltip);

(function(){
    this.setPosition = function(x, y) {
        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
        var width = this.getWidth();
        var height = this.getHeight();
        x += 15;
        y += 15;
        if (x + width > windowWidth) {
            x -= (x + width) - windowWidth;
        }
        if (y + height > windowHeight) {
            y -= 20 + height;
        }
        Tooltip.prototype.setPosition.call(this, x, y);
    };

}).call(GutterTooltip.prototype);



exports.GutterHandler = GutterHandler;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mouse/mouse_event',['require','exports','module','../lib/event','../lib/useragent'],function(require, exports, module) {
"use strict";

var event = require("../lib/event");
var useragent = require("../lib/useragent");

/*
 * Custom Ace mouse event
 */
var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
    this.domEvent = domEvent;
    this.editor = editor;
    
    this.x = this.clientX = domEvent.clientX;
    this.y = this.clientY = domEvent.clientY;

    this.$pos = null;
    this.$inSelection = null;
    
    this.propagationStopped = false;
    this.defaultPrevented = false;
};

(function() {  
    
    this.stopPropagation = function() {
        event.stopPropagation(this.domEvent);
        this.propagationStopped = true;
    };
    
    this.preventDefault = function() {
        event.preventDefault(this.domEvent);
        this.defaultPrevented = true;
    };
    
    this.stop = function() {
        this.stopPropagation();
        this.preventDefault();
    };

    /*
     * Get the document position below the mouse cursor
     * 
     * @return {Object} 'row' and 'column' of the document position
     */
    this.getDocumentPosition = function() {
        if (this.$pos)
            return this.$pos;
        
        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
        return this.$pos;
    };
    
    /*
     * Check if the mouse cursor is inside of the text selection
     * 
     * @return {Boolean} whether the mouse cursor is inside of the selection
     */
    this.inSelection = function() {
        if (this.$inSelection !== null)
            return this.$inSelection;
            
        var editor = this.editor;
        

        var selectionRange = editor.getSelectionRange();
        if (selectionRange.isEmpty())
            this.$inSelection = false;
        else {
            var pos = this.getDocumentPosition();
            this.$inSelection = selectionRange.contains(pos.row, pos.column);
        }

        return this.$inSelection;
    };
    
    /*
     * Get the clicked mouse button
     * 
     * @return {Number} 0 for left button, 1 for middle button, 2 for right button
     */
    this.getButton = function() {
        return event.getButton(this.domEvent);
    };
    
    /*
     * @return {Boolean} whether the shift key was pressed when the event was emitted
     */
    this.getShiftKey = function() {
        return this.domEvent.shiftKey;
    };
    
    this.getAccelKey = useragent.isMac
        ? function() { return this.domEvent.metaKey; }
        : function() { return this.domEvent.ctrlKey; };
    
}).call(MouseEvent.prototype);

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mouse/dragdrop_handler',['require','exports','module','../lib/dom','../lib/event','../lib/useragent'],function(require, exports, module) {
"use strict";

var dom = require("../lib/dom");
var event = require("../lib/event");
var useragent = require("../lib/useragent");

var AUTOSCROLL_DELAY = 200;
var SCROLL_CURSOR_DELAY = 200;
var SCROLL_CURSOR_HYSTERESIS = 5;

function DragdropHandler(mouseHandler) {

    var editor = mouseHandler.editor;

    var blankImage = dom.createElement("img");
    // Safari crashes without image data
    blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
    if (useragent.isOpera)
        blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";

    var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

     exports.forEach(function(x) {
         mouseHandler[x] = this[x];
    }, this);
    editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));


    var mouseTarget = editor.container;
    var dragSelectionMarker, x, y;
    var timerId, range;
    var dragCursor, counter = 0;
    var dragOperation;
    var isInternal;
    var autoScrollStartTime;
    var cursorMovedTime;
    var cursorPointOnCaretMoved;

    this.onDragStart = function(e) {
        // webkit workaround, see this.onMouseDown
        if (this.cancelDrag || !mouseTarget.draggable) {
            var self = this;
            setTimeout(function(){
                self.startSelect();
                self.captureMouse(e);
            }, 0);
            return e.preventDefault();
        }
        range = editor.getSelectionRange();

        var dataTransfer = e.dataTransfer;
        dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
        if (useragent.isOpera) {
            editor.container.appendChild(blankImage);
            // force layout
            blankImage.scrollTop = 0;
        }
        dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
        if (useragent.isOpera) {
            editor.container.removeChild(blankImage);
        }
        // clear Opera garbage
        dataTransfer.clearData();
        dataTransfer.setData("Text", editor.session.getTextRange());

        isInternal = true;
        this.setState("drag");
    };

    this.onDragEnd = function(e) {
        mouseTarget.draggable = false;
        isInternal = false;
        this.setState(null);
        if (!editor.getReadOnly()) {
            var dropEffect = e.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move")
                // text was dragged outside the editor
                editor.session.remove(editor.getSelectionRange());
            editor.renderer.$cursorLayer.setBlinking(true);
        }
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
    };

    this.onDragEnter = function(e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker)
            addDragMarker();
        counter++;
        // dataTransfer object does not save dropEffect across events on IE, so we store it in dragOperation
        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };

    this.onDragOver = function(e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        // Opera doesn't trigger dragenter event on drag start
        if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
        }
        if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;

        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };

    this.onDragLeave = function(e) {
        counter--;
        if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e);
        }
    };

    this.onDrop = function(e) {
        if (!dragCursor)
            return;
        var dataTransfer = e.dataTransfer;
        if (isInternal) {
            switch (dragOperation) {
                case "move":
                    if (range.contains(dragCursor.row, dragCursor.column)) {
                        // clear selection
                        range = {
                            start: dragCursor,
                            end: dragCursor
                        };
                    } else {
                        // move text
                        range = editor.moveText(range, dragCursor);
                    }
                    break;
                case "copy":
                    // copy text
                    range = editor.moveText(range, dragCursor, true);
                    break;
            }
        } else {
            var dropData = dataTransfer.getData('Text');
            range = {
                start: dragCursor,
                end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
        }
        clearDragMarker();
        return event.preventDefault(e);
    };

    event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
    event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
    event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
    event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
    event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
    event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));

    function scrollCursorIntoView(cursor, prevCursor) {
        var now = Date.now();
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        var hMovement = !prevCursor || cursor.column != prevCursor.column;
        if (!cursorMovedTime || vMovement || hMovement) {
            editor.$blockScrolling += 1;
            editor.moveCursorToPosition(cursor);
            editor.$blockScrolling -= 1;
            cursorMovedTime = now;
            cursorPointOnCaretMoved = {x: x, y: y};
        } else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
                cursorMovedTime = null;
            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                editor.renderer.scrollCursorIntoView();
                cursorMovedTime = null;
            }
        }
    }

    function autoScroll(cursor, prevCursor) {
        var now = Date.now();
        var lineHeight = editor.renderer.layerConfig.lineHeight;
        var characterWidth = editor.renderer.layerConfig.characterWidth;
        var editorRect = editor.renderer.scroller.getBoundingClientRect();
        var offsets = {
           x: {
               left: x - editorRect.left,
               right: editorRect.right - x
           },
           y: {
               top: y - editorRect.top,
               bottom: editorRect.bottom - y
           }
        };
        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
        var scrollCursor = {row: cursor.row, column: cursor.column};
        if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
        }
        if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
        }
        var vScroll = cursor.row != scrollCursor.row;
        var hScroll = cursor.column != scrollCursor.column;
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        if (vScroll || (hScroll && !vMovement)) {
            if (!autoScrollStartTime)
                autoScrollStartTime = now;
            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
                editor.renderer.scrollCursorIntoView(scrollCursor);
        } else {
            autoScrollStartTime = null;
        }
    }

    function onDragInterval() {
        var prevCursor = dragCursor;
        dragCursor = editor.renderer.screenToTextCoordinates(x, y);
        scrollCursorIntoView(dragCursor, prevCursor);
        autoScroll(dragCursor, prevCursor);
    }

    function addDragMarker() {
        range = editor.selection.toOrientedRange();
        dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
        editor.clearSelection();
        if (editor.isFocused())
            editor.renderer.$cursorLayer.setBlinking(false);
        clearInterval(timerId);
        onDragInterval();
        timerId = setInterval(onDragInterval, 20);
        counter = 0;
        event.addListener(document, "mousemove", onMouseMove);
    }

    function clearDragMarker() {
        clearInterval(timerId);
        editor.session.removeMarker(dragSelectionMarker);
        dragSelectionMarker = null;
        editor.$blockScrolling += 1;
        editor.selection.fromOrientedRange(range);
        editor.$blockScrolling -= 1;
        if (editor.isFocused() && !isInternal)
            editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
        range = null;
        dragCursor = null;
        counter = 0;
        autoScrollStartTime = null;
        cursorMovedTime = null;
        event.removeListener(document, "mousemove", onMouseMove);
    }

    // sometimes other code on the page can stop dragleave event leaving editor stuck in the drag state
    var onMouseMoveTimer = null;
    function onMouseMove() {
        if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function() {
                if (onMouseMoveTimer != null && dragSelectionMarker)
                    clearDragMarker();
            }, 20);
        }
    }

    function canAccept(dataTransfer) {
        var types = dataTransfer.types;
        return !types || Array.prototype.some.call(types, function(type) {
            return type == 'text/plain' || type == 'Text';
        });
    }

    function getDropEffect(e) {
        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;

        // IE throws error while dragging from another app
        var effectAllowed = "uninitialized";
        try {
            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
        } catch (e) {}
        var dropEffect = "none";

        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
        else if (moveAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "move";
        else if (copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";

        return dropEffect;
    }
}

(function() {

    this.dragWait = function() {
        var interval = Date.now() - this.mousedownEvent.time;
        if (interval > this.editor.getDragDelay())
            this.startDrag();
    };

    this.dragWaitEnd = function() {
        var target = this.editor.container;
        target.draggable = false;
        this.startSelect(this.mousedownEvent.getDocumentPosition());
        this.selectEnd();
    };

    this.dragReadyEnd = function(e) {
        this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
        this.dragWaitEnd();
    };

    this.startDrag = function(){
        this.cancelDrag = false;
        var editor = this.editor;
        var target = editor.container;
        target.draggable = true;
        editor.renderer.$cursorLayer.setBlinking(false);
        editor.setStyle("ace_dragging");
        var cursorStyle = useragent.isWin ? "default" : "move";
        editor.renderer.setCursorStyle(cursorStyle);
        this.setState("dragReady");
    };

    this.onMouseDrag = function(e) {
        var target = this.editor.container;
        if (useragent.isIE && this.state == "dragReady") {
            // IE does not handle [draggable] attribute set after mousedown
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3)
                target.dragDrop();
        }
        if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
                target.draggable = false;
                this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
        }
    };

    this.onMouseDown = function(e) {
        if (!this.$dragEnabled)
            return;
        this.mousedownEvent = e;
        var editor = this.editor;

        var inSelection = e.inSelection();
        var button = e.getButton();
        var clickCount = e.domEvent.detail || 1;
        if (clickCount === 1 && button === 0 && inSelection) {
            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
                return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
            if ("unselectable" in eventTarget)
                eventTarget.unselectable = "on";
            if (editor.getDragDelay()) {
                // https://code.google.com/p/chromium/issues/detail?id=286700
                if (useragent.isWebKit) {
                    this.cancelDrag = true;
                    var mouseTarget = editor.container;
                    mouseTarget.draggable = true;
                }
                this.setState("dragWait");
            } else {
                this.startDrag();
            }
            this.captureMouse(e, this.onMouseDrag.bind(this));
            // TODO: a better way to prevent default handler without preventing browser default action
            e.defaultPrevented = true;
        }
    };

}).call(DragdropHandler.prototype);


function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

exports.DragdropHandler = DragdropHandler;

});
/*
 * based on code from:
 *
 * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
define('bower_components/ace/lib/ace/lib/net',['require','exports','module','./dom'],function(require, exports, module) {
"use strict";
var dom = require("./dom");

exports.get = function (url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
        //Do not explicitly handle errors, those should be
        //visible via console output in the browser.
        if (xhr.readyState === 4) {
            callback(xhr.responseText);
        }
    };
    xhr.send(null);
};

exports.loadScript = function(path, callback) {
    var head = dom.getDocumentHead();
    var s = document.createElement('script');

    s.src = path;
    head.appendChild(s);

    s.onload = s.onreadystatechange = function(_, isAbort) {
        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort)
                callback();
        }
    };
};

/*
 * Convert a url into a fully qualified absolute URL
 * This function does not work in IE6
 */
exports.qualifyURL = function(url) {
    var a = document.createElement('a');
    a.href = url;
    return a.href;
}

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/lib/event_emitter',['require','exports','module'],function(require, exports, module) {
"use strict";

var EventEmitter = {};
var stopPropagation = function() { this.propagationStopped = true; };
var preventDefault = function() { this.defaultPrevented = true; };

EventEmitter._emit =
EventEmitter._dispatchEvent = function(eventName, e) {
    this._eventRegistry || (this._eventRegistry = {});
    this._defaultHandlers || (this._defaultHandlers = {});

    var listeners = this._eventRegistry[eventName] || [];
    var defaultHandler = this._defaultHandlers[eventName];
    if (!listeners.length && !defaultHandler)
        return;

    if (typeof e != "object" || !e)
        e = {};

    if (!e.type)
        e.type = eventName;
    if (!e.stopPropagation)
        e.stopPropagation = stopPropagation;
    if (!e.preventDefault)
        e.preventDefault = preventDefault;

    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++) {
        listeners[i](e, this);
        if (e.propagationStopped)
            break;
    }
    
    if (defaultHandler && !e.defaultPrevented)
        return defaultHandler(e, this);
};


EventEmitter._signal = function(eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++)
        listeners[i](e, this);
};

EventEmitter.once = function(eventName, callback) {
    var _self = this;
    callback && this.addEventListener(eventName, function newCallback() {
        _self.removeEventListener(eventName, newCallback);
        callback.apply(null, arguments);
    });
};


EventEmitter.setDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers
    if (!handlers)
        handlers = this._defaultHandlers = {_disabled_: {}};
    
    if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1) 
            disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
};
EventEmitter.removeDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers
    if (!handlers)
        return;
    var disabled = handlers._disabled_[eventName];
    
    if (handlers[eventName] == callback) {
        var old = handlers[eventName];
        if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
    } else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
};

EventEmitter.on =
EventEmitter.addEventListener = function(eventName, callback, capturing) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        listeners = this._eventRegistry[eventName] = [];

    if (listeners.indexOf(callback) == -1)
        listeners[capturing ? "unshift" : "push"](callback);
    return callback;
};

EventEmitter.off =
EventEmitter.removeListener =
EventEmitter.removeEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        return;

    var index = listeners.indexOf(callback);
    if (index !== -1)
        listeners.splice(index, 1);
};

EventEmitter.removeAllListeners = function(eventName) {
    if (this._eventRegistry) this._eventRegistry[eventName] = [];
};

exports.EventEmitter = EventEmitter;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/lib/app_config',['require','exports','module','./oop','./event_emitter'],function(require, exports, module) {
"no use strict";

var oop = require("./oop");
var EventEmitter = require("./event_emitter").EventEmitter;

var optionsProvider = {
    setOptions: function(optList) {
        Object.keys(optList).forEach(function(key) {
            this.setOption(key, optList[key]);
        }, this);
    },
    getOptions: function(optionNames) {
        var result = {};
        if (!optionNames) {
            optionNames = Object.keys(this.$options);
        } else if (!Array.isArray(optionNames)) {
            result = optionNames;
            optionNames = Object.keys(result);
        }
        optionNames.forEach(function(key) {
            result[key] = this.getOption(key);
        }, this);
        return result;
    },
    setOption: function(name, value) {
        if (this["$" + name] === value)
            return;
        var opt = this.$options[name];
        if (!opt) {
            return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

        if (!opt.handlesSet)
            this["$" + name] = value;
        if (opt && opt.set)
            opt.set.call(this, value);
    },
    getOption: function(name) {
        var opt = this.$options[name];
        if (!opt) {
            return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
        return opt && opt.get ? opt.get.call(this) : this["$" + name];
    }
};

function warn(message) {
    if (typeof console != "undefined" && console.warn)
        console.warn.apply(console, arguments);
}

function reportError(msg, data) {
    var e = new Error(msg);
    e.data = data;
    if (typeof console == "object" && console.error)
        console.error(e);
    setTimeout(function() { throw e; });
}

var AppConfig = function() {
    this.$defaultOptions = {};
};

(function() {
    // module loading
    oop.implement(this, EventEmitter);
    /*
     * option {name, value, initialValue, setterName, set, get }
     */
    this.defineOptions = function(obj, path, options) {
        if (!obj.$options)
            this.$defaultOptions[path] = obj.$options = {};

        Object.keys(options).forEach(function(key) {
            var opt = options[key];
            if (typeof opt == "string")
                opt = {forwardTo: opt};

            opt.name || (opt.name = key);
            obj.$options[opt.name] = opt;
            if ("initialValue" in opt)
                obj["$" + opt.name] = opt.initialValue;
        });

        // implement option provider interface
        oop.implement(obj, optionsProvider);

        return this;
    };

    this.resetOptions = function(obj) {
        Object.keys(obj.$options).forEach(function(key) {
            var opt = obj.$options[key];
            if ("value" in opt)
                obj.setOption(key, opt.value);
        });
    };

    this.setDefaultValue = function(path, name, value) {
        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
        if (opts[name]) {
            if (opts.forwardTo)
                this.setDefaultValue(opts.forwardTo, name, value);
            else
                opts[name].value = value;
        }
    };

    this.setDefaultValues = function(path, optionHash) {
        Object.keys(optionHash).forEach(function(key) {
            this.setDefaultValue(path, key, optionHash[key]);
        }, this);
    };
    
    this.warn = warn;
    this.reportError = reportError;
    
}).call(AppConfig.prototype);

exports.AppConfig = AppConfig;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/config',['require','exports','module','./lib/lang','./lib/oop','./lib/net','./lib/app_config'],function(require, exports, module) {
"no use strict";

var lang = require("./lib/lang");
var oop = require("./lib/oop");
var net = require("./lib/net");
var AppConfig = require("./lib/app_config").AppConfig;

module.exports = exports = new AppConfig();

var global = (function() {
    return this || typeof window != "undefined" && window;
})();

var options = {
    packaged: false,
    workerPath: null,
    modePath: null,
    themePath: null,
    basePath: "",
    suffix: ".js",
    $moduleUrls: {}
};

exports.get = function(key) {
    if (!options.hasOwnProperty(key))
        throw new Error("Unknown config key: " + key);

    return options[key];
};

exports.set = function(key, value) {
    if (!options.hasOwnProperty(key))
        throw new Error("Unknown config key: " + key);

    options[key] = value;
};

exports.all = function() {
    return lang.copyObject(options);
};

// module loading
exports.moduleUrl = function(name, component) {
    if (options.$moduleUrls[name])
        return options.$moduleUrls[name];

    var parts = name.split("/");
    component = component || parts[parts.length - 2] || "";
    
    // todo make this configurable or get rid of '-'
    var sep = component == "snippets" ? "/" : "-";
    var base = parts[parts.length - 1];
    if (component == "worker" && sep == "-") {
        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
        base = base.replace(re, "");
    }

    if ((!base || base == component) && parts.length > 1)
        base = parts[parts.length - 2];
    var path = options[component + "Path"];
    if (path == null) {
        path = options.basePath;
    } else if (sep == "/") {
        component = sep = "";
    }
    if (path && path.slice(-1) != "/")
        path += "/";
    return path + component + sep + base + this.get("suffix");
};

exports.setModuleUrl = function(name, subst) {
    return options.$moduleUrls[name] = subst;
};

exports.$loading = {};
exports.loadModule = function(moduleName, onLoad) {
    var module, moduleType;
    if (Array.isArray(moduleName)) {
        moduleType = moduleName[0];
        moduleName = moduleName[1];
    }

    try {
        module = require(moduleName);
    } catch (e) {}
    // require(moduleName) can return empty object if called after require([moduleName], callback)
    if (module && !exports.$loading[moduleName])
        return onLoad && onLoad(module);

    if (!exports.$loading[moduleName])
        exports.$loading[moduleName] = [];

    exports.$loading[moduleName].push(onLoad);

    if (exports.$loading[moduleName].length > 1)
        return;

    var afterLoad = function() {
        require([moduleName], function(module) {
            exports._emit("load.module", {name: moduleName, module: module});
            var listeners = exports.$loading[moduleName];
            exports.$loading[moduleName] = null;
            listeners.forEach(function(onLoad) {
                onLoad && onLoad(module);
            });
        });
    };

    if (!exports.get("packaged"))
        return afterLoad();
    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
};

// initialization
function init(packaged) {
    if (!global || !global.document)
        return;
    
    options.packaged = packaged || require.packaged || module.packaged || (global.define && define.packaged);

    var scriptOptions = {};
    var scriptUrl = "";

    // Use currentScript.ownerDocument in case this file was loaded from imported document. (HTML Imports)
    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill
    var currentDocument = currentScript && currentScript.ownerDocument || document;
    
    var scripts = currentDocument.getElementsByTagName("script");
    for (var i=0; i<scripts.length; i++) {
        var script = scripts[i];

        var src = script.src || script.getAttribute("src");
        if (!src)
            continue;

        var attributes = script.attributes;
        for (var j=0, l=attributes.length; j < l; j++) {
            var attr = attributes[j];
            if (attr.name.indexOf("data-ace-") === 0) {
                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
            }
        }

        var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
        if (m)
            scriptUrl = m[1];
    }

    if (scriptUrl) {
        scriptOptions.base = scriptOptions.base || scriptUrl;
        scriptOptions.packaged = true;
    }

    scriptOptions.basePath = scriptOptions.base;
    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
    delete scriptOptions.base;

    for (var key in scriptOptions)
        if (typeof scriptOptions[key] !== "undefined")
            exports.set(key, scriptOptions[key]);
}

exports.init = init;

function deHyphenate(str) {
    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
}

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mouse/mouse_handler',['require','exports','module','../lib/event','../lib/useragent','./default_handlers','./default_gutter_handler','./mouse_event','./dragdrop_handler','../config'],function(require, exports, module) {
"use strict";

var event = require("../lib/event");
var useragent = require("../lib/useragent");
var DefaultHandlers = require("./default_handlers").DefaultHandlers;
var DefaultGutterHandler = require("./default_gutter_handler").GutterHandler;
var MouseEvent = require("./mouse_event").MouseEvent;
var DragdropHandler = require("./dragdrop_handler").DragdropHandler;
var config = require("../config");

var MouseHandler = function(editor) {
    var _self = this;
    this.editor = editor;

    new DefaultHandlers(this);
    new DefaultGutterHandler(this);
    new DragdropHandler(this);

    var focusEditor = function(e) {
        // because we have to call event.preventDefault() any window on ie and iframes
        // on other browsers do not get focus, so we have to call window.focus() here
        var windowBlurred = !document.hasFocus || !document.hasFocus()
            || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement())
        if (windowBlurred)
            window.focus();
        editor.focus();
    };

    var mouseTarget = editor.renderer.getMouseEventTarget();
    event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
    event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
    event.addMultiMouseDownListener([
        mouseTarget,
        editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
        editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
        editor.textInput && editor.textInput.getElement()
    ].filter(Boolean), [400, 300, 250], this, "onMouseEvent");
    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
    event.addTouchMoveListener(editor.container, this.onTouchMove.bind(this, "touchmove"));

    var gutterEl = editor.renderer.$gutter;
    event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
    event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
    event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
    event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));

    event.addListener(mouseTarget, "mousedown", focusEditor);
    event.addListener(gutterEl, "mousedown", focusEditor);
    if (useragent.isIE && editor.renderer.scrollBarV) {
        event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
        event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
    }

    editor.on("mousemove", function(e){
        if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
            return;

        var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
        var range = editor.session.selection.getRange();
        var renderer = editor.renderer;

        if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
            renderer.setCursorStyle("default");
        } else {
            renderer.setCursorStyle("");
        }
    });
};

(function() {
    this.onMouseEvent = function(name, e) {
        this.editor._emit(name, new MouseEvent(e, this.editor));
    };

    this.onMouseMove = function(name, e) {
        // optimization, because mousemove doesn't have a default handler.
        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
        if (!listeners || !listeners.length)
            return;

        this.editor._emit(name, new MouseEvent(e, this.editor));
    };

    this.onMouseWheel = function(name, e) {
        var mouseEvent = new MouseEvent(e, this.editor);
        mouseEvent.speed = this.$scrollSpeed * 2;
        mouseEvent.wheelX = e.wheelX;
        mouseEvent.wheelY = e.wheelY;

        this.editor._emit(name, mouseEvent);
    };
    
    this.onTouchMove = function (name, e) {
        var mouseEvent = new MouseEvent(e, this.editor);
        mouseEvent.speed = 1;//this.$scrollSpeed * 2;
        mouseEvent.wheelX = e.wheelX;
        mouseEvent.wheelY = e.wheelY;
        this.editor._emit(name, mouseEvent);
    };

    this.setState = function(state) {
        this.state = state;
    };

    this.captureMouse = function(ev, mouseMoveHandler) {
        this.x = ev.x;
        this.y = ev.y;

        this.isMousePressed = true;

        // do not move textarea during selection
        var renderer = this.editor.renderer;
        if (renderer.$keepTextAreaAtCursor)
            renderer.$keepTextAreaAtCursor = null;

        var self = this;
        var onMouseMove = function(e) {
            if (!e) return;
            // if editor is loaded inside iframe, and mouseup event is outside
            // we won't recieve it, so we cancel on first mousemove without button
            if (useragent.isWebKit && !e.which && self.releaseMouse)
                return self.releaseMouse();

            self.x = e.clientX;
            self.y = e.clientY;
            mouseMoveHandler && mouseMoveHandler(e);
            self.mouseEvent = new MouseEvent(e, self.editor);
            self.$mouseMoved = true;
        };

        var onCaptureEnd = function(e) {
            clearInterval(timerId);
            onCaptureInterval();
            self[self.state + "End"] && self[self.state + "End"](e);
            self.state = "";
            if (renderer.$keepTextAreaAtCursor == null) {
                renderer.$keepTextAreaAtCursor = true;
                renderer.$moveTextAreaToCursor();
            }
            self.isMousePressed = false;
            self.$onCaptureMouseMove = self.releaseMouse = null;
            e && self.onMouseEvent("mouseup", e);
        };

        var onCaptureInterval = function() {
            self[self.state] && self[self.state]();
            self.$mouseMoved = false;
        };

        if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
            return setTimeout(function() {onCaptureEnd(ev);});
        }

        self.$onCaptureMouseMove = onMouseMove;
        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
        var timerId = setInterval(onCaptureInterval, 20);
    };
    this.releaseMouse = null;
    this.cancelContextMenu = function() {
        var stop = function(e) {
            if (e && e.domEvent && e.domEvent.type != "contextmenu")
                return;
            this.editor.off("nativecontextmenu", stop);
            if (e && e.domEvent)
                event.stopEvent(e.domEvent);
        }.bind(this);
        setTimeout(stop, 10);
        this.editor.on("nativecontextmenu", stop);
    };
}).call(MouseHandler.prototype);

config.defineOptions(MouseHandler.prototype, "mouseHandler", {
    scrollSpeed: {initialValue: 2},
    dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
    dragEnabled: {initialValue: true},
    focusTimout: {initialValue: 0},
    tooltipFollowsMouse: {initialValue: true}
});


exports.MouseHandler = MouseHandler;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mouse/fold_handler',['require','exports','module'],function(require, exports, module) {
"use strict";

function FoldHandler(editor) {

    editor.on("click", function(e) {
        var position = e.getDocumentPosition();
        var session = editor.session;

        // If the user clicked on a fold, then expand it.
        var fold = session.getFoldAt(position.row, position.column, 1);
        if (fold) {
            if (e.getAccelKey())
                session.removeFold(fold);
            else
                session.expandFold(fold);

            e.stop();
        }
    });

    editor.on("gutterclick", function(e) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

        if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            if (session.foldWidgets && session.foldWidgets[row])
                editor.session.onFoldWidgetClick(row, e);
            if (!editor.isFocused())
                editor.focus();
            e.stop();
        }
    });

    editor.on("gutterdblclick", function(e) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

        if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            var data = session.getParentFoldRangeData(row, true);
            var range = data.range || data.firstRange;

            if (range) {
                row = range.start.row;
                var fold = session.getFoldAt(row, session.getLine(row).length, 1);

                if (fold) {
                    session.removeFold(fold);
                } else {
                    session.addFold("...", range);
                    editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
                }
            }
            e.stop();
        }
    });
}

exports.FoldHandler = FoldHandler;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/keyboard/keybinding',['require','exports','module','../lib/keys','../lib/event'],function(require, exports, module) {
"use strict";

var keyUtil  = require("../lib/keys");
var event = require("../lib/event");

var KeyBinding = function(editor) {
    this.$editor = editor;
    this.$data = {editor: editor};
    this.$handlers = [];
    this.setDefaultHandler(editor.commands);
};

(function() {
    this.setDefaultHandler = function(kb) {
        this.removeKeyboardHandler(this.$defaultHandler);
        this.$defaultHandler = kb;
        this.addKeyboardHandler(kb, 0);
    };

    this.setKeyboardHandler = function(kb) {
        var h = this.$handlers;
        if (h[h.length - 1] == kb)
            return;

        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
            this.removeKeyboardHandler(h[h.length - 1]);

        this.addKeyboardHandler(kb, 1);
    };

    this.addKeyboardHandler = function(kb, pos) {
        if (!kb)
            return;
        if (typeof kb == "function" && !kb.handleKeyboard)
            kb.handleKeyboard = kb;
        var i = this.$handlers.indexOf(kb);
        if (i != -1)
            this.$handlers.splice(i, 1);

        if (pos == undefined)
            this.$handlers.push(kb);
        else
            this.$handlers.splice(pos, 0, kb);

        if (i == -1 && kb.attach)
            kb.attach(this.$editor);
    };

    this.removeKeyboardHandler = function(kb) {
        var i = this.$handlers.indexOf(kb);
        if (i == -1)
            return false;
        this.$handlers.splice(i, 1);
        kb.detach && kb.detach(this.$editor);
        return true;
    };

    this.getKeyboardHandler = function() {
        return this.$handlers[this.$handlers.length - 1];
    };
    
    this.getStatusText = function() {
        var data = this.$data;
        var editor = data.editor;
        return this.$handlers.map(function(h) {
            return h.getStatusText && h.getStatusText(editor, data) || "";
        }).filter(Boolean).join(" ");
    };

    this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
        var toExecute;
        var success = false;
        var commands = this.$editor.commands;

        for (var i = this.$handlers.length; i--;) {
            toExecute = this.$handlers[i].handleKeyboard(
                this.$data, hashId, keyString, keyCode, e
            );
            if (!toExecute || !toExecute.command)
                continue;
            
            // allow keyboardHandler to consume keys
            if (toExecute.command == "null") {
                success = true;
            } else {
                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
            }
            // do not stop input events to not break repeating
            if (success && e && hashId != -1 && 
                toExecute.passEvent != true && toExecute.command.passEvent != true
            ) {
                event.stopEvent(e);
            }
            if (success)
                break;
        }
        
        if (!success && hashId == -1) {
            toExecute = {command: "insertstring"};
            success = commands.exec("insertstring", this.$editor, keyString);
        }
        
        if (success && this.$editor._signal)
            this.$editor._signal("keyboardActivity", toExecute);
        
        return success;
    };

    this.onCommandKey = function(e, hashId, keyCode) {
        var keyString = keyUtil.keyCodeToString(keyCode);
        this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
    };

    this.onTextInput = function(text) {
        this.$callKeyboardHandlers(-1, text);
    };

}).call(KeyBinding.prototype);

exports.KeyBinding = KeyBinding;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/range',['require','exports','module'],function(require, exports, module) {
"use strict";
var comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
/**
 * This object is used in various places to indicate a region within the editor. To better visualize how this works, imagine a rectangle. Each quadrant of the rectangle is analogus to a range, as ranges contain a starting row and starting column, and an ending row, and ending column.
 * @class Range
 **/

/**
 * Creates a new `Range` object with the given starting and ending row and column points.
 * @param {Number} startRow The starting row
 * @param {Number} startColumn The starting column
 * @param {Number} endRow The ending row
 * @param {Number} endColumn The ending column
 *
 * @constructor
 **/
var Range = function(startRow, startColumn, endRow, endColumn) {
    this.start = {
        row: startRow,
        column: startColumn
    };

    this.end = {
        row: endRow,
        column: endColumn
    };
};

(function() {
    /**
     * Returns `true` if and only if the starting row and column, and ending row and column, are equivalent to those given by `range`.
     * @param {Range} range A range to check against
     *
     * @return {Boolean}
     **/
    this.isEqual = function(range) {
        return this.start.row === range.start.row &&
            this.end.row === range.end.row &&
            this.start.column === range.start.column &&
            this.end.column === range.end.column;
    };

    /**
     *
     * Returns a string containing the range's row and column information, given like this:
     * ```
     *    [start.row/start.column] -> [end.row/end.column]
     * ```
     * @return {String}
     **/
    this.toString = function() {
        return ("Range: [" + this.start.row + "/" + this.start.column +
            "] -> [" + this.end.row + "/" + this.end.column + "]");
    };

    /**
     *
     * Returns `true` if the `row` and `column` provided are within the given range. This can better be expressed as returning `true` if:
     * ```javascript
     *    this.start.row <= row <= this.end.row &&
     *    this.start.column <= column <= this.end.column
     * ```
     * @param {Number} row A row to check for
     * @param {Number} column A column to check for
     * @returns {Boolean}
     * @related Range.compare
     **/

    this.contains = function(row, column) {
        return this.compare(row, column) == 0;
    };

    /**
     * Compares `this` range (A) with another range (B).
     * @param {Range} range A range to compare with
     *
     * @related Range.compare
     * @returns {Number} This method returns one of the following numbers:<br/>
     * <br/>
     * * `-2`: (B) is in front of (A), and doesn't intersect with (A)<br/>
     * * `-1`: (B) begins before (A) but ends inside of (A)<br/>
     * * `0`: (B) is completely inside of (A) OR (A) is completely inside of (B)<br/>
     * * `+1`: (B) begins inside of (A) but ends outside of (A)<br/>
     * * `+2`: (B) is after (A) and doesn't intersect with (A)<br/>
     * * `42`: FTW state: (B) ends in (A) but starts outside of (A)
     **/
    this.compareRange = function(range) {
        var cmp,
            end = range.end,
            start = range.start;

        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            } else if (cmp == 0) {
                return 1;
            } else {
                return 0;
            }
        } else if (cmp == -1) {
            return -2;
        } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            } else if (cmp == 1) {
                return 42;
            } else {
                return 0;
            }
        }
    };

    /**
     * Checks the row and column points of `p` with the row and column points of the calling range.
     *
     * @param {Range} p A point to compare with
     *
     * @related Range.compare
     * @returns {Number} This method returns one of the following numbers:<br/>
     * * `0` if the two points are exactly equal<br/>
     * * `-1` if `p.row` is less then the calling range<br/>
     * * `1` if `p.row` is greater than the calling range<br/>
     * <br/>
     * If the starting row of the calling range is equal to `p.row`, and:<br/>
     * * `p.column` is greater than or equal to the calling range's starting column, this returns `0`<br/>
     * * Otherwise, it returns -1<br/>
     *<br/>
     * If the ending row of the calling range is equal to `p.row`, and:<br/>
     * * `p.column` is less than or equal to the calling range's ending column, this returns `0`<br/>
     * * Otherwise, it returns 1<br/>
     **/
    this.comparePoint = function(p) {
        return this.compare(p.row, p.column);
    };

    /**
     * Checks the start and end points of `range` and compares them to the calling range. Returns `true` if the `range` is contained within the caller's range.
     * @param {Range} range A range to compare with
     *
     * @returns {Boolean}
     * @related Range.comparePoint
     **/
    this.containsRange = function(range) {
        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    };

    /**
     * Returns `true` if passed in `range` intersects with the one calling this method.
     * @param {Range} range A range to compare with
     *
     * @returns {Boolean}
     **/
    this.intersects = function(range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    };

    /**
     * Returns `true` if the caller's ending row point is the same as `row`, and if the caller's ending column is the same as `column`.
     * @param {Number} row A row point to compare with
     * @param {Number} column A column point to compare with
     *
     * @returns {Boolean}
     **/
    this.isEnd = function(row, column) {
        return this.end.row == row && this.end.column == column;
    };

    /**
     * Returns `true` if the caller's starting row point is the same as `row`, and if the caller's starting column is the same as `column`.
     * @param {Number} row A row point to compare with
     * @param {Number} column A column point to compare with
     *
     * @returns {Boolean}
     **/
    this.isStart = function(row, column) {
        return this.start.row == row && this.start.column == column;
    };

    /**
     * Sets the starting row and column for the range.
     * @param {Number} row A row point to set
     * @param {Number} column A column point to set
     *
     **/
    this.setStart = function(row, column) {
        if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
        } else {
            this.start.row = row;
            this.start.column = column;
        }
    };

    /**
     * Sets the starting row and column for the range.
     * @param {Number} row A row point to set
     * @param {Number} column A column point to set
     *
     **/
    this.setEnd = function(row, column) {
        if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
        } else {
            this.end.row = row;
            this.end.column = column;
        }
    };

    /**
     * Returns `true` if the `row` and `column` are within the given range.
     * @param {Number} row A row point to compare with
     * @param {Number} column A column point to compare with
     *
     *
     * @returns {Boolean}
     * @related Range.compare
     **/
    this.inside = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };

    /**
     * Returns `true` if the `row` and `column` are within the given range's starting points.
     * @param {Number} row A row point to compare with
     * @param {Number} column A column point to compare with
     *
     * @returns {Boolean}
     * @related Range.compare
     **/
    this.insideStart = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };

    /**
     * Returns `true` if the `row` and `column` are within the given range's ending points.
     * @param {Number} row A row point to compare with
     * @param {Number} column A column point to compare with
     *
     * @returns {Boolean}
     * @related Range.compare
     *
     **/
    this.insideEnd = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };

    /**
     * Checks the row and column points with the row and column points of the calling range.
     * @param {Number} row A row point to compare with
     * @param {Number} column A column point to compare with
     *
     *
     * @returns {Number} This method returns one of the following numbers:<br/>
     * `0` if the two points are exactly equal <br/>
     * `-1` if `p.row` is less then the calling range <br/>
     * `1` if `p.row` is greater than the calling range <br/>
     *  <br/>
     * If the starting row of the calling range is equal to `p.row`, and: <br/>
     * `p.column` is greater than or equal to the calling range's starting column, this returns `0`<br/>
     * Otherwise, it returns -1<br/>
     * <br/>
     * If the ending row of the calling range is equal to `p.row`, and: <br/>
     * `p.column` is less than or equal to the calling range's ending column, this returns `0` <br/>
     * Otherwise, it returns 1
     **/
    this.compare = function(row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
            }
        }

        if (row < this.start.row)
            return -1;

        if (row > this.end.row)
            return 1;

        if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;

        if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;

        return 0;
    };

    /**
     * Checks the row and column points with the row and column points of the calling range.
     * @param {Number} row A row point to compare with
     * @param {Number} column A column point to compare with
     *
     * @returns {Number} This method returns one of the following numbers:<br/>
     * <br/>
     * `0` if the two points are exactly equal<br/>
     * `-1` if `p.row` is less then the calling range<br/>
     * `1` if `p.row` is greater than the calling range, or if `isStart` is `true`.<br/>
     * <br/>
     * If the starting row of the calling range is equal to `p.row`, and:<br/>
     * `p.column` is greater than or equal to the calling range's starting column, this returns `0`<br/>
     * Otherwise, it returns -1<br/>
     * <br/>
     * If the ending row of the calling range is equal to `p.row`, and:<br/>
     * `p.column` is less than or equal to the calling range's ending column, this returns `0`<br/>
     * Otherwise, it returns 1
     *
     **/
    this.compareStart = function(row, column) {
        if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };

    /**
     * Checks the row and column points with the row and column points of the calling range.
     * @param {Number} row A row point to compare with
     * @param {Number} column A column point to compare with
     *
     *
     * @returns {Number} This method returns one of the following numbers:<br/>
     * `0` if the two points are exactly equal<br/>
     * `-1` if `p.row` is less then the calling range<br/>
     * `1` if `p.row` is greater than the calling range, or if `isEnd` is `true.<br/>
     * <br/>
     * If the starting row of the calling range is equal to `p.row`, and:<br/>
     * `p.column` is greater than or equal to the calling range's starting column, this returns `0`<br/>
     * Otherwise, it returns -1<br/>
     *<br/>
     * If the ending row of the calling range is equal to `p.row`, and:<br/>
     * `p.column` is less than or equal to the calling range's ending column, this returns `0`<br/>
     * Otherwise, it returns 1
     */
    this.compareEnd = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else {
            return this.compare(row, column);
        }
    };

    /**
     * Checks the row and column points with the row and column points of the calling range.
     * @param {Number} row A row point to compare with
     * @param {Number} column A column point to compare with
     *
     *
     * @returns {Number} This method returns one of the following numbers:<br/>
     * * `1` if the ending row of the calling range is equal to `row`, and the ending column of the calling range is equal to `column`<br/>
     * * `-1` if the starting row of the calling range is equal to `row`, and the starting column of the calling range is equal to `column`<br/>
     * <br/>
     * Otherwise, it returns the value after calling [[Range.compare `compare()`]].
     *
     **/
    this.compareInside = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };

    /**
     * Returns the part of the current `Range` that occurs within the boundaries of `firstRow` and `lastRow` as a new `Range` object.
     * @param {Number} firstRow The starting row
     * @param {Number} lastRow The ending row
     *
     *
     * @returns {Range}
    **/
    this.clipRows = function(firstRow, lastRow) {
        if (this.end.row > lastRow)
            var end = {row: lastRow + 1, column: 0};
        else if (this.end.row < firstRow)
            var end = {row: firstRow, column: 0};

        if (this.start.row > lastRow)
            var start = {row: lastRow + 1, column: 0};
        else if (this.start.row < firstRow)
            var start = {row: firstRow, column: 0};

        return Range.fromPoints(start || this.start, end || this.end);
    };

    /**
     * Changes the row and column points for the calling range for both the starting and ending points.
     * @param {Number} row A new row to extend to
     * @param {Number} column A new column to extend to
     *
     *
     * @returns {Range} The original range with the new row
    **/
    this.extend = function(row, column) {
        var cmp = this.compare(row, column);

        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = {row: row, column: column};
        else
            var end = {row: row, column: column};

        return Range.fromPoints(start || this.start, end || this.end);
    };

    this.isEmpty = function() {
        return (this.start.row === this.end.row && this.start.column === this.end.column);
    };

    /**
     *
     * Returns `true` if the range spans across multiple lines.
     * @returns {Boolean}
    **/
    this.isMultiLine = function() {
        return (this.start.row !== this.end.row);
    };

    /**
     *
     * Returns a duplicate of the calling range.
     * @returns {Range}
    **/
    this.clone = function() {
        return Range.fromPoints(this.start, this.end);
    };

    /**
     *
     * Returns a range containing the starting and ending rows of the original range, but with a column value of `0`.
     * @returns {Range}
    **/
    this.collapseRows = function() {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0)
        else
            return new Range(this.start.row, 0, this.end.row, 0)
    };

    /**
     * Given the current `Range`, this function converts those starting and ending points into screen positions, and then returns a new `Range` object.
     * @param {EditSession} session The `EditSession` to retrieve coordinates from
     *
     *
     * @returns {Range}
    **/
    this.toScreenRange = function(session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);

        return new Range(
            screenPosStart.row, screenPosStart.column,
            screenPosEnd.row, screenPosEnd.column
        );
    };
    
    
    /* experimental */
    this.moveBy = function(row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
    };

}).call(Range.prototype);

/**
 * Creates and returns a new `Range` based on the row and column of the given parameters.
 * @param {Range} start A starting point to use
 * @param {Range} end An ending point to use
 *
 * @returns {Range}
**/
Range.fromPoints = function(start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};
Range.comparePoints = comparePoints;

Range.comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};


exports.Range = Range;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/selection',['require','exports','module','./lib/oop','./lib/lang','./lib/event_emitter','./range'],function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var lang = require("./lib/lang");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;

/**
 * Contains the cursor position and the text selection of an edit session.
 *
 * The row/columns used in the selection are in document coordinates representing the coordinates as they appear in the document before applying soft wrap and folding.
 * @class Selection
 **/


/**
 * Emitted when the cursor position changes.
 * @event changeCursor
 *
**/
/**
 * Emitted when the cursor selection changes.
 * 
 *  @event changeSelection
**/
/**
 * Creates a new `Selection` object.
 * @param {EditSession} session The session to use
 * 
 * @constructor
 **/
var Selection = function(session) {
    this.session = session;
    this.doc = session.getDocument();

    this.clearSelection();
    this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
    this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);

    var self = this;
    this.lead.on("change", function(e) {
        self._emit("changeCursor");
        if (!self.$isEmpty)
            self._emit("changeSelection");
        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
            self.$desiredColumn = null;
    });

    this.selectionAnchor.on("change", function() {
        if (!self.$isEmpty)
            self._emit("changeSelection");
    });
};

(function() {

    oop.implement(this, EventEmitter);

    /**
    *
    * Returns `true` if the selection is empty.
    * @returns {Boolean}
    **/
    this.isEmpty = function() {
        return (this.$isEmpty || (
            this.anchor.row == this.lead.row &&
            this.anchor.column == this.lead.column
        ));
    };

    /**
    * Returns `true` if the selection is a multi-line.
    * @returns {Boolean}
    **/
    this.isMultiLine = function() {
        if (this.isEmpty()) {
            return false;
        }

        return this.getRange().isMultiLine();
    };

    /**
    * Returns an object containing the `row` and `column` current position of the cursor.
    * @returns {Object}
    **/
    this.getCursor = function() {
        return this.lead.getPosition();
    };

    /**
    * Sets the row and column position of the anchor. This function also emits the `'changeSelection'` event.
    * @param {Number} row The new row
    * @param {Number} column The new column
    *
    *
    **/
    this.setSelectionAnchor = function(row, column) {
        this.anchor.setPosition(row, column);

        if (this.$isEmpty) {
            this.$isEmpty = false;
            this._emit("changeSelection");
        }
    };

    /**
    * Returns an object containing the `row` and `column` of the calling selection anchor.
    *
    * @returns {Object}
    * @related Anchor.getPosition
    **/
    this.getSelectionAnchor = function() {
        if (this.$isEmpty)
            return this.getSelectionLead();
        else
            return this.anchor.getPosition();
    };

    /**
    *
    * Returns an object containing the `row` and `column` of the calling selection lead.
    * @returns {Object}
    **/
    this.getSelectionLead = function() {
        return this.lead.getPosition();
    };

    /**
    * Shifts the selection up (or down, if [[Selection.isBackwards `isBackwards()`]] is true) the given number of columns.
    * @param {Number} columns The number of columns to shift by
    *
    *
    *
    **/
    this.shiftSelection = function(columns) {
        if (this.$isEmpty) {
            this.moveCursorTo(this.lead.row, this.lead.column + columns);
            return;
        }

        var anchor = this.getSelectionAnchor();
        var lead = this.getSelectionLead();

        var isBackwards = this.isBackwards();

        if (!isBackwards || anchor.column !== 0)
            this.setSelectionAnchor(anchor.row, anchor.column + columns);

        if (isBackwards || lead.column !== 0) {
            this.$moveSelection(function() {
                this.moveCursorTo(lead.row, lead.column + columns);
            });
        }
    };

    /**
    * Returns `true` if the selection is going backwards in the document.
    * @returns {Boolean}
    **/
    this.isBackwards = function() {
        var anchor = this.anchor;
        var lead = this.lead;
        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
    };

    /**
    * [Returns the [[Range]] for the selected text.]{: #Selection.getRange}
    * @returns {Range}
    **/
    this.getRange = function() {
        var anchor = this.anchor;
        var lead = this.lead;

        if (this.isEmpty())
            return Range.fromPoints(lead, lead);

        if (this.isBackwards()) {
            return Range.fromPoints(lead, anchor);
        }
        else {
            return Range.fromPoints(anchor, lead);
        }
    };

    /**
    * [Empties the selection (by de-selecting it). This function also emits the `'changeSelection'` event.]{: #Selection.clearSelection}
    **/
    this.clearSelection = function() {
        if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit("changeSelection");
        }
    };

    /**
    * Selects all the text in the document.
    **/
    this.selectAll = function() {
        var lastRow = this.doc.getLength() - 1;
        this.setSelectionAnchor(0, 0);
        this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
    };

    /**
    * Sets the selection to the provided range.
    * @param {Range} range The range of text to select
    * @param {Boolean} reverse Indicates if the range should go backwards (`true`) or not
    *
    *
    * @method setSelectionRange
    * @alias setRange
    **/
    this.setRange =
    this.setSelectionRange = function(range, reverse) {
        if (reverse) {
            this.setSelectionAnchor(range.end.row, range.end.column);
            this.selectTo(range.start.row, range.start.column);
        } else {
            this.setSelectionAnchor(range.start.row, range.start.column);
            this.selectTo(range.end.row, range.end.column);
        }
        if (this.getRange().isEmpty())
            this.$isEmpty = true;
        this.$desiredColumn = null;
    };

    this.$moveSelection = function(mover) {
        var lead = this.lead;
        if (this.$isEmpty)
            this.setSelectionAnchor(lead.row, lead.column);

        mover.call(this);
    };

    /**
    * Moves the selection cursor to the indicated row and column.
    * @param {Number} row The row to select to
    * @param {Number} column The column to select to
    *
    *
    *
    **/
    this.selectTo = function(row, column) {
        this.$moveSelection(function() {
            this.moveCursorTo(row, column);
        });
    };

    /**
    * Moves the selection cursor to the row and column indicated by `pos`.
    * @param {Object} pos An object containing the row and column
    *
    *
    *
    **/
    this.selectToPosition = function(pos) {
        this.$moveSelection(function() {
            this.moveCursorToPosition(pos);
        });
    };

    /**
    * Moves the selection cursor to the indicated row and column.
    * @param {Number} row The row to select to
    * @param {Number} column The column to select to
    *
    **/
    this.moveTo = function(row, column) {
        this.clearSelection();
        this.moveCursorTo(row, column);
    };

    /**
    * Moves the selection cursor to the row and column indicated by `pos`.
    * @param {Object} pos An object containing the row and column
    **/
    this.moveToPosition = function(pos) {
        this.clearSelection();
        this.moveCursorToPosition(pos);
    };


    /**
    *
    * Moves the selection up one row.
    **/
    this.selectUp = function() {
        this.$moveSelection(this.moveCursorUp);
    };

    /**
    *
    * Moves the selection down one row.
    **/
    this.selectDown = function() {
        this.$moveSelection(this.moveCursorDown);
    };

    /**
    *
    *
    * Moves the selection right one column.
    **/
    this.selectRight = function() {
        this.$moveSelection(this.moveCursorRight);
    };

    /**
    *
    * Moves the selection left one column.
    **/
    this.selectLeft = function() {
        this.$moveSelection(this.moveCursorLeft);
    };

    /**
    *
    * Moves the selection to the beginning of the current line.
    **/
    this.selectLineStart = function() {
        this.$moveSelection(this.moveCursorLineStart);
    };

    /**
    *
    * Moves the selection to the end of the current line.
    **/
    this.selectLineEnd = function() {
        this.$moveSelection(this.moveCursorLineEnd);
    };

    /**
    *
    * Moves the selection to the end of the file.
    **/
    this.selectFileEnd = function() {
        this.$moveSelection(this.moveCursorFileEnd);
    };

    /**
    *
    * Moves the selection to the start of the file.
    **/
    this.selectFileStart = function() {
        this.$moveSelection(this.moveCursorFileStart);
    };

    /**
    *
    * Moves the selection to the first word on the right.
    **/
    this.selectWordRight = function() {
        this.$moveSelection(this.moveCursorWordRight);
    };

    /**
    *
    * Moves the selection to the first word on the left.
    **/
    this.selectWordLeft = function() {
        this.$moveSelection(this.moveCursorWordLeft);
    };

    /**
    * Moves the selection to highlight the entire word.
    * @related EditSession.getWordRange
    **/
    this.getWordRange = function(row, column) {
        if (typeof column == "undefined") {
            var cursor = row || this.lead;
            row = cursor.row;
            column = cursor.column;
        }
        return this.session.getWordRange(row, column);
    };

    /**
    *
    * Selects an entire word boundary.
    **/
    this.selectWord = function() {
        this.setSelectionRange(this.getWordRange());
    };

    /**
    * Selects a word, including its right whitespace.
    * @related EditSession.getAWordRange
    **/
    this.selectAWord = function() {
        var cursor = this.getCursor();
        var range = this.session.getAWordRange(cursor.row, cursor.column);
        this.setSelectionRange(range);
    };

    this.getLineRange = function(row, excludeLastChar) {
        var rowStart = typeof row == "number" ? row : this.lead.row;
        var rowEnd;

        var foldLine = this.session.getFoldLine(rowStart);
        if (foldLine) {
            rowStart = foldLine.start.row;
            rowEnd = foldLine.end.row;
        } else {
            rowEnd = rowStart;
        }
        if (excludeLastChar === true)
            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
        else
            return new Range(rowStart, 0, rowEnd + 1, 0);
    };

    /**
    * Selects the entire line.
    **/
    this.selectLine = function() {
        this.setSelectionRange(this.getLineRange());
    };

    /**
    *
    * Moves the cursor up one row.
    **/
    this.moveCursorUp = function() {
        this.moveCursorBy(-1, 0);
    };

    /**
    *
    * Moves the cursor down one row.
    **/
    this.moveCursorDown = function() {
        this.moveCursorBy(1, 0);
    };

    /**
    *
    * Moves the cursor left one column.
    **/
    this.moveCursorLeft = function() {
        var cursor = this.lead.getPosition(),
            fold;

        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
        } else if (cursor.column === 0) {
            // cursor is a line (start
            if (cursor.row > 0) {
                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column-tabSize, cursor.column).split(" ").length-1 == tabSize)
                this.moveCursorBy(0, -tabSize);
            else
                this.moveCursorBy(0, -1);
        }
    };

    /**
    *
    * Moves the cursor right one column.
    **/
    this.moveCursorRight = function() {
        var cursor = this.lead.getPosition(),
            fold;
        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
            this.moveCursorTo(fold.end.row, fold.end.column);
        }
        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
            if (this.lead.row < this.doc.getLength() - 1) {
                this.moveCursorTo(this.lead.row + 1, 0);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            var cursor = this.lead;
            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column+tabSize).split(" ").length-1 == tabSize)
                this.moveCursorBy(0, tabSize);
            else
                this.moveCursorBy(0, 1);
        }
    };

    /**
    *
    * Moves the cursor to the start of the line.
    **/
    this.moveCursorLineStart = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var screenRow = this.session.documentToScreenRow(row, column);

        // Determ the doc-position of the first character at the screen line.
        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);

        // Determ the line
        var beforeCursor = this.session.getDisplayLine(
            row, null, firstColumnPosition.row,
            firstColumnPosition.column
        );

        var leadingSpace = beforeCursor.match(/^\s*/);
        // TODO find better way for emacs mode to override selection behaviors
        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
            firstColumnPosition.column += leadingSpace[0].length;
        this.moveCursorToPosition(firstColumnPosition);
    };

    /**
    *
    * Moves the cursor to the end of the line.
    **/
    this.moveCursorLineEnd = function() {
        var lead = this.lead;
        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
        if (this.lead.column == lineEnd.column) {
            var line = this.session.getLine(lineEnd.row);
            if (lineEnd.column == line.length) {
                var textEnd = line.search(/\s+$/);
                if (textEnd > 0)
                    lineEnd.column = textEnd;
            }
        }

        this.moveCursorTo(lineEnd.row, lineEnd.column);
    };

    /**
    *
    * Moves the cursor to the end of the file.
    **/
    this.moveCursorFileEnd = function() {
        var row = this.doc.getLength() - 1;
        var column = this.doc.getLine(row).length;
        this.moveCursorTo(row, column);
    };

    /**
    *
    * Moves the cursor to the start of the file.
    **/
    this.moveCursorFileStart = function() {
        this.moveCursorTo(0, 0);
    };

    /**
    *
    * Moves the cursor to the word on the right.
    **/
    this.moveCursorLongWordRight = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        var match;
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;

        // skip folds
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            this.moveCursorTo(fold.end.row, fold.end.column);
            return;
        }

        // first skip space
        if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
            column += this.session.nonTokenRe.lastIndex;
            this.session.nonTokenRe.lastIndex = 0;
            rightOfCursor = line.substring(column);
        }

        // if at line end proceed with next line
        if (column >= line.length) {
            this.moveCursorTo(row, line.length);
            this.moveCursorRight();
            if (row < this.doc.getLength() - 1)
                this.moveCursorWordRight();
            return;
        }

        // advance to the end of the next token
        if (match = this.session.tokenRe.exec(rightOfCursor)) {
            column += this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    };

    /**
    *
    * Moves the cursor to the word on the left.
    **/
    this.moveCursorLongWordLeft = function() {
        var row = this.lead.row;
        var column = this.lead.column;

        // skip folds
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
            return;
        }

        var str = this.session.getFoldStringAt(row, column, -1);
        if (str == null) {
            str = this.doc.getLine(row).substring(0, column);
        }

        var leftOfCursor = lang.stringReverse(str);
        var match;
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;

        // skip whitespace
        if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
            column -= this.session.nonTokenRe.lastIndex;
            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
            this.session.nonTokenRe.lastIndex = 0;
        }

        // if at begin of the line proceed in line above
        if (column <= 0) {
            this.moveCursorTo(row, 0);
            this.moveCursorLeft();
            if (row > 0)
                this.moveCursorWordLeft();
            return;
        }

        // move to the begin of the word
        if (match = this.session.tokenRe.exec(leftOfCursor)) {
            column -= this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    };

    this.$shortWordEndIndex = function(rightOfCursor) {
        var match, index = 0, ch;
        var whitespaceRe = /\s/;
        var tokenRe = this.session.tokenRe;

        tokenRe.lastIndex = 0;
        if (match = this.session.tokenRe.exec(rightOfCursor)) {
            index = this.session.tokenRe.lastIndex;
        } else {
            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                index ++;

            if (index < 1) {
                tokenRe.lastIndex = 0;
                 while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                    tokenRe.lastIndex = 0;
                    index ++;
                    if (whitespaceRe.test(ch)) {
                        if (index > 2) {
                            index--;
                            break;
                        } else {
                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                                index ++;
                            if (index > 2)
                                break;
                        }
                    }
                }
            }
        }
        tokenRe.lastIndex = 0;

        return index;
    };

    this.moveCursorShortWordRight = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        var fold = this.session.getFoldAt(row, column, 1);
        if (fold)
            return this.moveCursorTo(fold.end.row, fold.end.column);

        if (column == line.length) {
            var l = this.doc.getLength();
            do {
                row++;
                rightOfCursor = this.doc.getLine(row);
            } while (row < l && /^\s*$/.test(rightOfCursor));

            if (!/^\s+/.test(rightOfCursor))
                rightOfCursor = "";
            column = 0;
        }

        var index = this.$shortWordEndIndex(rightOfCursor);

        this.moveCursorTo(row, column + index);
    };

    this.moveCursorShortWordLeft = function() {
        var row = this.lead.row;
        var column = this.lead.column;

        var fold;
        if (fold = this.session.getFoldAt(row, column, -1))
            return this.moveCursorTo(fold.start.row, fold.start.column);

        var line = this.session.getLine(row).substring(0, column);
        if (column === 0) {
            do {
                row--;
                line = this.doc.getLine(row);
            } while (row > 0 && /^\s*$/.test(line));

            column = line.length;
            if (!/\s+$/.test(line))
                line = "";
        }

        var leftOfCursor = lang.stringReverse(line);
        var index = this.$shortWordEndIndex(leftOfCursor);

        return this.moveCursorTo(row, column - index);
    };

    this.moveCursorWordRight = function() {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordRight();
        else
            this.moveCursorShortWordRight();
    };

    this.moveCursorWordLeft = function() {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordLeft();
        else
            this.moveCursorShortWordLeft();
    };

    /**
    * Moves the cursor to position indicated by the parameters. Negative numbers move the cursor backwards in the document.
    * @param {Number} rows The number of rows to move by
    * @param {Number} chars The number of characters to move by
    *
    *
    * @related EditSession.documentToScreenPosition
    **/
    this.moveCursorBy = function(rows, chars) {
        var screenPos = this.session.documentToScreenPosition(
            this.lead.row,
            this.lead.column
        );

        if (chars === 0) {
            if (this.$desiredColumn)
                screenPos.column = this.$desiredColumn;
            else
                this.$desiredColumn = screenPos.column;
        }

        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);
        
        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
            if (this.session.lineWidgets && this.session.lineWidgets[docPos.row]) {
                if (docPos.row > 0 || rows > 0)
                    docPos.row++;
            }
        }

        // move the cursor and update the desired column
        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
    };

    /**
    * Moves the selection to the position indicated by its `row` and `column`.
    * @param {Object} position The position to move to
    *
    *
    **/
    this.moveCursorToPosition = function(position) {
        this.moveCursorTo(position.row, position.column);
    };

    /**
     * Moves the cursor to the row and column provided. [If `preventUpdateDesiredColumn` is `true`, then the cursor stays in the same column position as its original point.]{: #preventUpdateBoolDesc}
     * @param {Number} row The row to move to
     * @param {Number} column The column to move to
     * @param {Boolean} keepDesiredColumn [If `true`, the cursor move does not respect the previous column]{: #preventUpdateBool}
     *
     **/
    this.moveCursorTo = function(row, column, keepDesiredColumn) {
        // Ensure the row/column is not inside of a fold.
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            row = fold.start.row;
            column = fold.start.column;
        }

        this.$keepDesiredColumnOnChange = true;
        this.lead.setPosition(row, column);
        this.$keepDesiredColumnOnChange = false;

        if (!keepDesiredColumn)
            this.$desiredColumn = null;
    };

    /**
     * Moves the cursor to the screen position indicated by row and column. {:preventUpdateBoolDesc}
     * @param {Number} row The row to move to
     * @param {Number} column The column to move to
     * @param {Boolean} keepDesiredColumn {:preventUpdateBool}
     *
     **/
    this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
        var pos = this.session.screenToDocumentPosition(row, column);
        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
    };

    // remove listeners from document
    this.detach = function() {
        this.lead.detach();
        this.anchor.detach();
        this.session = this.doc = null;
    };

    this.fromOrientedRange = function(range) {
        this.setSelectionRange(range, range.cursor == range.start);
        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
    };

    this.toOrientedRange = function(range) {
        var r = this.getRange();
        if (range) {
            range.start.column = r.start.column;
            range.start.row = r.start.row;
            range.end.column = r.end.column;
            range.end.row = r.end.row;
        } else {
            range = r;
        }

        range.cursor = this.isBackwards() ? range.start : range.end;
        range.desiredColumn = this.$desiredColumn;
        return range;
    };

    /**
     * Saves the current cursor position and calls `func` that can change the cursor
     * postion. The result is the range of the starting and eventual cursor position.
     * Will reset the cursor position.
     * @param {Function} The callback that should change the cursor position
     * @returns {Range}
     *
     **/
    this.getRangeOfMovements = function(func) {
        var start = this.getCursor();
        try {
            func(this);
            var end = this.getCursor();
            return Range.fromPoints(start,end);
        } catch(e) {
            return Range.fromPoints(start,start);
        } finally {
            this.moveCursorToPosition(start);
        }
    };

    this.toJSON = function() {
        if (this.rangeCount) {
            var data = this.ranges.map(function(r) {
                var r1 = r.clone();
                r1.isBackwards = r.cursor == r.start;
                return r1;
            });
        } else {
            var data = this.getRange();
            data.isBackwards = this.isBackwards();
        }
        return data;
    };

    this.fromJSON = function(data) {
        if (data.start == undefined) {
            if (this.rangeList) {
                this.toSingleRange(data[0]);
                for (var i = data.length; i--; ) {
                    var r = Range.fromPoints(data[i].start, data[i].end);
                    if (data[i].isBackwards)
                        r.cursor = r.start;
                    this.addRange(r, true);
                }
                return;
            } else
                data = data[0];
        }
        if (this.rangeList)
            this.toSingleRange(data);
        this.setSelectionRange(data, data.isBackwards);
    };

    this.isEqual = function(data) {
        if ((data.length || this.rangeCount) && data.length != this.rangeCount)
            return false;
        if (!data.length || !this.ranges)
            return this.getRange().isEqual(data);

        for (var i = this.ranges.length; i--; ) {
            if (!this.ranges[i].isEqual(data[i]))
                return false;
        }
        return true;
    };

}).call(Selection.prototype);

exports.Selection = Selection;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/tokenizer',['require','exports','module','./config'],function(require, exports, module) {
"use strict";

var config = require("./config");
// tokenizing lines longer than this makes editor very slow
var MAX_TOKEN_COUNT = 2000;
/**
 * This class takes a set of highlighting rules, and creates a tokenizer out of them. For more information, see [the wiki on extending highlighters](https://github.com/ajaxorg/ace/wiki/Creating-or-Extending-an-Edit-Mode#wiki-extendingTheHighlighter).
 * @class Tokenizer
 **/

/**
 * Constructs a new tokenizer based on the given rules and flags.
 * @param {Object} rules The highlighting rules
 *
 * @constructor
 **/
var Tokenizer = function(rules) {
    this.states = rules;

    this.regExps = {};
    this.matchMappings = {};
    for (var key in this.states) {
        var state = this.states[key];
        var ruleRegExps = [];
        var matchTotal = 0;
        var mapping = this.matchMappings[key] = {defaultToken: "text"};
        var flag = "g";

        var splitterRurles = [];
        for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            if (rule.defaultToken)
                mapping.defaultToken = rule.defaultToken;
            if (rule.caseInsensitive)
                flag = "gi";
            if (rule.regex == null)
                continue;

            if (rule.regex instanceof RegExp)
                rule.regex = rule.regex.toString().slice(1, -1);

            // Count number of matching groups. 2 extra groups from the full match
            // And the catch-all on the end (used to force a match);
            var adjustedregex = rule.regex;
            var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
            if (Array.isArray(rule.token)) {
                if (rule.token.length == 1 || matchcount == 1) {
                    rule.token = rule.token[0];
                } else if (matchcount - 1 != rule.token.length) {
                    this.reportError("number of classes and regexp groups doesn't match", { 
                        rule: rule,
                        groupCount: matchcount - 1
                    });
                    rule.token = rule.token[0];
                } else {
                    rule.tokenArray = rule.token;
                    rule.token = null;
                    rule.onMatch = this.$arrayTokens;
                }
            } else if (typeof rule.token == "function" && !rule.onMatch) {
                if (matchcount > 1)
                    rule.onMatch = this.$applyToken;
                else
                    rule.onMatch = rule.token;
            }

            if (matchcount > 1) {
                if (/\\\d/.test(rule.regex)) {
                    // Replace any backreferences and offset appropriately.
                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                        return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                    });
                } else {
                    matchcount = 1;
                    adjustedregex = this.removeCapturingGroups(rule.regex);
                }
                if (!rule.splitRegex && typeof rule.token != "string")
                    splitterRurles.push(rule); // flag will be known only at the very end
            }

            mapping[matchTotal] = i;
            matchTotal += matchcount;

            ruleRegExps.push(adjustedregex);

            // makes property access faster
            if (!rule.onMatch)
                rule.onMatch = null;
        }
        
        if (!ruleRegExps.length) {
            mapping[0] = 0;
            ruleRegExps.push("$");
        }
        
        splitterRurles.forEach(function(rule) {
            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
        }, this);

        this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
    }
};

(function() {
    this.$setMaxTokenCount = function(m) {
        MAX_TOKEN_COUNT = m | 0;
    };
    
    this.$applyToken = function(str) {
        var values = this.splitRegex.exec(str).slice(1);
        var types = this.token.apply(this, values);

        // required for compatibility with old modes
        if (typeof types === "string")
            return [{type: types, value: str}];

        var tokens = [];
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i]
                };
        }
        return tokens;
    };

    this.$arrayTokens = function(str) {
        if (!str)
            return [];
        var values = this.splitRegex.exec(str);
        if (!values)
            return "text";
        var tokens = [];
        var types = this.tokenArray;
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i + 1])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i + 1]
                };
        }
        return tokens;
    };

    this.removeCapturingGroups = function(src) {
        var r = src.replace(
            /\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g,
            function(x, y) {return y ? "(?:" : x;}
        );
        return r;
    };

    this.createSplitterRegexp = function(src, flag) {
        if (src.indexOf("(?=") != -1) {
            var stack = 0;
            var inChClass = false;
            var lastCapture = {};
            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(
                m, esc, parenOpen, parenClose, square, index
            ) {
                if (inChClass) {
                    inChClass = square != "]";
                } else if (square) {
                    inChClass = true;
                } else if (parenClose) {
                    if (stack == lastCapture.stack) {
                        lastCapture.end = index+1;
                        lastCapture.stack = -1;
                    }
                    stack--;
                } else if (parenOpen) {
                    stack++;
                    if (parenOpen.length != 1) {
                        lastCapture.stack = stack
                        lastCapture.start = index;
                    }
                }
                return m;
            });

            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
        }
        
        // this is needed for regexps that can match in multiple ways
        if (src.charAt(0) != "^") src = "^" + src;
        if (src.charAt(src.length - 1) != "$") src += "$";
        
        return new RegExp(src, (flag||"").replace("g", ""));
    };

    /**
     * Returns an object containing two properties: `tokens`, which contains all the tokens; and `state`, the current state.
     * @returns {Object}
     **/
    this.getLineTokens = function(line, startState) {
        if (startState && typeof startState != "string") {
            var stack = startState.slice(0);
            startState = stack[0];
            if (startState === "#tmp") {
                stack.shift()
                startState = stack.shift()
            }
        } else
            var stack = [];

        var currentState = startState || "start";
        var state = this.states[currentState];
        if (!state) {
            currentState = "start";
            state = this.states[currentState];
        }
        var mapping = this.matchMappings[currentState];
        var re = this.regExps[currentState];
        re.lastIndex = 0;

        var match, tokens = [];
        var lastIndex = 0;
        var matchAttempts = 0;

        var token = {type: null, value: ""};

        while (match = re.exec(line)) {
            var type = mapping.defaultToken;
            var rule = null;
            var value = match[0];
            var index = re.lastIndex;

            if (index - value.length > lastIndex) {
                var skipped = line.substring(lastIndex, index - value.length);
                if (token.type == type) {
                    token.value += skipped;
                } else {
                    if (token.type)
                        tokens.push(token);
                    token = {type: type, value: skipped};
                }
            }

            for (var i = 0; i < match.length-2; i++) {
                if (match[i + 1] === undefined)
                    continue;

                rule = state[mapping[i]];

                if (rule.onMatch)
                    type = rule.onMatch(value, currentState, stack);
                else
                    type = rule.token;

                if (rule.next) {
                    if (typeof rule.next == "string") {
                        currentState = rule.next;
                    } else {
                        currentState = rule.next(currentState, stack);
                    }
                    
                    state = this.states[currentState];
                    if (!state) {
                        this.reportError("state doesn't exist", currentState);
                        currentState = "start";
                        state = this.states[currentState];
                    }
                    mapping = this.matchMappings[currentState];
                    lastIndex = index;
                    re = this.regExps[currentState];
                    re.lastIndex = index;
                }
                break;
            }

            if (value) {
                if (typeof type === "string") {
                    if ((!rule || rule.merge !== false) && token.type === type) {
                        token.value += value;
                    } else {
                        if (token.type)
                            tokens.push(token);
                        token = {type: type, value: value};
                    }
                } else if (type) {
                    if (token.type)
                        tokens.push(token);
                    token = {type: null, value: ""};
                    for (var i = 0; i < type.length; i++)
                        tokens.push(type[i]);
                }
            }

            if (lastIndex == line.length)
                break;

            lastIndex = index;

            if (matchAttempts++ > MAX_TOKEN_COUNT) {
                if (matchAttempts > 2 * line.length) {
                    this.reportError("infinite loop with in ace tokenizer", {
                        startState: startState,
                        line: line
                    });
                }
                // chrome doens't show contents of text nodes with very long text
                while (lastIndex < line.length) {
                    if (token.type)
                        tokens.push(token);
                    token = {
                        value: line.substring(lastIndex, lastIndex += 2000),
                        type: "overflow"
                    };
                }
                currentState = "start";
                stack = [];
                break;
            }
        }

        if (token.type)
            tokens.push(token);
        
        if (stack.length > 1) {
            if (stack[0] !== currentState)
                stack.unshift("#tmp", currentState);
        }
        return {
            tokens : tokens,
            state : stack.length ? stack : currentState
        };
    };
    
    this.reportError = config.reportError;
    
}).call(Tokenizer.prototype);

exports.Tokenizer = Tokenizer;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/text_highlight_rules',['require','exports','module','../lib/lang'],function(require, exports, module) {
"use strict";

var lang = require("../lib/lang");

var TextHighlightRules = function() {

    // regexp must not have capturing parentheses
    // regexps are ordered -> the first match is used

    this.$rules = {
        "start" : [{
            token : "empty_line",
            regex : '^$'
        }, {
            defaultToken : "text"
        }]
    };
};

(function() {

    this.addRules = function(rules, prefix) {
        if (!prefix) {
            for (var key in rules)
                this.$rules[key] = rules[key];
            return;
        }
        for (var key in rules) {
            var state = rules[key];
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.next || rule.onMatch) {
                    if (typeof rule.next == "string") {
                        if (rule.next.indexOf(prefix) !== 0)
                            rule.next = prefix + rule.next;
                    }
                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                        rule.nextState = prefix + rule.nextState;
                }
            }
            this.$rules[prefix + key] = state;
        }
    };

    this.getRules = function() {
        return this.$rules;
    };

    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
        var embedRules = typeof HighlightRules == "function"
            ? new HighlightRules().getRules()
            : HighlightRules;
        if (states) {
            for (var i = 0; i < states.length; i++)
                states[i] = prefix + states[i];
        } else {
            states = [];
            for (var key in embedRules)
                states.push(prefix + key);
        }

        this.addRules(embedRules, prefix);

        if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i = 0; i < states.length; i++)
                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
        }

        if (!this.$embeds)
            this.$embeds = [];
        this.$embeds.push(prefix);
    };

    this.getEmbeds = function() {
        return this.$embeds;
    };

    var pushState = function(currentState, stack) {
        if (currentState != "start" || stack.length)
            stack.unshift(this.nextState, currentState);
        return this.nextState;
    };
    var popState = function(currentState, stack) {
        // if (stack[0] === currentState)
        stack.shift();
        return stack.shift() || "start";
    };

    this.normalizeRules = function() {
        var id = 0;
        var rules = this.$rules;
        function processState(key) {
            var state = rules[key];
            state.processed = true;
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                var toInsert = null;
                if (Array.isArray(rule)) {
                    toInsert = rule;
                    rule = {};
                }
                if (!rule.regex && rule.start) {
                    rule.regex = rule.start;
                    if (!rule.next)
                        rule.next = [];
                    rule.next.push({
                        defaultToken: rule.token
                    }, {
                        token: rule.token + ".end",
                        regex: rule.end || rule.start,
                        next: "pop"
                    });
                    rule.token = rule.token + ".start";
                    rule.push = true;
                }
                var next = rule.next || rule.push;
                if (next && Array.isArray(next)) {
                    var stateName = rule.stateName;
                    if (!stateName)  {
                        stateName = rule.token;
                        if (typeof stateName != "string")
                            stateName = stateName[0] || "";
                        if (rules[stateName])
                            stateName += id++;
                    }
                    rules[stateName] = next;
                    rule.next = stateName;
                    processState(stateName);
                } else if (next == "pop") {
                    rule.next = popState;
                }

                if (rule.push) {
                    rule.nextState = rule.next || rule.push;
                    rule.next = pushState;
                    delete rule.push;
                }

                if (rule.rules) {
                    for (var r in rule.rules) {
                        if (rules[r]) {
                            if (rules[r].push)
                                rules[r].push.apply(rules[r], rule.rules[r]);
                        } else {
                            rules[r] = rule.rules[r];
                        }
                    }
                }
                var includeName = typeof rule == "string"
                    ? rule
                    : typeof rule.include == "string"
                    ? rule.include
                    : "";
                if (includeName) {
                    toInsert = rules[includeName];
                }

                if (toInsert) {
                    var args = [i, 1].concat(toInsert);
                    if (rule.noEscape)
                        args = args.filter(function(x) {return !x.next;});
                    state.splice.apply(state, args);
                    // skip included rules since they are already processed
                    //i += args.length - 3;
                    i--;
                }
                
                if (rule.keywordMap) {
                    rule.token = this.createKeywordMapper(
                        rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive
                    );
                    delete rule.defaultToken;
                }
            }
        }
        Object.keys(rules).forEach(processState, this);
    };

    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
        var keywords = Object.create(null);
        Object.keys(map).forEach(function(className) {
            var a = map[className];
            if (ignoreCase)
                a = a.toLowerCase();
            var list = a.split(splitChar || "|");
            for (var i = list.length; i--; )
                keywords[list[i]] = className;
        });
        // in old versions of opera keywords["__proto__"] sets prototype
        // even on objects with __proto__=null
        if (Object.getPrototypeOf(keywords)) {
            keywords.__proto__ = null;
        }
        this.$keywordList = Object.keys(keywords);
        map = null;
        return ignoreCase
            ? function(value) {return keywords[value.toLowerCase()] || defaultToken }
            : function(value) {return keywords[value] || defaultToken };
    };

    this.getKeywords = function() {
        return this.$keywords;
    };

}).call(TextHighlightRules.prototype);

exports.TextHighlightRules = TextHighlightRules;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/behaviour',['require','exports','module'],function(require, exports, module) {
"use strict";

var Behaviour = function() {
   this.$behaviours = {};
};

(function () {

    this.add = function (name, action, callback) {
        switch (undefined) {
          case this.$behaviours:
              this.$behaviours = {};
          case this.$behaviours[name]:
              this.$behaviours[name] = {};
        }
        this.$behaviours[name][action] = callback;
    }
    
    this.addBehaviours = function (behaviours) {
        for (var key in behaviours) {
            for (var action in behaviours[key]) {
                this.add(key, action, behaviours[key][action]);
            }
        }
    }
    
    this.remove = function (name) {
        if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
        }
    }
    
    this.inherit = function (mode, filter) {
        if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter);
        } else {
            var behaviours = mode.getBehaviours(filter);
        }
        this.addBehaviours(behaviours);
    }
    
    this.getBehaviours = function (filter) {
        if (!filter) {
            return this.$behaviours;
        } else {
            var ret = {}
            for (var i = 0; i < filter.length; i++) {
                if (this.$behaviours[filter[i]]) {
                    ret[filter[i]] = this.$behaviours[filter[i]];
                }
            }
            return ret;
        }
    }

}).call(Behaviour.prototype);

exports.Behaviour = Behaviour;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/token_iterator',['require','exports','module'],function(require, exports, module) {
"use strict";

/**
 * 
 *
 * This class provides an essay way to treat the document as a stream of tokens, and provides methods to iterate over these tokens.
 * @class TokenIterator
 **/

/**
 * Creates a new token iterator object. The inital token index is set to the provided row and column coordinates.
 * @param {EditSession} session The session to associate with
 * @param {Number} initialRow The row to start the tokenizing at
 * @param {Number} initialColumn The column to start the tokenizing at
 *
 * @constructor
 **/
var TokenIterator = function(session, initialRow, initialColumn) {
    this.$session = session;
    this.$row = initialRow;
    this.$rowTokens = session.getTokens(initialRow);

    var token = session.getTokenAt(initialRow, initialColumn);
    this.$tokenIndex = token ? token.index : -1;
};

(function() {
   
    /**
     * Tokenizes all the items from the current point to the row prior in the document. 
     * @returns {[String]} If the current point is not at the top of the file, this function returns `null`. Otherwise, it returns an array of the tokenized strings.
     **/ 
    this.stepBackward = function() {
        this.$tokenIndex -= 1;
        
        while (this.$tokenIndex < 0) {
            this.$row -= 1;
            if (this.$row < 0) {
                this.$row = 0;
                return null;
            }
                
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = this.$rowTokens.length - 1;
        }
            
        return this.$rowTokens[this.$tokenIndex];
    };
  
    /**
     * Tokenizes all the items from the current point until the next row in the document. If the current point is at the end of the file, this function returns `null`. Otherwise, it returns the tokenized string.
     * @returns {String}
     **/   
    this.stepForward = function() {
        this.$tokenIndex += 1;
        var rowCount;
        while (this.$tokenIndex >= this.$rowTokens.length) {
            this.$row += 1;
            if (!rowCount)
                rowCount = this.$session.getLength();
            if (this.$row >= rowCount) {
                this.$row = rowCount - 1;
                return null;
            }

            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = 0;
        }
            
        return this.$rowTokens[this.$tokenIndex];
    };
 
    /**
     * 
     * Returns the current tokenized string.
     * @returns {String}
     **/      
    this.getCurrentToken = function () {
        return this.$rowTokens[this.$tokenIndex];
    };

    /**
     * 
     * Returns the current row.
     * @returns {Number}
     **/      
    this.getCurrentTokenRow = function () {
        return this.$row;
    };

    /**
     * 
     * Returns the current column.
     * @returns {Number}
     **/     
    this.getCurrentTokenColumn = function() {
        var rowTokens = this.$rowTokens;
        var tokenIndex = this.$tokenIndex;
        
        // If a column was cached by EditSession.getTokenAt, then use it
        var column = rowTokens[tokenIndex].start;
        if (column !== undefined)
            return column;
            
        column = 0;
        while (tokenIndex > 0) {
            tokenIndex -= 1;
            column += rowTokens[tokenIndex].value.length;
        }
        
        return column;  
    };

    /**
     * Return the current token position.
     * @returns {Position}
     */
    this.getCurrentTokenPosition = function() {
        return {row: this.$row, column: this.getCurrentTokenColumn()};
    };
            
}).call(TokenIterator.prototype);

exports.TokenIterator = TokenIterator;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/behaviour/cstyle',['require','exports','module','../../lib/oop','../behaviour','../../token_iterator','../../lib/lang'],function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Behaviour = require("../behaviour").Behaviour;
var TokenIterator = require("../../token_iterator").TokenIterator;
var lang = require("../../lib/lang");

var SAFE_INSERT_IN_TOKENS =
    ["text", "paren.rparen", "punctuation.operator"];
var SAFE_INSERT_BEFORE_TOKENS =
    ["text", "paren.rparen", "punctuation.operator", "comment"];

var context;
var contextCache = {};
var initContext = function(editor) {
    var id = -1;
    if (editor.multiSelect) {
        id = editor.selection.index;
        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
            contextCache = {rangeCount: editor.multiSelect.rangeCount};
    }
    if (contextCache[id])
        return context = contextCache[id];
    context = contextCache[id] = {
        autoInsertedBrackets: 0,
        autoInsertedRow: -1,
        autoInsertedLineEnd: "",
        maybeInsertedBrackets: 0,
        maybeInsertedRow: -1,
        maybeInsertedLineStart: "",
        maybeInsertedLineEnd: ""
    };
};

var getWrapped = function(selection, selected, opening, closing) {
    var rowDiff = selection.end.row - selection.start.row;
    return {
        text: opening + selected + closing,
        selection: [
                0,
                selection.start.column + 1,
                rowDiff,
                selection.end.column + (rowDiff ? 0 : 1)
            ]
    };
};

var CstyleBehaviour = function() {
    this.add("braces", "insertion", function(state, action, editor, session, text) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (text == '{') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '{', '}');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {
                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
                    return {
                        text: '{}',
                        selection: [1, 1]
                    };
                } else {
                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                    return {
                        text: '{',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == '}') {
            initContext(editor);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == '}') {
                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == "\n" || text == "\r\n") {
            initContext(editor);
            var closing = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === '}') {
                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
                if (!openBracePos)
                     return null;
                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            } else if (closing) {
                var next_indent = this.$getIndent(line);
            } else {
                CstyleBehaviour.clearMaybeInsertedClosing();
                return;
            }
            var indent = next_indent + session.getTabString();

            return {
                text: '\n' + indent + '\n' + next_indent + closing,
                selection: [1, indent.length, 1, indent.length]
            };
        } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
        }
    });

    this.add("braces", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '{') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == '}') {
                range.end.column++;
                return range;
            } else {
                context.maybeInsertedBrackets--;
            }
        }
    });

    this.add("parens", "insertion", function(state, action, editor, session, text) {
        if (text == '(') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '(', ')');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, ")");
                return {
                    text: '()',
                    selection: [1, 1]
                };
            }
        } else if (text == ')') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ')') {
                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("parens", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '(') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ')') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("brackets", "insertion", function(state, action, editor, session, text) {
        if (text == '[') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '[', ']');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, "]");
                return {
                    text: '[]',
                    selection: [1, 1]
                };
            }
        } else if (text == ']') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ']') {
                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("brackets", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '[') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ']') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
        if (text == '"' || text == "'") {
            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1) 
                return;
            initContext(editor);
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, quote, quote);
            } else if (!selected) {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var leftChar = line.substring(cursor.column-1, cursor.column);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                
                var token = session.getTokenAt(cursor.row, cursor.column);
                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                // We're escaped.
                if (leftChar == "\\" && token && /escape/.test(token.type))
                    return null;
                
                var stringBefore = token && /string|escape/.test(token.type);
                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
                
                var pair;
                if (rightChar == quote) {
                    pair = stringBefore !== stringAfter;
                    if (pair && /string\.end/.test(rightToken.type))
                        pair = false;
                } else {
                    if (stringBefore && !stringAfter)
                        return null; // wrap string with different quote
                    if (stringBefore && stringAfter)
                        return null; // do not pair quotes inside strings
                    var wordRe = session.$mode.tokenRe;
                    wordRe.lastIndex = 0;
                    var isWordBefore = wordRe.test(leftChar);
                    wordRe.lastIndex = 0;
                    var isWordAfter = wordRe.test(leftChar);
                    if (isWordBefore || isWordAfter)
                        return null; // before or after alphanumeric
                    if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                        return null; // there is rightChar and it isn't closing
                    pair = true;
                }
                return {
                    text: pair ? quote + quote : "",
                    selection: [1,1]
                };
            }
        }
    });

    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
                range.end.column++;
                return range;
            }
        }
    });

};

    
CstyleBehaviour.isSaneInsertion = function(editor, session) {
    var cursor = editor.getCursorPosition();
    var iterator = new TokenIterator(session, cursor.row, cursor.column);
    
    // Don't insert in the middle of a keyword/identifier/lexical
    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
        // Look ahead in case we're at the end of a token
        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
            return false;
    }
    
    // Only insert in front of whitespace/comments
    iterator.stepForward();
    return iterator.getCurrentTokenRow() !== cursor.row ||
        this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
};

CstyleBehaviour.$matchTokenType = function(token, types) {
    return types.indexOf(token.type || token) > -1;
};

CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    // Reset previous state if text or context changed too much
    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
        context.autoInsertedBrackets = 0;
    context.autoInsertedRow = cursor.row;
    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
    context.autoInsertedBrackets++;
};

CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isMaybeInsertedClosing(cursor, line))
        context.maybeInsertedBrackets = 0;
    context.maybeInsertedRow = cursor.row;
    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
    context.maybeInsertedLineEnd = line.substr(cursor.column);
    context.maybeInsertedBrackets++;
};

CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
    return context.autoInsertedBrackets > 0 &&
        cursor.row === context.autoInsertedRow &&
        bracket === context.autoInsertedLineEnd[0] &&
        line.substr(cursor.column) === context.autoInsertedLineEnd;
};

CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
    return context.maybeInsertedBrackets > 0 &&
        cursor.row === context.maybeInsertedRow &&
        line.substr(cursor.column) === context.maybeInsertedLineEnd &&
        line.substr(0, cursor.column) == context.maybeInsertedLineStart;
};

CstyleBehaviour.popAutoInsertedClosing = function() {
    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
    context.autoInsertedBrackets--;
};

CstyleBehaviour.clearMaybeInsertedClosing = function() {
    if (context) {
        context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = -1;
    }
};



oop.inherits(CstyleBehaviour, Behaviour);

exports.CstyleBehaviour = CstyleBehaviour;
});

define('bower_components/ace/lib/ace/unicode',['require','exports','module'],function(require, exports, module) {
"use strict";

/*
XRegExp Unicode plugin pack: Categories 1.0
(c) 2010 Steven Levithan
MIT License
<http://xregexp.com>
Uses the Unicode 5.2 character database

This package for the XRegExp Unicode plugin enables the following Unicode categories (aka properties):

L - Letter (the top-level Letter category is included in the Unicode plugin base script)
    Ll - Lowercase letter
    Lu - Uppercase letter
    Lt - Titlecase letter
    Lm - Modifier letter
    Lo - Letter without case
M - Mark
    Mn - Non-spacing mark
    Mc - Spacing combining mark
    Me - Enclosing mark
N - Number
    Nd - Decimal digit
    Nl - Letter number
    No -  Other number
P - Punctuation
    Pd - Dash punctuation
    Ps - Open punctuation
    Pe - Close punctuation
    Pi - Initial punctuation
    Pf - Final punctuation
    Pc - Connector punctuation
    Po - Other punctuation
S - Symbol
    Sm - Math symbol
    Sc - Currency symbol
    Sk - Modifier symbol
    So - Other symbol
Z - Separator
    Zs - Space separator
    Zl - Line separator
    Zp - Paragraph separator
C - Other
    Cc - Control
    Cf - Format
    Co - Private use
    Cs - Surrogate
    Cn - Unassigned

Example usage:

    \p{N}
    \p{Cn}
*/


// will be populated by addUnicodePackage
exports.packages = {};

addUnicodePackage({
    L:  "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
    Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
    Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
    Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
    Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
    Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
    M:  "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
    Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
    Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
    Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
    N:  "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
    Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
    Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
    No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
    P:  "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
    Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
    Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
    Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
    Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
    Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
    Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
    Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
    S:  "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
    Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
    Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
    Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
    So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
    Z:  "002000A01680180E2000-200A20282029202F205F3000",
    Zs: "002000A01680180E2000-200A202F205F3000",
    Zl: "2028",
    Zp: "2029",
    C:  "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
    Cc: "0000-001F007F-009F",
    Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
    Co: "E000-F8FF",
    Cs: "D800-DFFF",
    Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
});

function addUnicodePackage (pack) {
    var codePoint = /\w{4}/g;
    for (var name in pack)
        exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
}

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/text',['require','exports','module','../tokenizer','./text_highlight_rules','./behaviour/cstyle','../unicode','../lib/lang','../token_iterator','../range'],function(require, exports, module) {
"use strict";

var Tokenizer = require("../tokenizer").Tokenizer;
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
var unicode = require("../unicode");
var lang = require("../lib/lang");
var TokenIterator = require("../token_iterator").TokenIterator;
var Range = require("../range").Range;

var Mode = function() {
    this.HighlightRules = TextHighlightRules;
};

(function() {
    this.$defaultBehaviour = new CstyleBehaviour();

    this.tokenRe = new RegExp("^["
        + unicode.packages.L
        + unicode.packages.Mn + unicode.packages.Mc
        + unicode.packages.Nd
        + unicode.packages.Pc + "\\$_]+", "g"
    );

    this.nonTokenRe = new RegExp("^(?:[^"
        + unicode.packages.L
        + unicode.packages.Mn + unicode.packages.Mc
        + unicode.packages.Nd
        + unicode.packages.Pc + "\\$_]|\\s])+", "g"
    );

    this.getTokenizer = function() {
        if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
        }
        return this.$tokenizer;
    };

    this.lineCommentStart = "";
    this.blockComment = "";

    this.toggleCommentLines = function(state, session, startRow, endRow) {
        var doc = session.doc;

        var ignoreBlankLines = true;
        var shouldRemove = true;
        var minIndent = Infinity;
        var tabSize = session.getTabSize();
        var insertAtTabStop = false;

        if (!this.lineCommentStart) {
            if (!this.blockComment)
                return false;
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

            var comment = function(line, i) {
                if (testRemove(line, i))
                    return;
                if (!ignoreBlankLines || /\S/.test(line)) {
                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                }
            };

            var uncomment = function(line, i) {
                var m;
                if (m = line.match(regexpEnd))
                    doc.removeInLine(i, line.length - m[0].length, line.length);
                if (m = line.match(regexpStart))
                    doc.removeInLine(i, m[1].length, m[0].length);
            };

            var testRemove = function(line, row) {
                if (regexpStart.test(line))
                    return true;
                var tokens = session.getTokens(row);
                for (var i = 0; i < tokens.length; i++) {
                    if (tokens[i].type === "comment")
                        return true;
                }
            };
        } else {
            if (Array.isArray(this.lineCommentStart)) {
                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                var lineCommentStart = this.lineCommentStart[0];
            } else {
                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
            
            insertAtTabStop = session.getUseSoftTabs();

            var uncomment = function(line, i) {
                var m = line.match(regexpStart);
                if (!m) return;
                var start = m[1].length, end = m[0].length;
                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                    end--;
                doc.removeInLine(i, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function(line, i) {
                if (!ignoreBlankLines || /\S/.test(line)) {
                    if (shouldInsertSpace(line, minIndent, minIndent))
                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
                    else
                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                }
            };
            var testRemove = function(line, i) {
                return regexpStart.test(line);
            };
            
            var shouldInsertSpace = function(line, before, after) {
                var spaces = 0;
                while (before-- && line.charAt(before) == " ")
                    spaces++;
                if (spaces % tabSize != 0)
                    return false;
                var spaces = 0;
                while (line.charAt(after++) == " ")
                    spaces++;
                if (tabSize > 2)
                    return spaces % tabSize != tabSize - 1;
                else
                    return spaces % tabSize == 0;
                return true;
            };
        }

        function iter(fun) {
            for (var i = startRow; i <= endRow; i++)
                fun(doc.getLine(i), i);
        }


        var minEmptyLength = Infinity;
        iter(function(line, i) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
                if (indent < minIndent)
                    minIndent = indent;
                if (shouldRemove && !testRemove(line, i))
                    shouldRemove = false;
            } else if (minEmptyLength > line.length) {
                minEmptyLength = line.length;
            }
        });

        if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
        }

        if (insertAtTabStop && minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;

        iter(shouldRemove ? uncomment : comment);
    };

    this.toggleBlockComment = function(state, session, range, cursor) {
        var comment = this.blockComment;
        if (!comment)
            return;
        if (!comment.start && comment[0])
            comment = comment[0];

        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        var token = iterator.getCurrentToken();

        var sel = session.selection;
        var initialRange = session.selection.toOrientedRange();
        var startRow, colDiff;

        if (token && /comment/.test(token.type)) {
            var startRange, endRange;
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.start);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    startRange = new Range(row, column, row, column + comment.start.length);
                    break;
                }
                token = iterator.stepBackward();
            }

            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.end);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    endRange = new Range(row, column, row, column + comment.end.length);
                    break;
                }
                token = iterator.stepForward();
            }
            if (endRange)
                session.remove(endRange);
            if (startRange) {
                session.remove(startRange);
                startRow = startRange.start.row;
                colDiff = -comment.start.length;
            }
        } else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
        }
        // todo: selection should have ended up in the right place automatically!
        if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
        if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
        session.selection.fromOrientedRange(initialRange);
    };

    this.getNextLineIndent = function(state, line, tab) {
        return this.$getIndent(line);
    };

    this.checkOutdent = function(state, line, input) {
        return false;
    };

    this.autoOutdent = function(state, doc, row) {
    };

    this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
    };

    this.createWorker = function(session) {
        return null;
    };

    this.createModeDelegates = function (mapping) {
        this.$embeds = [];
        this.$modes = {};
        for (var i in mapping) {
            if (mapping[i]) {
                this.$embeds.push(i);
                this.$modes[i] = new mapping[i]();
            }
        }

        var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent", 
            "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];

        for (var i = 0; i < delegations.length; i++) {
            (function(scope) {
              var functionName = delegations[i];
              var defaultHandler = scope[functionName];
              scope[delegations[i]] = function() {
                  return this.$delegator(functionName, arguments, defaultHandler);
              };
            }(this));
        }
    };

    this.$delegator = function(method, args, defaultHandler) {
        var state = args[0];
        if (typeof state != "string")
            state = state[0];
        for (var i = 0; i < this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]]) continue;

            var split = state.split(this.$embeds[i]);
            if (!split[0] && split[1]) {
                args[0] = split[1];
                var mode = this.$modes[this.$embeds[i]];
                return mode[method].apply(mode, args);
            }
        }
        var ret = defaultHandler.apply(this, args);
        return defaultHandler ? ret : undefined;
    };

    this.transformAction = function(state, action, editor, session, param) {
        if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
                if (behaviours[key][action]) {
                    var ret = behaviours[key][action].apply(this, arguments);
                    if (ret) {
                        return ret;
                    }
                }
            }
        }
    };
    
    this.getKeywords = function(append) {
        // this is for autocompletion to pick up regexp'ed keywords
        if (!this.completionKeywords) {
            var rules = this.$tokenizer.rules;
            var completionKeywords = [];
            for (var rule in rules) {
                var ruleItr = rules[rule];
                for (var r = 0, l = ruleItr.length; r < l; r++) {
                    if (typeof ruleItr[r].token === "string") {
                        if (/keyword|support|storage/.test(ruleItr[r].token))
                            completionKeywords.push(ruleItr[r].regex);
                    }
                    else if (typeof ruleItr[r].token === "object") {
                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {    
                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                // drop surrounding parens
                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                completionKeywords.push(rule.substr(1, rule.length - 2));
                            }
                        }
                    }
                }
            }
            this.completionKeywords = completionKeywords;
        }
        // this is for highlighting embed rules, like HAML/Ruby or Obj-C/C
        if (!append)
            return this.$keywordList;
        return completionKeywords.concat(this.$keywordList || []);
    };
    
    this.$createKeywordList = function() {
        if (!this.$highlightRules)
            this.getTokenizer();
        return this.$keywordList = this.$highlightRules.$keywordList || [];
    };

    this.getCompletions = function(state, session, pos, prefix) {
        var keywords = this.$keywordList || this.$createKeywordList();
        return keywords.map(function(word) {
            return {
                name: word,
                value: word,
                score: 0,
                meta: "keyword"
            };
        });
    };

    this.$id = "ace/mode/text";
}).call(Mode.prototype);

exports.Mode = Mode;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/apply_delta',['require','exports','module'],function(require, exports, module) {
"use strict";

function throwDeltaError(delta, errorText){
    console.log("Invalid Delta:", delta);
    throw "Invalid Delta: " + errorText;
}

function positionInDocument(docLines, position) {
    return position.row    >= 0 && position.row    <  docLines.length &&
           position.column >= 0 && position.column <= docLines[position.row].length;
}

function validateDelta(docLines, delta) {
    // Validate action string.
    if (delta.action != "insert" && delta.action != "remove")
        throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
    
    // Validate lines type.
    if (!(delta.lines instanceof Array))
        throwDeltaError(delta, "delta.lines must be an Array");

    // Validate range type.
    if (!delta.start || !delta.end)
       throwDeltaError(delta, "delta.start/end must be an present");

    // Validate that the start point is contained in the document.
    var start = delta.start;
    if (!positionInDocument(docLines, delta.start))
        throwDeltaError(delta, "delta.start must be contained in document");
    
    // Validate that the end point is contained in the document (remove deltas only).
    var end = delta.end;
    if (delta.action == "remove" && !positionInDocument(docLines, end))
        throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
    
    // Validate that the .range size matches the .lines size.
    var numRangeRows = end.row - start.row;
    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
        throwDeltaError(delta, "delta.range must match delta lines");
}

exports.applyDelta = function(docLines, delta, doNotValidate) {
    // disabled validation since it breaks autocompletion popup
    // if (!doNotValidate)
    //    validateDelta(docLines, delta);
    
    var row = delta.start.row;
    var startColumn = delta.start.column;
    var line = docLines[row] || "";
    switch (delta.action) {
        case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
                var args = [row, 1].concat(delta.lines);
                docLines.splice.apply(docLines, args);
                docLines[row] = line.substring(0, startColumn) + docLines[row];
                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
        case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
                docLines.splice(
                    row, endRow - row + 1,
                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)
                );
            }
            break;
    }
}
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/anchor',['require','exports','module','./lib/oop','./lib/event_emitter'],function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;

/**
 *
 * Defines a floating pointer in the document. Whenever text is inserted or deleted before the cursor, the position of the anchor is updated.
 *
 * @class Anchor
 **/

/**
 * Creates a new `Anchor` and associates it with a document.
 *
 * @param {Document} doc The document to associate with the anchor
 * @param {Number} row The starting row position
 * @param {Number} column The starting column position
 *
 * @constructor
 **/

var Anchor = exports.Anchor = function(doc, row, column) {
    this.$onChange = this.onChange.bind(this);
    this.attach(doc);
    
    if (typeof column == "undefined")
        this.setPosition(row.row, row.column);
    else
        this.setPosition(row, column);
};

(function() {

    oop.implement(this, EventEmitter);

    /**
     * Returns an object identifying the `row` and `column` position of the current anchor.
     * @returns {Object}
     **/
    this.getPosition = function() {
        return this.$clipPositionToDocument(this.row, this.column);
    };

    /**
     *
     * Returns the current document.
     * @returns {Document}
     **/
    this.getDocument = function() {
        return this.document;
    };

    /**
     * experimental: allows anchor to stick to the next on the left
     */
    this.$insertRight = false;
    /**
     * Fires whenever the anchor position changes.
     *
     * Both of these objects have a `row` and `column` property corresponding to the position.
     *
     * Events that can trigger this function include [[Anchor.setPosition `setPosition()`]].
     *
     * @event change
     * @param {Object} e  An object containing information about the anchor position. It has two properties:
     *  - `old`: An object describing the old Anchor position
     *  - `value`: An object describing the new Anchor position
     *
     **/
    this.onChange = function(delta) {
        if (delta.start.row == delta.end.row && delta.start.row != this.row)
            return;

        if (delta.start.row > this.row)
            return;
            
        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);
        this.setPosition(point.row, point.column, true);
    };
    
    function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
        return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
    }
            
    function $getTransformedPoint(delta, point, moveIfEqual) {
        // Get delta info.
        var deltaIsInsert = delta.action == "insert";
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
        
        // DELTA AFTER POINT: No change needed.
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
            return {
                row: point.row,
                column: point.column
            };
        }
        
        // DELTA BEFORE POINT: Move point by delta shift.
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
            return {
                row: point.row + deltaRowShift,
                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
            };
        }
        
        // DELTA ENVELOPS POINT (delete only): Move point to delta start.
        // TODO warn if delta.action != "remove" ?
        
        return {
            row: deltaStart.row,
            column: deltaStart.column
        };
    }

    /**
     * Sets the anchor position to the specified row and column. If `noClip` is `true`, the position is not clipped.
     * @param {Number} row The row index to move the anchor to
     * @param {Number} column The column index to move the anchor to
     * @param {Boolean} noClip Identifies if you want the position to be clipped
     *
     **/
    this.setPosition = function(row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        } else {
            pos = this.$clipPositionToDocument(row, column);
        }

        if (this.row == pos.row && this.column == pos.column)
            return;

        var old = {
            row: this.row,
            column: this.column
        };

        this.row = pos.row;
        this.column = pos.column;
        this._signal("change", {
            old: old,
            value: pos
        });
    };

    /**
     * When called, the `"change"` event listener is removed.
     *
     **/
    this.detach = function() {
        this.document.removeEventListener("change", this.$onChange);
    };
    this.attach = function(doc) {
        this.document = doc || this.document;
        this.document.on("change", this.$onChange);
    };

    /**
     * Clips the anchor position to the specified row and column.
     * @param {Number} row The row index to clip the anchor to
     * @param {Number} column The column index to clip the anchor to
     *
     **/
    this.$clipPositionToDocument = function(row, column) {
        var pos = {};

        if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }

        if (column < 0)
            pos.column = 0;

        return pos;
    };

}).call(Anchor.prototype);

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/document',['require','exports','module','./lib/oop','./apply_delta','./lib/event_emitter','./range','./anchor'],function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var applyDelta = require("./apply_delta").applyDelta;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;
var Anchor = require("./anchor").Anchor;

/**
 * Contains the text of the document. Document can be attached to several [[EditSession `EditSession`]]s. 
 * At its core, `Document`s are just an array of strings, with each row in the document matching up to the array index.
 *
 * @class Document
 **/

/**
 *
 * Creates a new `Document`. If `text` is included, the `Document` contains those strings; otherwise, it's empty.
 * @param {String | Array} text The starting text
 * @constructor
 **/

var Document = function(textOrLines) {
    this.$lines = [""];

    // There has to be one line at least in the document. If you pass an empty
    // string to the insert function, nothing will happen. Workaround.
    if (textOrLines.length === 0) {
        this.$lines = [""];
    } else if (Array.isArray(textOrLines)) {
        this.insertMergedLines({row: 0, column: 0}, textOrLines);
    } else {
        this.insert({row: 0, column:0}, textOrLines);
    }
};

(function() {

    oop.implement(this, EventEmitter);

    /**
     * Replaces all the lines in the current `Document` with the value of `text`.
     *
     * @param {String} text The text to use
     **/
    this.setValue = function(text) {
        var len = this.getLength() - 1;
        this.remove(new Range(0, 0, len, this.getLine(len).length));
        this.insert({row: 0, column: 0}, text);
    };

    /**
     * Returns all the lines in the document as a single string, joined by the new line character.
     **/
    this.getValue = function() {
        return this.getAllLines().join(this.getNewLineCharacter());
    };

    /** 
     * Creates a new `Anchor` to define a floating point in the document.
     * @param {Number} row The row number to use
     * @param {Number} column The column number to use
     *
     **/
    this.createAnchor = function(row, column) {
        return new Anchor(this, row, column);
    };

    /** 
     * Splits a string of text on any newline (`\n`) or carriage-return (`\r`) characters.
     *
     * @method $split
     * @param {String} text The text to work with
     * @returns {String} A String array, with each index containing a piece of the original `text` string.
     *
     **/

    // check for IE split bug
    if ("aaa".split(/a/).length === 0) {
        this.$split = function(text) {
            return text.replace(/\r\n|\r/g, "\n").split("\n");
        };
    } else {
        this.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
        };
    }


    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : "\n";
        this._signal("changeNewLineMode");
    };

    /**
     * Returns the newline character that's being used, depending on the value of `newLineMode`. 
     * @returns {String} If `newLineMode == windows`, `\r\n` is returned.  
     *  If `newLineMode == unix`, `\n` is returned.  
     *  If `newLineMode == auto`, the value of `autoNewLine` is returned.
     *
     **/
    this.getNewLineCharacter = function() {
        switch (this.$newLineMode) {
          case "windows":
            return "\r\n";
          case "unix":
            return "\n";
          default:
            return this.$autoNewLine || "\n";
        }
    };

    this.$autoNewLine = "";
    this.$newLineMode = "auto";
    /**
     * [Sets the new line mode.]{: #Document.setNewLineMode.desc}
     * @param {String} newLineMode [The newline mode to use; can be either `windows`, `unix`, or `auto`]{: #Document.setNewLineMode.param}
     *
     **/
    this.setNewLineMode = function(newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;

        this.$newLineMode = newLineMode;
        this._signal("changeNewLineMode");
    };

    /**
     * [Returns the type of newlines being used; either `windows`, `unix`, or `auto`]{: #Document.getNewLineMode}
     * @returns {String}
     **/
    this.getNewLineMode = function() {
        return this.$newLineMode;
    };

    /**
     * Returns `true` if `text` is a newline character (either `\r\n`, `\r`, or `\n`).
     * @param {String} text The text to check
     *
     **/
    this.isNewLine = function(text) {
        return (text == "\r\n" || text == "\r" || text == "\n");
    };

    /**
     * Returns a verbatim copy of the given line as it is in the document
     * @param {Number} row The row index to retrieve
     *
     **/
    this.getLine = function(row) {
        return this.$lines[row] || "";
    };

    /**
     * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.
     * @param {Number} firstRow The first row index to retrieve
     * @param {Number} lastRow The final row index to retrieve
     *
     **/
    this.getLines = function(firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    };

    /**
     * Returns all lines in the document as string array.
     **/
    this.getAllLines = function() {
        return this.getLines(0, this.getLength());
    };

    /**
     * Returns the number of rows in the document.
     **/
    this.getLength = function() {
        return this.$lines.length;
    };

    /**
     * Returns all the text within `range` as a single string.
     * @param {Range} range The range to work with.
     * 
     * @returns {String}
     **/
    this.getTextRange = function(range) {
        return this.getLinesForRange(range).join(this.getNewLineCharacter());
    };
    
    /**
     * Returns all the text within `range` as an array of lines.
     * @param {Range} range The range to work with.
     * 
     * @returns {Array}
     **/
    this.getLinesForRange = function(range) {
        var lines;
        if (range.start.row === range.end.row) {
            // Handle a single-line range.
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
        } else {
            // Handle a multi-line range.
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || "").substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
        }
        return lines;
    };

    // Deprecated methods retained for backwards compatibility.
    this.insertLines = function(row, lines) {
        console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
        return this.insertFullLines(row, lines);
    };
    this.removeLines = function(firstRow, lastRow) {
        console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
        return this.removeFullLines(firstRow, lastRow);
    };
    this.insertNewLine = function(position) {
        console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
        return this.insertMergedLines(position, ["", ""]);
    };

    /**
     * Inserts a block of `text` at the indicated `position`.
     * @param {Object} position The position to start inserting at; it's an object that looks like `{ row: row, column: column}`
     * @param {String} text A chunk of text to insert
     * @returns {Object} The position ({row, column}) of the last line of `text`. If the length of `text` is 0, this function simply returns `position`. 
     *
     **/
    this.insert = function(position, text) {
        // Only detect new lines if the document has no line break yet.
        if (this.getLength() <= 1)
            this.$detectNewLine(text);
        
        return this.insertMergedLines(position, this.$split(text));
    };
    
    /**
     * Inserts `text` into the `position` at the current row. This method also triggers the `"change"` event.
     * 
     * This differs from the `insert` method in two ways:
     *   1. This does NOT handle newline characters (single-line text only).
     *   2. This is faster than the `insert` method for single-line text insertions.
     * 
     * @param {Object} position The position to insert at; it's an object that looks like `{ row: row, column: column}`
     * @param {String} text A chunk of text
     * @returns {Object} Returns an object containing the final row and column, like this:  
     *     ```
     *     {row: endRow, column: 0}
     *     ```
     **/
    this.insertInLine = function(position, text) {
        var start = this.clippedPos(position.row, position.column);
        var end = this.pos(position.row, position.column + text.length);
        
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: [text]
        }, true);
        
        return this.clonePos(end);
    };
    
    this.clippedPos = function(row, column) {
        var length = this.getLength();
        if (row === undefined) {
            row = length;
        } else if (row < 0) {
            row = 0;
        } else if (row >= length) {
            row = length - 1;
            column = undefined;
        }
        var line = this.getLine(row);
        if (column == undefined)
            column = line.length;
        column = Math.min(Math.max(column, 0), line.length);
        return {row: row, column: column};
    };
    
    this.clonePos = function(pos) {
        return {row: pos.row, column: pos.column};
    };
    
    this.pos = function(row, column) {
        return {row: row, column: column};
    };
    
    this.$clipPosition = function(position) {
        var length = this.getLength();
        if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
        } else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
        }
        return position;
    };

    /**
     * Fires whenever the document changes.
     *
     * Several methods trigger different `"change"` events. Below is a list of each action type, followed by each property that's also available:
     *
     *  * `"insert"`
     *    * `range`: the [[Range]] of the change within the document
     *    * `lines`: the lines being added
     *  * `"remove"`
     *    * `range`: the [[Range]] of the change within the document
     *    * `lines`: the lines being removed
     *
     * @event change
     * @param {Object} e Contains at least one property called `"action"`. `"action"` indicates the action that triggered the change. Each action also has a set of additional properties.
     *
     **/
    
    /**
     * Inserts the elements in `lines` into the document as full lines (does not merge with existing line), starting at the row index given by `row`. This method also triggers the `"change"` event.
     * @param {Number} row The index of the row to insert at
     * @param {Array} lines An array of strings
     * @returns {Object} Contains the final row and column, like this:  
     *   ```
     *   {row: endRow, column: 0}
     *   ```  
     *   If `lines` is empty, this function returns an object containing the current row, and column, like this:  
     *   ``` 
     *   {row: row, column: 0}
     *   ```
     *
     **/
    this.insertFullLines = function(row, lines) {
        // Clip to document.
        // Allow one past the document end.
        row = Math.min(Math.max(row, 0), this.getLength());
        
        // Calculate insertion point.
        var column = 0;
        if (row < this.getLength()) {
            // Insert before the specified row.
            lines = lines.concat([""]);
            column = 0;
        } else {
            // Insert after the last row in the document.
            lines = [""].concat(lines);
            row--;
            column = this.$lines[row].length;
        }
        
        // Insert.
        this.insertMergedLines({row: row, column: column}, lines);
    };

    /**
     * Inserts the elements in `lines` into the document, starting at the position index given by `row`. This method also triggers the `"change"` event.
     * @param {Number} row The index of the row to insert at
     * @param {Array} lines An array of strings
     * @returns {Object} Contains the final row and column, like this:  
     *   ```
     *   {row: endRow, column: 0}
     *   ```  
     *   If `lines` is empty, this function returns an object containing the current row, and column, like this:  
     *   ``` 
     *   {row: row, column: 0}
     *   ```
     *
     **/    
    this.insertMergedLines = function(position, lines) {
        var start = this.clippedPos(position.row, position.column);
        var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
        };
        
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: lines
        });
        
        return this.clonePos(end);
    };

    /**
     * Removes the `range` from the document.
     * @param {Range} range A specified Range to remove
     * @returns {Object} Returns the new `start` property of the range, which contains `startRow` and `startColumn`. If `range` is empty, this function returns the unmodified value of `range.start`.
     *
     **/
    this.remove = function(range) {
        var start = this.clippedPos(range.start.row, range.start.column);
        var end = this.clippedPos(range.end.row, range.end.column);
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        });
        return this.clonePos(start);
    };

    /**
     * Removes the specified columns from the `row`. This method also triggers a `"change"` event.
     * @param {Number} row The row to remove from
     * @param {Number} startColumn The column to start removing at 
     * @param {Number} endColumn The column to stop removing at
     * @returns {Object} Returns an object containing `startRow` and `startColumn`, indicating the new row and column values.<br/>If `startColumn` is equal to `endColumn`, this function returns nothing.
     *
     **/
    this.removeInLine = function(row, startColumn, endColumn) {
        var start = this.clippedPos(row, startColumn);
        var end = this.clippedPos(row, endColumn);
        
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        }, true);
        
        return this.clonePos(start);
    };

    /**
     * Removes a range of full lines. This method also triggers the `"change"` event.
     * @param {Number} firstRow The first row to be removed
     * @param {Number} lastRow The last row to be removed
     * @returns {[String]} Returns all the removed lines.
     *
     **/
    this.removeFullLines = function(firstRow, lastRow) {
        // Clip to document.
        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);
        
        // Calculate deletion range.
        // Delete the ending new line unless we're at the end of the document.
        // If we're at the end of the document, delete the starting new line.
        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
        var deleteLastNewLine  = lastRow  < this.getLength() - 1;
        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );
        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );
        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );
        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); 
        var range = new Range(startRow, startCol, endRow, endCol);
        
        // Store delelted lines with bounding newlines ommitted (maintains previous behavior).
        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
        
        this.applyDelta({
            start: range.start,
            end: range.end,
            action: "remove",
            lines: this.getLinesForRange(range)
        });
        
        // Return the deleted lines.
        return deletedLines;
    };

    /**
     * Removes the new line between `row` and the row immediately following it. This method also triggers the `"change"` event.
     * @param {Number} row The row to check
     *
     **/
    this.removeNewLine = function(row) {
        if (row < this.getLength() - 1 && row >= 0) {
            this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: ["", ""]
            });
        }
    };

    /**
     * Replaces a range in the document with the new `text`.
     * @param {Range} range A specified Range to replace
     * @param {String} text The new text to use as a replacement
     * @returns {Object} Returns an object containing the final row and column, like this:
     *     {row: endRow, column: 0}
     * If the text and range are empty, this function returns an object containing the current `range.start` value.
     * If the text is the exact same as what currently exists, this function returns an object containing the current `range.end` value.
     *
     **/
    this.replace = function(range, text) {
        if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
        if (text.length === 0 && range.isEmpty())
            return range.start;

        // Shortcut: If the text we want to insert is the same as it is already
        // in the document, we don't have to replace anything.
        if (text == this.getTextRange(range))
            return range.end;

        this.remove(range);
        var end;
        if (text) {
            end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }
        
        return end;
    };

    /**
     * Applies all changes in `deltas` to the document.
     * @param {Array} deltas An array of delta objects (can include "insert" and "remove" actions)
     **/
    this.applyDeltas = function(deltas) {
        for (var i=0; i<deltas.length; i++) {
            this.applyDelta(deltas[i]);
        }
    };
    
    /**
     * Reverts all changes in `deltas` from the document.
     * @param {Array} deltas An array of delta objects (can include "insert" and "remove" actions)
     **/
    this.revertDeltas = function(deltas) {
        for (var i=deltas.length-1; i>=0; i--) {
            this.revertDelta(deltas[i]);
        }
    };
    
    /**
     * Applies `delta` to the document.
     * @param {Object} delta A delta object (can include "insert" and "remove" actions)
     **/
    this.applyDelta = function(delta, doNotValidate) {
        var isInsert = delta.action == "insert";
        // An empty range is a NOOP.
        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
            : !Range.comparePoints(delta.start, delta.end)) {
            return;
        }
        
        if (isInsert && delta.lines.length > 20000)
            this.$splitAndapplyLargeDelta(delta, 20000);
        
        // Apply.
        applyDelta(this.$lines, delta, doNotValidate);
        this._signal("change", delta);
    };
    
    this.$splitAndapplyLargeDelta = function(delta, MAX) {
        // Split large insert deltas. This is necessary because:
        //    1. We need to support splicing delta lines into the document via $lines.splice.apply(...)
        //    2. fn.apply() doesn't work for a large number of params. The smallest threshold is on chrome 40 ~42000.
        // we use 20000 to leave some space for actual stack
        // 
        // To Do: Ideally we'd be consistent and also split 'delete' deltas. We don't do this now, because delete
        //        delta handling is too slow. If we make delete delta handling faster we can split all large deltas
        //        as shown in https://gist.github.com/aldendaniels/8367109#file-document-snippet-js
        //        If we do this, update validateDelta() to limit the number of lines in a delete delta.
        var lines = delta.lines;
        var l = lines.length;
        var row = delta.start.row; 
        var column = delta.start.column;
        var from = 0, to = 0;
        do {
            from = to;
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            if (to > l) {
                // Update remaining delta.
                delta.lines = chunk;
                delta.start.row = row + from;
                delta.start.column = column;
                break;
            }
            chunk.push("");
            this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
            }, true);
        } while(true);
    };
    
    /**
     * Reverts `delta` from the document.
     * @param {Object} delta A delta object (can include "insert" and "remove" actions)
     **/
    this.revertDelta = function(delta) {
        this.applyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: (delta.action == "insert" ? "remove" : "insert"),
            lines: delta.lines.slice()
        });
    };
    
    /**
     * Converts an index position in a document to a `{row, column}` object.
     *
     * Index refers to the "absolute position" of a character in the document. For example:
     *
     * ```javascript
     * var x = 0; // 10 characters, plus one for newline
     * var y = -1;
     * ```
     * 
     * Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.
     *
     * @param {Number} index An index to convert
     * @param {Number} startRow=0 The row from which to start the conversion
     * @returns {Object} A `{row, column}` object of the `index` position
     */
    this.indexToPosition = function(index, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l = lines.length; i < l; i++) {
            index -= lines[i].length + newlineLength;
            if (index < 0)
                return {row: i, column: index + lines[i].length + newlineLength};
        }
        return {row: l-1, column: lines[l-1].length};
    };

    /**
     * Converts the `{row, column}` position in a document to the character's index.
     *
     * Index refers to the "absolute position" of a character in the document. For example:
     *
     * ```javascript
     * var x = 0; // 10 characters, plus one for newline
     * var y = -1;
     * ```
     * 
     * Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.
     *
     * @param {Object} pos The `{row, column}` to convert
     * @param {Number} startRow=0 The row from which to start the conversion
     * @returns {Number} The index position in the document
     */
    this.positionToIndex = function(pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i < row; ++i)
            index += lines[i].length + newlineLength;

        return index + pos.column;
    };

}).call(Document.prototype);

exports.Document = Document;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/background_tokenizer',['require','exports','module','./lib/oop','./lib/event_emitter'],function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;


/**
 * Tokenizes the current [[Document `Document`]] in the background, and caches the tokenized rows for future use. 
 * 
 * If a certain row is changed, everything below that row is re-tokenized.
 *
 * @class BackgroundTokenizer
 **/

/**
 * Creates a new `BackgroundTokenizer` object.
 * @param {Tokenizer} tokenizer The tokenizer to use
 * @param {Editor} editor The editor to associate with
 *
 * @constructor
 **/

var BackgroundTokenizer = function(tokenizer, editor) {
    this.running = false;
    this.lines = [];
    this.states = [];
    this.currentLine = 0;
    this.tokenizer = tokenizer;

    var self = this;

    this.$worker = function() {
        if (!self.running) { return; }

        var workerStart = new Date();
        var currentLine = self.currentLine;
        var endLine = -1;
        var doc = self.doc;

        var startLine = currentLine;
        while (self.lines[currentLine])
            currentLine++;
        
        var len = doc.getLength();
        var processedLines = 0;
        self.running = false;
        while (currentLine < len) {
            self.$tokenizeRow(currentLine);
            endLine = currentLine;
            do {
                currentLine++;
            } while (self.lines[currentLine]);

            // only check every 5 lines
            processedLines ++;
            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {                
                self.running = setTimeout(self.$worker, 20);
                break;
            }
        }
        self.currentLine = currentLine;
        
        if (startLine <= endLine)
            self.fireUpdateEvent(startLine, endLine);
    };
};

(function(){

    oop.implement(this, EventEmitter);

    /**
     * Sets a new tokenizer for this object.
     *
     * @param {Tokenizer} tokenizer The new tokenizer to use
     *
     **/
    this.setTokenizer = function(tokenizer) {
        this.tokenizer = tokenizer;
        this.lines = [];
        this.states = [];

        this.start(0);
    };

    /**
     * Sets a new document to associate with this object.
     * @param {Document} doc The new document to associate with
     **/
    this.setDocument = function(doc) {
        this.doc = doc;
        this.lines = [];
        this.states = [];

        this.stop();
    };

     /**
     * Fires whenever the background tokeniziers between a range of rows are going to be updated.
     * 
     * @event update
     * @param {Object} e An object containing two properties, `first` and `last`, which indicate the rows of the region being updated.
     *
     **/
    /**
     * Emits the `'update'` event. `firstRow` and `lastRow` are used to define the boundaries of the region to be updated.
     * @param {Number} firstRow The starting row region
     * @param {Number} lastRow The final row region
     *
     **/
    this.fireUpdateEvent = function(firstRow, lastRow) {
        var data = {
            first: firstRow,
            last: lastRow
        };
        this._signal("update", {data: data});
    };

    /**
     * Starts tokenizing at the row indicated.
     *
     * @param {Number} startRow The row to start at
     *
     **/
    this.start = function(startRow) {
        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());

        // remove all cached items below this line
        this.lines.splice(this.currentLine, this.lines.length);
        this.states.splice(this.currentLine, this.states.length);

        this.stop();
        // pretty long delay to prevent the tokenizer from interfering with the user
        this.running = setTimeout(this.$worker, 700);
    };
    
    this.scheduleStart = function() {
        if (!this.running)
            this.running = setTimeout(this.$worker, 700);
    }

    this.$updateOnChange = function(delta) {
        var startRow = delta.start.row;
        var len = delta.end.row - startRow;

        if (len === 0) {
            this.lines[startRow] = null;
        } else if (delta.action == "remove") {
            this.lines.splice(startRow, len + 1, null);
            this.states.splice(startRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(startRow, 1);
            this.lines.splice.apply(this.lines, args);
            this.states.splice.apply(this.states, args);
        }

        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

        this.stop();
    };

    /**
     * Stops tokenizing.
     *
     **/
    this.stop = function() {
        if (this.running)
            clearTimeout(this.running);
        this.running = false;
    };

    /**
     * Gives list of tokens of the row. (tokens are cached)
     * 
     * @param {Number} row The row to get tokens at
     *
     * 
     *
     **/
    this.getTokens = function(row) {
        return this.lines[row] || this.$tokenizeRow(row);
    };

    /**
     * [Returns the state of tokenization at the end of a row.]{: #BackgroundTokenizer.getState}
     *
     * @param {Number} row The row to get state at
     **/
    this.getState = function(row) {
        if (this.currentLine == row)
            this.$tokenizeRow(row);
        return this.states[row] || "start";
    };

    this.$tokenizeRow = function(row) {
        var line = this.doc.getLine(row);
        var state = this.states[row - 1];

        var data = this.tokenizer.getLineTokens(line, state, row);

        if (this.states[row] + "" !== data.state + "") {
            this.states[row] = data.state;
            this.lines[row + 1] = null;
            if (this.currentLine > row + 1)
                this.currentLine = row + 1;
        } else if (this.currentLine == row) {
            this.currentLine = row + 1;
        }

        return this.lines[row] = data.tokens;
    };

}).call(BackgroundTokenizer.prototype);

exports.BackgroundTokenizer = BackgroundTokenizer;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/search_highlight',['require','exports','module','./lib/lang','./lib/oop','./range'],function(require, exports, module) {
"use strict";

var lang = require("./lib/lang");
var oop = require("./lib/oop");
var Range = require("./range").Range;

var SearchHighlight = function(regExp, clazz, type) {
    this.setRegexp(regExp);
    this.clazz = clazz;
    this.type = type || "text";
};

(function() {
    // needed to prevent long lines from freezing the browser
    this.MAX_RANGES = 500;
    
    this.setRegexp = function(regExp) {
        if (this.regExp+"" == regExp+"")
            return;
        this.regExp = regExp;
        this.cache = [];
    };

    this.update = function(html, markerLayer, session, config) {
        if (!this.regExp)
            return;
        var start = config.firstRow, end = config.lastRow;

        for (var i = start; i <= end; i++) {
            var ranges = this.cache[i];
            if (ranges == null) {
                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                if (ranges.length > this.MAX_RANGES)
                    ranges = ranges.slice(0, this.MAX_RANGES);
                ranges = ranges.map(function(match) {
                    return new Range(i, match.offset, i, match.offset + match.length);
                });
                this.cache[i] = ranges.length ? ranges : "";
            }

            for (var j = ranges.length; j --; ) {
                markerLayer.drawSingleLineMarker(
                    html, ranges[j].toScreenRange(session), this.clazz, config);
            }
        }
    };

}).call(SearchHighlight.prototype);

exports.SearchHighlight = SearchHighlight;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/edit_session/fold_line',['require','exports','module','../range'],function(require, exports, module) {
"use strict";

var Range = require("../range").Range;

/*
 * If an array is passed in, the folds are expected to be sorted already.
 */
function FoldLine(foldData, folds) {
    this.foldData = foldData;
    if (Array.isArray(folds)) {
        this.folds = folds;
    } else {
        folds = this.folds = [ folds ];
    }

    var last = folds[folds.length - 1];
    this.range = new Range(folds[0].start.row, folds[0].start.column,
                           last.end.row, last.end.column);
    this.start = this.range.start;
    this.end   = this.range.end;

    this.folds.forEach(function(fold) {
        fold.setFoldLine(this);
    }, this);
}

(function() {
    /*
     * Note: This doesn't update wrapData!
     */
    this.shiftRow = function(shift) {
        this.start.row += shift;
        this.end.row += shift;
        this.folds.forEach(function(fold) {
            fold.start.row += shift;
            fold.end.row += shift;
        });
    };

    this.addFold = function(fold) {
        if (fold.sameRow) {
            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                throw new Error("Can't add a fold to this FoldLine as it has no connection");
            }
            this.folds.push(fold);
            this.folds.sort(function(a, b) {
                return -a.range.compareEnd(b.start.row, b.start.column);
            });
            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                this.end.row = fold.end.row;
                this.end.column =  fold.end.column;
            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
            }
        } else if (fold.start.row == this.end.row) {
            this.folds.push(fold);
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
        } else if (fold.end.row == this.start.row) {
            this.folds.unshift(fold);
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
        } else {
            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
        }
        fold.foldLine = this;
    };

    this.containsRow = function(row) {
        return row >= this.start.row && row <= this.end.row;
    };

    this.walk = function(callback, endRow, endColumn) {
        var lastEnd = 0,
            folds = this.folds,
            fold,
            cmp, stop, isNewRow = true;

        if (endRow == null) {
            endRow = this.end.row;
            endColumn = this.end.column;
        }

        for (var i = 0; i < folds.length; i++) {
            fold = folds[i];

            cmp = fold.range.compareStart(endRow, endColumn);
            // This fold is after the endRow/Column.
            if (cmp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
            }

            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);

            // If the user requested to stop the walk or endRow/endColumn is
            // inside of this fold (cmp == 0), then end here.
            if (stop || cmp === 0) {
                return;
            }

            // Note the new lastEnd might not be on the same line. However,
            // it's the callback's job to recognize this.
            isNewRow = !fold.sameRow;
            lastEnd = fold.end.column;
        }
        callback(null, endRow, endColumn, lastEnd, isNewRow);
    };

    this.getNextFoldTo = function(row, column) {
        var fold, cmp;
        for (var i = 0; i < this.folds.length; i++) {
            fold = this.folds[i];
            cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                return {
                    fold: fold,
                    kind: "after"
                };
            } else if (cmp === 0) {
                return {
                    fold: fold,
                    kind: "inside"
                };
            }
        }
        return null;
    };

    this.addRemoveChars = function(row, column, len) {
        var ret = this.getNextFoldTo(row, column),
            fold, folds;
        if (ret) {
            fold = ret.fold;
            if (ret.kind == "inside"
                && fold.start.column != column
                && fold.start.row != row)
            {
                //throwing here breaks whole editor
                //TODO: properly handle this
                window.console && window.console.log(row, column, fold);
            } else if (fold.start.row == row) {
                folds = this.folds;
                var i = folds.indexOf(fold);
                if (i === 0) {
                    this.start.column += len;
                }
                for (i; i < folds.length; i++) {
                    fold = folds[i];
                    fold.start.column += len;
                    if (!fold.sameRow) {
                        return;
                    }
                    fold.end.column += len;
                }
                this.end.column += len;
            }
        }
    };

    this.split = function(row, column) {
        var pos = this.getNextFoldTo(row, column);
        
        if (!pos || pos.kind == "inside")
            return null;
            
        var fold = pos.fold;
        var folds = this.folds;
        var foldData = this.foldData;
        
        var i = folds.indexOf(fold);
        var foldBefore = folds[i - 1];
        this.end.row = foldBefore.end.row;
        this.end.column = foldBefore.end.column;

        // Remove the folds after row/column and create a new FoldLine
        // containing these removed folds.
        folds = folds.splice(i, folds.length - i);

        var newFoldLine = new FoldLine(foldData, folds);
        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
        return newFoldLine;
    };

    this.merge = function(foldLineNext) {
        var folds = foldLineNext.folds;
        for (var i = 0; i < folds.length; i++) {
            this.addFold(folds[i]);
        }
        // Remove the foldLineNext - no longer needed, as
        // it's merged now with foldLineNext.
        var foldData = this.foldData;
        foldData.splice(foldData.indexOf(foldLineNext), 1);
    };

    this.toString = function() {
        var ret = [this.range.toString() + ": [" ];

        this.folds.forEach(function(fold) {
            ret.push("  " + fold.toString());
        });
        ret.push("]");
        return ret.join("\n");
    };

    this.idxToPosition = function(idx) {
        var lastFoldEndColumn = 0;

        for (var i = 0; i < this.folds.length; i++) {
            var fold = this.folds[i];

            idx -= fold.start.column - lastFoldEndColumn;
            if (idx < 0) {
                return {
                    row: fold.start.row,
                    column: fold.start.column + idx
                };
            }

            idx -= fold.placeholder.length;
            if (idx < 0) {
                return fold.start;
            }

            lastFoldEndColumn = fold.end.column;
        }

        return {
            row: this.end.row,
            column: this.end.column + idx
        };
    };
}).call(FoldLine.prototype);

exports.FoldLine = FoldLine;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/range_list',['require','exports','module','./range'],function(require, exports, module) {
"use strict";
var Range = require("./range").Range;
var comparePoints = Range.comparePoints;

var RangeList = function() {
    this.ranges = [];
};

(function() {
    this.comparePoints = comparePoints;

    this.pointIndex = function(pos, excludeEdges, startIndex) {
        var list = this.ranges;

        for (var i = startIndex || 0; i < list.length; i++) {
            var range = list[i];
            var cmpEnd = comparePoints(pos, range.end);
            if (cmpEnd > 0)
                continue;
            var cmpStart = comparePoints(pos, range.start);
            if (cmpEnd === 0)
                return excludeEdges && cmpStart !== 0 ? -i-2 : i;
            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
                return i;

            return -i-1;
        }
        return -i - 1;
    };

    this.add = function(range) {
        var excludeEdges = !range.isEmpty();
        var startIndex = this.pointIndex(range.start, excludeEdges);
        if (startIndex < 0)
            startIndex = -startIndex - 1;

        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

        if (endIndex < 0)
            endIndex = -endIndex - 1;
        else
            endIndex++;
        return this.ranges.splice(startIndex, endIndex - startIndex, range);
    };

    this.addList = function(list) {
        var removed = [];
        for (var i = list.length; i--; ) {
            removed.push.apply(removed, this.add(list[i]));
        }
        return removed;
    };

    this.substractPoint = function(pos) {
        var i = this.pointIndex(pos);

        if (i >= 0)
            return this.ranges.splice(i, 1);
    };

    // merge overlapping ranges
    this.merge = function() {
        var removed = [];
        var list = this.ranges;
        
        list = list.sort(function(a, b) {
            return comparePoints(a.start, b.start);
        });
        
        var next = list[0], range;
        for (var i = 1; i < list.length; i++) {
            range = next;
            next = list[i];
            var cmp = comparePoints(range.end, next.start);
            if (cmp < 0)
                continue;

            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                continue;

            if (comparePoints(range.end, next.end) < 0) {
                range.end.row = next.end.row;
                range.end.column = next.end.column;
            }

            list.splice(i, 1);
            removed.push(next);
            next = range;
            i--;
        }
        
        this.ranges = list;

        return removed;
    };

    this.contains = function(row, column) {
        return this.pointIndex({row: row, column: column}) >= 0;
    };

    this.containsPoint = function(pos) {
        return this.pointIndex(pos) >= 0;
    };

    this.rangeAtPoint = function(pos) {
        var i = this.pointIndex(pos);
        if (i >= 0)
            return this.ranges[i];
    };


    this.clipRows = function(startRow, endRow) {
        var list = this.ranges;
        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
            return [];

        var startIndex = this.pointIndex({row: startRow, column: 0});
        if (startIndex < 0)
            startIndex = -startIndex - 1;
        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
        if (endIndex < 0)
            endIndex = -endIndex - 1;

        var clipped = [];
        for (var i = startIndex; i < endIndex; i++) {
            clipped.push(list[i]);
        }
        return clipped;
    };

    this.removeAll = function() {
        return this.ranges.splice(0, this.ranges.length);
    };

    this.attach = function(session) {
        if (this.session)
            this.detach();

        this.session = session;
        this.onChange = this.$onChange.bind(this);

        this.session.on('change', this.onChange);
    };

    this.detach = function() {
        if (!this.session)
            return;
        this.session.removeListener('change', this.onChange);
        this.session = null;
    };

    this.$onChange = function(delta) {
        if (delta.action == "insert"){
            var start = delta.start;
            var end = delta.end;
        } else {
            var end = delta.start;
            var start = delta.end;
        }
        var startRow = start.row;
        var endRow = end.row;
        var lineDif = endRow - startRow;

        var colDiff = -start.column + end.column;
        var ranges = this.ranges;

        for (var i = 0, n = ranges.length; i < n; i++) {
            var r = ranges[i];
            if (r.end.row < startRow)
                continue;
            if (r.start.row > startRow)
                break;

            if (r.start.row == startRow && r.start.column >= start.column ) {
                if (r.start.column == start.column && this.$insertRight) {
                    // do nothing
                } else {
                    r.start.column += colDiff;
                    r.start.row += lineDif;
                }
            }
            if (r.end.row == startRow && r.end.column >= start.column) {
                if (r.end.column == start.column && this.$insertRight) {
                    continue;
                }
                // special handling for the case when two ranges share an edge
                if (r.end.column == start.column && colDiff > 0 && i < n - 1) {                
                    if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)
                        r.end.column -= colDiff;
                }
                r.end.column += colDiff;
                r.end.row += lineDif;
            }
        }

        if (lineDif != 0 && i < n) {
            for (; i < n; i++) {
                var r = ranges[i];
                r.start.row += lineDif;
                r.end.row += lineDif;
            }
        }
    };

}).call(RangeList.prototype);

exports.RangeList = RangeList;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/edit_session/fold',['require','exports','module','../range','../range_list','../lib/oop'],function(require, exports, module) {
"use strict";

var Range = require("../range").Range;
var RangeList = require("../range_list").RangeList;
var oop = require("../lib/oop")
/*
 * Simple fold-data struct.
 **/
var Fold = exports.Fold = function(range, placeholder) {
    this.foldLine = null;
    this.placeholder = placeholder;
    this.range = range;
    this.start = range.start;
    this.end = range.end;

    this.sameRow = range.start.row == range.end.row;
    this.subFolds = this.ranges = [];
};

oop.inherits(Fold, RangeList);

(function() {

    this.toString = function() {
        return '"' + this.placeholder + '" ' + this.range.toString();
    };

    this.setFoldLine = function(foldLine) {
        this.foldLine = foldLine;
        this.subFolds.forEach(function(fold) {
            fold.setFoldLine(foldLine);
        });
    };

    this.clone = function() {
        var range = this.range.clone();
        var fold = new Fold(range, this.placeholder);
        this.subFolds.forEach(function(subFold) {
            fold.subFolds.push(subFold.clone());
        });
        fold.collapseChildren = this.collapseChildren;
        return fold;
    };

    this.addSubFold = function(fold) {
        if (this.range.isEqual(fold))
            return;

        if (!this.range.containsRange(fold))
            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);

        // transform fold to local coordinates
        consumeRange(fold, this.start);

        var row = fold.start.row, column = fold.start.column;
        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
            cmp = this.subFolds[i].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        var afterStart = this.subFolds[i];

        if (cmp == 0)
            return afterStart.addSubFold(fold);

        // cmp == -1
        var row = fold.range.end.row, column = fold.range.end.column;
        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
            cmp = this.subFolds[j].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        var afterEnd = this.subFolds[j];

        if (cmp == 0)
            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);

        var consumedFolds = this.subFolds.splice(i, j - i, fold);
        fold.setFoldLine(this.foldLine);

        return fold;
    };
    
    this.restoreRange = function(range) {
        return restoreRange(range, this.start);
    };

}).call(Fold.prototype);

function consumePoint(point, anchor) {
    point.row -= anchor.row;
    if (point.row == 0)
        point.column -= anchor.column;
}
function consumeRange(range, anchor) {
    consumePoint(range.start, anchor);
    consumePoint(range.end, anchor);
}
function restorePoint(point, anchor) {
    if (point.row == 0)
        point.column += anchor.column;
    point.row += anchor.row;
}
function restoreRange(range, anchor) {
    restorePoint(range.start, anchor);
    restorePoint(range.end, anchor);
}

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/edit_session/folding',['require','exports','module','../range','./fold_line','./fold','../token_iterator'],function(require, exports, module) {
"use strict";

var Range = require("../range").Range;
var FoldLine = require("./fold_line").FoldLine;
var Fold = require("./fold").Fold;
var TokenIterator = require("../token_iterator").TokenIterator;

function Folding() {
    /*
     * Looks up a fold at a given row/column. Possible values for side:
     *   -1: ignore a fold if fold.start = row/column
     *   +1: ignore a fold if fold.end = row/column
     */
    this.getFoldAt = function(row, column, side) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine)
            return null;

        var folds = foldLine.folds;
        for (var i = 0; i < folds.length; i++) {
            var fold = folds[i];
            if (fold.range.contains(row, column)) {
                if (side == 1 && fold.range.isEnd(row, column)) {
                    continue;
                } else if (side == -1 && fold.range.isStart(row, column)) {
                    continue;
                }
                return fold;
            }
        }
    };

    /*
     * Returns all folds in the given range. Note, that this will return folds
     *
     */
    this.getFoldsInRange = function(range) {
        var start = range.start;
        var end = range.end;
        var foldLines = this.$foldData;
        var foundFolds = [];

        start.column += 1;
        end.column -= 1;

        for (var i = 0; i < foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
                // Range is before foldLine. No intersection. This means,
                // there might be other foldLines that intersect.
                continue;
            }
            else if (cmp == -2) {
                // Range is after foldLine. There can't be any other foldLines then,
                // so let's give up.
                break;
            }

            var folds = foldLines[i].folds;
            for (var j = 0; j < folds.length; j++) {
                var fold = folds[j];
                cmp = fold.range.compareRange(range);
                if (cmp == -2) {
                    break;
                } else if (cmp == 2) {
                    continue;
                } else
                // WTF-state: Can happen due to -1/+1 to start/end column.
                if (cmp == 42) {
                    break;
                }
                foundFolds.push(fold);
            }
        }
        start.column -= 1;
        end.column += 1;

        return foundFolds;
    };

    this.getFoldsInRangeList = function(ranges) {
        if (Array.isArray(ranges)) {
            var folds = [];
            ranges.forEach(function(range) {
                folds = folds.concat(this.getFoldsInRange(range));
            }, this);
        } else {
            var folds = this.getFoldsInRange(ranges);
        }
        return folds;
    };
    
    /*
     * Returns all folds in the document
     */
    this.getAllFolds = function() {
        var folds = [];
        var foldLines = this.$foldData;
        
        for (var i = 0; i < foldLines.length; i++)
            for (var j = 0; j < foldLines[i].folds.length; j++)
                folds.push(foldLines[i].folds[j]);

        return folds;
    };

    /*
     * Returns the string between folds at the given position.
     * E.g.
     *  foo<fold>b|ar<fold>wolrd -> "bar"
     *  foo<fold>bar<fold>wol|rd -> "world"
     *  foo<fold>bar<fo|ld>wolrd -> <null>
     *
     * where | means the position of row/column
     *
     * The trim option determs if the return string should be trimed according
     * to the "side" passed with the trim value:
     *
     * E.g.
     *  foo<fold>b|ar<fold>wolrd -trim=-1> "b"
     *  foo<fold>bar<fold>wol|rd -trim=+1> "rld"
     *  fo|o<fold>bar<fold>wolrd -trim=00> "foo"
     */
    this.getFoldStringAt = function(row, column, trim, foldLine) {
        foldLine = foldLine || this.getFoldLine(row);
        if (!foldLine)
            return null;

        var lastFold = {
            end: { column: 0 }
        };
        // TODO: Refactor to use getNextFoldTo function.
        var str, fold;
        for (var i = 0; i < foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                str = this
                    .getLine(fold.start.row)
                    .substring(lastFold.end.column, fold.start.column);
                break;
            }
            else if (cmp === 0) {
                return null;
            }
            lastFold = fold;
        }
        if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);

        if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
        else if (trim == 1)
            return str.substring(column - lastFold.end.column);
        else
            return str;
    };

    this.getFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                return foldLine;
            } else if (foldLine.end.row > docRow) {
                return null;
            }
        }
        return null;
    };

    // returns the fold which starts after or contains docRow
    this.getNextFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row >= docRow) {
                return foldLine;
            }
        }
        return null;
    };

    this.getFoldedRowCount = function(first, last) {
        var foldData = this.$foldData, rowCount = last-first+1;
        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i],
                end = foldLine.end.row,
                start = foldLine.start.row;
            if (end >= last) {
                if (start < last) {
                    if (start >= first)
                        rowCount -= last-start;
                    else
                        rowCount = 0; // in one fold
                }
                break;
            } else if (end >= first){
                if (start >= first) // fold inside range
                    rowCount -=  end-start;
                else
                    rowCount -=  end-first+1;
            }
        }
        return rowCount;
    };

    this.$addFoldLine = function(foldLine) {
        this.$foldData.push(foldLine);
        this.$foldData.sort(function(a, b) {
            return a.start.row - b.start.row;
        });
        return foldLine;
    };

    /**
     * Adds a new fold.
     *
     * @returns
     *      The new created Fold object or an existing fold object in case the
     *      passed in range fits an existing fold exactly.
     */
    this.addFold = function(placeholder, range) {
        var foldData = this.$foldData;
        var added = false;
        var fold;
        
        if (placeholder instanceof Fold)
            fold = placeholder;
        else {
            fold = new Fold(range, placeholder);
            fold.collapseChildren = range.collapseChildren;
        }
        this.$clipRangeToDocument(fold.range);

        var startRow = fold.start.row;
        var startColumn = fold.start.column;
        var endRow = fold.end.row;
        var endColumn = fold.end.column;

        // --- Some checking ---
        if (!(startRow < endRow || 
            startRow == endRow && startColumn <= endColumn - 2))
            throw new Error("The range has to be at least 2 characters width");

        var startFold = this.getFoldAt(startRow, startColumn, 1);
        var endFold = this.getFoldAt(endRow, endColumn, -1);
        if (startFold && endFold == startFold)
            return startFold.addSubFold(fold);

        if (startFold && !startFold.range.isStart(startRow, startColumn))
            this.removeFold(startFold);
        
        if (endFold && !endFold.range.isEnd(endRow, endColumn))
            this.removeFold(endFold);
        
        // Check if there are folds in the range we create the new fold for.
        var folds = this.getFoldsInRange(fold.range);
        if (folds.length > 0) {
            // Remove the folds from fold data.
            this.removeFolds(folds);
            // Add the removed folds as subfolds on the new fold.
            folds.forEach(function(subFold) {
                fold.addSubFold(subFold);
            });
        }

        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
                foldLine.addFold(fold);
                added = true;
                break;
            } else if (startRow == foldLine.end.row) {
                foldLine.addFold(fold);
                added = true;
                if (!fold.sameRow) {
                    // Check if we might have to merge two FoldLines.
                    var foldLineNext = foldData[i + 1];
                    if (foldLineNext && foldLineNext.start.row == endRow) {
                        // We need to merge!
                        foldLine.merge(foldLineNext);
                        break;
                    }
                }
                break;
            } else if (endRow <= foldLine.start.row) {
                break;
            }
        }

        if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

        if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
        else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);

        // Notify that fold data has changed.
        this.$modified = true;
        this._signal("changeFold", { data: fold, action: "add" });

        return fold;
    };

    this.addFolds = function(folds) {
        folds.forEach(function(fold) {
            this.addFold(fold);
        }, this);
    };

    this.removeFold = function(fold) {
        var foldLine = fold.foldLine;
        var startRow = foldLine.start.row;
        var endRow = foldLine.end.row;

        var foldLines = this.$foldData;
        var folds = foldLine.folds;
        // Simple case where there is only one fold in the FoldLine such that
        // the entire fold line can get removed directly.
        if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
        } else
        // If the fold is the last fold of the foldLine, just remove it.
        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
        } else
        // If the fold is the first fold of the foldLine, just remove it.
        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
        } else
        // We know there are more then 2 folds and the fold is not at the edge.
        // This means, the fold is somewhere in between.
        //
        // If the fold is in one row, we just can remove it.
        if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
        } else
        // The fold goes over more then one row. This means remvoing this fold
        // will cause the fold line to get splitted up. newFoldLine is the second part
        {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
        }

        if (!this.$updating) {
            if (this.$useWrapMode)
                this.$updateWrapData(startRow, endRow);
            else
                this.$updateRowLengthCache(startRow, endRow);
        }
        
        // Notify that fold data has changed.
        this.$modified = true;
        this._signal("changeFold", { data: fold, action: "remove" });
    };

    this.removeFolds = function(folds) {
        // We need to clone the folds array passed in as it might be the folds
        // array of a fold line and as we call this.removeFold(fold), folds
        // are removed from folds and changes the current index.
        var cloneFolds = [];
        for (var i = 0; i < folds.length; i++) {
            cloneFolds.push(folds[i]);
        }

        cloneFolds.forEach(function(fold) {
            this.removeFold(fold);
        }, this);
        this.$modified = true;
    };

    this.expandFold = function(fold) {
        this.removeFold(fold);
        fold.subFolds.forEach(function(subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
        }, this);
        if (fold.collapseChildren > 0) {
            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);
        }
        fold.subFolds = [];
    };

    this.expandFolds = function(folds) {
        folds.forEach(function(fold) {
            this.expandFold(fold);
        }, this);
    };

    this.unfold = function(location, expandInner) {
        var range, folds;
        if (location == null) {
            range = new Range(0, 0, this.getLength(), 0);
            expandInner = true;
        } else if (typeof location == "number")
            range = new Range(location, 0, location, this.getLine(location).length);
        else if ("row" in location)
            range = Range.fromPoints(location, location);
        else
            range = location;
        
        folds = this.getFoldsInRangeList(range);
        if (expandInner) {
            this.removeFolds(folds);
        } else {
            var subFolds = folds;
            // TODO: might be better to remove and add folds in one go instead of using
            // expandFolds several times.
            while (subFolds.length) {
                this.expandFolds(subFolds);
                subFolds = this.getFoldsInRangeList(range);
            }
        }
        if (folds.length)
            return folds;
    };

    /*
     * Checks if a given documentRow is folded. This is true if there are some
     * folded parts such that some parts of the line is still visible.
     **/
    this.isRowFolded = function(docRow, startFoldRow) {
        return !!this.getFoldLine(docRow, startFoldRow);
    };

    this.getRowFoldEnd = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.end.row : docRow;
    };

    this.getRowFoldStart = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.start.row : docRow;
    };

    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
        if (startRow == null)
            startRow = foldLine.start.row;
        if (startColumn == null)
            startColumn = 0;
        if (endRow == null)
            endRow = foldLine.end.row;
        if (endColumn == null)
            endColumn = this.getLine(endRow).length;
        

        // Build the textline using the FoldLine walker.
        var doc = this.doc;
        var textLine = "";

        foldLine.walk(function(placeholder, row, column, lastColumn) {
            if (row < startRow)
                return;
            if (row == startRow) {
                if (column < startColumn)
                    return;
                lastColumn = Math.max(startColumn, lastColumn);
            }

            if (placeholder != null) {
                textLine += placeholder;
            } else {
                textLine += doc.getLine(row).substring(lastColumn, column);
            }
        }, endRow, endColumn);
        return textLine;
    };

    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
        var foldLine = this.getFoldLine(row);

        if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
        } else {
            return this.getFoldDisplayLine(
                foldLine, row, endColumn, startRow, startColumn);
        }
    };

    this.$cloneFoldData = function() {
        var fd = [];
        fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold) {
                return fold.clone();
            });
            return new FoldLine(fd, folds);
        });

        return fd;
    };

    this.toggleFold = function(tryToUnfold) {
        var selection = this.selection;
        var range = selection.getRange();
        var fold;
        var bracketPos;

        if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);

            if (fold) {
                this.expandFold(fold);
                return;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
                if (range.comparePoint(bracketPos) == 1) {
                    range.end = bracketPos;
                } else {
                    range.start = bracketPos;
                    range.start.column++;
                    range.end.column--;
                }
            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
                if (range.comparePoint(bracketPos) == 1)
                    range.end = bracketPos;
                else
                    range.start = bracketPos;

                range.start.column++;
            } else {
                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
        } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
                this.expandFolds(folds);
                return;
            } else if (folds.length == 1 ) {
                fold = folds[0];
            }
        }

        if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);

        if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
        }

        var placeholder = "...";
        if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if (placeholder.length < 4)
                return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
        }

        this.addFold(placeholder, range);
    };

    this.getCommentFoldRange = function(row, column, dir) {
        var iterator = new TokenIterator(this, row, column);
        var token = iterator.getCurrentToken();
        if (token && /^comment|string/.test(token.type)) {
            var range = new Range();
            var re = new RegExp(token.type.replace(/\..*/, "\\."));
            if (dir != 1) {
                do {
                    token = iterator.stepBackward();
                } while (token && re.test(token.type));
                iterator.stepForward();
            }
            
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + 2;

            iterator = new TokenIterator(this, row, column);
            
            if (dir != -1) {
                do {
                    token = iterator.stepForward();
                } while (token && re.test(token.type));
                token = iterator.stepBackward();
            } else
                token = iterator.getCurrentToken();

            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
            return range;
        }
    };

    this.foldAll = function(startRow, endRow, depth) {
        if (depth == undefined)
            depth = 100000; // JSON.stringify doesn't hanle Infinity
        var foldWidgets = this.foldWidgets;
        if (!foldWidgets)
            return; // mode doesn't support folding
        endRow = endRow || this.getLength();
        startRow = startRow || 0;
        for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null)
                foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
                continue;

            var range = this.getFoldWidgetRange(row);
            // sometimes range can be incompatible with existing fold
            // TODO change addFold to return null istead of throwing
            if (range && range.isMultiLine()
                && range.end.row <= endRow
                && range.start.row >= startRow
            ) {
                row = range.end.row;
                try {
                    // addFold can change the range
                    var fold = this.addFold("...", range);
                    if (fold)
                        fold.collapseChildren = depth;
                } catch(e) {}
            }
        }
    };
    
    // structured folding
    this.$foldStyles = {
        "manual": 1,
        "markbegin": 1,
        "markbeginend": 1
    };
    this.$foldStyle = "markbegin";
    this.setFoldStyle = function(style) {
        if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
        
        if (this.$foldStyle == style)
            return;

        this.$foldStyle = style;
        
        if (style == "manual")
            this.unfold();
        
        // reset folding
        var mode = this.$foldMode;
        this.$setFolding(null);
        this.$setFolding(mode);
    };

    this.$setFolding = function(foldMode) {
        if (this.$foldMode == foldMode)
            return;
            
        this.$foldMode = foldMode;
        
        this.off('change', this.$updateFoldWidgets);
        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
        this._signal("changeAnnotation");
        
        if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
        }
        
        this.foldWidgets = [];
        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
        
        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
        this.on('change', this.$updateFoldWidgets);
        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
    };

    this.getParentFoldRangeData = function (row, ignoreCurrent) {
        var fw = this.foldWidgets;
        if (!fw || (ignoreCurrent && fw[row]))
            return {};

        var i = row - 1, firstRange;
        while (i >= 0) {
            var c = fw[i];
            if (c == null)
                c = fw[i] = this.getFoldWidget(i);

            if (c == "start") {
                var range = this.getFoldWidgetRange(i);
                if (!firstRange)
                    firstRange = range;
                if (range && range.end.row >= row)
                    break;
            }
            i--;
        }

        return {
            range: i !== -1 && range,
            firstRange: firstRange
        };
    };

    this.onFoldWidgetClick = function(row, e) {
        e = e.domEvent;
        var options = {
            children: e.shiftKey,
            all: e.ctrlKey || e.metaKey,
            siblings: e.altKey
        };
        
        var range = this.$toggleFoldWidget(row, options);
        if (!range) {
            var el = (e.target || e.srcElement);
            if (el && /ace_fold-widget/.test(el.className))
                el.className += " ace_invalid";
        }
    };
    
    this.$toggleFoldWidget = function(row, options) {
        if (!this.getFoldWidget)
            return;
        var type = this.getFoldWidget(row);
        var line = this.getLine(row);

        var dir = type === "end" ? -1 : 1;
        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

        if (fold) {
            if (options.children || options.all)
                this.removeFold(fold);
            else
                this.expandFold(fold);
            return fold;
        }

        var range = this.getFoldWidgetRange(row, true);
        // sometimes singleline folds can be missed by the code above
        if (range && !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold && range.isEqual(fold.range)) {
                this.removeFold(fold);
                return fold;
            }
        }
        
        if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
                var startRow = data.range.start.row + 1;
                var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
        } else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
        } else if (range) {
            if (options.all) 
                range.collapseChildren = 10000;
            this.addFold("...", range);
        }
        
        return range;
    };
    
    
    
    this.toggleFoldWidget = function(toggleParent) {
        var row = this.selection.getCursor().row;
        row = this.getRowFoldStart(row);
        var range = this.$toggleFoldWidget(row, {});
        
        if (range)
            return;
        // handle toggleParent
        var data = this.getParentFoldRangeData(row, true);
        range = data.range || data.firstRange;
        
        if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);

            if (fold) {
                this.removeFold(fold);
            } else {
                this.addFold("...", range);
            }
        }
    };

    this.updateFoldWidgets = function(delta) {
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;

        if (len === 0) {
            this.foldWidgets[firstRow] = null;
        } else if (delta.action == 'remove') {
            this.foldWidgets.splice(firstRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
        }
    };
    this.tokenizerUpdateFoldWidgets = function(e) {
        var rows = e.data;
        if (rows.first != rows.last) {
            if (this.foldWidgets.length > rows.first)
                this.foldWidgets.splice(rows.first, this.foldWidgets.length);
        }
    };
}

exports.Folding = Folding;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/edit_session/bracket_match',['require','exports','module','../token_iterator','../range'],function(require, exports, module) {
"use strict";

var TokenIterator = require("../token_iterator").TokenIterator;
var Range = require("../range").Range;


function BracketMatch() {

    this.findMatchingBracket = function(position, chr) {
        if (position.column == 0) return null;

        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);
        if (charBeforeCursor == "") return null;

        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
        if (!match)
            return null;

        if (match[1])
            return this.$findClosingBracket(match[1], position);
        else
            return this.$findOpeningBracket(match[2], position);
    };
    
    this.getBracketRange = function(pos) {
        var line = this.getLine(pos.row);
        var before = true, range;

        var chr = line.charAt(pos.column-1);
        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        if (!match) {
            chr = line.charAt(pos.column);
            pos = {row: pos.row, column: pos.column + 1};
            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
        }
        if (!match)
            return null;

        if (match[1]) {
            var bracketPos = this.$findClosingBracket(match[1], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
                range.end.column++;
                range.start.column--;
            }
            range.cursor = range.end;
        } else {
            var bracketPos = this.$findOpeningBracket(match[2], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
                range.start.column++;
                range.end.column--;
            }
            range.cursor = range.start;
        }
        
        return range;
    };

    this.$brackets = {
        ")": "(",
        "(": ")",
        "]": "[",
        "[": "]",
        "{": "}",
        "}": "{"
    };

    this.$findOpeningBracket = function(bracket, position, typeRe) {
        var openBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;
        
         if (!typeRe){
            typeRe = new RegExp(
                "(\\.?" +
                token.type.replace(".", "\\.").replace("rparen", ".paren")
                    .replace(/\b(?:end)\b/, "(?:start|begin|end)")
                + ")+"
            );
        }
        
        // Start searching in token, just before the character at position.column
        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
        var value = token.value;
        
        while (true) {
        
            while (valueIndex >= 0) {
                var chr = value.charAt(valueIndex);
                if (chr == openBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex -= 1;
            }

            // Scan backward through the document, looking for the next token
            // whose type matches typeRe
            do {
                token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;
                
            value = token.value;
            valueIndex = value.length - 1;
        }
        
        return null;
    };

    this.$findClosingBracket = function(bracket, position, typeRe) {
        var closingBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;

        if (!typeRe){
            typeRe = new RegExp(
                "(\\.?" +
                token.type.replace(".", "\\.").replace("lparen", ".paren")
                    .replace(/\b(?:start|begin)\b/, "(?:start|begin|end)")
                + ")+"
            );
        }

        // Start searching in token, after the character at position.column
        var valueIndex = position.column - iterator.getCurrentTokenColumn();

        while (true) {

            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
                var chr = value.charAt(valueIndex);
                if (chr == closingBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex += 1;
            }

            // Scan forward through the document, looking for the next token
            // whose type matches typeRe
            do {
                token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;

            valueIndex = 0;
        }
        
        return null;
    };
}
exports.BracketMatch = BracketMatch;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/edit_session',['require','exports','module','./lib/oop','./lib/lang','./config','./lib/event_emitter','./selection','./mode/text','./range','./document','./background_tokenizer','./search_highlight','./edit_session/folding','./edit_session/bracket_match'],function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var lang = require("./lib/lang");
var config = require("./config");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Selection = require("./selection").Selection;
var TextMode = require("./mode/text").Mode;
var Range = require("./range").Range;
var Document = require("./document").Document;
var BackgroundTokenizer = require("./background_tokenizer").BackgroundTokenizer;
var SearchHighlight = require("./search_highlight").SearchHighlight;

/**
 * Stores all the data about [[Editor `Editor`]] state providing easy way to change editors state.
 *
 * `EditSession` can be attached to only one [[Document `Document`]]. Same `Document` can be attached to several `EditSession`s.
 * @class EditSession
 **/

//{ events
/**
 *
 * Emitted when the document changes.
 * @event change
 * @param {Object} e An object containing a `delta` of information about the change.
 **/
/**
 * Emitted when the tab size changes, via [[EditSession.setTabSize]].
 *
 * @event changeTabSize
 **/
/**
 * Emitted when the ability to overwrite text changes, via [[EditSession.setOverwrite]].
 *
 * @event changeOverwrite
 **/
/**
 * Emitted when the gutter changes, either by setting or removing breakpoints, or when the gutter decorations change.
 *
 * @event changeBreakpoint
 **/
/**
 * Emitted when a front marker changes.
 *
 * @event changeFrontMarker
 **/
/**
 * Emitted when a back marker changes.
 *
 * @event changeBackMarker
 **/
/**
 * Emitted when an annotation changes, like through [[EditSession.setAnnotations]].
 *
 * @event changeAnnotation
 **/
/**
 * Emitted when a background tokenizer asynchronously processes new rows.
 * @event tokenizerUpdate
 *
 * @param {Object} e An object containing one property, `"data"`, that contains information about the changing rows
 *
 **/
/**
 * Emitted when the current mode changes.
 *
 * @event changeMode
 *
 **/
/**
 * Emitted when the wrap mode changes.
 *
 * @event changeWrapMode
 *
 **/
/**
 * Emitted when the wrapping limit changes.
 *
 * @event changeWrapLimit
 *
 **/
/**
 * Emitted when a code fold is added or removed.
 *
 * @event changeFold
 *
 **/
 /**
 * Emitted when the scroll top changes.
 * @event changeScrollTop
 *
 * @param {Number} scrollTop The new scroll top value
 **/
/**
 * Emitted when the scroll left changes.
 * @event changeScrollLeft
 *
 * @param {Number} scrollLeft The new scroll left value
 **/
//}

/**
 * Sets up a new `EditSession` and associates it with the given `Document` and `TextMode`.
 * @param {Document | String} text [If `text` is a `Document`, it associates the `EditSession` with it. Otherwise, a new `Document` is created, with the initial text]{: #textParam}
 * @param {TextMode} mode [The inital language mode to use for the document]{: #modeParam}
 *
 * @constructor
 **/

var EditSession = function(text, mode) {
    this.$breakpoints = [];
    this.$decorations = [];
    this.$frontMarkers = {};
    this.$backMarkers = {};
    this.$markerId = 1;
    this.$undoSelect = true;

    this.$foldData = [];
    this.id = "session" + (++EditSession.$uid);
    this.$foldData.toString = function() {
        return this.join("\n");
    };
    this.on("changeFold", this.onChangeFold.bind(this));
    this.$onChange = this.onChange.bind(this);

    if (typeof text != "object" || !text.getLine)
        text = new Document(text);

    this.setDocument(text);
    this.selection = new Selection(this);

    config.resetOptions(this);
    this.setMode(mode);
    config._signal("session", this);
};


(function() {

    oop.implement(this, EventEmitter);

    /**
     * Sets the `EditSession` to point to a new `Document`. If a `BackgroundTokenizer` exists, it also points to `doc`.
     *
     * @param {Document} doc The new `Document` to use
     *
     **/
    this.setDocument = function(doc) {
        if (this.doc)
            this.doc.removeListener("change", this.$onChange);

        this.doc = doc;
        doc.on("change", this.$onChange);

        if (this.bgTokenizer)
            this.bgTokenizer.setDocument(this.getDocument());

        this.resetCaches();
    };

    /**
     * Returns the `Document` associated with this session.
     * @return {Document}
     **/
    this.getDocument = function() {
        return this.doc;
    };

    /**
     * @param {Number} row The row to work with
     *
     **/
    this.$resetRowCache = function(docRow) {
        if (!docRow) {
            this.$docRowCache = [];
            this.$screenRowCache = [];
            return;
        }
        var l = this.$docRowCache.length;
        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
        if (l > i) {
            this.$docRowCache.splice(i, l);
            this.$screenRowCache.splice(i, l);
        }
    };

    this.$getRowCacheIndex = function(cacheArray, val) {
        var low = 0;
        var hi = cacheArray.length - 1;

        while (low <= hi) {
            var mid = (low + hi) >> 1;
            var c = cacheArray[mid];

            if (val > c)
                low = mid + 1;
            else if (val < c)
                hi = mid - 1;
            else
                return mid;
        }

        return low -1;
    };

    this.resetCaches = function() {
        this.$modified = true;
        this.$wrapData = [];
        this.$rowLengthCache = [];
        this.$resetRowCache(0);
        if (this.bgTokenizer)
            this.bgTokenizer.start(0);
    };

    this.onChangeFold = function(e) {
        var fold = e.data;
        this.$resetRowCache(fold.start.row);
    };

    this.onChange = function(delta) {
        this.$modified = true;

        this.$resetRowCache(delta.start.row);

        var removedFolds = this.$updateInternalDataOnChange(delta);
        if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
            this.$deltasDoc.push(delta);
            if (removedFolds && removedFolds.length != 0) {
                this.$deltasFold.push({
                    action: "removeFolds",
                    folds:  removedFolds
                });
            }

            this.$informUndoManager.schedule();
        }

        this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
        this._signal("change", delta);
    };

    /**
     * Sets the session text.
     * @param {String} text The new text to place
     *
     **/
    this.setValue = function(text) {
        this.doc.setValue(text);
        this.selection.moveTo(0, 0);

        this.$resetRowCache(0);
        this.$deltas = [];
        this.$deltasDoc = [];
        this.$deltasFold = [];
        this.setUndoManager(this.$undoManager);
        this.getUndoManager().reset();
    };

    /**
     * Returns the current [[Document `Document`]] as a string.
     * @method toString
     * @returns {String}
     * @alias EditSession.getValue
     *
     **/

    /**
     * Returns the current [[Document `Document`]] as a string.
     * @method getValue
     * @returns {String}
     * @alias EditSession.toString
     **/
    this.getValue =
    this.toString = function() {
        return this.doc.getValue();
    };

    /**
     * Returns selection object.
     **/
    this.getSelection = function() {
        return this.selection;
    };

    /**
     * {:BackgroundTokenizer.getState}
     * @param {Number} row The row to start at
     *
     * @related BackgroundTokenizer.getState
     **/
    this.getState = function(row) {
        return this.bgTokenizer.getState(row);
    };

    /**
     * Starts tokenizing at the row indicated. Returns a list of objects of the tokenized rows.
     * @param {Number} row The row to start at
     *
     *
     *
     **/
    this.getTokens = function(row) {
        return this.bgTokenizer.getTokens(row);
    };

    /**
     * Returns an object indicating the token at the current row. The object has two properties: `index` and `start`.
     * @param {Number} row The row number to retrieve from
     * @param {Number} column The column number to retrieve from
     *
     *
     **/
    this.getTokenAt = function(row, column) {
        var tokens = this.bgTokenizer.getTokens(row);
        var token, c = 0;
        if (column == null) {
            i = tokens.length - 1;
            c = this.getLine(row).length;
        } else {
            for (var i = 0; i < tokens.length; i++) {
                c += tokens[i].value.length;
                if (c >= column)
                    break;
            }
        }
        token = tokens[i];
        if (!token)
            return null;
        token.index = i;
        token.start = c - token.value.length;
        return token;
    };

    /**
     * Sets the undo manager.
     * @param {UndoManager} undoManager The new undo manager
     *
     *
     **/
    this.setUndoManager = function(undoManager) {
        this.$undoManager = undoManager;
        this.$deltas = [];
        this.$deltasDoc = [];
        this.$deltasFold = [];

        if (this.$informUndoManager)
            this.$informUndoManager.cancel();

        if (undoManager) {
            var self = this;

            this.$syncInformUndoManager = function() {
                self.$informUndoManager.cancel();

                if (self.$deltasFold.length) {
                    self.$deltas.push({
                        group: "fold",
                        deltas: self.$deltasFold
                    });
                    self.$deltasFold = [];
                }

                if (self.$deltasDoc.length) {
                    self.$deltas.push({
                        group: "doc",
                        deltas: self.$deltasDoc
                    });
                    self.$deltasDoc = [];
                }

                if (self.$deltas.length > 0) {
                    undoManager.execute({
                        action: "aceupdate",
                        args: [self.$deltas, self],
                        merge: self.mergeUndoDeltas
                    });
                }
                self.mergeUndoDeltas = false;
                self.$deltas = [];
            };
            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
        }
    };

    /**
     * starts a new group in undo history
     **/
    this.markUndoGroup = function() {
        if (this.$syncInformUndoManager)
            this.$syncInformUndoManager();
    };
    
    this.$defaultUndoManager = {
        undo: function() {},
        redo: function() {},
        reset: function() {}
    };

    /**
     * Returns the current undo manager.
     **/
    this.getUndoManager = function() {
        return this.$undoManager || this.$defaultUndoManager;
    };

    /**
     * Returns the current value for tabs. If the user is using soft tabs, this will be a series of spaces (defined by [[EditSession.getTabSize `getTabSize()`]]); otherwise it's simply `'\t'`.
     **/
    this.getTabString = function() {
        if (this.getUseSoftTabs()) {
            return lang.stringRepeat(" ", this.getTabSize());
        } else {
            return "\t";
        }
    };

    /**
     * Pass `true` to enable the use of soft tabs. Soft tabs means you're using spaces instead of the tab character (`'\t'`).
     * @param {Boolean} useSoftTabs Value indicating whether or not to use soft tabs
     **/
    this.setUseSoftTabs = function(val) {
        this.setOption("useSoftTabs", val);
    };
    /**
     * Returns `true` if soft tabs are being used, `false` otherwise.
     * @returns {Boolean}
     **/
    this.getUseSoftTabs = function() {
        // todo might need more general way for changing settings from mode, but this is ok for now
        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
    };
    /**
     * Set the number of spaces that define a soft tab; for example, passing in `4` transforms the soft tabs to be equivalent to four spaces. This function also emits the `changeTabSize` event.
     * @param {Number} tabSize The new tab size
     **/
    this.setTabSize = function(tabSize) {
        this.setOption("tabSize", tabSize);
    };
    /**
     * Returns the current tab size.
     **/
    this.getTabSize = function() {
        return this.$tabSize;
    };

    /**
     * Returns `true` if the character at the position is a soft tab.
     * @param {Object} position The position to check
     *
     **/
    this.isTabStop = function(position) {
        return this.$useSoftTabs && (position.column % this.$tabSize === 0);
    };

    this.$overwrite = false;
    /**
     * Pass in `true` to enable overwrites in your session, or `false` to disable.
     *
     * If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emites the `changeOverwrite` event.
     *
     * @param {Boolean} overwrite Defines wheter or not to set overwrites
     *
     *
     **/
    this.setOverwrite = function(overwrite) {
        this.setOption("overwrite", overwrite);
    };

    /**
     * Returns `true` if overwrites are enabled; `false` otherwise.
     **/
    this.getOverwrite = function() {
        return this.$overwrite;
    };

    /**
     * Sets the value of overwrite to the opposite of whatever it currently is.
     **/
    this.toggleOverwrite = function() {
        this.setOverwrite(!this.$overwrite);
    };

    /**
     * Adds `className` to the `row`, to be used for CSS stylings and whatnot.
     * @param {Number} row The row number
     * @param {String} className The class to add
     *
     **/
    this.addGutterDecoration = function(row, className) {
        if (!this.$decorations[row])
            this.$decorations[row] = "";
        this.$decorations[row] += " " + className;
        this._signal("changeBreakpoint", {});
    };

    /**
     * Removes `className` from the `row`.
     * @param {Number} row The row number
     * @param {String} className The class to add
     *
     **/
    this.removeGutterDecoration = function(row, className) {
        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
        this._signal("changeBreakpoint", {});
    };

    /**
     * Returns an array of strings, indicating the breakpoint class (if any) applied to each row.
     * @returns {[String]}
     **/
    this.getBreakpoints = function() {
        return this.$breakpoints;
    };

    /**
     * Sets a breakpoint on every row number given by `rows`. This function also emites the `'changeBreakpoint'` event.
     * @param {Array} rows An array of row indices
     *
     **/
    this.setBreakpoints = function(rows) {
        this.$breakpoints = [];
        for (var i=0; i<rows.length; i++) {
            this.$breakpoints[rows[i]] = "ace_breakpoint";
        }
        this._signal("changeBreakpoint", {});
    };

    /**
     * Removes all breakpoints on the rows. This function also emites the `'changeBreakpoint'` event.
     **/
    this.clearBreakpoints = function() {
        this.$breakpoints = [];
        this._signal("changeBreakpoint", {});
    };

    /**
     * Sets a breakpoint on the row number given by `row`. This function also emites the `'changeBreakpoint'` event.
     * @param {Number} row A row index
     * @param {String} className Class of the breakpoint
     *
     **/
    this.setBreakpoint = function(row, className) {
        if (className === undefined)
            className = "ace_breakpoint";
        if (className)
            this.$breakpoints[row] = className;
        else
            delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
    };

    /**
     * Removes a breakpoint on the row number given by `row`. This function also emites the `'changeBreakpoint'` event.
     * @param {Number} row A row index
     *
     **/
    this.clearBreakpoint = function(row) {
        delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
    };

    /**
     * Adds a new marker to the given `Range`. If `inFront` is `true`, a front marker is defined, and the `'changeFrontMarker'` event fires; otherwise, the `'changeBackMarker'` event fires.
     * @param {Range} range Define the range of the marker
     * @param {String} clazz Set the CSS class for the marker
     * @param {Function | String} type Identify the type of the marker
     * @param {Boolean} inFront Set to `true` to establish a front marker
     *
     * @return {Number} The new marker id
     **/
    this.addMarker = function(range, clazz, type, inFront) {
        var id = this.$markerId++;

        var marker = {
            range : range,
            type : type || "line",
            renderer: typeof type == "function" ? type : null,
            clazz : clazz,
            inFront: !!inFront,
            id: id
        };

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
        } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
        }

        return id;
    };

    /**
     * Adds a dynamic marker to the session.
     * @param {Object} marker object with update method
     * @param {Boolean} inFront Set to `true` to establish a front marker
     *
     * @return {Object} The added marker
     **/
    this.addDynamicMarker = function(marker, inFront) {
        if (!marker.update)
            return;
        var id = this.$markerId++;
        marker.id = id;
        marker.inFront = !!inFront;

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
        } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
        }

        return marker;
    };

    /**
     * Removes the marker with the specified ID. If this marker was in front, the `'changeFrontMarker'` event is emitted. If the marker was in the back, the `'changeBackMarker'` event is emitted.
     * @param {Number} markerId A number representing a marker
     *
     **/
    this.removeMarker = function(markerId) {
        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
        if (!marker)
            return;

        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
        if (marker) {
            delete (markers[markerId]);
            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
        }
    };

    /**
     * Returns an object containing all of the markers, either front or back.
     * @param {Boolean} inFront If `true`, indicates you only want front markers; `false` indicates only back markers
     *
     * @returns {Object}
     **/
    this.getMarkers = function(inFront) {
        return inFront ? this.$frontMarkers : this.$backMarkers;
    };

    this.highlight = function(re) {
        if (!this.$searchHighlight) {
            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
            this.$searchHighlight = this.addDynamicMarker(highlight);
        }
        this.$searchHighlight.setRegexp(re);
    };

    // experimental
    this.highlightLines = function(startRow, endRow, clazz, inFront) {
        if (typeof endRow != "number") {
            clazz = endRow;
            endRow = startRow;
        }
        if (!clazz)
            clazz = "ace_step";

        var range = new Range(startRow, 0, endRow, Infinity);
        range.id = this.addMarker(range, clazz, "fullLine", inFront);
        return range;
    };

    /*
     * Error:
     *  {
     *    row: 12,
     *    column: 2, //can be undefined
     *    text: "Missing argument",
     *    type: "error" // or "warning" or "info"
     *  }
     */
    /**
     * Sets annotations for the `EditSession`. This functions emits the `'changeAnnotation'` event.
     * @param {Array} annotations A list of annotations
     *
     **/
    this.setAnnotations = function(annotations) {
        this.$annotations = annotations;
        this._signal("changeAnnotation", {});
    };

    /**
     * Returns the annotations for the `EditSession`.
     * @returns {Array}
     **/
    this.getAnnotations = function() {
        return this.$annotations || [];
    };

    /**
     * Clears all the annotations for this session. This function also triggers the `'changeAnnotation'` event.
     **/
    this.clearAnnotations = function() {
        this.setAnnotations([]);
    };

    /**
     * If `text` contains either the newline (`\n`) or carriage-return ('\r') characters, `$autoNewLine` stores that value.
     * @param {String} text A block of text
     *
     **/
    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r?\n)/m);
        if (match) {
            this.$autoNewLine = match[1];
        } else {
            this.$autoNewLine = "\n";
        }
    };

    /**
     * Given a starting row and column, this method returns the `Range` of the first word boundary it finds.
     * @param {Number} row The row to start at
     * @param {Number} column The column to start at
     *
     * @returns {Range}
     **/
    this.getWordRange = function(row, column) {
        var line = this.getLine(row);

        var inToken = false;
        if (column > 0)
            inToken = !!line.charAt(column - 1).match(this.tokenRe);

        if (!inToken)
            inToken = !!line.charAt(column).match(this.tokenRe);

        if (inToken)
            var re = this.tokenRe;
        else if (/^\s+$/.test(line.slice(column-1, column+1)))
            var re = /\s/;
        else
            var re = this.nonTokenRe;

        var start = column;
        if (start > 0) {
            do {
                start--;
            }
            while (start >= 0 && line.charAt(start).match(re));
            start++;
        }

        var end = column;
        while (end < line.length && line.charAt(end).match(re)) {
            end++;
        }

        return new Range(row, start, row, end);
    };

    /**
     * Gets the range of a word, including its right whitespace.
     * @param {Number} row The row number to start from
     * @param {Number} column The column number to start from
     *
     * @return {Range}
     **/
    this.getAWordRange = function(row, column) {
        var wordRange = this.getWordRange(row, column);
        var line = this.getLine(wordRange.end.row);

        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
            wordRange.end.column += 1;
        }
        return wordRange;
    };

    /**
     * {:Document.setNewLineMode.desc}
     * @param {String} newLineMode {:Document.setNewLineMode.param}
     *
     *
     * @related Document.setNewLineMode
     **/
    this.setNewLineMode = function(newLineMode) {
        this.doc.setNewLineMode(newLineMode);
    };

    /**
     *
     * Returns the current new line mode.
     * @returns {String}
     * @related Document.getNewLineMode
     **/
    this.getNewLineMode = function() {
        return this.doc.getNewLineMode();
    };

    /**
     * Identifies if you want to use a worker for the `EditSession`.
     * @param {Boolean} useWorker Set to `true` to use a worker
     *
     **/
    this.setUseWorker = function(useWorker) { this.setOption("useWorker", useWorker); };

    /**
     * Returns `true` if workers are being used.
     **/
    this.getUseWorker = function() { return this.$useWorker; };

    /**
     * Reloads all the tokens on the current session. This function calls [[BackgroundTokenizer.start `BackgroundTokenizer.start ()`]] to all the rows; it also emits the `'tokenizerUpdate'` event.
     **/
    this.onReloadTokenizer = function(e) {
        var rows = e.data;
        this.bgTokenizer.start(rows.first);
        this._signal("tokenizerUpdate", e);
    };

    this.$modes = {};

    /**
     * Sets a new text mode for the `EditSession`. This method also emits the `'changeMode'` event. If a [[BackgroundTokenizer `BackgroundTokenizer`]] is set, the `'tokenizerUpdate'` event is also emitted.
     * @param {TextMode} mode Set a new text mode
     * @param {cb} optional callback
     *
     **/
    this.$mode = null;
    this.$modeId = null;
    this.setMode = function(mode, cb) {
        if (mode && typeof mode === "object") {
            if (mode.getTokenizer)
                return this.$onChangeMode(mode);
            var options = mode;
            var path = options.path;
        } else {
            path = mode || "ace/mode/text";
        }

        // this is needed if ace isn't on require path (e.g tests in node)
        if (!this.$modes["ace/mode/text"])
            this.$modes["ace/mode/text"] = new TextMode();

        if (this.$modes[path] && !options) {
            this.$onChangeMode(this.$modes[path]);
            cb && cb();
            return;
        }
        // load on demand
        this.$modeId = path;
        config.loadModule(["mode", path], function(m) {
            if (this.$modeId !== path)
                return cb && cb();
            if (this.$modes[path] && !options) {
                this.$onChangeMode(this.$modes[path]);
            } else if (m && m.Mode) {
                m = new m.Mode(options);
                if (!options) {
                    this.$modes[path] = m;
                    m.$id = path;
                }
                this.$onChangeMode(m);
            }
            cb && cb();
        }.bind(this));

        // set mode to text until loading is finished
        if (!this.$mode)
            this.$onChangeMode(this.$modes["ace/mode/text"], true);
    };

    this.$onChangeMode = function(mode, $isPlaceholder) {
        if (!$isPlaceholder)
            this.$modeId = mode.$id;
        if (this.$mode === mode) 
            return;

        this.$mode = mode;

        this.$stopWorker();

        if (this.$useWorker)
            this.$startWorker();

        var tokenizer = mode.getTokenizer();

        if(tokenizer.addEventListener !== undefined) {
            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
            tokenizer.addEventListener("update", onReloadTokenizer);
        }

        if (!this.bgTokenizer) {
            this.bgTokenizer = new BackgroundTokenizer(tokenizer);
            var _self = this;
            this.bgTokenizer.addEventListener("update", function(e) {
                _self._signal("tokenizerUpdate", e);
            });
        } else {
            this.bgTokenizer.setTokenizer(tokenizer);
        }

        this.bgTokenizer.setDocument(this.getDocument());

        this.tokenRe = mode.tokenRe;
        this.nonTokenRe = mode.nonTokenRe;

        
        if (!$isPlaceholder) {
            // experimental method, used by c9 findiniles
            if (mode.attachToSession)
                mode.attachToSession(this);
            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
            this.$setFolding(mode.foldingRules);
            this.bgTokenizer.start(0);
            this._emit("changeMode");
        }
    };

    this.$stopWorker = function() {
        if (this.$worker) {
            this.$worker.terminate();
            this.$worker = null;
        }
    };

    this.$startWorker = function() {
        try {
            this.$worker = this.$mode.createWorker(this);
        } catch (e) {
            config.warn("Could not load worker", e);
            this.$worker = null;
        }
    };

    /**
     * Returns the current text mode.
     * @returns {TextMode} The current text mode
     **/
    this.getMode = function() {
        return this.$mode;
    };

    this.$scrollTop = 0;
    /**
     * This function sets the scroll top value. It also emits the `'changeScrollTop'` event.
     * @param {Number} scrollTop The new scroll top value
     *
     **/
    this.setScrollTop = function(scrollTop) {
        // TODO: should we force integer lineheight instead? scrollTop = Math.round(scrollTop); 
        if (this.$scrollTop === scrollTop || isNaN(scrollTop))
            return;

        this.$scrollTop = scrollTop;
        this._signal("changeScrollTop", scrollTop);
    };

    /**
     * [Returns the value of the distance between the top of the editor and the topmost part of the visible content.]{: #EditSession.getScrollTop}
     * @returns {Number}
     **/
    this.getScrollTop = function() {
        return this.$scrollTop;
    };

    this.$scrollLeft = 0;
    /**
     * [Sets the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.setScrollLeft}
     **/
    this.setScrollLeft = function(scrollLeft) {
        // scrollLeft = Math.round(scrollLeft);
        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
            return;

        this.$scrollLeft = scrollLeft;
        this._signal("changeScrollLeft", scrollLeft);
    };

    /**
     * [Returns the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.getScrollLeft}
     * @returns {Number}
     **/
    this.getScrollLeft = function() {
        return this.$scrollLeft;
    };

    /**
     * Returns the width of the screen.
     * @returns {Number}
     **/
    this.getScreenWidth = function() {
        this.$computeWidth();
        if (this.lineWidgets) 
            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
        return this.screenWidth;
    };
    
    this.getLineWidgetMaxWidth = function() {
        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
        var width = 0;
        this.lineWidgets.forEach(function(w) {
            if (w && w.screenWidth > width)
                width = w.screenWidth;
        });
        return this.lineWidgetWidth = width;
    };

    this.$computeWidth = function(force) {
        if (this.$modified || force) {
            this.$modified = false;

            if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;

            var lines = this.doc.getAllLines();
            var cache = this.$rowLengthCache;
            var longestScreenLine = 0;
            var foldIndex = 0;
            var foldLine = this.$foldData[foldIndex];
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            var len = lines.length;

            for (var i = 0; i < len; i++) {
                if (i > foldStart) {
                    i = foldLine.end.row + 1;
                    if (i >= len)
                        break;
                    foldLine = this.$foldData[foldIndex++];
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }

                if (cache[i] == null)
                    cache[i] = this.$getStringScreenWidth(lines[i])[0];

                if (cache[i] > longestScreenLine)
                    longestScreenLine = cache[i];
            }
            this.screenWidth = longestScreenLine;
        }
    };

    /**
     * Returns a verbatim copy of the given line as it is in the document
     * @param {Number} row The row to retrieve from
     *
     * @returns {String}
     **/
    this.getLine = function(row) {
        return this.doc.getLine(row);
    };

    /**
     * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.
     * @param {Number} firstRow The first row index to retrieve
     * @param {Number} lastRow The final row index to retrieve
     *
     * @returns {[String]}
     *
     **/
    this.getLines = function(firstRow, lastRow) {
        return this.doc.getLines(firstRow, lastRow);
    };

    /**
     * Returns the number of rows in the document.
     * @returns {Number}
     **/
    this.getLength = function() {
        return this.doc.getLength();
    };

    /**
     * {:Document.getTextRange.desc}
     * @param {Range} range The range to work with
     *
     * @returns {String}
     **/
    this.getTextRange = function(range) {
        return this.doc.getTextRange(range || this.selection.getRange());
    };

    /**
     * Inserts a block of `text` and the indicated `position`.
     * @param {Object} position The position {row, column} to start inserting at
     * @param {String} text A chunk of text to insert
     * @returns {Object} The position of the last line of `text`. If the length of `text` is 0, this function simply returns `position`.
     *
     *
     **/
    this.insert = function(position, text) {
        return this.doc.insert(position, text);
    };

    /**
     * Removes the `range` from the document.
     * @param {Range} range A specified Range to remove
     * @returns {Object} The new `start` property of the range, which contains `startRow` and `startColumn`. If `range` is empty, this function returns the unmodified value of `range.start`.
     *
     * @related Document.remove
     *
     **/
    this.remove = function(range) {
        return this.doc.remove(range);
    };
    
    /**
     * Removes a range of full lines. This method also triggers the `'change'` event.
     * @param {Number} firstRow The first row to be removed
     * @param {Number} lastRow The last row to be removed
     * @returns {[String]} Returns all the removed lines.
     *
     * @related Document.removeFullLines
     *
     **/
    this.removeFullLines = function(firstRow, lastRow){
        return this.doc.removeFullLines(firstRow, lastRow);
    };

    /**
     * Reverts previous changes to your document.
     * @param {Array} deltas An array of previous changes
     * @param {Boolean} dontSelect [If `true`, doesn't select the range of where the change occured]{: #dontSelect}
     *
     * @returns {Range}
     **/
    this.undoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        var lastUndoRange = null;
        for (var i = deltas.length - 1; i != -1; i--) {
            var delta = deltas[i];
            if (delta.group == "doc") {
                this.doc.revertDeltas(delta.deltas);
                lastUndoRange =
                    this.$getUndoSelection(delta.deltas, true, lastUndoRange);
            } else {
                delta.deltas.forEach(function(foldDelta) {
                    this.addFolds(foldDelta.folds);
                }, this);
            }
        }
        this.$fromUndo = false;
        lastUndoRange &&
            this.$undoSelect &&
            !dontSelect &&
            this.selection.setSelectionRange(lastUndoRange);
        return lastUndoRange;
    };

    /**
     * Re-implements a previously undone change to your document.
     * @param {Array} deltas An array of previous changes
     * @param {Boolean} dontSelect {:dontSelect}
     *
     * @returns {Range}
     **/
    this.redoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        var lastUndoRange = null;
        for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (delta.group == "doc") {
                this.doc.applyDeltas(delta.deltas);
                lastUndoRange =
                    this.$getUndoSelection(delta.deltas, false, lastUndoRange);
            }
        }
        this.$fromUndo = false;
        lastUndoRange &&
            this.$undoSelect &&
            !dontSelect &&
            this.selection.setSelectionRange(lastUndoRange);
        return lastUndoRange;
    };

    /**
     * Enables or disables highlighting of the range where an undo occured.
     * @param {Boolean} enable If `true`, selects the range of the reinserted change
     *
     **/
    this.setUndoSelect = function(enable) {
        this.$undoSelect = enable;
    };

    this.$getUndoSelection = function(deltas, isUndo, lastUndoRange) {
        function isInsert(delta) {
            return isUndo ? delta.action !== "insert" : delta.action === "insert";
        }

        var delta = deltas[0];
        var range, point;
        var lastDeltaIsInsert = false;
        if (isInsert(delta)) {
            range = Range.fromPoints(delta.start, delta.end);
            lastDeltaIsInsert = true;
        } else {
            range = Range.fromPoints(delta.start, delta.start);
            lastDeltaIsInsert = false;
        }

        for (var i = 1; i < deltas.length; i++) {
            delta = deltas[i];
            if (isInsert(delta)) {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                    range.setStart(point);
                }
                point = delta.end;
                if (range.compare(point.row, point.column) == 1) {
                    range.setEnd(point);
                }
                lastDeltaIsInsert = true;
            } else {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                    range = Range.fromPoints(delta.start, delta.start);
                }
                lastDeltaIsInsert = false;
            }
        }

        // Check if this range and the last undo range has something in common.
        // If true, merge the ranges.
        if (lastUndoRange != null) {
            if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
                lastUndoRange.start.column += range.end.column - range.start.column;
                lastUndoRange.end.column += range.end.column - range.start.column;
            }

            var cmp = lastUndoRange.compareRange(range);
            if (cmp == 1) {
                range.setStart(lastUndoRange.start);
            } else if (cmp == -1) {
                range.setEnd(lastUndoRange.end);
            }
        }

        return range;
    };

    /**
     * Replaces a range in the document with the new `text`.
     *
     * @param {Range} range A specified Range to replace
     * @param {String} text The new text to use as a replacement
     * @returns {Object} An object containing the final row and column, like this:
     * ```
     * {row: endRow, column: 0}
     * ```
     * If the text and range are empty, this function returns an object containing the current `range.start` value.
     * If the text is the exact same as what currently exists, this function returns an object containing the current `range.end` value.
     *
     * @related Document.replace
     **/
    this.replace = function(range, text) {
        return this.doc.replace(range, text);
    };

    /**
     * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:
     *  ```json
     *    { row: newRowLocation, column: newColumnLocation }
     *  ```
     * @param {Range} fromRange The range of text you want moved within the document
     * @param {Object} toPosition The location (row and column) where you want to move the text to
     * @returns {Range} The new range where the text was moved to.
     **/
    this.moveText = function(fromRange, toPosition, copy) {
        var text = this.getTextRange(fromRange);
        var folds = this.getFoldsInRange(fromRange);

        var toRange = Range.fromPoints(toPosition, toPosition);
        if (!copy) {
            this.remove(fromRange);
            var rowDiff = fromRange.start.row - fromRange.end.row;
            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
            if (collDiff) {
                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                    toRange.start.column += collDiff;
                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                    toRange.end.column += collDiff;
            }
            if (rowDiff && toRange.start.row >= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
            }
        }

        toRange.end = this.insert(toRange.start, text);
        if (folds.length) {
            var oldStart = fromRange.start;
            var newStart = toRange.start;
            var rowDiff = newStart.row - oldStart.row;
            var collDiff = newStart.column - oldStart.column;
            this.addFolds(folds.map(function(x) {
                x = x.clone();
                if (x.start.row == oldStart.row)
                    x.start.column += collDiff;
                if (x.end.row == oldStart.row)
                    x.end.column += collDiff;
                x.start.row += rowDiff;
                x.end.row += rowDiff;
                return x;
            }));
        }

        return toRange;
    };

    /**
     * Indents all the rows, from `startRow` to `endRow` (inclusive), by prefixing each row with the token in `indentString`.
     *
     * If `indentString` contains the `'\t'` character, it's replaced by whatever is defined by [[EditSession.getTabString `getTabString()`]].
     * @param {Number} startRow Starting row
     * @param {Number} endRow Ending row
     * @param {String} indentString The indent token
     *
     *
     **/
    this.indentRows = function(startRow, endRow, indentString) {
        indentString = indentString.replace(/\t/g, this.getTabString());
        for (var row=startRow; row<=endRow; row++)
            this.doc.insertInLine({row: row, column: 0}, indentString);
    };

    /**
     * Outdents all the rows defined by the `start` and `end` properties of `range`.
     * @param {Range} range A range of rows
     *
     **/
    this.outdentRows = function (range) {
        var rowRange = range.collapseRows();
        var deleteRange = new Range(0, 0, 0, 0);
        var size = this.getTabSize();

        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
            var line = this.getLine(i);

            deleteRange.start.row = i;
            deleteRange.end.row = i;
            for (var j = 0; j < size; ++j)
                if (line.charAt(j) != ' ')
                    break;
            if (j < size && line.charAt(j) == '\t') {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
            } else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
            }
            this.remove(deleteRange);
        }
    };

    this.$moveLines = function(firstRow, lastRow, dir) {
        firstRow = this.getRowFoldStart(firstRow);
        lastRow = this.getRowFoldEnd(lastRow);
        if (dir < 0) {
            var row = this.getRowFoldStart(firstRow + dir);
            if (row < 0) return 0;
            var diff = row-firstRow;
        } else if (dir > 0) {
            var row = this.getRowFoldEnd(lastRow + dir);
            if (row > this.doc.getLength()-1) return 0;
            var diff = row-lastRow;
        } else {
            firstRow = this.$clipRowToDocument(firstRow);
            lastRow = this.$clipRowToDocument(lastRow);
            var diff = lastRow - firstRow + 1;
        }

        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
        var folds = this.getFoldsInRange(range).map(function(x){
            x = x.clone();
            x.start.row += diff;
            x.end.row += diff;
            return x;
        });
        
        var lines = dir == 0
            ? this.doc.getLines(firstRow, lastRow)
            : this.doc.removeFullLines(firstRow, lastRow);
        this.doc.insertFullLines(firstRow+diff, lines);
        folds.length && this.addFolds(folds);
        return diff;
    };
    /**
     * Shifts all the lines in the document up one, starting from `firstRow` and ending at `lastRow`.
     * @param {Number} firstRow The starting row to move up
     * @param {Number} lastRow The final row to move up
     * @returns {Number} If `firstRow` is less-than or equal to 0, this function returns 0. Otherwise, on success, it returns -1.
     *
     **/
    this.moveLinesUp = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, -1);
    };

    /**
     * Shifts all the lines in the document down one, starting from `firstRow` and ending at `lastRow`.
     * @param {Number} firstRow The starting row to move down
     * @param {Number} lastRow The final row to move down
     * @returns {Number} If `firstRow` is less-than or equal to 0, this function returns 0. Otherwise, on success, it returns -1.
     **/
    this.moveLinesDown = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 1);
    };

    /**
     * Duplicates all the text between `firstRow` and `lastRow`.
     * @param {Number} firstRow The starting row to duplicate
     * @param {Number} lastRow The final row to duplicate
     * @returns {Number} Returns the number of new rows added; in other words, `lastRow - firstRow + 1`.
     *
     *
     **/
    this.duplicateLines = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 0);
    };


    this.$clipRowToDocument = function(row) {
        return Math.max(0, Math.min(row, this.doc.getLength()-1));
    };

    this.$clipColumnToRow = function(row, column) {
        if (column < 0)
            return 0;
        return Math.min(this.doc.getLine(row).length, column);
    };


    this.$clipPositionToDocument = function(row, column) {
        column = Math.max(0, column);

        if (row < 0) {
            row = 0;
            column = 0;
        } else {
            var len = this.doc.getLength();
            if (row >= len) {
                row = len - 1;
                column = this.doc.getLine(len-1).length;
            } else {
                column = Math.min(this.doc.getLine(row).length, column);
            }
        }

        return {
            row: row,
            column: column
        };
    };

    this.$clipRangeToDocument = function(range) {
        if (range.start.row < 0) {
            range.start.row = 0;
            range.start.column = 0;
        } else {
            range.start.column = this.$clipColumnToRow(
                range.start.row,
                range.start.column
            );
        }

        var len = this.doc.getLength() - 1;
        if (range.end.row > len) {
            range.end.row = len;
            range.end.column = this.doc.getLine(len).length;
        } else {
            range.end.column = this.$clipColumnToRow(
                range.end.row,
                range.end.column
            );
        }
        return range;
    };

    // WRAPMODE
    this.$wrapLimit = 80;
    this.$useWrapMode = false;
    this.$wrapLimitRange = {
        min : null,
        max : null
    };

    /**
     * Sets whether or not line wrapping is enabled. If `useWrapMode` is different than the current value, the `'changeWrapMode'` event is emitted.
     * @param {Boolean} useWrapMode Enable (or disable) wrap mode
     *
     **/
    this.setUseWrapMode = function(useWrapMode) {
        if (useWrapMode != this.$useWrapMode) {
            this.$useWrapMode = useWrapMode;
            this.$modified = true;
            this.$resetRowCache(0);

            // If wrapMode is activaed, the wrapData array has to be initialized.
            if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = Array(len);
                this.$updateWrapData(0, len - 1);
            }

            this._signal("changeWrapMode");
        }
    };

    /**
     * Returns `true` if wrap mode is being used; `false` otherwise.
     * @returns {Boolean}
     **/
    this.getUseWrapMode = function() {
        return this.$useWrapMode;
    };

    // Allow the wrap limit to move freely between min and max. Either
    // parameter can be null to allow the wrap limit to be unconstrained
    // in that direction. Or set both parameters to the same number to pin
    // the limit to that value.
    /**
     * Sets the boundaries of wrap. Either value can be `null` to have an unconstrained wrap, or, they can be the same number to pin the limit. If the wrap limits for `min` or `max` are different, this method also emits the `'changeWrapMode'` event.
     * @param {Number} min The minimum wrap value (the left side wrap)
     * @param {Number} max The maximum wrap value (the right side wrap)
     *
     **/
    this.setWrapLimitRange = function(min, max) {
        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
            this.$wrapLimitRange = { min: min, max: max };
            this.$modified = true;
            // This will force a recalculation of the wrap limit
            if (this.$useWrapMode)
                this._signal("changeWrapMode");
        }
    };

    /**
     * This should generally only be called by the renderer when a resize is detected.
     * @param {Number} desiredLimit The new wrap limit
     * @returns {Boolean}
     *
     * @private
     **/
    this.adjustWrapLimit = function(desiredLimit, $printMargin) {
        var limits = this.$wrapLimitRange;
        if (limits.max < 0)
            limits = {min: $printMargin, max: $printMargin};
        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
            this.$wrapLimit = wrapLimit;
            this.$modified = true;
            if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._signal("changeWrapLimit");
            }
            return true;
        }
        return false;
    };

    this.$constrainWrapLimit = function(wrapLimit, min, max) {
        if (min)
            wrapLimit = Math.max(min, wrapLimit);

        if (max)
            wrapLimit = Math.min(max, wrapLimit);

        return wrapLimit;
    };

    /**
     * Returns the value of wrap limit.
     * @returns {Number} The wrap limit.
     **/
    this.getWrapLimit = function() {
        return this.$wrapLimit;
    };
    
    /**
     * Sets the line length for soft wrap in the editor. Lines will break
     *  at a minimum of the given length minus 20 chars and at a maximum
     *  of the given number of chars.
     * @param {number} limit The maximum line length in chars, for soft wrapping lines.
     */
    this.setWrapLimit = function (limit) {
        this.setWrapLimitRange(limit, limit);
    };
    
    /**
     * Returns an object that defines the minimum and maximum of the wrap limit; it looks something like this:
     *
     *     { min: wrapLimitRange_min, max: wrapLimitRange_max }
     *
     * @returns {Object}
     **/
    this.getWrapLimitRange = function() {
        // Avoid unexpected mutation by returning a copy
        return {
            min : this.$wrapLimitRange.min,
            max : this.$wrapLimitRange.max
        };
    };

    this.$updateInternalDataOnChange = function(delta) {
        var useWrapMode = this.$useWrapMode;
        var action = delta.action;
        var start = delta.start;
        var end = delta.end;
        var firstRow = start.row;
        var lastRow = end.row;
        var len = lastRow - firstRow;
        var removedFolds = null;
        
        this.$updating = true;
        if (len != 0) {
            if (action === "remove") {
                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);

                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                    foldLine.shiftRow(-len);

                    var foldLineBefore = this.getFoldLine(firstRow);
                    if (foldLineBefore && foldLineBefore !== foldLine) {
                        foldLineBefore.merge(foldLine);
                        foldLine = foldLineBefore;
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= end.row) {
                        foldLine.shiftRow(-len);
                    }
                }

                lastRow = firstRow;
            } else {
                var args = Array(len);
                args.unshift(firstRow, 0);
                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache
                arr.splice.apply(arr, args);

                // If some new line is added inside of a foldLine, then split
                // the fold line up.
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                    var cmp = foldLine.range.compareInside(start.row, start.column);
                    // Inside of the foldLine range. Need to split stuff up.
                    if (cmp == 0) {
                        foldLine = foldLine.split(start.row, start.column);
                        if (foldLine) {
                            foldLine.shiftRow(len);
                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                        }
                    } else
                    // Infront of the foldLine but same row. Need to shift column.
                    if (cmp == -1) {
                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                        foldLine.shiftRow(len);
                    }
                    // Nothing to do if the insert is after the foldLine.
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= firstRow) {
                        foldLine.shiftRow(len);
                    }
                }
            }
        } else {
            // Realign folds. E.g. if you add some new chars before a fold, the
            // fold should "move" to the right.
            len = Math.abs(delta.start.column - delta.end.column);
            if (action === "remove") {
                // Get all the folds in the change range and remove them.
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);

                len = -len;
            }
            var foldLine = this.getFoldLine(firstRow);
            if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
            }
        }

        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
            console.error("doc.getLength() and $wrapData.length have to be the same!");
        }
        this.$updating = false;

        if (useWrapMode)
            this.$updateWrapData(firstRow, lastRow);
        else
            this.$updateRowLengthCache(firstRow, lastRow);

        return removedFolds;
    };

    this.$updateRowLengthCache = function(firstRow, lastRow, b) {
        this.$rowLengthCache[firstRow] = null;
        this.$rowLengthCache[lastRow] = null;
    };

    this.$updateWrapData = function(firstRow, lastRow) {
        var lines = this.doc.getAllLines();
        var tabSize = this.getTabSize();
        var wrapData = this.$wrapData;
        var wrapLimit = this.$wrapLimit;
        var tokens;
        var foldLine;

        var row = firstRow;
        lastRow = Math.min(lastRow, lines.length - 1);
        while (row <= lastRow) {
            foldLine = this.getFoldLine(row, foldLine);
            if (!foldLine) {
                tokens = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row ++;
            } else {
                tokens = [];
                foldLine.walk(function(placeholder, row, column, lastColumn) {
                        var walkTokens;
                        if (placeholder != null) {
                            walkTokens = this.$getDisplayTokens(
                                            placeholder, tokens.length);
                            walkTokens[0] = PLACEHOLDER_START;
                            for (var i = 1; i < walkTokens.length; i++) {
                                walkTokens[i] = PLACEHOLDER_BODY;
                            }
                        } else {
                            walkTokens = this.$getDisplayTokens(
                                lines[row].substring(lastColumn, column),
                                tokens.length);
                        }
                        tokens = tokens.concat(walkTokens);
                    }.bind(this),
                    foldLine.end.row,
                    lines[foldLine.end.row].length + 1
                );

                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
            }
        }
    };

    // "Tokens"
    var CHAR = 1,
        CHAR_EXT = 2,
        PLACEHOLDER_START = 3,
        PLACEHOLDER_BODY =  4,
        PUNCTUATION = 9,
        SPACE = 10,
        TAB = 11,
        TAB_SPACE = 12;


    this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
        if (tokens.length == 0) {
            return [];
        }

        var splits = [];
        var displayLength = tokens.length;
        var lastSplit = 0, lastDocSplit = 0;

        var isCode = this.$wrapAsCode;

        var indentedSoftWrap = this.$indentedSoftWrap;
        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)
            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);

        function getWrapIndent() {
            var indentation = 0;
            if (maxIndent === 0)
                return indentation;
            if (indentedSoftWrap) {
                for (var i = 0; i < tokens.length; i++) {
                    var token = tokens[i];
                    if (token == SPACE)
                        indentation += 1;
                    else if (token == TAB)
                        indentation += tabSize;
                    else if (token == TAB_SPACE)
                        continue;
                    else
                        break;
                }
            }
            if (isCode && indentedSoftWrap !== false)
                indentation += tabSize;
            return Math.min(indentation, maxIndent);
        }
        function addSplit(screenPos) {
            var displayed = tokens.slice(lastSplit, screenPos);

            // The document size is the current size - the extra width for tabs
            // and multipleWidth characters.
            var len = displayed.length;
            displayed.join("")
                // Get all the TAB_SPACEs.
                .replace(/12/g, function() {
                    len -= 1;
                })
                // Get all the CHAR_EXT/multipleWidth characters.
                .replace(/2/g, function() {
                    len -= 1;
                });

            if (!splits.length) {
                indent = getWrapIndent();
                splits.indent = indent;
            }
            lastDocSplit += len;
            splits.push(lastDocSplit);
            lastSplit = screenPos;
        }
        var indent = 0;
        while (displayLength - lastSplit > wrapLimit - indent) {
            // This is, where the split should be.
            var split = lastSplit + wrapLimit - indent;

            // If there is a space or tab at this split position, then making
            // a split is simple.
            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                /* disabled see https://github.com/ajaxorg/ace/issues/1186
                // Include all following spaces + tabs in this split as well.
                while (tokens[split] >= SPACE) {
                    split ++;
                } */
                addSplit(split);
                continue;
            }

            // === ELSE ===
            // Check if split is inside of a placeholder. Placeholder are
            // not splitable. Therefore, seek the beginning of the placeholder
            // and try to place the split beofre the placeholder's start.
            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                // Seek the start of the placeholder and do the split
                // before the placeholder. By definition there always
                // a PLACEHOLDER_START between split and lastSplit.
                for (split; split != lastSplit - 1; split--) {
                    if (tokens[split] == PLACEHOLDER_START) {
                        // split++; << No incremental here as we want to
                        //  have the position before the Placeholder.
                        break;
                    }
                }

                // If the PLACEHOLDER_START is not the index of the
                // last split, then we can do the split
                if (split > lastSplit) {
                    addSplit(split);
                    continue;
                }

                // If the PLACEHOLDER_START IS the index of the last
                // split, then we have to place the split after the
                // placeholder. So, let's seek for the end of the placeholder.
                split = lastSplit + wrapLimit;
                for (split; split < tokens.length; split++) {
                    if (tokens[split] != PLACEHOLDER_BODY) {
                        break;
                    }
                }

                // If spilt == tokens.length, then the placeholder is the last
                // thing in the line and adding a new split doesn't make sense.
                if (split == tokens.length) {
                    break;  // Breaks the while-loop.
                }

                // Finally, add the split...
                addSplit(split);
                continue;
            }

            // === ELSE ===
            // Search for the first non space/tab/placeholder/punctuation token backwards.
            var minSplit = Math.max(split - (wrapLimit -(wrapLimit>>2)), lastSplit - 1);
            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split --;
            }
            if (isCode) {
                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                    split --;
                }
                while (split > minSplit && tokens[split] == PUNCTUATION) {
                    split --;
                }
            } else {
                while (split > minSplit && tokens[split] < SPACE) {
                    split --;
                }
            }
            // If we found one, then add the split.
            if (split > minSplit) {
                addSplit(++split);
                continue;
            }

            // === ELSE ===
            split = lastSplit + wrapLimit;
            // The split is inside of a CHAR or CHAR_EXT token and no space
            // around -> force a split.
            if (tokens[split] == CHAR_EXT)
                split--;
            addSplit(split - indent);
        }
        return splits;
    };

    /**
     * Given a string, returns an array of the display characters, including tabs and spaces.
     * @param {String} str The string to check
     * @param {Number} offset The value to start at
     *
     **/
    this.$getDisplayTokens = function(str, offset) {
        var arr = [];
        var tabSize;
        offset = offset || 0;

        for (var i = 0; i < str.length; i++) {
            var c = str.charCodeAt(i);
            // Tab
            if (c == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n < tabSize; n++) {
                    arr.push(TAB_SPACE);
                }
            }
            // Space
            else if (c == 32) {
                arr.push(SPACE);
            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {
                arr.push(PUNCTUATION);
            }
            // full width characters
            else if (c >= 0x1100 && isFullWidth(c)) {
                arr.push(CHAR, CHAR_EXT);
            } else {
                arr.push(CHAR);
            }
        }
        return arr;
    };

    /**
     * Calculates the width of the string `str` on the screen while assuming that the string starts at the first column on the screen.
     * @param {String} str The string to calculate the screen width of
     * @param {Number} maxScreenColumn
     * @param {Number} screenColumn
     * @returns {[Number]} Returns an `int[]` array with two elements:<br/>
     * The first position indicates the number of columns for `str` on screen.<br/>
     * The second value contains the position of the document column that this function read until.
     *
     **/
    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
        if (maxScreenColumn == 0)
            return [0, 0];
        if (maxScreenColumn == null)
            maxScreenColumn = Infinity;
        screenColumn = screenColumn || 0;

        var c, column;
        for (column = 0; column < str.length; column++) {
            c = str.charCodeAt(column);
            // tab
            if (c == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
            }
            // full width characters
            else if (c >= 0x1100 && isFullWidth(c)) {
                screenColumn += 2;
            } else {
                screenColumn += 1;
            }
            if (screenColumn > maxScreenColumn) {
                break;
            }
        }

        return [screenColumn, column];
    };

    this.lineWidgets = null;
    /**
     * Returns number of screenrows in a wrapped line.
     * @param {Number} row The row number to check
     *
     * @returns {Number}
     **/
    this.getRowLength = function(row) {
        if (this.lineWidgets)
            var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        else 
            h = 0
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
        } else {
            return this.$wrapData[row].length + 1 + h;
        }
    };
    this.getRowLineCount = function(row) {
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1;
        } else {
            return this.$wrapData[row].length + 1;
        }
    };

    this.getRowWrapIndent = function(screenRow) {
        if (this.$useWrapMode) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            var splits = this.$wrapData[pos.row];
            return splits.length && splits[0] < pos.column ? splits.indent : 0;
        } else {
            return 0;
        }
    }

    /**
     * Returns the position (on screen) for the last character in the provided screen row.
     * @param {Number} screenRow The screen row to check
     * @returns {Number}
     *
     * @related EditSession.documentToScreenColumn
     **/
    this.getScreenLastRowColumn = function(screenRow) {
        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
        return this.documentToScreenColumn(pos.row, pos.column);
    };

    /**
     * For the given document row and column, this returns the column position of the last screen row.
     * @param {Number} docRow
     *
     * @param {Number} docColumn
     **/
    this.getDocumentLastRowColumn = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.getScreenLastRowColumn(screenRow);
    };

    /**
     * For the given document row and column, this returns the document position of the last row.
     * @param {Number} docRow
     * @param {Number} docColumn
     *
     **/
    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
    };

    /**
     * For the given row, this returns the split data.
     * @returns {String}
     **/
    this.getRowSplitData = function(row) {
        if (!this.$useWrapMode) {
            return undefined;
        } else {
            return this.$wrapData[row];
        }
    };

    /**
     * The distance to the next tab stop at the specified screen column.
     * @param {Number} screenColumn The screen column to check
     *
     * @returns {Number}
     **/
    this.getScreenTabSize = function(screenColumn) {
        return this.$tabSize - screenColumn % this.$tabSize;
    };


    this.screenToDocumentRow = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).row;
    };


    this.screenToDocumentColumn = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).column;
    };

    /**
     * Converts characters coordinates on the screen to characters coordinates within the document. [This takes into account code folding, word wrap, tab size, and any other visual modifications.]{: #conversionConsiderations}
     * @param {Number} screenRow The screen row to check
     * @param {Number} screenColumn The screen column to check
     * @returns {Object} The object returned has two properties: `row` and `column`.
     *
     * @related EditSession.documentToScreenPosition
     **/
    this.screenToDocumentPosition = function(screenRow, screenColumn) {
        if (screenRow < 0)
            return {row: 0, column: 0};

        var line;
        var docRow = 0;
        var docColumn = 0;
        var column;
        var row = 0;
        var rowLength = 0;

        var rowCache = this.$screenRowCache;
        var i = this.$getRowCacheIndex(rowCache, screenRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var docRow = this.$docRowCache[i];
            var doCache = screenRow > rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var maxRow = this.getLength() - 1;
        var foldLine = this.getNextFoldLine(docRow);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (row <= screenRow) {
            rowLength = this.getRowLength(docRow);
            if (row + rowLength > screenRow || docRow >= maxRow) {
                break;
            } else {
                row += rowLength;
                docRow++;
                if (docRow > foldStart) {
                    docRow = foldLine.end.row+1;
                    foldLine = this.getNextFoldLine(docRow, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
            }

            if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
            }
        }

        if (foldLine && foldLine.start.row <= docRow) {
            line = this.getFoldDisplayLine(foldLine);
            docRow = foldLine.start.row;
        } else if (row + rowLength <= screenRow || docRow > maxRow) {
            // clip at the end of the document
            return {
                row: maxRow,
                column: this.getLine(maxRow).length
            };
        } else {
            line = this.getLine(docRow);
            foldLine = null;
        }
        var wrapIndent = 0;
        if (this.$useWrapMode) {
            var splits = this.$wrapData[docRow];
            if (splits) {
                var splitIndex = Math.floor(screenRow - row);
                column = splits[splitIndex];
                if(splitIndex > 0 && splits.length) {
                    wrapIndent = splits.indent;
                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                    line = line.substring(docColumn);
                }
            }
        }

        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];

        // We remove one character at the end so that the docColumn
        // position returned is not associated to the next row on the screen.
        if (this.$useWrapMode && docColumn >= column)
            docColumn = column - 1;

        if (foldLine)
            return foldLine.idxToPosition(docColumn);

        return {row: docRow, column: docColumn};
    };

    /**
     * Converts document coordinates to screen coordinates. {:conversionConsiderations}
     * @param {Number} docRow The document row to check
     * @param {Number} docColumn The document column to check
     * @returns {Object} The object returned by this method has two properties: `row` and `column`.
     *
     * @related EditSession.screenToDocumentPosition
     **/
    this.documentToScreenPosition = function(docRow, docColumn) {
        // Normalize the passed in arguments.
        if (typeof docColumn === "undefined")
            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
        else
            pos = this.$clipPositionToDocument(docRow, docColumn);

        docRow = pos.row;
        docColumn = pos.column;

        var screenRow = 0;
        var foldStartRow = null;
        var fold = null;

        // Clamp the docRow position in case it's inside of a folded block.
        fold = this.getFoldAt(docRow, docColumn, 1);
        if (fold) {
            docRow = fold.start.row;
            docColumn = fold.start.column;
        }

        var rowEnd, row = 0;


        var rowCache = this.$docRowCache;
        var i = this.$getRowCacheIndex(rowCache, docRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var screenRow = this.$screenRowCache[i];
            var doCache = docRow > rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var foldLine = this.getNextFoldLine(row);
        var foldStart = foldLine ?foldLine.start.row :Infinity;

        while (row < docRow) {
            if (row >= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd > docRow)
                    break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ?foldLine.start.row :Infinity;
            }
            else {
                rowEnd = row + 1;
            }

            screenRow += this.getRowLength(row);
            row = rowEnd;

            if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
            }
        }

        // Calculate the text line that is displayed in docRow on the screen.
        var textLine = "";
        // Check if the final row we want to reach is inside of a fold.
        if (foldLine && row >= foldStart) {
            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
            foldStartRow = foldLine.start.row;
        } else {
            textLine = this.getLine(docRow).substring(0, docColumn);
            foldStartRow = docRow;
        }
        var wrapIndent = 0;
        // Clamp textLine if in wrapMode.
        if (this.$useWrapMode) {
            var wrapRow = this.$wrapData[foldStartRow];
            if (wrapRow) {
                var screenRowOffset = 0;
                while (textLine.length >= wrapRow[screenRowOffset]) {
                    screenRow ++;
                    screenRowOffset++;
                }
                textLine = textLine.substring(
                    wrapRow[screenRowOffset - 1] || 0, textLine.length
                );
                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
            }
        }

        return {
            row: screenRow,
            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
        };
    };

    /**
     * For the given document row and column, returns the screen column.
     * @param {Number} row
     * @param {Number} docColumn
     * @returns {Number}
     *
     **/
    this.documentToScreenColumn = function(row, docColumn) {
        return this.documentToScreenPosition(row, docColumn).column;
    };

    /**
     * For the given document row and column, returns the screen row.
     * @param {Number} docRow
     * @param {Number} docColumn
     *
     **/
    this.documentToScreenRow = function(docRow, docColumn) {
        return this.documentToScreenPosition(docRow, docColumn).row;
    };

    /**
     * Returns the length of the screen.
     * @returns {Number}
     **/
    this.getScreenLength = function() {
        var screenRows = 0;
        var fold = null;
        if (!this.$useWrapMode) {
            screenRows = this.getLength();

            // Remove the folded lines again.
            var foldData = this.$foldData;
            for (var i = 0; i < foldData.length; i++) {
                fold = foldData[i];
                screenRows -= fold.end.row - fold.start.row;
            }
        } else {
            var lastRow = this.$wrapData.length;
            var row = 0, i = 0;
            var fold = this.$foldData[i++];
            var foldStart = fold ? fold.start.row :Infinity;

            while (row < lastRow) {
                var splits = this.$wrapData[row];
                screenRows += splits ? splits.length + 1 : 1;
                row ++;
                if (row > foldStart) {
                    row = fold.end.row+1;
                    fold = this.$foldData[i++];
                    foldStart = fold ?fold.start.row :Infinity;
                }
            }
        }

        // todo
        if (this.lineWidgets)
            screenRows += this.$getWidgetScreenLength();

        return screenRows;
    };
    
    /**
     * @private
     *
     */
    this.$setFontMetrics = function(fm) {
        if (!this.$enableVarChar) return;
        this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn === 0)
                return [0, 0];
            if (!maxScreenColumn)
                maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;
            
            var c, column;
            for (column = 0; column < str.length; column++) {
                c = str.charAt(column);
                // tab
                if (c === "\t") {
                    screenColumn += this.getScreenTabSize(screenColumn);
                } else {
                    screenColumn += fm.getCharacterWidth(c);
                }
                if (screenColumn > maxScreenColumn) {
                    break;
                }
            }
            
            return [screenColumn, column];
        };
    };
    
    this.destroy = function() {
        if (this.bgTokenizer) {
            this.bgTokenizer.setDocument(null);
            this.bgTokenizer = null;
        }
        this.$stopWorker();
    };

    // For every keystroke this gets called once per char in the whole doc!!
    // Wouldn't hurt to make it a bit faster for c >= 0x1100
    function isFullWidth(c) {
        if (c < 0x1100)
            return false;
        return c >= 0x1100 && c <= 0x115F ||
               c >= 0x11A3 && c <= 0x11A7 ||
               c >= 0x11FA && c <= 0x11FF ||
               c >= 0x2329 && c <= 0x232A ||
               c >= 0x2E80 && c <= 0x2E99 ||
               c >= 0x2E9B && c <= 0x2EF3 ||
               c >= 0x2F00 && c <= 0x2FD5 ||
               c >= 0x2FF0 && c <= 0x2FFB ||
               c >= 0x3000 && c <= 0x303E ||
               c >= 0x3041 && c <= 0x3096 ||
               c >= 0x3099 && c <= 0x30FF ||
               c >= 0x3105 && c <= 0x312D ||
               c >= 0x3131 && c <= 0x318E ||
               c >= 0x3190 && c <= 0x31BA ||
               c >= 0x31C0 && c <= 0x31E3 ||
               c >= 0x31F0 && c <= 0x321E ||
               c >= 0x3220 && c <= 0x3247 ||
               c >= 0x3250 && c <= 0x32FE ||
               c >= 0x3300 && c <= 0x4DBF ||
               c >= 0x4E00 && c <= 0xA48C ||
               c >= 0xA490 && c <= 0xA4C6 ||
               c >= 0xA960 && c <= 0xA97C ||
               c >= 0xAC00 && c <= 0xD7A3 ||
               c >= 0xD7B0 && c <= 0xD7C6 ||
               c >= 0xD7CB && c <= 0xD7FB ||
               c >= 0xF900 && c <= 0xFAFF ||
               c >= 0xFE10 && c <= 0xFE19 ||
               c >= 0xFE30 && c <= 0xFE52 ||
               c >= 0xFE54 && c <= 0xFE66 ||
               c >= 0xFE68 && c <= 0xFE6B ||
               c >= 0xFF01 && c <= 0xFF60 ||
               c >= 0xFFE0 && c <= 0xFFE6;
    }

}).call(EditSession.prototype);

require("./edit_session/folding").Folding.call(EditSession.prototype);
require("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);


config.defineOptions(EditSession.prototype, "session", {
    wrap: {
        set: function(value) {
            if (!value || value == "off")
                value = false;
            else if (value == "free")
                value = true;
            else if (value == "printMargin")
                value = -1;
            else if (typeof value == "string")
                value = parseInt(value, 10) || false;

            if (this.$wrap == value)
                return;
            this.$wrap = value;
            if (!value) {
                this.setUseWrapMode(false);
            } else {
                var col = typeof value == "number" ? value : null;
                this.setWrapLimitRange(col, col);
                this.setUseWrapMode(true);
            }
        },
        get: function() {
            if (this.getUseWrapMode()) {
                if (this.$wrap == -1)
                    return "printMargin";
                if (!this.getWrapLimitRange().min)
                    return "free";
                return this.$wrap;
            }
            return "off";
        },
        handlesSet: true
    },    
    wrapMethod: {
        // code|text|auto
        set: function(val) {
            val = val == "auto"
                ? this.$mode.type != "text"
                : val != "text";
            if (val != this.$wrapAsCode) {
                this.$wrapAsCode = val;
                if (this.$useWrapMode) {
                    this.$modified = true;
                    this.$resetRowCache(0);
                    this.$updateWrapData(0, this.getLength() - 1);
                }
            }
        },
        initialValue: "auto"
    },
    indentedSoftWrap: { initialValue: true },
    firstLineNumber: {
        set: function() {this._signal("changeBreakpoint");},
        initialValue: 1
    },
    useWorker: {
        set: function(useWorker) {
            this.$useWorker = useWorker;

            this.$stopWorker();
            if (useWorker)
                this.$startWorker();
        },
        initialValue: true
    },
    useSoftTabs: {initialValue: true},
    tabSize: {
        set: function(tabSize) {
            if (isNaN(tabSize) || this.$tabSize === tabSize) return;

            this.$modified = true;
            this.$rowLengthCache = [];
            this.$tabSize = tabSize;
            this._signal("changeTabSize");
        },
        initialValue: 4,
        handlesSet: true
    },
    overwrite: {
        set: function(val) {this._signal("changeOverwrite");},
        initialValue: false
    },
    newLineMode: {
        set: function(val) {this.doc.setNewLineMode(val)},
        get: function() {return this.doc.getNewLineMode()},
        handlesSet: true
    },
    mode: {
        set: function(val) { this.setMode(val) },
        get: function() { return this.$modeId }
    }
});

exports.EditSession = EditSession;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/search',['require','exports','module','./lib/lang','./lib/oop','./range'],function(require, exports, module) {
"use strict";

var lang = require("./lib/lang");
var oop = require("./lib/oop");
var Range = require("./range").Range;

/**
 * @class Search
 *
 * A class designed to handle all sorts of text searches within a [[Document `Document`]].
 *
 **/

/**
 * 
 *
 * Creates a new `Search` object. The following search options are avaliable:
 *
 * - `needle`: The string or regular expression you're looking for
 * - `backwards`: Whether to search backwards from where cursor currently is. Defaults to `false`.
 * - `wrap`: Whether to wrap the search back to the beginning when it hits the end. Defaults to `false`.
 * - `caseSensitive`: Whether the search ought to be case-sensitive. Defaults to `false`.
 * - `wholeWord`: Whether the search matches only on whole words. Defaults to `false`.
 * - `range`: The [[Range]] to search within. Set this to `null` for the whole document
 * - `regExp`: Whether the search is a regular expression or not. Defaults to `false`.
 * - `start`: The starting [[Range]] or cursor position to begin the search
 * - `skipCurrent`: Whether or not to include the current line in the search. Default to `false`.
 * 
 * @constructor
 **/

var Search = function() {
    this.$options = {};
};

(function() {
    /**
     * Sets the search options via the `options` parameter.
     * @param {Object} options An object containing all the new search properties
     *
     * 
     * @returns {Search}
     * @chainable
    **/
    this.set = function(options) {
        oop.mixin(this.$options, options);
        return this;
    };

    /**
     * [Returns an object containing all the search options.]{: #Search.getOptions}
     * @returns {Object}
    **/
    this.getOptions = function() {
        return lang.copyObject(this.$options);
    };
    
    /**
     * Sets the search options via the `options` parameter.
     * @param {Object} An object containing all the search propertie
     * @related Search.set
    **/
    this.setOptions = function(options) {
        this.$options = options;
    };
    /**
     * Searches for `options.needle`. If found, this method returns the [[Range `Range`]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.
     * @param {EditSession} session The session to search with
     *
     * 
     * @returns {Range}
    **/
    this.find = function(session) {
        var options = this.$options;
        var iterator = this.$matchIterator(session, options);
        if (!iterator)
            return false;

        var firstRange = null;
        iterator.forEach(function(range, row, offset) {
            if (!range.start) {
                var column = range.offset + (offset || 0);
                firstRange = new Range(row, column, row, column + range.length);
                if (!range.length && options.start && options.start.start
                    && options.skipCurrent != false && firstRange.isEqual(options.start)
                ) {
                    firstRange = null;
                    return false;
                }
            } else
                firstRange = range;
            return true;
        });

        return firstRange;
    };

    /**
     * Searches for all occurances `options.needle`. If found, this method returns an array of [[Range `Range`s]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.
     * @param {EditSession} session The session to search with
     *
     * 
     * @returns {[Range]}
    **/
    this.findAll = function(session) {
        var options = this.$options;
        if (!options.needle)
            return [];
        this.$assembleRegExp(options);

        var range = options.range;
        var lines = range
            ? session.getLines(range.start.row, range.end.row)
            : session.doc.getAllLines();

        var ranges = [];
        var re = options.re;
        if (options.$isMultiLine) {
            var len = re.length;
            var maxRow = lines.length - len;
            var prevRange;
            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
                for (var j = 0; j < len; j++)
                    if (lines[row + j].search(re[j]) == -1)
                        continue outer;
                
                var startLine = lines[row];
                var line = lines[row + len - 1];
                var startIndex = startLine.length - startLine.match(re[0])[0].length;
                var endIndex = line.match(re[len - 1])[0].length;
                
                if (prevRange && prevRange.end.row === row &&
                    prevRange.end.column > startIndex
                ) {
                    continue;
                }
                ranges.push(prevRange = new Range(
                    row, startIndex, row + len - 1, endIndex
                ));
                if (len > 2)
                    row = row + len - 2;
            }
        } else {
            for (var i = 0; i < lines.length; i++) {
                var matches = lang.getMatchOffsets(lines[i], re);
                for (var j = 0; j < matches.length; j++) {
                    var match = matches[j];
                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                }
            }
        }

        if (range) {
            var startColumn = range.start.column;
            var endColumn = range.start.column;
            var i = 0, j = ranges.length - 1;
            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
                i++;

            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
                j--;
            
            ranges = ranges.slice(i, j + 1);
            for (i = 0, j = ranges.length; i < j; i++) {
                ranges[i].start.row += range.start.row;
                ranges[i].end.row += range.start.row;
            }
        }

        return ranges;
    };

    /**
     * Searches for `options.needle` in `input`, and, if found, replaces it with `replacement`.
     * @param {String} input The text to search in
     * @param {String} replacement The replacing text
     * + (String): If `options.regExp` is `true`, this function returns `input` with the replacement already made. Otherwise, this function just returns `replacement`.<br/>
     * If `options.needle` was not found, this function returns `null`.
     *
     * 
     * @returns {String}
    **/
    this.replace = function(input, replacement) {
        var options = this.$options;

        var re = this.$assembleRegExp(options);
        if (options.$isMultiLine)
            return replacement;

        if (!re)
            return;

        var match = re.exec(input);
        if (!match || match[0].length != input.length)
            return null;
        
        replacement = input.replace(re, replacement);
        if (options.preserveCase) {
            replacement = replacement.split("");
            for (var i = Math.min(input.length, input.length); i--; ) {
                var ch = input[i];
                if (ch && ch.toLowerCase() != ch)
                    replacement[i] = replacement[i].toUpperCase();
                else
                    replacement[i] = replacement[i].toLowerCase();
            }
            replacement = replacement.join("");
        }
        
        return replacement;
    };

    this.$matchIterator = function(session, options) {
        var re = this.$assembleRegExp(options);
        if (!re)
            return false;

        var callback;
        if (options.$isMultiLine) {
            var len = re.length;
            var matchIterator = function(line, row, offset) {
                var startIndex = line.search(re[0]);
                if (startIndex == -1)
                    return;
                for (var i = 1; i < len; i++) {
                    line = session.getLine(row + i);
                    if (line.search(re[i]) == -1)
                        return;
                }

                var endIndex = line.match(re[len - 1])[0].length;

                var range = new Range(row, startIndex, row + len - 1, endIndex);
                if (re.offset == 1) {
                    range.start.row--;
                    range.start.column = Number.MAX_VALUE;
                } else if (offset)
                    range.start.column += offset;

                if (callback(range))
                    return true;
            };
        } else if (options.backwards) {
            var matchIterator = function(line, row, startIndex) {
                var matches = lang.getMatchOffsets(line, re);
                for (var i = matches.length-1; i >= 0; i--)
                    if (callback(matches[i], row, startIndex))
                        return true;
            };
        } else {
            var matchIterator = function(line, row, startIndex) {
                var matches = lang.getMatchOffsets(line, re);
                for (var i = 0; i < matches.length; i++)
                    if (callback(matches[i], row, startIndex))
                        return true;
            };
        }
        
        var lineIterator = this.$lineIterator(session, options);

        return {
            forEach: function(_callback) {
                callback = _callback;
                lineIterator.forEach(matchIterator);
            }
        };
    };

    this.$assembleRegExp = function(options, $disableFakeMultiline) {
        if (options.needle instanceof RegExp)
            return options.re = options.needle;

        var needle = options.needle;

        if (!options.needle)
            return options.re = false;

        if (!options.regExp)
            needle = lang.escapeRegExp(needle);

        if (options.wholeWord)
            needle = addWordBoundary(needle, options);

        var modifier = options.caseSensitive ? "gm" : "gmi";

        options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
        if (options.$isMultiLine)
            return options.re = this.$assembleMultilineRegExp(needle, modifier);

        try {
            var re = new RegExp(needle, modifier);
        } catch(e) {
            re = false;
        }
        return options.re = re;
    };

    this.$assembleMultilineRegExp = function(needle, modifier) {
        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
        var re = [];
        for (var i = 0; i < parts.length; i++) try {
            re.push(new RegExp(parts[i], modifier));
        } catch(e) {
            return false;
        }
        if (parts[0] == "") {
            re.shift();
            re.offset = 1;
        } else {
            re.offset = 0;
        }
        return re;
    };

    this.$lineIterator = function(session, options) {
        var backwards = options.backwards == true;
        var skipCurrent = options.skipCurrent != false;

        var range = options.range;
        var start = options.start;
        if (!start)
            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
         
        if (start.start)
            start = start[skipCurrent != backwards ? "end" : "start"];

        var firstRow = range ? range.start.row : 0;
        var lastRow = range ? range.end.row : session.getLength() - 1;

        var forEach = backwards ? function(callback) {
                var row = start.row;

                var line = session.getLine(row).substring(0, start.column);
                if (callback(line, row))
                    return;

                for (row--; row >= firstRow; row--)
                    if (callback(session.getLine(row), row))
                        return;

                if (options.wrap == false)
                    return;

                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                    if (callback(session.getLine(row), row))
                        return;
            } : function(callback) {
                var row = start.row;

                var line = session.getLine(row).substr(start.column);
                if (callback(line, row, start.column))
                    return;

                for (row = row+1; row <= lastRow; row++)
                    if (callback(session.getLine(row), row))
                        return;

                if (options.wrap == false)
                    return;

                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                    if (callback(session.getLine(row), row))
                        return;
            };
        
        return {forEach: forEach};
    };

}).call(Search.prototype);

function addWordBoundary(needle, options) {
    function wordBoundary(c) {
        if (/\w/.test(c) || options.regExp) return "\\b";
        return "";
    }
    return wordBoundary(needle[0]) + needle
        + wordBoundary(needle[needle.length - 1]);
}

exports.Search = Search;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/keyboard/hash_handler',['require','exports','module','../lib/keys','../lib/useragent'],function(require, exports, module) {
"use strict";

var keyUtil = require("../lib/keys");
var useragent = require("../lib/useragent");
var KEY_MODS = keyUtil.KEY_MODS;

function HashHandler(config, platform) {
    this.platform = platform || (useragent.isMac ? "mac" : "win");
    this.commands = {};
    this.commandKeyBinding = {};
    this.addCommands(config);
    this.$singleCommand = true;
}

function MultiHashHandler(config, platform) {
    HashHandler.call(this, config, platform);
    this.$singleCommand = false;
}

MultiHashHandler.prototype = HashHandler.prototype;

(function() {
    

    this.addCommand = function(command) {
        if (this.commands[command.name])
            this.removeCommand(command);

        this.commands[command.name] = command;

        if (command.bindKey)
            this._buildKeyHash(command);
    };

    this.removeCommand = function(command, keepCommand) {
        var name = command && (typeof command === 'string' ? command : command.name);
        command = this.commands[name];
        if (!keepCommand)
            delete this.commands[name];

        // exhaustive search is brute force but since removeCommand is
        // not a performance critical operation this should be OK
        var ckb = this.commandKeyBinding;
        for (var keyId in ckb) {
            var cmdGroup = ckb[keyId];
            if (cmdGroup == command) {
                delete ckb[keyId];
            } else if (Array.isArray(cmdGroup)) {
                var i = cmdGroup.indexOf(command);
                if (i != -1) {
                    cmdGroup.splice(i, 1);
                    if (cmdGroup.length == 1)
                        ckb[keyId] = cmdGroup[0];
                }
            }
        }
    };

    this.bindKey = function(key, command, position) {
        if (typeof key == "object" && key) {
            if (position == undefined)
                position = key.position;
            key = key[this.platform];
        }
        if (!key)
            return;
        if (typeof command == "function")
            return this.addCommand({exec: command, bindKey: key, name: command.name || key});
        
        key.split("|").forEach(function(keyPart) {
            var chain = "";
            if (keyPart.indexOf(" ") != -1) {
                var parts = keyPart.split(/\s+/);
                keyPart = parts.pop();
                parts.forEach(function(keyPart) {
                    var binding = this.parseKeys(keyPart);
                    var id = KEY_MODS[binding.hashId] + binding.key;
                    chain += (chain ? " " : "") + id;
                    this._addCommandToBinding(chain, "chainKeys");
                }, this);
                chain += " ";
            }
            var binding = this.parseKeys(keyPart);
            var id = KEY_MODS[binding.hashId] + binding.key;
            this._addCommandToBinding(chain + id, command, position);
        }, this);
    };
    
    function getPosition(command) {
        return typeof command == "object" && command.bindKey
            && command.bindKey.position || 0;
    }
    this._addCommandToBinding = function(keyId, command, position) {
        var ckb = this.commandKeyBinding, i;
        if (!command) {
            delete ckb[keyId];
        } else if (!ckb[keyId] || this.$singleCommand) {
            ckb[keyId] = command;
        } else {
            if (!Array.isArray(ckb[keyId])) {
                ckb[keyId] = [ckb[keyId]];
            } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                ckb[keyId].splice(i, 1);
            }

            if (typeof position != "number") {
                if (position || command.isDefault)
                    position = -100;
                else
                   position = getPosition(command);
            }
            var commands = ckb[keyId];
            for (i = 0; i < commands.length; i++) {
                var other = commands[i];
                var otherPos = getPosition(other);
                if (otherPos > position)
                    break;
            }
            commands.splice(i, 0, command);
        }
    };

    this.addCommands = function(commands) {
        commands && Object.keys(commands).forEach(function(name) {
            var command = commands[name];
            if (!command)
                return;
            
            if (typeof command === "string")
                return this.bindKey(command, name);

            if (typeof command === "function")
                command = { exec: command };

            if (typeof command !== "object")
                return;

            if (!command.name)
                command.name = name;

            this.addCommand(command);
        }, this);
    };

    this.removeCommands = function(commands) {
        Object.keys(commands).forEach(function(name) {
            this.removeCommand(commands[name]);
        }, this);
    };

    this.bindKeys = function(keyList) {
        Object.keys(keyList).forEach(function(key) {
            this.bindKey(key, keyList[key]);
        }, this);
    };

    this._buildKeyHash = function(command) {
        this.bindKey(command.bindKey, command);
    };

    // accepts keys in the form ctrl+Enter or ctrl-Enter
    // keys without modifiers or shift only 
    this.parseKeys = function(keys) {
        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x){return x});
        var key = parts.pop();

        var keyCode = keyUtil[key];
        if (keyUtil.FUNCTION_KEYS[keyCode])
            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
        else if (!parts.length)
            return {key: key, hashId: -1};
        else if (parts.length == 1 && parts[0] == "shift")
            return {key: key.toUpperCase(), hashId: -1};

        var hashId = 0;
        for (var i = parts.length; i--;) {
            var modifier = keyUtil.KEY_MODS[parts[i]];
            if (modifier == null) {
                if (typeof console != "undefined")
                    console.error("invalid modifier " + parts[i] + " in " + keys);
                return false;
            }
            hashId |= modifier;
        }
        return {key: key, hashId: hashId};
    };

    this.findKeyCommand = function findKeyCommand(hashId, keyString) {
        var key = KEY_MODS[hashId] + keyString;
        return this.commandKeyBinding[key];
    };

    this.handleKeyboard = function(data, hashId, keyString, keyCode) {
        if (keyCode < 0) return;
        var key = KEY_MODS[hashId] + keyString;
        var command = this.commandKeyBinding[key];
        if (data.$keyChain) {
            data.$keyChain += " " + key;
            command = this.commandKeyBinding[data.$keyChain] || command;
        }
        
        if (command) {
            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                data.$keyChain = data.$keyChain || key;
                return {command: "null"};
            }
        }
        
        if (data.$keyChain) {
            if ((!hashId || hashId == 4) && keyString.length == 1)
                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
            else if (hashId == -1 || keyCode > 0)
                data.$keyChain = ""; // reset keyChain
        }
        return {command: command};
    };
    
    this.getStatusText = function(editor, data) {
        return data.$keyChain || "";
    };

}).call(HashHandler.prototype);

exports.HashHandler = HashHandler;
exports.MultiHashHandler = MultiHashHandler;
});

define('bower_components/ace/lib/ace/commands/command_manager',['require','exports','module','../lib/oop','../keyboard/hash_handler','../lib/event_emitter'],function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var MultiHashHandler = require("../keyboard/hash_handler").MultiHashHandler;
var EventEmitter = require("../lib/event_emitter").EventEmitter;

/**
 * @class CommandManager
 *
 **/

/**
 * new CommandManager(platform, commands)
 * @param {String} platform Identifier for the platform; must be either `"mac"` or `"win"`
 * @param {Array} commands A list of commands
 *
 **/

var CommandManager = function(platform, commands) {
    MultiHashHandler.call(this, commands, platform);
    this.byName = this.commands;
    this.setDefaultHandler("exec", function(e) {
        return e.command.exec(e.editor, e.args || {});
    });
};

oop.inherits(CommandManager, MultiHashHandler);

(function() {

    oop.implement(this, EventEmitter);

    this.exec = function(command, editor, args) {
        if (Array.isArray(command)) {
            for (var i = command.length; i--; ) {
                if (this.exec(command[i], editor, args)) return true;
            }
            return false;
        }
        
        if (typeof command === "string")
            command = this.commands[command];

        if (!command)
            return false;

        if (editor && editor.$readOnly && !command.readOnly)
            return false;

        var e = {editor: editor, command: command, args: args};
        e.returnValue = this._emit("exec", e);
        this._signal("afterExec", e);

        return e.returnValue === false ? false : true;
    };

    this.toggleRecording = function(editor) {
        if (this.$inReplay)
            return;

        editor && editor._emit("changeStatus");
        if (this.recording) {
            this.macro.pop();
            this.removeEventListener("exec", this.$addCommandToMacro);

            if (!this.macro.length)
                this.macro = this.oldMacro;

            return this.recording = false;
        }
        if (!this.$addCommandToMacro) {
            this.$addCommandToMacro = function(e) {
                this.macro.push([e.command, e.args]);
            }.bind(this);
        }

        this.oldMacro = this.macro;
        this.macro = [];
        this.on("exec", this.$addCommandToMacro);
        return this.recording = true;
    };

    this.replay = function(editor) {
        if (this.$inReplay || !this.macro)
            return;

        if (this.recording)
            return this.toggleRecording(editor);

        try {
            this.$inReplay = true;
            this.macro.forEach(function(x) {
                if (typeof x == "string")
                    this.exec(x, editor);
                else
                    this.exec(x[0], editor, x[1]);
            }, this);
        } finally {
            this.$inReplay = false;
        }
    };

    this.trimMacro = function(m) {
        return m.map(function(x){
            if (typeof x[0] != "string")
                x[0] = x[0].name;
            if (!x[1])
                x = x[0];
            return x;
        });
    };

}).call(CommandManager.prototype);

exports.CommandManager = CommandManager;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/commands/default_commands',['require','exports','module','../lib/lang','../config','../range'],function(require, exports, module) {
"use strict";

var lang = require("../lib/lang");
var config = require("../config");
var Range = require("../range").Range;

function bindKey(win, mac) {
    return {win: win, mac: mac};
}

/*
    multiSelectAction: "forEach"|"forEachLine"|function|undefined,
    scrollIntoView: true|"cursor"|"center"|"selectionPart"
*/
exports.commands = [{
    name: "showSettingsMenu",
    bindKey: bindKey("Ctrl-,", "Command-,"),
    exec: function(editor) {
        config.loadModule("ace/ext/settings_menu", function(module) {
            module.init(editor);
            editor.showSettingsMenu();
        });
    },
    readOnly: true
}, {
    name: "goToNextError",
    bindKey: bindKey("Alt-E", "F4"),
    exec: function(editor) {
        config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, 1);
        });
    },
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "goToPreviousError",
    bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
    exec: function(editor) {
        config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, -1);
        });
    },
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "selectall",
    bindKey: bindKey("Ctrl-A", "Command-A"),
    exec: function(editor) { editor.selectAll(); },
    readOnly: true
}, {
    name: "centerselection",
    bindKey: bindKey(null, "Ctrl-L"),
    exec: function(editor) { editor.centerSelection(); },
    readOnly: true
}, {
    name: "gotoline",
    bindKey: bindKey("Ctrl-L", "Command-L"),
    exec: function(editor) {
        var line = parseInt(prompt("Enter line number:"), 10);
        if (!isNaN(line)) {
            editor.gotoLine(line);
        }
    },
    readOnly: true
}, {
    name: "fold",
    bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
    exec: function(editor) { editor.session.toggleFold(false); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "unfold",
    bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
    exec: function(editor) { editor.session.toggleFold(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "toggleFoldWidget",
    bindKey: bindKey("F2", "F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "toggleParentFoldWidget",
    bindKey: bindKey("Alt-F2", "Alt-F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldall",
    bindKey: bindKey(null, "Ctrl-Command-Option-0"),
    exec: function(editor) { editor.session.foldAll(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldOther",
    bindKey: bindKey("Alt-0", "Command-Option-0"),
    exec: function(editor) { 
        editor.session.foldAll();
        editor.session.unfold(editor.selection.getAllRanges());
    },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "unfoldall",
    bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
    exec: function(editor) { editor.session.unfold(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "findnext",
    bindKey: bindKey("Ctrl-K", "Command-G"),
    exec: function(editor) { editor.findNext(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "findprevious",
    bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
    exec: function(editor) { editor.findPrevious(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "selectOrFindNext",
    bindKey: bindKey("Alt-K", "Ctrl-G"),
    exec: function(editor) {
        if (editor.selection.isEmpty())
            editor.selection.selectWord();
        else
            editor.findNext(); 
    },
    readOnly: true
}, {
    name: "selectOrFindPrevious",
    bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
    exec: function(editor) { 
        if (editor.selection.isEmpty())
            editor.selection.selectWord();
        else
            editor.findPrevious();
    },
    readOnly: true
}, {
    name: "find",
    bindKey: bindKey("Ctrl-F", "Command-F"),
    exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor)});
    },
    readOnly: true
}, {
    name: "overwrite",
    bindKey: "Insert",
    exec: function(editor) { editor.toggleOverwrite(); },
    readOnly: true
}, {
    name: "selecttostart",
    bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
    exec: function(editor) { editor.getSelection().selectFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "gotostart",
    bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
    exec: function(editor) { editor.navigateFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "selectup",
    bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
    exec: function(editor) { editor.getSelection().selectUp(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "golineup",
    bindKey: bindKey("Up", "Up|Ctrl-P"),
    exec: function(editor, args) { editor.navigateUp(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttoend",
    bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
    exec: function(editor) { editor.getSelection().selectFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "gotoend",
    bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
    exec: function(editor) { editor.navigateFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "selectdown",
    bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
    exec: function(editor) { editor.getSelection().selectDown(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "golinedown",
    bindKey: bindKey("Down", "Down|Ctrl-N"),
    exec: function(editor, args) { editor.navigateDown(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectwordleft",
    bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
    exec: function(editor) { editor.getSelection().selectWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotowordleft",
    bindKey: bindKey("Ctrl-Left", "Option-Left"),
    exec: function(editor) { editor.navigateWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttolinestart",
    bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotolinestart",
    bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
    exec: function(editor) { editor.navigateLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectleft",
    bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
    exec: function(editor) { editor.getSelection().selectLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotoleft",
    bindKey: bindKey("Left", "Left|Ctrl-B"),
    exec: function(editor, args) { editor.navigateLeft(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectwordright",
    bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
    exec: function(editor) { editor.getSelection().selectWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotowordright",
    bindKey: bindKey("Ctrl-Right", "Option-Right"),
    exec: function(editor) { editor.navigateWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttolineend",
    bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotolineend",
    bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
    exec: function(editor) { editor.navigateLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectright",
    bindKey: bindKey("Shift-Right", "Shift-Right"),
    exec: function(editor) { editor.getSelection().selectRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotoright",
    bindKey: bindKey("Right", "Right|Ctrl-F"),
    exec: function(editor, args) { editor.navigateRight(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectpagedown",
    bindKey: "Shift-PageDown",
    exec: function(editor) { editor.selectPageDown(); },
    readOnly: true
}, {
    name: "pagedown",
    bindKey: bindKey(null, "Option-PageDown"),
    exec: function(editor) { editor.scrollPageDown(); },
    readOnly: true
}, {
    name: "gotopagedown",
    bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
    exec: function(editor) { editor.gotoPageDown(); },
    readOnly: true
}, {
    name: "selectpageup",
    bindKey: "Shift-PageUp",
    exec: function(editor) { editor.selectPageUp(); },
    readOnly: true
}, {
    name: "pageup",
    bindKey: bindKey(null, "Option-PageUp"),
    exec: function(editor) { editor.scrollPageUp(); },
    readOnly: true
}, {
    name: "gotopageup",
    bindKey: "PageUp",
    exec: function(editor) { editor.gotoPageUp(); },
    readOnly: true
}, {
    name: "scrollup",
    bindKey: bindKey("Ctrl-Up", null),
    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
}, {
    name: "scrolldown",
    bindKey: bindKey("Ctrl-Down", null),
    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
}, {
    name: "selectlinestart",
    bindKey: "Shift-Home",
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectlineend",
    bindKey: "Shift-End",
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "togglerecording",
    bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
    exec: function(editor) { editor.commands.toggleRecording(editor); },
    readOnly: true
}, {
    name: "replaymacro",
    bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
    exec: function(editor) { editor.commands.replay(editor); },
    readOnly: true
}, {
    name: "jumptomatching",
    bindKey: bindKey("Ctrl-P", "Ctrl-P"),
    exec: function(editor) { editor.jumpToMatching(); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "selecttomatching",
    bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
    exec: function(editor) { editor.jumpToMatching(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "expandToMatching",
    bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
    exec: function(editor) { editor.jumpToMatching(true, true); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "passKeysToBrowser",
    bindKey: bindKey(null, null),
    exec: function() {},
    passEvent: true,
    readOnly: true
}, {
    name: "copy",
    exec: function(editor) {
        // placeholder for replay macro
    },
    readOnly: true
},

// commands disabled in readOnly mode
{
    name: "cut",
    exec: function(editor) {
        var range = editor.getSelectionRange();
        editor._emit("cut", range);

        if (!editor.selection.isEmpty()) {
            editor.session.remove(range);
            editor.clearSelection();
        }
    },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "paste",
    exec: function(editor, args) {
        editor.$handlePaste(args);
    },
    scrollIntoView: "cursor"
}, {
    name: "removeline",
    bindKey: bindKey("Ctrl-D", "Command-D"),
    exec: function(editor) { editor.removeLines(); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEachLine"
}, {
    name: "duplicateSelection",
    bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
    exec: function(editor) { editor.duplicateSelection(); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "sortlines",
    bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
    exec: function(editor) { editor.sortLines(); },
    scrollIntoView: "selection",
    multiSelectAction: "forEachLine"
}, {
    name: "togglecomment",
    bindKey: bindKey("Ctrl-/", "Command-/"),
    exec: function(editor) { editor.toggleCommentLines(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "toggleBlockComment",
    bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
    exec: function(editor) { editor.toggleBlockComment(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "modifyNumberUp",
    bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
    exec: function(editor) { editor.modifyNumber(1); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "modifyNumberDown",
    bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
    exec: function(editor) { editor.modifyNumber(-1); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "replace",
    bindKey: bindKey("Ctrl-H", "Command-Option-F"),
    exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor, true)});
    }
}, {
    name: "undo",
    bindKey: bindKey("Ctrl-Z", "Command-Z"),
    exec: function(editor) { editor.undo(); }
}, {
    name: "redo",
    bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
    exec: function(editor) { editor.redo(); }
}, {
    name: "copylinesup",
    bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
    exec: function(editor) { editor.copyLinesUp(); },
    scrollIntoView: "cursor"
}, {
    name: "movelinesup",
    bindKey: bindKey("Alt-Up", "Option-Up"),
    exec: function(editor) { editor.moveLinesUp(); },
    scrollIntoView: "cursor"
}, {
    name: "copylinesdown",
    bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
    exec: function(editor) { editor.copyLinesDown(); },
    scrollIntoView: "cursor"
}, {
    name: "movelinesdown",
    bindKey: bindKey("Alt-Down", "Option-Down"),
    exec: function(editor) { editor.moveLinesDown(); },
    scrollIntoView: "cursor"
}, {
    name: "del",
    bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
    exec: function(editor) { editor.remove("right"); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "backspace",
    bindKey: bindKey(
        "Shift-Backspace|Backspace",
        "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"
    ),
    exec: function(editor) { editor.remove("left"); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "cut_or_delete",
    bindKey: bindKey("Shift-Delete", null),
    exec: function(editor) { 
        if (editor.selection.isEmpty()) {
            editor.remove("left");
        } else {
            return false;
        }
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolinestart",
    bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
    exec: function(editor) { editor.removeToLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolineend",
    bindKey: bindKey("Alt-Delete", "Ctrl-K"),
    exec: function(editor) { editor.removeToLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removewordleft",
    bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
    exec: function(editor) { editor.removeWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removewordright",
    bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
    exec: function(editor) { editor.removeWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "outdent",
    bindKey: bindKey("Shift-Tab", "Shift-Tab"),
    exec: function(editor) { editor.blockOutdent(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "indent",
    bindKey: bindKey("Tab", "Tab"),
    exec: function(editor) { editor.indent(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "blockoutdent",
    bindKey: bindKey("Ctrl-[", "Ctrl-["),
    exec: function(editor) { editor.blockOutdent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "blockindent",
    bindKey: bindKey("Ctrl-]", "Ctrl-]"),
    exec: function(editor) { editor.blockIndent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "insertstring",
    exec: function(editor, str) { editor.insert(str); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "inserttext",
    exec: function(editor, args) {
        editor.insert(lang.stringRepeat(args.text  || "", args.times || 1));
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "splitline",
    bindKey: bindKey(null, "Ctrl-O"),
    exec: function(editor) { editor.splitLine(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "transposeletters",
    bindKey: bindKey("Ctrl-T", "Ctrl-T"),
    exec: function(editor) { editor.transposeLetters(); },
    multiSelectAction: function(editor) {editor.transposeSelections(1); },
    scrollIntoView: "cursor"
}, {
    name: "touppercase",
    bindKey: bindKey("Ctrl-U", "Ctrl-U"),
    exec: function(editor) { editor.toUpperCase(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "tolowercase",
    bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
    exec: function(editor) { editor.toLowerCase(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "expandtoline",
    bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
    exec: function(editor) {
        var range = editor.selection.getRange();

        range.start.column = range.end.column = 0;
        range.end.row++;
        editor.selection.setRange(range, false);
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "joinlines",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        var isBackwards = editor.selection.isBackwards();
        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
        var selectedCount = selectedText.replace(/\n\s*/, " ").length;
        var insertLine = editor.session.doc.getLine(selectionStart.row);

        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
            if (curLine.length !== 0) {
                curLine = " " + curLine;
            }
            insertLine += curLine;
        }

        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
            // Don't insert a newline at the end of the document
            insertLine += editor.session.doc.getNewLineCharacter();
        }

        editor.clearSelection();
        editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);

        if (selectedCount > 0) {
            // Select the text that was previously selected
            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
        } else {
            // If the joined line had something in it, start the cursor at that something
            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
        }
    },
    multiSelectAction: "forEach",
    readOnly: true
}, {
    name: "invertSelection",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        var endRow = editor.session.doc.getLength() - 1;
        var endCol = editor.session.doc.getLine(endRow).length;
        var ranges = editor.selection.rangeList.ranges;
        var newRanges = [];

        // If multiple selections don't exist, rangeList will return 0 so replace with single range
        if (ranges.length < 1) {
            ranges = [editor.selection.getRange()];
        }

        for (var i = 0; i < ranges.length; i++) {
            if (i == (ranges.length - 1)) {
                // The last selection must connect to the end of the document, unless it already does
                if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                    newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                }
            }

            if (i === 0) {
                // The first selection must connect to the start of the document, unless it already does
                if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                    newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                }
            } else {
                newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));
            }
        }

        editor.exitMultiSelectMode();
        editor.clearSelection();

        for(var i = 0; i < newRanges.length; i++) {
            editor.selection.addRange(newRanges[i], false);
        }
    },
    readOnly: true,
    scrollIntoView: "none"
}];

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/editor',['require','exports','module','./lib/fixoldbrowsers','./lib/oop','./lib/dom','./lib/lang','./lib/useragent','./keyboard/textinput','./mouse/mouse_handler','./mouse/fold_handler','./keyboard/keybinding','./edit_session','./search','./range','./lib/event_emitter','./commands/command_manager','./commands/default_commands','./config','./token_iterator'],function(require, exports, module) {
"use strict";

require("./lib/fixoldbrowsers");

var oop = require("./lib/oop");
var dom = require("./lib/dom");
var lang = require("./lib/lang");
var useragent = require("./lib/useragent");
var TextInput = require("./keyboard/textinput").TextInput;
var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
var FoldHandler = require("./mouse/fold_handler").FoldHandler;
var KeyBinding = require("./keyboard/keybinding").KeyBinding;
var EditSession = require("./edit_session").EditSession;
var Search = require("./search").Search;
var Range = require("./range").Range;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var CommandManager = require("./commands/command_manager").CommandManager;
var defaultCommands = require("./commands/default_commands").commands;
var config = require("./config");
var TokenIterator = require("./token_iterator").TokenIterator;

/**
 * The main entry point into the Ace functionality.
 *
 * The `Editor` manages the [[EditSession]] (which manages [[Document]]s), as well as the [[VirtualRenderer]], which draws everything to the screen.
 *
 * Event sessions dealing with the mouse and keyboard are bubbled up from `Document` to the `Editor`, which decides what to do with them.
 * @class Editor
 **/

/**
 * Creates a new `Editor` object.
 *
 * @param {VirtualRenderer} renderer Associated `VirtualRenderer` that draws everything
 * @param {EditSession} session The `EditSession` to refer to
 *
 *
 * @constructor
 **/
var Editor = function(renderer, session) {
    var container = renderer.getContainerElement();
    this.container = container;
    this.renderer = renderer;

    this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
    this.textInput  = new TextInput(renderer.getTextAreaContainer(), this);
    this.renderer.textarea = this.textInput.getElement();
    this.keyBinding = new KeyBinding(this);

    // TODO detect touch event support
    this.$mouseHandler = new MouseHandler(this);
    new FoldHandler(this);

    this.$blockScrolling = 0;
    this.$search = new Search().set({
        wrap: true
    });

    this.$historyTracker = this.$historyTracker.bind(this);
    this.commands.on("exec", this.$historyTracker);

    this.$initOperationListeners();
    
    this._$emitInputEvent = lang.delayedCall(function() {
        this._signal("input", {});
        if (this.session && this.session.bgTokenizer)
            this.session.bgTokenizer.scheduleStart();
    }.bind(this));
    
    this.on("change", function(_, _self) {
        _self._$emitInputEvent.schedule(31);
    });

    this.setSession(session || new EditSession(""));
    config.resetOptions(this);
    config._signal("editor", this);
};

(function(){

    oop.implement(this, EventEmitter);

    this.$initOperationListeners = function() {
        function last(a) {return a[a.length - 1]}

        this.selections = [];
        this.commands.on("exec", this.startOperation.bind(this), true);
        this.commands.on("afterExec", this.endOperation.bind(this), true);

        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));

        this.on("change", function() {
            this.curOp || this.startOperation();
            this.curOp.docChanged = true;
        }.bind(this), true);

        this.on("changeSelection", function() {
            this.curOp || this.startOperation();
            this.curOp.selectionChanged = true;
        }.bind(this), true);
    };

    this.curOp = null;
    this.prevOp = {};
    this.startOperation = function(commadEvent) {
        if (this.curOp) {
            if (!commadEvent || this.curOp.command)
                return;
            this.prevOp = this.curOp;
        }
        if (!commadEvent) {
            this.previousCommand = null;
            commadEvent = {};
        }

        this.$opResetTimer.schedule();
        this.curOp = {
            command: commadEvent.command || {},
            args: commadEvent.args,
            scrollTop: this.renderer.scrollTop
        };
        if (this.curOp.command.name && this.curOp.command.scrollIntoView !== undefined)
            this.$blockScrolling++;
    };

    this.endOperation = function(e) {
        if (this.curOp) {
            if (e && e.returnValue === false)
                return this.curOp = null;
            this._signal("beforeEndOperation");
            var command = this.curOp.command;
            if (command.name && this.$blockScrolling > 0)
                this.$blockScrolling--;
            var scrollIntoView = command && command.scrollIntoView;
            if (scrollIntoView) {
                switch (scrollIntoView) {
                    case "center-animate":
                        scrollIntoView = "animate";
                        /* fall through */
                    case "center":
                        this.renderer.scrollCursorIntoView(null, 0.5);
                        break;
                    case "animate":
                    case "cursor":
                        this.renderer.scrollCursorIntoView();
                        break;
                    case "selectionPart":
                        var range = this.selection.getRange();
                        var config = this.renderer.layerConfig;
                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                        }
                        break;
                    default:
                        break;
                }
                if (scrollIntoView == "animate")
                    this.renderer.animateScrolling(this.curOp.scrollTop);
            }
            
            this.prevOp = this.curOp;
            this.curOp = null;
        }
    };

    // TODO use property on commands instead of this
    this.$mergeableCommands = ["backspace", "del", "insertstring"];
    this.$historyTracker = function(e) {
        if (!this.$mergeUndoDeltas)
            return;

        var prev = this.prevOp;
        var mergeableCommands = this.$mergeableCommands;
        // previous command was the same
        var shouldMerge = prev.command && (e.command.name == prev.command.name);
        if (e.command.name == "insertstring") {
            var text = e.args;
            if (this.mergeNextCommand === undefined)
                this.mergeNextCommand = true;

            shouldMerge = shouldMerge
                && this.mergeNextCommand // previous command allows to coalesce with
                && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

            this.mergeNextCommand = true;
        } else {
            shouldMerge = shouldMerge
                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
        }

        if (
            this.$mergeUndoDeltas != "always"
            && Date.now() - this.sequenceStartTime > 2000
        ) {
            shouldMerge = false; // the sequence is too long
        }

        if (shouldMerge)
            this.session.mergeUndoDeltas = true;
        else if (mergeableCommands.indexOf(e.command.name) !== -1)
            this.sequenceStartTime = Date.now();
    };

    /**
     * Sets a new key handler, such as "vim" or "windows".
     * @param {String} keyboardHandler The new key handler
     *
     **/
    this.setKeyboardHandler = function(keyboardHandler, cb) {
        if (keyboardHandler && typeof keyboardHandler === "string") {
            this.$keybindingId = keyboardHandler;
            var _self = this;
            config.loadModule(["keybinding", keyboardHandler], function(module) {
                if (_self.$keybindingId == keyboardHandler)
                    _self.keyBinding.setKeyboardHandler(module && module.handler);
                cb && cb();
            });
        } else {
            this.$keybindingId = null;
            this.keyBinding.setKeyboardHandler(keyboardHandler);
            cb && cb();
        }
    };

    /**
     * Returns the keyboard handler, such as "vim" or "windows".
     *
     * @returns {String}
     *
     **/
    this.getKeyboardHandler = function() {
        return this.keyBinding.getKeyboardHandler();
    };


    /**
     * Emitted whenever the [[EditSession]] changes.
     * @event changeSession
     * @param {Object} e An object with two properties, `oldSession` and `session`, that represent the old and new [[EditSession]]s.
     *
     **/
    /**
     * Sets a new editsession to use. This method also emits the `'changeSession'` event.
     * @param {EditSession} session The new session to use
     *
     **/
    this.setSession = function(session) {
        if (this.session == session)
            return;
        
        // make sure operationEnd events are not emitted to wrong session
        if (this.curOp) this.endOperation();
        this.curOp = {};

        var oldSession = this.session;
        if (oldSession) {
            this.session.off("change", this.$onDocumentChange);
            this.session.off("changeMode", this.$onChangeMode);
            this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
            this.session.off("changeTabSize", this.$onChangeTabSize);
            this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
            this.session.off("changeWrapMode", this.$onChangeWrapMode);
            this.session.off("changeFold", this.$onChangeFold);
            this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
            this.session.off("changeBackMarker", this.$onChangeBackMarker);
            this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
            this.session.off("changeAnnotation", this.$onChangeAnnotation);
            this.session.off("changeOverwrite", this.$onCursorChange);
            this.session.off("changeScrollTop", this.$onScrollTopChange);
            this.session.off("changeScrollLeft", this.$onScrollLeftChange);

            var selection = this.session.getSelection();
            selection.off("changeCursor", this.$onCursorChange);
            selection.off("changeSelection", this.$onSelectionChange);
        }

        this.session = session;
        if (session) {
            this.$onDocumentChange = this.onDocumentChange.bind(this);
            session.on("change", this.$onDocumentChange);
            this.renderer.setSession(session);
    
            this.$onChangeMode = this.onChangeMode.bind(this);
            session.on("changeMode", this.$onChangeMode);
    
            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
            session.on("tokenizerUpdate", this.$onTokenizerUpdate);
    
            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
            session.on("changeTabSize", this.$onChangeTabSize);
    
            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
            session.on("changeWrapLimit", this.$onChangeWrapLimit);
    
            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
            session.on("changeWrapMode", this.$onChangeWrapMode);
    
            this.$onChangeFold = this.onChangeFold.bind(this);
            session.on("changeFold", this.$onChangeFold);
    
            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
            this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
    
            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
            this.session.on("changeBackMarker", this.$onChangeBackMarker);
    
            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
            this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
    
            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
            this.session.on("changeAnnotation", this.$onChangeAnnotation);
    
            this.$onCursorChange = this.onCursorChange.bind(this);
            this.session.on("changeOverwrite", this.$onCursorChange);
    
            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
            this.session.on("changeScrollTop", this.$onScrollTopChange);
    
            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
            this.session.on("changeScrollLeft", this.$onScrollLeftChange);
    
            this.selection = session.getSelection();
            this.selection.on("changeCursor", this.$onCursorChange);
    
            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.on("changeSelection", this.$onSelectionChange);
    
            this.onChangeMode();
    
            this.$blockScrolling += 1;
            this.onCursorChange();
            this.$blockScrolling -= 1;
    
            this.onScrollTopChange();
            this.onScrollLeftChange();
            this.onSelectionChange();
            this.onChangeFrontMarker();
            this.onChangeBackMarker();
            this.onChangeBreakpoint();
            this.onChangeAnnotation();
            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
            this.renderer.updateFull();
        } else {
            this.selection = null;
            this.renderer.setSession(session);
        }

        this._signal("changeSession", {
            session: session,
            oldSession: oldSession
        });
        
        this.curOp = null;
        
        oldSession && oldSession._signal("changeEditor", {oldEditor: this});
        session && session._signal("changeEditor", {editor: this});
    };

    /**
     * Returns the current session being used.
     * @returns {EditSession}
     **/
    this.getSession = function() {
        return this.session;
    };

    /**
     * Sets the current document to `val`.
     * @param {String} val The new value to set for the document
     * @param {Number} cursorPos Where to set the new value. `undefined` or 0 is selectAll, -1 is at the document start, and 1 is at the end
     *
     * @returns {String} The current document value
     * @related Document.setValue
     **/
    this.setValue = function(val, cursorPos) {
        this.session.doc.setValue(val);

        if (!cursorPos)
            this.selectAll();
        else if (cursorPos == 1)
            this.navigateFileEnd();
        else if (cursorPos == -1)
            this.navigateFileStart();

        return val;
    };

    /**
     * Returns the current session's content.
     *
     * @returns {String}
     * @related EditSession.getValue
     **/
    this.getValue = function() {
        return this.session.getValue();
    };

    /**
     *
     * Returns the currently highlighted selection.
     * @returns {Selection} The selection object
     **/
    this.getSelection = function() {
        return this.selection;
    };

    /**
     * {:VirtualRenderer.onResize}
     * @param {Boolean} force If `true`, recomputes the size, even if the height and width haven't changed
     *
     *
     * @related VirtualRenderer.onResize
     **/
    this.resize = function(force) {
        this.renderer.onResize(force);
    };

    /**
     * {:VirtualRenderer.setTheme}
     * @param {String} theme The path to a theme
     * @param {Function} cb optional callback called when theme is loaded
     **/
    this.setTheme = function(theme, cb) {
        this.renderer.setTheme(theme, cb);
    };

    /**
     * {:VirtualRenderer.getTheme}
     *
     * @returns {String} The set theme
     * @related VirtualRenderer.getTheme
     **/
    this.getTheme = function() {
        return this.renderer.getTheme();
    };

    /**
     * {:VirtualRenderer.setStyle}
     * @param {String} style A class name
     *
     *
     * @related VirtualRenderer.setStyle
     **/
    this.setStyle = function(style) {
        this.renderer.setStyle(style);
    };

    /**
     * {:VirtualRenderer.unsetStyle}
     * @related VirtualRenderer.unsetStyle
     **/
    this.unsetStyle = function(style) {
        this.renderer.unsetStyle(style);
    };

    /**
     * Gets the current font size of the editor text.
     */
    this.getFontSize = function () {
        return this.getOption("fontSize") ||
           dom.computedStyle(this.container, "fontSize");
    };

    /**
     * Set a new font size (in pixels) for the editor text.
     * @param {String} size A font size ( _e.g._ "12px")
     *
     *
     **/
    this.setFontSize = function(size) {
        this.setOption("fontSize", size);
    };

    this.$highlightBrackets = function() {
        if (this.session.$bracketHighlight) {
            this.session.removeMarker(this.session.$bracketHighlight);
            this.session.$bracketHighlight = null;
        }

        if (this.$highlightPending) {
            return;
        }

        // perform highlight async to not block the browser during navigation
        var self = this;
        this.$highlightPending = true;
        setTimeout(function() {
            self.$highlightPending = false;
            var session = self.session;
            if (!session || !session.bgTokenizer) return;
            var pos = session.findMatchingBracket(self.getCursorPosition());
            if (pos) {
                var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
            } else if (session.$mode.getMatching) {
                var range = session.$mode.getMatching(self.session);
            }
            if (range)
                session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
        }, 50);
    };

    // todo: move to mode.getMatching
    this.$highlightTags = function() {
        if (this.$highlightTagPending)
            return;

        // perform highlight async to not block the browser during navigation
        var self = this;
        this.$highlightTagPending = true;
        setTimeout(function() {
            self.$highlightTagPending = false;
            
            var session = self.session;
            if (!session || !session.bgTokenizer) return;
            
            var pos = self.getCursorPosition();
            var iterator = new TokenIterator(self.session, pos.row, pos.column);
            var token = iterator.getCurrentToken();
            
            if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
                return;
            }
            
            if (token.type.indexOf("tag-open") != -1) {
                token = iterator.stepForward();
                if (!token)
                    return;
            }
            
            var tag = token.value;
            var depth = 0;
            var prevToken = iterator.stepBackward();
            
            if (prevToken.value == '<'){
                //find closing tag
                do {
                    prevToken = token;
                    token = iterator.stepForward();
                    
                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                        if (prevToken.value === '<'){
                            depth++;
                        } else if (prevToken.value === '</'){
                            depth--;
                        }
                    }
                    
                } while (token && depth >= 0);
            } else {
                //find opening tag
                do {
                    token = prevToken;
                    prevToken = iterator.stepBackward();
                    
                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                        if (prevToken.value === '<') {
                            depth++;
                        } else if (prevToken.value === '</') {
                            depth--;
                        }
                    }
                } while (prevToken && depth <= 0);
                
                //select tag again
                iterator.stepForward();
            }
            
            if (!token) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
                return;
            }
            
            var row = iterator.getCurrentTokenRow();
            var column = iterator.getCurrentTokenColumn();
            var range = new Range(row, column, row, column+token.value.length);
            
            //remove range if different
            var sbm = session.$backMarkers[session.$tagHighlight];
            if (session.$tagHighlight && sbm != undefined && range.compareRange(sbm.range) !== 0) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
            }
            
            if (range && !session.$tagHighlight)
                session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
        }, 50);
    };

    /**
     *
     * Brings the current `textInput` into focus.
     **/
    this.focus = function() {
        // Safari needs the timeout
        // iOS and Firefox need it called immediately
        // to be on the save side we do both
        var _self = this;
        setTimeout(function() {
            _self.textInput.focus();
        });
        this.textInput.focus();
    };

    /**
     * Returns `true` if the current `textInput` is in focus.
     * @return {Boolean}
     **/
    this.isFocused = function() {
        return this.textInput.isFocused();
    };

    /**
     *
     * Blurs the current `textInput`.
     **/
    this.blur = function() {
        this.textInput.blur();
    };

    /**
     * Emitted once the editor comes into focus.
     * @event focus
     *
     *
     **/
    this.onFocus = function(e) {
        if (this.$isFocused)
            return;
        this.$isFocused = true;
        this.renderer.showCursor();
        this.renderer.visualizeFocus();
        this._emit("focus", e);
    };

    /**
     * Emitted once the editor has been blurred.
     * @event blur
     *
     *
     **/
    this.onBlur = function(e) {
        if (!this.$isFocused)
            return;
        this.$isFocused = false;
        this.renderer.hideCursor();
        this.renderer.visualizeBlur();
        this._emit("blur", e);
    };

    this.$cursorChange = function() {
        this.renderer.updateCursor();
    };

    /**
     * Emitted whenever the document is changed.
     * @event change
     * @param {Object} e Contains a single property, `data`, which has the delta of changes
     *
     *
     *
     **/
    this.onDocumentChange = function(delta) {
        // Rerender and emit "change" event.
        var wrap = this.session.$useWrapMode;
        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
        this.renderer.updateLines(delta.start.row, lastRow, wrap);

        this._signal("change", delta);
        
        // Update cursor because tab characters can influence the cursor position.
        this.$cursorChange();
        this.$updateHighlightActiveLine();
    };

    this.onTokenizerUpdate = function(e) {
        var rows = e.data;
        this.renderer.updateLines(rows.first, rows.last);
    };


    this.onScrollTopChange = function() {
        this.renderer.scrollToY(this.session.getScrollTop());
    };

    this.onScrollLeftChange = function() {
        this.renderer.scrollToX(this.session.getScrollLeft());
    };

    /**
     * Emitted when the selection changes.
     *
     **/
    this.onCursorChange = function() {
        this.$cursorChange();

        if (!this.$blockScrolling) {
            config.warn("Automatically scrolling cursor into view after selection change",
                "this will be disabled in the next version",
                "set editor.$blockScrolling = Infinity to disable this message"
            );
            this.renderer.scrollCursorIntoView();
        }

        this.$highlightBrackets();
        this.$highlightTags();
        this.$updateHighlightActiveLine();
        this._signal("changeSelection");
    };

    this.$updateHighlightActiveLine = function() {
        var session = this.getSession();

        var highlight;
        if (this.$highlightActiveLine) {
            if ((this.$selectionStyle != "line" || !this.selection.isMultiLine()))
                highlight = this.getCursorPosition();
            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                highlight = false;
        }

        if (session.$highlightLineMarker && !highlight) {
            session.removeMarker(session.$highlightLineMarker.id);
            session.$highlightLineMarker = null;
        } else if (!session.$highlightLineMarker && highlight) {
            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
            range.id = session.addMarker(range, "ace_active-line", "screenLine");
            session.$highlightLineMarker = range;
        } else if (highlight) {
            session.$highlightLineMarker.start.row = highlight.row;
            session.$highlightLineMarker.end.row = highlight.row;
            session.$highlightLineMarker.start.column = highlight.column;
            session._signal("changeBackMarker");
        }
    };

    this.onSelectionChange = function(e) {
        var session = this.session;

        if (session.$selectionMarker) {
            session.removeMarker(session.$selectionMarker);
        }
        session.$selectionMarker = null;

        if (!this.selection.isEmpty()) {
            var range = this.selection.getRange();
            var style = this.getSelectionStyle();
            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
        } else {
            this.$updateHighlightActiveLine();
        }

        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
        this.session.highlight(re);

        this._signal("changeSelection");
    };

    this.$getSelectionHighLightRegexp = function() {
        var session = this.session;

        var selection = this.getSelectionRange();
        if (selection.isEmpty() || selection.isMultiLine())
            return;

        var startOuter = selection.start.column - 1;
        var endOuter = selection.end.column + 1;
        var line = session.getLine(selection.start.row);
        var lineCols = line.length;
        var needle = line.substring(Math.max(startOuter, 0),
                                    Math.min(endOuter, lineCols));

        // Make sure the outer characters are not part of the word.
        if ((startOuter >= 0 && /^[\w\d]/.test(needle)) ||
            (endOuter <= lineCols && /[\w\d]$/.test(needle)))
            return;

        needle = line.substring(selection.start.column, selection.end.column);
        if (!/^[\w\d]+$/.test(needle))
            return;

        var re = this.$search.$assembleRegExp({
            wholeWord: true,
            caseSensitive: true,
            needle: needle
        });

        return re;
    };


    this.onChangeFrontMarker = function() {
        this.renderer.updateFrontMarkers();
    };

    this.onChangeBackMarker = function() {
        this.renderer.updateBackMarkers();
    };


    this.onChangeBreakpoint = function() {
        this.renderer.updateBreakpoints();
    };

    this.onChangeAnnotation = function() {
        this.renderer.setAnnotations(this.session.getAnnotations());
    };


    this.onChangeMode = function(e) {
        this.renderer.updateText();
        this._emit("changeMode", e);
    };


    this.onChangeWrapLimit = function() {
        this.renderer.updateFull();
    };

    this.onChangeWrapMode = function() {
        this.renderer.onResize(true);
    };


    this.onChangeFold = function() {
        // Update the active line marker as due to folding changes the current
        // line range on the screen might have changed.
        this.$updateHighlightActiveLine();
        // TODO: This might be too much updating. Okay for now.
        this.renderer.updateFull();
    };

    
    /**
     * Returns the string of text currently highlighted.
     * @returns {String}
     **/
    this.getSelectedText = function() {
        return this.session.getTextRange(this.getSelectionRange());
    };
    
    /**
     * Emitted when text is copied.
     * @event copy
     * @param {String} text The copied text
     *
     **/
    /**
     * Returns the string of text currently highlighted.
     * @returns {String}
     * @deprecated Use getSelectedText instead.
     **/
    this.getCopyText = function() {
        var text = this.getSelectedText();
        this._signal("copy", text);
        return text;
    };

    /**
     * Called whenever a text "copy" happens.
     **/
    this.onCopy = function() {
        this.commands.exec("copy", this);
    };

    /**
     * Called whenever a text "cut" happens.
     **/
    this.onCut = function() {
        this.commands.exec("cut", this);
    };

    /**
     * Emitted when text is pasted.
     * @event paste
     * @param {Object} an object which contains one property, `text`, that represents the text to be pasted. Editing this property will alter the text that is pasted.
     *
     *
     **/
    /**
     * Called whenever a text "paste" happens.
     * @param {String} text The pasted text
     *
     *
     **/
    this.onPaste = function(text, event) {
        var e = {text: text, event: event};
        this.commands.exec("paste", this, e);
    };
    
    this.$handlePaste = function(e) {
        if (typeof e == "string") 
            e = {text: e};
        this._signal("paste", e);
        var text = e.text;
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
            this.insert(text);
        } else {
            var lines = text.split(/\r\n|\r|\n/);
            var ranges = this.selection.rangeList.ranges;
    
            if (lines.length > ranges.length || lines.length < 2 || !lines[1])
                return this.commands.exec("insertstring", this, text);
    
            for (var i = ranges.length; i--;) {
                var range = ranges[i];
                if (!range.isEmpty())
                    this.session.remove(range);
    
                this.session.insert(range.start, lines[i]);
            }
        }
    };

    this.execCommand = function(command, args) {
        return this.commands.exec(command, this, args);
    };

    /**
     * Inserts `text` into wherever the cursor is pointing.
     * @param {String} text The new text to add
     *
     **/
    this.insert = function(text, pasted) {
        var session = this.session;
        var mode = session.getMode();
        var cursor = this.getCursorPosition();

        if (this.getBehavioursEnabled() && !pasted) {
            // Get a transform if the current mode wants one.
            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
            if (transform) {
                if (text !== transform.text) {
                    this.session.mergeUndoDeltas = false;
                    this.$mergeNextCommand = false;
                }
                text = transform.text;

            }
        }
        
        if (text == "\t")
            text = this.session.getTabString();

        // remove selected text
        if (!this.selection.isEmpty()) {
            var range = this.getSelectionRange();
            cursor = this.session.remove(range);
            this.clearSelection();
        }
        else if (this.session.getOverwrite()) {
            var range = new Range.fromPoints(cursor, cursor);
            range.end.column += text.length;
            this.session.remove(range);
        }

        if (text == "\n" || text == "\r\n") {
            var line = session.getLine(cursor.row);
            if (cursor.column > line.search(/\S|$/)) {
                var d = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
            }
        }
        this.clearSelection();

        var start = cursor.column;
        var lineState = session.getState(cursor.row);
        var line = session.getLine(cursor.row);
        var shouldOutdent = mode.checkOutdent(lineState, line, text);
        var end = session.insert(cursor, text);

        if (transform && transform.selection) {
            if (transform.selection.length == 2) { // Transform relative to the current column
                this.selection.setSelectionRange(
                    new Range(cursor.row, start + transform.selection[0],
                              cursor.row, start + transform.selection[1]));
            } else { // Transform relative to the current row.
                this.selection.setSelectionRange(
                    new Range(cursor.row + transform.selection[0],
                              transform.selection[1],
                              cursor.row + transform.selection[2],
                              transform.selection[3]));
            }
        }

        if (session.getDocument().isNewLine(text)) {
            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

            session.insert({row: cursor.row+1, column: 0}, lineIndent);
        }
        if (shouldOutdent)
            mode.autoOutdent(lineState, session, cursor.row);
    };

    this.onTextInput = function(text) {
        this.keyBinding.onTextInput(text);
    };

    this.onCommandKey = function(e, hashId, keyCode) {
        this.keyBinding.onCommandKey(e, hashId, keyCode);
    };

    /**
     * Pass in `true` to enable overwrites in your session, or `false` to disable. If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emits the `changeOverwrite` event.
     * @param {Boolean} overwrite Defines whether or not to set overwrites
     *
     *
     * @related EditSession.setOverwrite
     **/
    this.setOverwrite = function(overwrite) {
        this.session.setOverwrite(overwrite);
    };

    /**
     * Returns `true` if overwrites are enabled; `false` otherwise.
     * @returns {Boolean}
     * @related EditSession.getOverwrite
     **/
    this.getOverwrite = function() {
        return this.session.getOverwrite();
    };

    /**
     * Sets the value of overwrite to the opposite of whatever it currently is.
     * @related EditSession.toggleOverwrite
     **/
    this.toggleOverwrite = function() {
        this.session.toggleOverwrite();
    };

    /**
     * Sets how fast the mouse scrolling should do.
     * @param {Number} speed A value indicating the new speed (in milliseconds)
     **/
    this.setScrollSpeed = function(speed) {
        this.setOption("scrollSpeed", speed);
    };

    /**
     * Returns the value indicating how fast the mouse scroll speed is (in milliseconds).
     * @returns {Number}
     **/
    this.getScrollSpeed = function() {
        return this.getOption("scrollSpeed");
    };

    /**
     * Sets the delay (in milliseconds) of the mouse drag.
     * @param {Number} dragDelay A value indicating the new delay
     **/
    this.setDragDelay = function(dragDelay) {
        this.setOption("dragDelay", dragDelay);
    };

    /**
     * Returns the current mouse drag delay.
     * @returns {Number}
     **/
    this.getDragDelay = function() {
        return this.getOption("dragDelay");
    };

    /**
     * Emitted when the selection style changes, via [[Editor.setSelectionStyle]].
     * @event changeSelectionStyle
     * @param {Object} data Contains one property, `data`, which indicates the new selection style
     **/
    /**
     * Draw selection markers spanning whole line, or only over selected text. Default value is "line"
     * @param {String} style The new selection style "line"|"text"
     *
     **/
    this.setSelectionStyle = function(val) {
        this.setOption("selectionStyle", val);
    };

    /**
     * Returns the current selection style.
     * @returns {String}
     **/
    this.getSelectionStyle = function() {
        return this.getOption("selectionStyle");
    };

    /**
     * Determines whether or not the current line should be highlighted.
     * @param {Boolean} shouldHighlight Set to `true` to highlight the current line
     **/
    this.setHighlightActiveLine = function(shouldHighlight) {
        this.setOption("highlightActiveLine", shouldHighlight);
    };
    /**
     * Returns `true` if current lines are always highlighted.
     * @return {Boolean}
     **/
    this.getHighlightActiveLine = function() {
        return this.getOption("highlightActiveLine");
    };
    this.setHighlightGutterLine = function(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    };

    this.getHighlightGutterLine = function() {
        return this.getOption("highlightGutterLine");
    };

    /**
     * Determines if the currently selected word should be highlighted.
     * @param {Boolean} shouldHighlight Set to `true` to highlight the currently selected word
     *
     **/
    this.setHighlightSelectedWord = function(shouldHighlight) {
        this.setOption("highlightSelectedWord", shouldHighlight);
    };

    /**
     * Returns `true` if currently highlighted words are to be highlighted.
     * @returns {Boolean}
     **/
    this.getHighlightSelectedWord = function() {
        return this.$highlightSelectedWord;
    };

    this.setAnimatedScroll = function(shouldAnimate){
        this.renderer.setAnimatedScroll(shouldAnimate);
    };

    this.getAnimatedScroll = function(){
        return this.renderer.getAnimatedScroll();
    };

    /**
     * If `showInvisibles` is set to `true`, invisible characters&mdash;like spaces or new lines&mdash;are show in the editor.
     * @param {Boolean} showInvisibles Specifies whether or not to show invisible characters
     *
     **/
    this.setShowInvisibles = function(showInvisibles) {
        this.renderer.setShowInvisibles(showInvisibles);
    };

    /**
     * Returns `true` if invisible characters are being shown.
     * @returns {Boolean}
     **/
    this.getShowInvisibles = function() {
        return this.renderer.getShowInvisibles();
    };

    this.setDisplayIndentGuides = function(display) {
        this.renderer.setDisplayIndentGuides(display);
    };

    this.getDisplayIndentGuides = function() {
        return this.renderer.getDisplayIndentGuides();
    };

    /**
     * If `showPrintMargin` is set to `true`, the print margin is shown in the editor.
     * @param {Boolean} showPrintMargin Specifies whether or not to show the print margin
     *
     **/
    this.setShowPrintMargin = function(showPrintMargin) {
        this.renderer.setShowPrintMargin(showPrintMargin);
    };

    /**
     * Returns `true` if the print margin is being shown.
     * @returns {Boolean}
     **/
    this.getShowPrintMargin = function() {
        return this.renderer.getShowPrintMargin();
    };

    /**
     * Sets the column defining where the print margin should be.
     * @param {Number} showPrintMargin Specifies the new print margin
     *
     **/
    this.setPrintMarginColumn = function(showPrintMargin) {
        this.renderer.setPrintMarginColumn(showPrintMargin);
    };

    /**
     * Returns the column number of where the print margin is.
     * @returns {Number}
     **/
    this.getPrintMarginColumn = function() {
        return this.renderer.getPrintMarginColumn();
    };

    /**
     * If `readOnly` is true, then the editor is set to read-only mode, and none of the content can change.
     * @param {Boolean} readOnly Specifies whether the editor can be modified or not
     *
     **/
    this.setReadOnly = function(readOnly) {
        this.setOption("readOnly", readOnly);
    };

    /**
     * Returns `true` if the editor is set to read-only mode.
     * @returns {Boolean}
     **/
    this.getReadOnly = function() {
        return this.getOption("readOnly");
    };

    /**
     * Specifies whether to use behaviors or not. ["Behaviors" in this case is the auto-pairing of special characters, like quotation marks, parenthesis, or brackets.]{: #BehaviorsDef}
     * @param {Boolean} enabled Enables or disables behaviors
     *
     **/
    this.setBehavioursEnabled = function (enabled) {
        this.setOption("behavioursEnabled", enabled);
    };

    /**
     * Returns `true` if the behaviors are currently enabled. {:BehaviorsDef}
     *
     * @returns {Boolean}
     **/
    this.getBehavioursEnabled = function () {
        return this.getOption("behavioursEnabled");
    };

    /**
     * Specifies whether to use wrapping behaviors or not, i.e. automatically wrapping the selection with characters such as brackets
     * when such a character is typed in.
     * @param {Boolean} enabled Enables or disables wrapping behaviors
     *
     **/
    this.setWrapBehavioursEnabled = function (enabled) {
        this.setOption("wrapBehavioursEnabled", enabled);
    };

    /**
     * Returns `true` if the wrapping behaviors are currently enabled.
     **/
    this.getWrapBehavioursEnabled = function () {
        return this.getOption("wrapBehavioursEnabled");
    };

    /**
     * Indicates whether the fold widgets should be shown or not.
     * @param {Boolean} show Specifies whether the fold widgets are shown
     **/
    this.setShowFoldWidgets = function(show) {
        this.setOption("showFoldWidgets", show);

    };
    /**
     * Returns `true` if the fold widgets are shown.
     * @return {Boolean}
     **/
    this.getShowFoldWidgets = function() {
        return this.getOption("showFoldWidgets");
    };

    this.setFadeFoldWidgets = function(fade) {
        this.setOption("fadeFoldWidgets", fade);
    };

    this.getFadeFoldWidgets = function() {
        return this.getOption("fadeFoldWidgets");
    };

    /**
     * Removes the current selection or one character.
     * @param {String} dir The direction of the deletion to occur, either "left" or "right"
     *
     **/
    this.remove = function(dir) {
        if (this.selection.isEmpty()){
            if (dir == "left")
                this.selection.selectLeft();
            else
                this.selection.selectRight();
        }

        var range = this.getSelectionRange();
        if (this.getBehavioursEnabled()) {
            var session = this.session;
            var state = session.getState(range.start.row);
            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

            if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == "\n") {
                    var line = session.getLine(range.end.row);
                    if (/^\s+$/.test(line)) {
                        range.end.column = line.length;
                    }
                }
            }
            if (new_range)
                range = new_range;
        }

        this.session.remove(range);
        this.clearSelection();
    };

    /**
     * Removes the word directly to the right of the current selection.
     **/
    this.removeWordRight = function() {
        if (this.selection.isEmpty())
            this.selection.selectWordRight();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };

    /**
     * Removes the word directly to the left of the current selection.
     **/
    this.removeWordLeft = function() {
        if (this.selection.isEmpty())
            this.selection.selectWordLeft();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };

    /**
     * Removes all the words to the left of the current selection, until the start of the line.
     **/
    this.removeToLineStart = function() {
        if (this.selection.isEmpty())
            this.selection.selectLineStart();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };

    /**
     * Removes all the words to the right of the current selection, until the end of the line.
     **/
    this.removeToLineEnd = function() {
        if (this.selection.isEmpty())
            this.selection.selectLineEnd();

        var range = this.getSelectionRange();
        if (range.start.column == range.end.column && range.start.row == range.end.row) {
            range.end.column = 0;
            range.end.row++;
        }

        this.session.remove(range);
        this.clearSelection();
    };

    /**
     * Splits the line at the current selection (by inserting an `'\n'`).
     **/
    this.splitLine = function() {
        if (!this.selection.isEmpty()) {
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        }

        var cursor = this.getCursorPosition();
        this.insert("\n");
        this.moveCursorToPosition(cursor);
    };

    /**
     * Transposes current line.
     **/
    this.transposeLetters = function() {
        if (!this.selection.isEmpty()) {
            return;
        }

        var cursor = this.getCursorPosition();
        var column = cursor.column;
        if (column === 0)
            return;

        var line = this.session.getLine(cursor.row);
        var swap, range;
        if (column < line.length) {
            swap = line.charAt(column) + line.charAt(column-1);
            range = new Range(cursor.row, column-1, cursor.row, column+1);
        }
        else {
            swap = line.charAt(column-1) + line.charAt(column-2);
            range = new Range(cursor.row, column-2, cursor.row, column);
        }
        this.session.replace(range, swap);
    };

    /**
     * Converts the current selection entirely into lowercase.
     **/
    this.toLowerCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toLowerCase());
        this.selection.setSelectionRange(originalRange);
    };

    /**
     * Converts the current selection entirely into uppercase.
     **/
    this.toUpperCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toUpperCase());
        this.selection.setSelectionRange(originalRange);
    };

    /**
     * Inserts an indentation into the current cursor position or indents the selected lines.
     *
     * @related EditSession.indentRows
     **/
    this.indent = function() {
        var session = this.session;
        var range = this.getSelectionRange();

        if (range.start.row < range.end.row) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, "\t");
            return;
        } else if (range.start.column < range.end.column) {
            var text = session.getTextRange(range);
            if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "\t");
                return;
            }
        }
        
        var line = session.getLine(range.start.row);
        var position = range.start;
        var size = session.getTabSize();
        var column = session.documentToScreenColumn(position.row, position.column);

        if (this.session.getUseSoftTabs()) {
            var count = (size - column % size);
            var indentString = lang.stringRepeat(" ", count);
        } else {
            var count = column % size;
            while (line[range.start.column - 1] == " " && count) {
                range.start.column--;
                count--;
            }
            this.selection.setSelectionRange(range);
            indentString = "\t";
        }
        return this.insert(indentString);
    };

    /**
     * Indents the current line.
     * @related EditSession.indentRows
     **/
    this.blockIndent = function() {
        var rows = this.$getSelectedRows();
        this.session.indentRows(rows.first, rows.last, "\t");
    };

    /**
     * Outdents the current line.
     * @related EditSession.outdentRows
     **/
    this.blockOutdent = function() {
        var selection = this.session.getSelection();
        this.session.outdentRows(selection.getRange());
    };

    // TODO: move out of core when we have good mechanism for managing extensions
    this.sortLines = function() {
        var rows = this.$getSelectedRows();
        var session = this.session;

        var lines = [];
        for (i = rows.first; i <= rows.last; i++)
            lines.push(session.getLine(i));

        lines.sort(function(a, b) {
            if (a.toLowerCase() < b.toLowerCase()) return -1;
            if (a.toLowerCase() > b.toLowerCase()) return 1;
            return 0;
        });

        var deleteRange = new Range(0, 0, 0, 0);
        for (var i = rows.first; i <= rows.last; i++) {
            var line = session.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            deleteRange.end.column = line.length;
            session.replace(deleteRange, lines[i-rows.first]);
        }
    };

    /**
     * Given the currently selected range, this function either comments all the lines, or uncomments all of them.
     **/
    this.toggleCommentLines = function() {
        var state = this.session.getState(this.getCursorPosition().row);
        var rows = this.$getSelectedRows();
        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
    };

    this.toggleBlockComment = function() {
        var cursor = this.getCursorPosition();
        var state = this.session.getState(cursor.row);
        var range = this.getSelectionRange();
        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
    };

    /**
     * Works like [[EditSession.getTokenAt]], except it returns a number.
     * @returns {Number}
     **/
    this.getNumberAt = function(row, column) {
        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
        _numberRx.lastIndex = 0;

        var s = this.session.getLine(row);
        while (_numberRx.lastIndex < column) {
            var m = _numberRx.exec(s);
            if(m.index <= column && m.index+m[0].length >= column){
                var number = {
                    value: m[0],
                    start: m.index,
                    end: m.index+m[0].length
                };
                return number;
            }
        }
        return null;
    };

    /**
     * If the character before the cursor is a number, this functions changes its value by `amount`.
     * @param {Number} amount The value to change the numeral by (can be negative to decrease value)
     *
     **/
    this.modifyNumber = function(amount) {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;

        // get the char before the cursor
        var charRange = new Range(row, column-1, row, column);

        var c = this.session.getTextRange(charRange);
        // if the char is a digit
        if (!isNaN(parseFloat(c)) && isFinite(c)) {
            // get the whole number the digit is part of
            var nr = this.getNumberAt(row, column);
            // if number found
            if (nr) {
                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                var decimals = nr.start + nr.value.length - fp;

                var t = parseFloat(nr.value);
                t *= Math.pow(10, decimals);


                if(fp !== nr.end && column < fp){
                    amount *= Math.pow(10, nr.end - column - 1);
                } else {
                    amount *= Math.pow(10, nr.end - column);
                }

                t += amount;
                t /= Math.pow(10, decimals);
                var nnr = t.toFixed(decimals);

                //update number
                var replaceRange = new Range(row, nr.start, row, nr.end);
                this.session.replace(replaceRange, nnr);

                //reposition the cursor
                this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));

            }
        }
    };

    /**
     * Removes all the lines in the current selection
     * @related EditSession.remove
     **/
    this.removeLines = function() {
        var rows = this.$getSelectedRows();
        this.session.removeFullLines(rows.first, rows.last);
        this.clearSelection();
    };

    this.duplicateSelection = function() {
        var sel = this.selection;
        var doc = this.session;
        var range = sel.getRange();
        var reverse = sel.isBackwards();
        if (range.isEmpty()) {
            var row = range.start.row;
            doc.duplicateLines(row, row);
        } else {
            var point = reverse ? range.start : range.end;
            var endPoint = doc.insert(point, doc.getTextRange(range), false);
            range.start = point;
            range.end = endPoint;

            sel.setSelectionRange(range, reverse);
        }
    };

    /**
     * Shifts all the selected lines down one row.
     *
     * @returns {Number} On success, it returns -1.
     * @related EditSession.moveLinesUp
     **/
    this.moveLinesDown = function() {
        this.$moveLines(1, false);
    };

    /**
     * Shifts all the selected lines up one row.
     * @returns {Number} On success, it returns -1.
     * @related EditSession.moveLinesDown
     **/
    this.moveLinesUp = function() {
        this.$moveLines(-1, false);
    };

    /**
     * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:
     * ```json
     *    { row: newRowLocation, column: newColumnLocation }
     * ```
     * @param {Range} fromRange The range of text you want moved within the document
     * @param {Object} toPosition The location (row and column) where you want to move the text to
     *
     * @returns {Range} The new range where the text was moved to.
     * @related EditSession.moveText
     **/
    this.moveText = function(range, toPosition, copy) {
        return this.session.moveText(range, toPosition, copy);
    };

    /**
     * Copies all the selected lines up one row.
     * @returns {Number} On success, returns 0.
     *
     **/
    this.copyLinesUp = function() {
        this.$moveLines(-1, true);
    };

    /**
     * Copies all the selected lines down one row.
     * @returns {Number} On success, returns the number of new rows added; in other words, `lastRow - firstRow + 1`.
     * @related EditSession.duplicateLines
     *
     **/
    this.copyLinesDown = function() {
        this.$moveLines(1, true);
    };

    /**
     * for internal use
     * @ignore
     *
     **/
    this.$moveLines = function(dir, copy) {
        var rows, moved;
        var selection = this.selection;
        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
            var range = selection.toOrientedRange();
            rows = this.$getSelectedRows(range);
            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
            if (copy && dir == -1) moved = 0;
            range.moveBy(moved, 0);
            selection.fromOrientedRange(range);
        } else {
            var ranges = selection.rangeList.ranges;
            selection.rangeList.detach(this.session);
            this.inVirtualSelectionMode = true;
            
            var diff = 0;
            var totalDiff = 0;
            var l = ranges.length;
            for (var i = 0; i < l; i++) {
                var rangeIndex = i;
                ranges[i].moveBy(diff, 0);
                rows = this.$getSelectedRows(ranges[i]);
                var first = rows.first;
                var last = rows.last;
                while (++i < l) {
                    if (totalDiff) ranges[i].moveBy(totalDiff, 0);
                    var subRows = this.$getSelectedRows(ranges[i]);
                    if (copy && subRows.first != last)
                        break;
                    else if (!copy && subRows.first > last + 1)
                        break;
                    last = subRows.last;
                }
                i--;
                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                if (copy && dir == -1) rangeIndex = i + 1;
                while (rangeIndex <= i) {
                    ranges[rangeIndex].moveBy(diff, 0);
                    rangeIndex++;
                }
                if (!copy) diff = 0;
                totalDiff += diff;
            }
            
            selection.fromOrientedRange(selection.ranges[0]);
            selection.rangeList.attach(this.session);
            this.inVirtualSelectionMode = false;
        }
    };

    /**
     * Returns an object indicating the currently selected rows. The object looks like this:
     *
     * ```json
     * { first: range.start.row, last: range.end.row }
     * ```
     *
     * @returns {Object}
     **/
    this.$getSelectedRows = function(range) {
        range = (range || this.getSelectionRange()).collapseRows();

        return {
            first: this.session.getRowFoldStart(range.start.row),
            last: this.session.getRowFoldEnd(range.end.row)
        };
    };

    this.onCompositionStart = function(text) {
        this.renderer.showComposition(this.getCursorPosition());
    };

    this.onCompositionUpdate = function(text) {
        this.renderer.setCompositionText(text);
    };

    this.onCompositionEnd = function() {
        this.renderer.hideComposition();
    };

    /**
     * {:VirtualRenderer.getFirstVisibleRow}
     *
     * @returns {Number}
     * @related VirtualRenderer.getFirstVisibleRow
     **/
    this.getFirstVisibleRow = function() {
        return this.renderer.getFirstVisibleRow();
    };

    /**
     * {:VirtualRenderer.getLastVisibleRow}
     *
     * @returns {Number}
     * @related VirtualRenderer.getLastVisibleRow
     **/
    this.getLastVisibleRow = function() {
        return this.renderer.getLastVisibleRow();
    };

    /**
     * Indicates if the row is currently visible on the screen.
     * @param {Number} row The row to check
     *
     * @returns {Boolean}
     **/
    this.isRowVisible = function(row) {
        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
    };

    /**
     * Indicates if the entire row is currently visible on the screen.
     * @param {Number} row The row to check
     *
     *
     * @returns {Boolean}
     **/
    this.isRowFullyVisible = function(row) {
        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
    };

    /**
     * Returns the number of currently visible rows.
     * @returns {Number}
     **/
    this.$getVisibleRowCount = function() {
        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
    };

    this.$moveByPage = function(dir, select) {
        var renderer = this.renderer;
        var config = this.renderer.layerConfig;
        var rows = dir * Math.floor(config.height / config.lineHeight);

        this.$blockScrolling++;
        if (select === true) {
            this.selection.$moveSelection(function(){
                this.moveCursorBy(rows, 0);
            });
        } else if (select === false) {
            this.selection.moveCursorBy(rows, 0);
            this.selection.clearSelection();
        }
        this.$blockScrolling--;

        var scrollTop = renderer.scrollTop;

        renderer.scrollBy(0, rows * config.lineHeight);
        if (select != null)
            renderer.scrollCursorIntoView(null, 0.5);

        renderer.animateScrolling(scrollTop);
    };

    /**
     * Selects the text from the current position of the document until where a "page down" finishes.
     **/
    this.selectPageDown = function() {
        this.$moveByPage(1, true);
    };

    /**
     * Selects the text from the current position of the document until where a "page up" finishes.
     **/
    this.selectPageUp = function() {
        this.$moveByPage(-1, true);
    };

    /**
     * Shifts the document to wherever "page down" is, as well as moving the cursor position.
     **/
    this.gotoPageDown = function() {
       this.$moveByPage(1, false);
    };

    /**
     * Shifts the document to wherever "page up" is, as well as moving the cursor position.
     **/
    this.gotoPageUp = function() {
        this.$moveByPage(-1, false);
    };

    /**
     * Scrolls the document to wherever "page down" is, without changing the cursor position.
     **/
    this.scrollPageDown = function() {
        this.$moveByPage(1);
    };

    /**
     * Scrolls the document to wherever "page up" is, without changing the cursor position.
     **/
    this.scrollPageUp = function() {
        this.$moveByPage(-1);
    };

    /**
     * Moves the editor to the specified row.
     * @related VirtualRenderer.scrollToRow
     **/
    this.scrollToRow = function(row) {
        this.renderer.scrollToRow(row);
    };

    /**
     * Scrolls to a line. If `center` is `true`, it puts the line in middle of screen (or attempts to).
     * @param {Number} line The line to scroll to
     * @param {Boolean} center If `true`
     * @param {Boolean} animate If `true` animates scrolling
     * @param {Function} callback Function to be called when the animation has finished
     *
     *
     * @related VirtualRenderer.scrollToLine
     **/
    this.scrollToLine = function(line, center, animate, callback) {
        this.renderer.scrollToLine(line, center, animate, callback);
    };

    /**
     * Attempts to center the current selection on the screen.
     **/
    this.centerSelection = function() {
        var range = this.getSelectionRange();
        var pos = {
            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
        };
        this.renderer.alignCursor(pos, 0.5);
    };

    /**
     * Gets the current position of the cursor.
     * @returns {Object} An object that looks something like this:
     *
     * ```json
     * { row: currRow, column: currCol }
     * ```
     *
     * @related Selection.getCursor
     **/
    this.getCursorPosition = function() {
        return this.selection.getCursor();
    };

    /**
     * Returns the screen position of the cursor.
     * @returns {Number}
     * @related EditSession.documentToScreenPosition
     **/
    this.getCursorPositionScreen = function() {
        return this.session.documentToScreenPosition(this.getCursorPosition());
    };

    /**
     * {:Selection.getRange}
     * @returns {Range}
     * @related Selection.getRange
     **/
    this.getSelectionRange = function() {
        return this.selection.getRange();
    };


    /**
     * Selects all the text in editor.
     * @related Selection.selectAll
     **/
    this.selectAll = function() {
        this.$blockScrolling += 1;
        this.selection.selectAll();
        this.$blockScrolling -= 1;
    };

    /**
     * {:Selection.clearSelection}
     * @related Selection.clearSelection
     **/
    this.clearSelection = function() {
        this.selection.clearSelection();
    };

    /**
     * Moves the cursor to the specified row and column. Note that this does not de-select the current selection.
     * @param {Number} row The new row number
     * @param {Number} column The new column number
     *
     *
     * @related Selection.moveCursorTo
     **/
    this.moveCursorTo = function(row, column) {
        this.selection.moveCursorTo(row, column);
    };

    /**
     * Moves the cursor to the position indicated by `pos.row` and `pos.column`.
     * @param {Object} pos An object with two properties, row and column
     *
     *
     * @related Selection.moveCursorToPosition
     **/
    this.moveCursorToPosition = function(pos) {
        this.selection.moveCursorToPosition(pos);
    };

    /**
     * Moves the cursor's row and column to the next matching bracket or HTML tag.
     *
     **/
    this.jumpToMatching = function(select, expand) {
        var cursor = this.getCursorPosition();
        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
        var prevToken = iterator.getCurrentToken();
        var token = prevToken || iterator.stepForward();

        if (!token) return;

        //get next closing tag or bracket
        var matchType;
        var found = false;
        var depth = {};
        var i = cursor.column - token.start;
        var bracketType;
        var brackets = {
            ")": "(",
            "(": "(",
            "]": "[",
            "[": "[",
            "{": "{",
            "}": "{"
        };
        
        do {
            if (token.value.match(/[{}()\[\]]/g)) {
                for (; i < token.value.length && !found; i++) {
                    if (!brackets[token.value[i]]) {
                        continue;
                    }

                    bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");

                    if (isNaN(depth[bracketType])) {
                        depth[bracketType] = 0;
                    }

                    switch (token.value[i]) {
                        case '(':
                        case '[':
                        case '{':
                            depth[bracketType]++;
                            break;
                        case ')':
                        case ']':
                        case '}':
                            depth[bracketType]--;

                            if (depth[bracketType] === -1) {
                                matchType = 'bracket';
                                found = true;
                            }
                        break;
                    }
                }
            }
            else if (token && token.type.indexOf('tag-name') !== -1) {
                if (isNaN(depth[token.value])) {
                    depth[token.value] = 0;
                }
                
                if (prevToken.value === '<') {
                    depth[token.value]++;
                }
                else if (prevToken.value === '</') {
                    depth[token.value]--;
                }
                
                if (depth[token.value] === -1) {
                    matchType = 'tag';
                    found = true;
                }
            }

            if (!found) {
                prevToken = token;
                token = iterator.stepForward();
                i = 0;
            }
        } while (token && !found);

        //no match found
        if (!matchType)
            return;

        var range, pos;
        if (matchType === 'bracket') {
            range = this.session.getBracketRange(cursor);
            if (!range) {
                range = new Range(
                    iterator.getCurrentTokenRow(),
                    iterator.getCurrentTokenColumn() + i - 1,
                    iterator.getCurrentTokenRow(),
                    iterator.getCurrentTokenColumn() + i - 1
                );
                pos = range.start;
                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                    range = this.session.getBracketRange(pos);
            }
        }
        else if (matchType === 'tag') {
            if (token && token.type.indexOf('tag-name') !== -1) 
                var tag = token.value;
            else
                return;

            range = new Range(
                iterator.getCurrentTokenRow(),
                iterator.getCurrentTokenColumn() - 2,
                iterator.getCurrentTokenRow(),
                iterator.getCurrentTokenColumn() - 2
            );

            //find matching tag
            if (range.compare(cursor.row, cursor.column) === 0) {
                found = false;
                do {
                    token = prevToken;
                    prevToken = iterator.stepBackward();
                    
                    if (prevToken) {
                        if (prevToken.type.indexOf('tag-close') !== -1) {
                            range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                        }

                        if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                            if (prevToken.value === '<') {
                                depth[tag]++;
                            }
                            else if (prevToken.value === '</') {
                                depth[tag]--;
                            }
                            
                            if (depth[tag] === 0)
                                found = true;
                        }
                    }
                } while (prevToken && !found);
            }

            //we found it
            if (token && token.type.indexOf('tag-name')) {
                pos = range.start;
                if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
                    pos = range.end;
            }
        }

        pos = range && range.cursor || pos;
        if (pos) {
            if (select) {
                if (range && expand) {
                    this.selection.setRange(range);
                } else if (range && range.isEqual(this.getSelectionRange())) {
                    this.clearSelection();
                } else {
                    this.selection.selectTo(pos.row, pos.column);
                }
            } else {
                this.selection.moveTo(pos.row, pos.column);
            }
        }
    };

    /**
     * Moves the cursor to the specified line number, and also into the indicated column.
     * @param {Number} lineNumber The line number to go to
     * @param {Number} column A column number to go to
     * @param {Boolean} animate If `true` animates scolling
     *
     **/
    this.gotoLine = function(lineNumber, column, animate) {
        this.selection.clearSelection();
        this.session.unfold({row: lineNumber - 1, column: column || 0});

        this.$blockScrolling += 1;
        // todo: find a way to automatically exit multiselect mode
        this.exitMultiSelectMode && this.exitMultiSelectMode();
        this.moveCursorTo(lineNumber - 1, column || 0);
        this.$blockScrolling -= 1;

        if (!this.isRowFullyVisible(lineNumber - 1))
            this.scrollToLine(lineNumber - 1, true, animate);
    };

    /**
     * Moves the cursor to the specified row and column. Note that this does de-select the current selection.
     * @param {Number} row The new row number
     * @param {Number} column The new column number
     *
     *
     * @related Editor.moveCursorTo
     **/
    this.navigateTo = function(row, column) {
        this.selection.moveTo(row, column);
    };

    /**
     * Moves the cursor up in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} times The number of times to change navigation
     *
     *
     **/
    this.navigateUp = function(times) {
        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
            var selectionStart = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionStart);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(-times || -1, 0);
    };

    /**
     * Moves the cursor down in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} times The number of times to change navigation
     *
     *
     **/
    this.navigateDown = function(times) {
        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
            var selectionEnd = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionEnd);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(times || 1, 0);
    };

    /**
     * Moves the cursor left in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} times The number of times to change navigation
     *
     *
     **/
    this.navigateLeft = function(times) {
        if (!this.selection.isEmpty()) {
            var selectionStart = this.getSelectionRange().start;
            this.moveCursorToPosition(selectionStart);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorLeft();
            }
        }
        this.clearSelection();
    };

    /**
     * Moves the cursor right in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} times The number of times to change navigation
     *
     *
     **/
    this.navigateRight = function(times) {
        if (!this.selection.isEmpty()) {
            var selectionEnd = this.getSelectionRange().end;
            this.moveCursorToPosition(selectionEnd);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorRight();
            }
        }
        this.clearSelection();
    };

    /**
     *
     * Moves the cursor to the start of the current line. Note that this does de-select the current selection.
     **/
    this.navigateLineStart = function() {
        this.selection.moveCursorLineStart();
        this.clearSelection();
    };

    /**
     *
     * Moves the cursor to the end of the current line. Note that this does de-select the current selection.
     **/
    this.navigateLineEnd = function() {
        this.selection.moveCursorLineEnd();
        this.clearSelection();
    };

    /**
     *
     * Moves the cursor to the end of the current file. Note that this does de-select the current selection.
     **/
    this.navigateFileEnd = function() {
        this.selection.moveCursorFileEnd();
        this.clearSelection();
    };

    /**
     *
     * Moves the cursor to the start of the current file. Note that this does de-select the current selection.
     **/
    this.navigateFileStart = function() {
        this.selection.moveCursorFileStart();
        this.clearSelection();
    };

    /**
     *
     * Moves the cursor to the word immediately to the right of the current position. Note that this does de-select the current selection.
     **/
    this.navigateWordRight = function() {
        this.selection.moveCursorWordRight();
        this.clearSelection();
    };

    /**
     *
     * Moves the cursor to the word immediately to the left of the current position. Note that this does de-select the current selection.
     **/
    this.navigateWordLeft = function() {
        this.selection.moveCursorWordLeft();
        this.clearSelection();
    };

    /**
     * Replaces the first occurrence of `options.needle` with the value in `replacement`.
     * @param {String} replacement The text to replace with
     * @param {Object} options The [[Search `Search`]] options to use
     *
     *
     **/
    this.replace = function(replacement, options) {
        if (options)
            this.$search.set(options);

        var range = this.$search.find(this.session);
        var replaced = 0;
        if (!range)
            return replaced;

        if (this.$tryReplace(range, replacement)) {
            replaced = 1;
        }
        if (range !== null) {
            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);
        }

        return replaced;
    };

    /**
     * Replaces all occurrences of `options.needle` with the value in `replacement`.
     * @param {String} replacement The text to replace with
     * @param {Object} options The [[Search `Search`]] options to use
     *
     *
     **/
    this.replaceAll = function(replacement, options) {
        if (options) {
            this.$search.set(options);
        }

        var ranges = this.$search.findAll(this.session);
        var replaced = 0;
        if (!ranges.length)
            return replaced;

        this.$blockScrolling += 1;

        var selection = this.getSelectionRange();
        this.selection.moveTo(0, 0);

        for (var i = ranges.length - 1; i >= 0; --i) {
            if(this.$tryReplace(ranges[i], replacement)) {
                replaced++;
            }
        }

        this.selection.setSelectionRange(selection);
        this.$blockScrolling -= 1;

        return replaced;
    };

    this.$tryReplace = function(range, replacement) {
        var input = this.session.getTextRange(range);
        replacement = this.$search.replace(input, replacement);
        if (replacement !== null) {
            range.end = this.session.replace(range, replacement);
            return range;
        } else {
            return null;
        }
    };

    /**
     * {:Search.getOptions} For more information on `options`, see [[Search `Search`]].
     * @related Search.getOptions
     * @returns {Object}
     **/
    this.getLastSearchOptions = function() {
        return this.$search.getOptions();
    };

    /**
     * Attempts to find `needle` within the document. For more information on `options`, see [[Search `Search`]].
     * @param {String} needle The text to search for (optional)
     * @param {Object} options An object defining various search properties
     * @param {Boolean} animate If `true` animate scrolling
     *
     *
     * @related Search.find
     **/
    this.find = function(needle, options, animate) {
        if (!options)
            options = {};

        if (typeof needle == "string" || needle instanceof RegExp)
            options.needle = needle;
        else if (typeof needle == "object")
            oop.mixin(options, needle);

        var range = this.selection.getRange();
        if (options.needle == null) {
            needle = this.session.getTextRange(range)
                || this.$search.$options.needle;
            if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
            }
            this.$search.set({needle: needle});
        }

        this.$search.set(options);
        if (!options.start)
            this.$search.set({start: range});

        var newRange = this.$search.find(this.session);
        if (options.preventScroll)
            return newRange;
        if (newRange) {
            this.revealRange(newRange, animate);
            return newRange;
        }
        // clear selection if nothing is found
        if (options.backwards)
            range.start = range.end;
        else
            range.end = range.start;
        this.selection.setRange(range);
    };

    /**
     * Performs another search for `needle` in the document. For more information on `options`, see [[Search `Search`]].
     * @param {Object} options search options
     * @param {Boolean} animate If `true` animate scrolling
     *
     *
     * @related Editor.find
     **/
    this.findNext = function(options, animate) {
        this.find({skipCurrent: true, backwards: false}, options, animate);
    };

    /**
     * Performs a search for `needle` backwards. For more information on `options`, see [[Search `Search`]].
     * @param {Object} options search options
     * @param {Boolean} animate If `true` animate scrolling
     *
     *
     * @related Editor.find
     **/
    this.findPrevious = function(options, animate) {
        this.find(options, {skipCurrent: true, backwards: true}, animate);
    };

    this.revealRange = function(range, animate) {
        this.$blockScrolling += 1;
        this.session.unfold(range);
        this.selection.setSelectionRange(range);
        this.$blockScrolling -= 1;

        var scrollTop = this.renderer.scrollTop;
        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
        if (animate !== false)
            this.renderer.animateScrolling(scrollTop);
    };

    /**
     * {:UndoManager.undo}
     * @related UndoManager.undo
     **/
    this.undo = function() {
        this.$blockScrolling++;
        this.session.getUndoManager().undo();
        this.$blockScrolling--;
        this.renderer.scrollCursorIntoView(null, 0.5);
    };

    /**
     * {:UndoManager.redo}
     * @related UndoManager.redo
     **/
    this.redo = function() {
        this.$blockScrolling++;
        this.session.getUndoManager().redo();
        this.$blockScrolling--;
        this.renderer.scrollCursorIntoView(null, 0.5);
    };

    /**
     *
     * Cleans up the entire editor.
     **/
    this.destroy = function() {
        this.renderer.destroy();
        this._signal("destroy", this);
        if (this.session) {
            this.session.destroy();
        }
    };

    /**
     * Enables automatic scrolling of the cursor into view when editor itself is inside scrollable element
     * @param {Boolean} enable default true
     **/
    this.setAutoScrollEditorIntoView = function(enable) {
        if (!enable)
            return;
        var rect;
        var self = this;
        var shouldScroll = false;
        if (!this.$scrollAnchor)
            this.$scrollAnchor = document.createElement("div");
        var scrollAnchor = this.$scrollAnchor;
        scrollAnchor.style.cssText = "position:absolute";
        this.container.insertBefore(scrollAnchor, this.container.firstChild);
        var onChangeSelection = this.on("changeSelection", function() {
            shouldScroll = true;
        });
        // needed to not trigger sync reflow
        var onBeforeRender = this.renderer.on("beforeRender", function() {
            if (shouldScroll)
                rect = self.renderer.container.getBoundingClientRect();
        });
        var onAfterRender = this.renderer.on("afterRender", function() {
            if (shouldScroll && rect && (self.isFocused()
                || self.searchBox && self.searchBox.isFocused())
            ) {
                var renderer = self.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config = renderer.layerConfig;
                var top = pos.top - config.offset;
                if (pos.top >= 0 && top + rect.top < 0) {
                    shouldScroll = true;
                } else if (pos.top < config.height &&
                    pos.top + rect.top + config.lineHeight > window.innerHeight) {
                    shouldScroll = false;
                } else {
                    shouldScroll = null;
                }
                if (shouldScroll != null) {
                    scrollAnchor.style.top = top + "px";
                    scrollAnchor.style.left = pos.left + "px";
                    scrollAnchor.style.height = config.lineHeight + "px";
                    scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
            }
        });
        this.setAutoScrollEditorIntoView = function(enable) {
            if (enable)
                return;
            delete this.setAutoScrollEditorIntoView;
            this.off("changeSelection", onChangeSelection);
            this.renderer.off("afterRender", onAfterRender);
            this.renderer.off("beforeRender", onBeforeRender);
        };
    };


    this.$resetCursorStyle = function() {
        var style = this.$cursorStyle || "ace";
        var cursorLayer = this.renderer.$cursorLayer;
        if (!cursorLayer)
            return;
        cursorLayer.setSmoothBlinking(/smooth/.test(style));
        cursorLayer.isBlinking = !this.$readOnly && style != "wide";
        dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
    };

}).call(Editor.prototype);



config.defineOptions(Editor.prototype, "editor", {
    selectionStyle: {
        set: function(style) {
            this.onSelectionChange();
            this._signal("changeSelectionStyle", {data: style});
        },
        initialValue: "line"
    },
    highlightActiveLine: {
        set: function() {this.$updateHighlightActiveLine();},
        initialValue: true
    },
    highlightSelectedWord: {
        set: function(shouldHighlight) {this.$onSelectionChange();},
        initialValue: true
    },
    readOnly: {
        set: function(readOnly) {
            // disabled to not break vim mode!
            // this.textInput.setReadOnly(readOnly);
            this.$resetCursorStyle(); 
        },
        initialValue: false
    },
    cursorStyle: {
        set: function(val) { this.$resetCursorStyle(); },
        values: ["ace", "slim", "smooth", "wide"],
        initialValue: "ace"
    },
    mergeUndoDeltas: {
        values: [false, true, "always"],
        initialValue: true
    },
    behavioursEnabled: {initialValue: true},
    wrapBehavioursEnabled: {initialValue: true},
    autoScrollEditorIntoView: {
        set: function(val) {this.setAutoScrollEditorIntoView(val)}
    },
    keyboardHandler: {
        set: function(val) { this.setKeyboardHandler(val); },
        get: function() { return this.keybindingId; },
        handlesSet: true
    },

    hScrollBarAlwaysVisible: "renderer",
    vScrollBarAlwaysVisible: "renderer",
    highlightGutterLine: "renderer",
    animatedScroll: "renderer",
    showInvisibles: "renderer",
    showPrintMargin: "renderer",
    printMarginColumn: "renderer",
    printMargin: "renderer",
    fadeFoldWidgets: "renderer",
    showFoldWidgets: "renderer",
    showLineNumbers: "renderer",
    showGutter: "renderer",
    displayIndentGuides: "renderer",
    fontSize: "renderer",
    fontFamily: "renderer",
    maxLines: "renderer",
    minLines: "renderer",
    scrollPastEnd: "renderer",
    fixedWidthGutter: "renderer",
    theme: "renderer",

    scrollSpeed: "$mouseHandler",
    dragDelay: "$mouseHandler",
    dragEnabled: "$mouseHandler",
    focusTimout: "$mouseHandler",
    tooltipFollowsMouse: "$mouseHandler",

    firstLineNumber: "session",
    overwrite: "session",
    newLineMode: "session",
    useWorker: "session",
    useSoftTabs: "session",
    tabSize: "session",
    wrap: "session",
    indentedSoftWrap: "session",
    foldStyle: "session",
    mode: "session"
});

exports.Editor = Editor;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/undomanager',['require','exports','module'],function(require, exports, module) {
"use strict";

/**
 * 
 *
 * This object maintains the undo stack for an [[EditSession `EditSession`]].
 * @class UndoManager
 **/

/**
 * 
 * 
 * Resets the current undo state and creates a new `UndoManager`.
 * 
 * @constructor
 **/
var UndoManager = function() {
    this.reset();
};

(function() {

    /**
     * Provides a means for implementing your own undo manager. `options` has one property, `args`, an [[Array `Array`]], with two elements:
     *
     * - `args[0]` is an array of deltas
     * - `args[1]` is the document to associate with
     *
     * @param {Object} options Contains additional properties
     *
     **/
    this.execute = function(options) {
        // Normalize deltas for storage.
        // var deltaSets = this.$serializeDeltas(options.args[0]);
        var deltaSets = options.args[0];
        // Add deltas to undo stack.
        this.$doc  = options.args[1];
        if (options.merge && this.hasUndo()){
            this.dirtyCounter--;
            deltaSets = this.$undoStack.pop().concat(deltaSets);
        }
        this.$undoStack.push(deltaSets);
        
        // Reset redo stack.
        this.$redoStack = [];
        if (this.dirtyCounter < 0) {
            // The user has made a change after undoing past the last clean state.
            // We can never get back to a clean state now until markClean() is called.
            this.dirtyCounter = NaN;
        }
        this.dirtyCounter++;
    };

    /**
     * [Perform an undo operation on the document, reverting the last change.]{: #UndoManager.undo}
     * @param {Boolean} dontSelect {:dontSelect}
     *
     * 
     * @returns {Range} The range of the undo.
     **/
    this.undo = function(dontSelect) {
        var deltaSets = this.$undoStack.pop();
        var undoSelectionRange = null;
        if (deltaSets) {
            undoSelectionRange = this.$doc.undoChanges(deltaSets, dontSelect);
            this.$redoStack.push(deltaSets);
            this.dirtyCounter--;
        }

        return undoSelectionRange;
    };

    /**
     * [Perform a redo operation on the document, reimplementing the last change.]{: #UndoManager.redo}
     * @param {Boolean} dontSelect {:dontSelect}
     *
     * 
     **/
    this.redo = function(dontSelect) {
        var deltaSets = this.$redoStack.pop();
        var redoSelectionRange = null;
        if (deltaSets) {
            redoSelectionRange =
                this.$doc.redoChanges(this.$deserializeDeltas(deltaSets), dontSelect);
            this.$undoStack.push(deltaSets);
            this.dirtyCounter++;
        }
        return redoSelectionRange;
    };

    /**
     * 
     * Destroys the stack of undo and redo redo operations.
     **/
    this.reset = function() {
        this.$undoStack = [];
        this.$redoStack = [];
        this.dirtyCounter = 0;
    };

    /**
     * 
     * Returns `true` if there are undo operations left to perform.
     * @returns {Boolean}
     **/
    this.hasUndo = function() {
        return this.$undoStack.length > 0;
    };

    /**
     * 
     * Returns `true` if there are redo operations left to perform.
     * @returns {Boolean}
     **/
    this.hasRedo = function() {
        return this.$redoStack.length > 0;
    };

    /**
     *
     * Marks the current status clean
     **/
    this.markClean = function() {
        this.dirtyCounter = 0;
    };

    /**
     *
     * Returns if the current status is clean
     * @returns {Boolean}
     **/
    this.isClean = function() {
        return this.dirtyCounter === 0;
    };
    
    // Serializes deltaSets to reduce memory usage.
    this.$serializeDeltas = function(deltaSets) {
        return cloneDeltaSetsObj(deltaSets, $serializeDelta);
    };
    
    // Deserializes deltaSets to allow application to the document.
    this.$deserializeDeltas = function(deltaSets) {
        return cloneDeltaSetsObj(deltaSets, $deserializeDelta);
    };
    
    function $serializeDelta(delta){
        return {
            action: delta.action,
            start: delta.start,
            end: delta.end,
            lines: delta.lines.length == 1 ? null : delta.lines,
            text: delta.lines.length == 1 ? delta.lines[0] : null
        };
    }
        
    function $deserializeDelta(delta) {
        return {
            action: delta.action,
            start: delta.start,
            end: delta.end,
            lines: delta.lines || [delta.text]
        };
    }
    
    function cloneDeltaSetsObj(deltaSets_old, fnGetModifiedDelta) {
        var deltaSets_new = new Array(deltaSets_old.length);
        for (var i = 0; i < deltaSets_old.length; i++) {
            var deltaSet_old = deltaSets_old[i];
            var deltaSet_new = { group: deltaSet_old.group, deltas: new Array(deltaSet_old.length)};
            
            for (var j = 0; j < deltaSet_old.deltas.length; j++) {
                var delta_old = deltaSet_old.deltas[j];
                deltaSet_new.deltas[j] = fnGetModifiedDelta(delta_old);
            }
            
            deltaSets_new[i] = deltaSet_new;
        }
        return deltaSets_new;
    }
    
}).call(UndoManager.prototype);

exports.UndoManager = UndoManager;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/layer/gutter',['require','exports','module','../lib/dom','../lib/oop','../lib/lang','../lib/event_emitter'],function(require, exports, module) {
"use strict";

var dom = require("../lib/dom");
var oop = require("../lib/oop");
var lang = require("../lib/lang");
var EventEmitter = require("../lib/event_emitter").EventEmitter;

var Gutter = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_gutter-layer";
    parentEl.appendChild(this.element);
    this.setShowFoldWidgets(this.$showFoldWidgets);
    
    this.gutterWidth = 0;

    this.$annotations = [];
    this.$updateAnnotations = this.$updateAnnotations.bind(this);

    this.$cells = [];
};

(function() {

    oop.implement(this, EventEmitter);

    this.setSession = function(session) {
        if (this.session)
            this.session.removeEventListener("change", this.$updateAnnotations);
        this.session = session;
        if (session)
            session.on("change", this.$updateAnnotations);
    };

    this.addGutterDecoration = function(row, className){
        if (window.console)
            console.warn && console.warn("deprecated use session.addGutterDecoration");
        this.session.addGutterDecoration(row, className);
    };

    this.removeGutterDecoration = function(row, className){
        if (window.console)
            console.warn && console.warn("deprecated use session.removeGutterDecoration");
        this.session.removeGutterDecoration(row, className);
    };

    this.setAnnotations = function(annotations) {
        // iterate over sparse array
        this.$annotations = [];
        for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            var row = annotation.row;
            var rowInfo = this.$annotations[row];
            if (!rowInfo)
                rowInfo = this.$annotations[row] = {text: []};
           
            var annoText = annotation.text;
            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";

            if (rowInfo.text.indexOf(annoText) === -1)
                rowInfo.text.push(annoText);

            var type = annotation.type;
            if (type == "error")
                rowInfo.className = " ace_error";
            else if (type == "warning" && rowInfo.className != " ace_error")
                rowInfo.className = " ace_warning";
            else if (type == "info" && (!rowInfo.className))
                rowInfo.className = " ace_info";
        }
    };

    this.$updateAnnotations = function (delta) {
        if (!this.$annotations.length)
            return;
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;
        if (len === 0) {
            // do nothing
        } else if (delta.action == 'remove') {
            this.$annotations.splice(firstRow, len + 1, null);
        } else {
            var args = new Array(len + 1);
            args.unshift(firstRow, 1);
            this.$annotations.splice.apply(this.$annotations, args);
        }
    };

    this.update = function(config) {
        var session = this.session;
        var firstRow = config.firstRow;
        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
            session.getLength() - 1);
        var fold = session.getNextFoldLine(firstRow);
        var foldStart = fold ? fold.start.row : Infinity;
        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
        var breakpoints = session.$breakpoints;
        var decorations = session.$decorations;
        var firstLineNumber = session.$firstLineNumber;
        var lastLineNumber = 0;
        
        var gutterRenderer = session.gutterRenderer || this.$renderer;

        var cell = null;
        var index = -1;
        var row = firstRow;
        while (true) {
            if (row > foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
            }
            if (row > lastRow) {
                while (this.$cells.length > index + 1) {
                    cell = this.$cells.pop();
                    this.element.removeChild(cell.element);
                }
                break;
            }

            cell = this.$cells[++index];
            if (!cell) {
                cell = {element: null, textNode: null, foldWidget: null};
                cell.element = dom.createElement("div");
                cell.textNode = document.createTextNode('');
                cell.element.appendChild(cell.textNode);
                this.element.appendChild(cell.element);
                this.$cells[index] = cell;
            }

            var className = "ace_gutter-cell ";
            if (breakpoints[row])
                className += breakpoints[row];
            if (decorations[row])
                className += decorations[row];
            if (this.$annotations[row])
                className += this.$annotations[row].className;
            if (cell.element.className != className)
                cell.element.className = className;

            var height = session.getRowLength(row) * config.lineHeight + "px";
            if (height != cell.element.style.height)
                cell.element.style.height = height;

            if (foldWidgets) {
                var c = foldWidgets[row];
                // check if cached value is invalidated and we need to recompute
                if (c == null)
                    c = foldWidgets[row] = session.getFoldWidget(row);
            }

            if (c) {
                if (!cell.foldWidget) {
                    cell.foldWidget = dom.createElement("span");
                    cell.element.appendChild(cell.foldWidget);
                }
                var className = "ace_fold-widget ace_" + c;
                if (c == "start" && row == foldStart && row < fold.end.row)
                    className += " ace_closed";
                else
                    className += " ace_open";
                if (cell.foldWidget.className != className)
                    cell.foldWidget.className = className;

                var height = config.lineHeight + "px";
                if (cell.foldWidget.style.height != height)
                    cell.foldWidget.style.height = height;
            } else {
                if (cell.foldWidget) {
                    cell.element.removeChild(cell.foldWidget);
                    cell.foldWidget = null;
                }
            }
            
            var text = lastLineNumber = gutterRenderer
                ? gutterRenderer.getText(session, row)
                : row + firstLineNumber;
            if (text != cell.textNode.data)
                cell.textNode.data = text;

            row++;
        }

        this.element.style.height = config.minHeight + "px";

        if (this.$fixedWidth || session.$useWrapMode)
            lastLineNumber = session.getLength() + firstLineNumber;

        var gutterWidth = gutterRenderer 
            ? gutterRenderer.getWidth(session, lastLineNumber, config)
            : lastLineNumber.toString().length * config.characterWidth;
        
        var padding = this.$padding || this.$computePadding();
        gutterWidth += padding.left + padding.right;
        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
            this.gutterWidth = gutterWidth;
            this.element.style.width = Math.ceil(this.gutterWidth) + "px";
            this._emit("changeGutterWidth", gutterWidth);
        }
    };

    this.$fixedWidth = false;
    
    this.$showLineNumbers = true;
    this.$renderer = "";
    this.setShowLineNumbers = function(show) {
        this.$renderer = !show && {
            getWidth: function() {return ""},
            getText: function() {return ""}
        };
    };
    
    this.getShowLineNumbers = function() {
        return this.$showLineNumbers;
    };
    
    this.$showFoldWidgets = true;
    this.setShowFoldWidgets = function(show) {
        if (show)
            dom.addCssClass(this.element, "ace_folding-enabled");
        else
            dom.removeCssClass(this.element, "ace_folding-enabled");

        this.$showFoldWidgets = show;
        this.$padding = null;
    };
    
    this.getShowFoldWidgets = function() {
        return this.$showFoldWidgets;
    };

    this.$computePadding = function() {
        if (!this.element.firstChild)
            return {left: 0, right: 0};
        var style = dom.computedStyle(this.element.firstChild);
        this.$padding = {};
        this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
        this.$padding.right = parseInt(style.paddingRight) || 0;
        return this.$padding;
    };

    this.getRegion = function(point) {
        var padding = this.$padding || this.$computePadding();
        var rect = this.element.getBoundingClientRect();
        if (point.x < padding.left + rect.left)
            return "markers";
        if (this.$showFoldWidgets && point.x > rect.right - padding.right)
            return "foldWidgets";
    };

}).call(Gutter.prototype);

exports.Gutter = Gutter;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/layer/marker',['require','exports','module','../range','../lib/dom'],function(require, exports, module) {
"use strict";

var Range = require("../range").Range;
var dom = require("../lib/dom");

var Marker = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_marker-layer";
    parentEl.appendChild(this.element);
};

(function() {

    this.$padding = 0;

    this.setPadding = function(padding) {
        this.$padding = padding;
    };
    this.setSession = function(session) {
        this.session = session;
    };
    
    this.setMarkers = function(markers) {
        this.markers = markers;
    };

    this.update = function(config) {
        var config = config || this.config;
        if (!config)
            return;

        this.config = config;


        var html = [];
        for (var key in this.markers) {
            var marker = this.markers[key];

            if (!marker.range) {
                marker.update(html, this, this.session, config);
                continue;
            }

            var range = marker.range.clipRows(config.firstRow, config.lastRow);
            if (range.isEmpty()) continue;

            range = range.toScreenRange(this.session);
            if (marker.renderer) {
                var top = this.$getTop(range.start.row, config);
                var left = this.$padding + range.start.column * config.characterWidth;
                marker.renderer(html, range, left, top, config);
            } else if (marker.type == "fullLine") {
                this.drawFullLineMarker(html, range, marker.clazz, config);
            } else if (marker.type == "screenLine") {
                this.drawScreenLineMarker(html, range, marker.clazz, config);
            } else if (range.isMultiLine()) {
                if (marker.type == "text")
                    this.drawTextMarker(html, range, marker.clazz, config);
                else
                    this.drawMultiLineMarker(html, range, marker.clazz, config);
            } else {
                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
            }
        }
        this.element.innerHTML = html.join("");
    };

    this.$getTop = function(row, layerConfig) {
        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
    };

    function getBorderClass(tl, tr, br, bl) {
        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
    }
    // Draws a marker, which spans a range of text on multiple lines 
    this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
        var session = this.session;
        var start = range.start.row;
        var end = range.end.row;
        var row = start;
        var prev = 0; 
        var curr = 0;
        var next = session.getScreenLastRowColumn(row);
        var lineRange = new Range(row, range.start.column, row, curr);
        for (; row <= end; row++) {
            lineRange.start.row = lineRange.end.row = row;
            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
            lineRange.end.column = next;
            prev = curr;
            curr = next;
            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
            this.drawSingleLineMarker(stringBuilder, lineRange, 
                clazz + (row == start  ? " ace_start" : "") + " ace_br"
                    + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end),
                layerConfig, row == end ? 0 : 1, extraStyle);
        }
    };

    // Draws a multi line marker, where lines span the full width
    this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        // from selection start to the end of the line
        var padding = this.$padding;
        var height = config.lineHeight;
        var top = this.$getTop(range.start.row, config);
        var left = padding + range.start.column * config.characterWidth;
        extraStyle = extraStyle || "";

        stringBuilder.push(
            "<div class='", clazz, " ace_br1 ace_start' style='",
            "height:", height, "px;",
            "right:0;",
            "top:", top, "px;",
            "left:", left, "px;", extraStyle, "'></div>"
        );

        // from start of the last line to the selection end
        top = this.$getTop(range.end.row, config);
        var width = range.end.column * config.characterWidth;

        stringBuilder.push(
            "<div class='", clazz, " ace_br12' style='",
            "height:", height, "px;",
            "width:", width, "px;",
            "top:", top, "px;",
            "left:", padding, "px;", extraStyle, "'></div>"
        );

        // all the complete lines
        height = (range.end.row - range.start.row - 1) * config.lineHeight;
        if (height <= 0)
            return;
        top = this.$getTop(range.start.row + 1, config);
        
        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);

        stringBuilder.push(
            "<div class='", clazz, (radiusClass ? " ace_br" + radiusClass : ""), "' style='",
            "height:", height, "px;",
            "right:0;",
            "top:", top, "px;",
            "left:", padding, "px;", extraStyle, "'></div>"
        );
    };

    // Draws a marker which covers part or whole width of a single screen line
    this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
        var height = config.lineHeight;
        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

        var top = this.$getTop(range.start.row, config);
        var left = this.$padding + range.start.column * config.characterWidth;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "width:", width, "px;",
            "top:", top, "px;",
            "left:", left, "px;", extraStyle || "", "'></div>"
        );
    };

    this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;
        if (range.start.row != range.end.row)
            height += this.$getTop(range.end.row, config) - top;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "top:", top, "px;",
            "left:0;right:0;", extraStyle || "", "'></div>"
        );
    };
    
    this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "top:", top, "px;",
            "left:0;right:0;", extraStyle || "", "'></div>"
        );
    };

}).call(Marker.prototype);

exports.Marker = Marker;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/layer/text',['require','exports','module','../lib/oop','../lib/dom','../lib/lang','../lib/useragent','../lib/event_emitter'],function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var dom = require("../lib/dom");
var lang = require("../lib/lang");
var useragent = require("../lib/useragent");
var EventEmitter = require("../lib/event_emitter").EventEmitter;

var Text = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_text-layer";
    parentEl.appendChild(this.element);
    this.$updateEolChar = this.$updateEolChar.bind(this);
};

(function() {

    oop.implement(this, EventEmitter);

    this.EOF_CHAR = "\xB6";
    this.EOL_CHAR_LF = "\xAC";
    this.EOL_CHAR_CRLF = "\xa4";
    this.EOL_CHAR = this.EOL_CHAR_LF;
    this.TAB_CHAR = "\u2014"; //"\u21E5";
    this.SPACE_CHAR = "\xB7";
    this.$padding = 0;

    this.$updateEolChar = function() {
        var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n"
           ? this.EOL_CHAR_LF
           : this.EOL_CHAR_CRLF;
        if (this.EOL_CHAR != EOL_CHAR) {
            this.EOL_CHAR = EOL_CHAR;
            return true;
        }
    }

    this.setPadding = function(padding) {
        this.$padding = padding;
        this.element.style.padding = "0 " + padding + "px";
    };

    this.getLineHeight = function() {
        return this.$fontMetrics.$characterSize.height || 0;
    };

    this.getCharacterWidth = function() {
        return this.$fontMetrics.$characterSize.width || 0;
    };
    
    this.$setFontMetrics = function(measure) {
        this.$fontMetrics = measure;
        this.$fontMetrics.on("changeCharacterSize", function(e) {
            this._signal("changeCharacterSize", e);
        }.bind(this));
        this.$pollSizeChanges();
    }

    this.checkForSizeChanges = function() {
        this.$fontMetrics.checkForSizeChanges();
    };
    this.$pollSizeChanges = function() {
        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
    };
    this.setSession = function(session) {
        this.session = session;
        if (session)
            this.$computeTabString();
    };

    this.showInvisibles = false;
    this.setShowInvisibles = function(showInvisibles) {
        if (this.showInvisibles == showInvisibles)
            return false;

        this.showInvisibles = showInvisibles;
        this.$computeTabString();
        return true;
    };

    this.displayIndentGuides = true;
    this.setDisplayIndentGuides = function(display) {
        if (this.displayIndentGuides == display)
            return false;

        this.displayIndentGuides = display;
        this.$computeTabString();
        return true;
    };

    this.$tabStrings = [];
    this.onChangeTabSize =
    this.$computeTabString = function() {
        var tabSize = this.session.getTabSize();
        this.tabSize = tabSize;
        var tabStr = this.$tabStrings = [0];
        for (var i = 1; i < tabSize + 1; i++) {
            if (this.showInvisibles) {
                tabStr.push("<span class='ace_invisible ace_invisible_tab'>"
                    + lang.stringRepeat(this.TAB_CHAR, i)
                    + "</span>");
            } else {
                tabStr.push(lang.stringRepeat(" ", i));
            }
        }
        if (this.displayIndentGuides) {
            this.$indentGuideRe =  /\s\S| \t|\t |\s$/;
            var className = "ace_indent-guide";
            var spaceClass = "";
            var tabClass = "";
            if (this.showInvisibles) {
                className += " ace_invisible";
                spaceClass = " ace_invisible_space";
                tabClass = " ace_invisible_tab";
                var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
                var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);
            } else{
                var spaceContent = lang.stringRepeat(" ", this.tabSize);
                var tabContent = spaceContent;
            }

            this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
            this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
        }
    };

    this.updateLines = function(config, firstRow, lastRow) {
        // Due to wrap line changes there can be new lines if e.g.
        // the line to updated wrapped in the meantime.
        if (this.config.lastRow != config.lastRow ||
            this.config.firstRow != config.firstRow) {
            this.scrollLines(config);
        }
        this.config = config;

        var first = Math.max(firstRow, config.firstRow);
        var last = Math.min(lastRow, config.lastRow);

        var lineElements = this.element.childNodes;
        var lineElementsIdx = 0;

        for (var row = config.firstRow; row < first; row++) {
            var foldLine = this.session.getFoldLine(row);
            if (foldLine) {
                if (foldLine.containsRow(first)) {
                    first = foldLine.start.row;
                    break;
                } else {
                    row = foldLine.end.row;
                }
            }
            lineElementsIdx ++;
        }

        var row = first;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row :Infinity;
            }
            if (row > last)
                break;

            var lineElement = lineElements[lineElementsIdx++];
            if (lineElement) {
                var html = [];
                this.$renderLine(
                    html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false
                );
                lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
                lineElement.innerHTML = html.join("");
            }
            row++;
        }
    };

    this.scrollLines = function(config) {
        var oldConfig = this.config;
        this.config = config;

        if (!oldConfig || oldConfig.lastRow < config.firstRow)
            return this.update(config);

        if (config.lastRow < oldConfig.firstRow)
            return this.update(config);

        var el = this.element;
        if (oldConfig.firstRow < config.firstRow)
            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
                el.removeChild(el.firstChild);

        if (oldConfig.lastRow > config.lastRow)
            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)
                el.removeChild(el.lastChild);

        if (config.firstRow < oldConfig.firstRow) {
            var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
            if (el.firstChild)
                el.insertBefore(fragment, el.firstChild);
            else
                el.appendChild(fragment);
        }

        if (config.lastRow > oldConfig.lastRow) {
            var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
            el.appendChild(fragment);
        }
    };

    this.$renderLinesFragment = function(config, firstRow, lastRow) {
        var fragment = this.element.ownerDocument.createDocumentFragment();
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
                break;

            var container = dom.createElement("div");

            var html = [];
            // Get the tokens per line as there might be some lines in between
            // beeing folded.
            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);

            // don't use setInnerHtml since we are working with an empty DIV
            container.innerHTML = html.join("");
            if (this.$useLineGroups()) {
                container.className = 'ace_line_group';
                fragment.appendChild(container);
                container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";

            } else {
                while(container.firstChild)
                    fragment.appendChild(container.firstChild);
            }

            row++;
        }
        return fragment;
    };

    this.update = function(config) {
        this.config = config;

        var html = [];
        var firstRow = config.firstRow, lastRow = config.lastRow;

        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row :Infinity;
            }
            if (row > lastRow)
                break;

            if (this.$useLineGroups())
                html.push("<div class='ace_line_group' style='height:", config.lineHeight*this.session.getRowLength(row), "px'>")

            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);

            if (this.$useLineGroups())
                html.push("</div>"); // end the line group

            row++;
        }
        this.element.innerHTML = html.join("");
    };

    this.$textToken = {
        "text": true,
        "rparen": true,
        "lparen": true
    };

    this.$renderToken = function(stringBuilder, screenColumn, token, value) {
        var self = this;
        var replaceReg = /\t|&|<|>|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF\uFFF9-\uFFFC])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
        var replaceFunc = function(c, a, b, tabIdx, idx4) {
            if (a) {
                return self.showInvisibles
                    ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>"
                    : c;
            } else if (c == "&") {
                return "&#38;";
            } else if (c == "<") {
                return "&#60;";
            } else if (c == ">") {
                // normally escaping this is not needed, but xml documents throw error when setting innerHTML to ]]>
                return "&#62;";
            } else if (c == "\t") {
                var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
                screenColumn += tabSize - 1;
                return self.$tabStrings[tabSize];
            } else if (c == "\u3000") {
                // U+3000 is both invisible AND full-width, so must be handled uniquely
                var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                var space = self.showInvisibles ? self.SPACE_CHAR : "";
                screenColumn += 1;
                return "<span class='" + classToUse + "' style='width:" +
                    (self.config.characterWidth * 2) +
                    "px'>" + space + "</span>";
            } else if (b) {
                return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
            } else {
                screenColumn += 1;
                return "<span class='ace_cjk' style='width:" +
                    (self.config.characterWidth * 2) +
                    "px'>" + c + "</span>";
            }
        };

        var output = value.replace(replaceReg, replaceFunc);

        if (!this.$textToken[token.type]) {
            var classes = "ace_" + token.type.replace(/\./g, " ace_");
            var style = "";
            if (token.type == "fold")
                style = " style='width:" + (token.value.length * this.config.characterWidth) + "px;' ";
            stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
        }
        else {
            stringBuilder.push(output);
        }
        return screenColumn + value.length;
    };

    this.renderIndentGuide = function(stringBuilder, value, max) {
        var cols = value.search(this.$indentGuideRe);
        if (cols <= 0 || cols >= max)
            return value;
        if (value[0] == " ") {
            cols -= cols % this.tabSize;
            stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols/this.tabSize));
            return value.substr(cols);
        } else if (value[0] == "\t") {
            stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
            return value.substr(cols);
        }
        return value;
    };

    this.$renderWrappedLine = function(stringBuilder, tokens, splits, onlyContents) {
        var chars = 0;
        var split = 0;
        var splitChars = splits[0];
        var screenColumn = 0;

        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
                chars = value.length;
                value = this.renderIndentGuide(stringBuilder, value, splitChars);
                if (!value)
                    continue;
                chars -= value.length;
            }

            if (chars + value.length < splitChars) {
                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                chars += value.length;
            } else {
                while (chars + value.length >= splitChars) {
                    screenColumn = this.$renderToken(
                        stringBuilder, screenColumn,
                        token, value.substring(0, splitChars - chars)
                    );
                    value = value.substring(splitChars - chars);
                    chars = splitChars;

                    if (!onlyContents) {
                        stringBuilder.push("</div>",
                            "<div class='ace_line' style='height:",
                            this.config.lineHeight, "px'>"
                        );
                    }

                    stringBuilder.push(lang.stringRepeat("\xa0", splits.indent));

                    split ++;
                    screenColumn = 0;
                    splitChars = splits[split] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                    chars += value.length;
                    screenColumn = this.$renderToken(
                        stringBuilder, screenColumn, token, value
                    );
                }
            }
        }
    };

    this.$renderSimpleLine = function(stringBuilder, tokens) {
        var screenColumn = 0;
        var token = tokens[0];
        var value = token.value;
        if (this.displayIndentGuides)
            value = this.renderIndentGuide(stringBuilder, value);
        if (value)
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
        for (var i = 1; i < tokens.length; i++) {
            token = tokens[i];
            value = token.value;
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
        }
    };

    // row is either first row of foldline or not in fold
    this.$renderLine = function(stringBuilder, row, onlyContents, foldLine) {
        if (!foldLine && foldLine != false)
            foldLine = this.session.getFoldLine(row);

        if (foldLine)
            var tokens = this.$getFoldLineTokens(row, foldLine);
        else
            var tokens = this.session.getTokens(row);


        if (!onlyContents) {
            stringBuilder.push(
                "<div class='ace_line' style='height:", 
                    this.config.lineHeight * (
                        this.$useLineGroups() ? 1 :this.session.getRowLength(row)
                    ), "px'>"
            );
        }

        if (tokens.length) {
            var splits = this.session.getRowSplitData(row);
            if (splits && splits.length)
                this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
            else
                this.$renderSimpleLine(stringBuilder, tokens);
        }

        if (this.showInvisibles) {
            if (foldLine)
                row = foldLine.end.row

            stringBuilder.push(
                "<span class='ace_invisible ace_invisible_eol'>",
                row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR,
                "</span>"
            );
        }
        if (!onlyContents)
            stringBuilder.push("</div>");
    };

    this.$getFoldLineTokens = function(row, foldLine) {
        var session = this.session;
        var renderTokens = [];

        function addTokens(tokens, from, to) {
            var idx = 0, col = 0;
            while ((col + tokens[idx].value.length) < from) {
                col += tokens[idx].value.length;
                idx++;

                if (idx == tokens.length)
                    return;
            }
            if (col != from) {
                var value = tokens[idx].value.substring(from - col);
                // Check if the token value is longer then the from...to spacing.
                if (value.length > (to - from))
                    value = value.substring(0, to - from);

                renderTokens.push({
                    type: tokens[idx].type,
                    value: value
                });

                col = from + value.length;
                idx += 1;
            }

            while (col < to && idx < tokens.length) {
                var value = tokens[idx].value;
                if (value.length + col > to) {
                    renderTokens.push({
                        type: tokens[idx].type,
                        value: value.substring(0, to - col)
                    });
                } else
                    renderTokens.push(tokens[idx]);
                col += value.length;
                idx += 1;
            }
        }

        var tokens = session.getTokens(row);
        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
            if (placeholder != null) {
                renderTokens.push({
                    type: "fold",
                    value: placeholder
                });
            } else {
                if (isNewRow)
                    tokens = session.getTokens(row);

                if (tokens.length)
                    addTokens(tokens, lastColumn, column);
            }
        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

        return renderTokens;
    };

    this.$useLineGroups = function() {
        // For the updateLines function to work correctly, it's important that the
        // child nodes of this.element correspond on a 1-to-1 basis to rows in the
        // document (as distinct from lines on the screen). For sessions that are
        // wrapped, this means we need to add a layer to the node hierarchy (tagged
        // with the class name ace_line_group).
        return this.session.getUseWrapMode();
    };

    this.destroy = function() {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.$measureNode)
            this.$measureNode.parentNode.removeChild(this.$measureNode);
        delete this.$measureNode;
    };

}).call(Text.prototype);

exports.Text = Text;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/layer/cursor',['require','exports','module','../lib/dom'],function(require, exports, module) {
"use strict";

var dom = require("../lib/dom");
var isIE8;

var Cursor = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_cursor-layer";
    parentEl.appendChild(this.element);
    
    if (isIE8 === undefined)
        isIE8 = !("opacity" in this.element.style);

    this.isVisible = false;
    this.isBlinking = true;
    this.blinkInterval = 1000;
    this.smoothBlinking = false;

    this.cursors = [];
    this.cursor = this.addCursor();
    dom.addCssClass(this.element, "ace_hidden-cursors");
    this.$updateCursors = (isIE8
        ? this.$updateVisibility
        : this.$updateOpacity).bind(this);
};

(function() {
    
    this.$updateVisibility = function(val) {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; )
            cursors[i].style.visibility = val ? "" : "hidden";
    };
    this.$updateOpacity = function(val) {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; )
            cursors[i].style.opacity = val ? "" : "0";
    };
    

    this.$padding = 0;
    this.setPadding = function(padding) {
        this.$padding = padding;
    };

    this.setSession = function(session) {
        this.session = session;
    };

    this.setBlinking = function(blinking) {
        if (blinking != this.isBlinking){
            this.isBlinking = blinking;
            this.restartTimer();
        }
    };

    this.setBlinkInterval = function(blinkInterval) {
        if (blinkInterval != this.blinkInterval){
            this.blinkInterval = blinkInterval;
            this.restartTimer();
        }
    };

    this.setSmoothBlinking = function(smoothBlinking) {
        if (smoothBlinking != this.smoothBlinking && !isIE8) {
            this.smoothBlinking = smoothBlinking;
            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
            this.$updateCursors(true);
            this.$updateCursors = (this.$updateOpacity).bind(this);
            this.restartTimer();
        }
    };

    this.addCursor = function() {
        var el = dom.createElement("div");
        el.className = "ace_cursor";
        this.element.appendChild(el);
        this.cursors.push(el);
        return el;
    };

    this.removeCursor = function() {
        if (this.cursors.length > 1) {
            var el = this.cursors.pop();
            el.parentNode.removeChild(el);
            return el;
        }
    };

    this.hideCursor = function() {
        this.isVisible = false;
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    };

    this.showCursor = function() {
        this.isVisible = true;
        dom.removeCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    };

    this.restartTimer = function() {
        var update = this.$updateCursors;
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
        if (this.smoothBlinking) {
            dom.removeCssClass(this.element, "ace_smooth-blinking");
        }
        
        update(true);

        if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
            return;

        if (this.smoothBlinking) {
            setTimeout(function(){
                dom.addCssClass(this.element, "ace_smooth-blinking");
            }.bind(this));
        }
        
        var blink = function(){
            this.timeoutId = setTimeout(function() {
                update(false);
            }, 0.6 * this.blinkInterval);
        }.bind(this);

        this.intervalId = setInterval(function() {
            update(true);
            blink();
        }, this.blinkInterval);

        blink();
    };

    this.getPixelPosition = function(position, onScreen) {
        if (!this.config || !this.session)
            return {left : 0, top : 0};

        if (!position)
            position = this.session.selection.getCursor();
        var pos = this.session.documentToScreenPosition(position);
        var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
            this.config.lineHeight;

        return {left : cursorLeft, top : cursorTop};
    };

    this.update = function(config) {
        this.config = config;

        var selections = this.session.$selectionMarkers;
        var i = 0, cursorIndex = 0;

        if (selections === undefined || selections.length === 0){
            selections = [{cursor: null}];
        }

        for (var i = 0, n = selections.length; i < n; i++) {
            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
            if ((pixelPos.top > config.height + config.offset ||
                 pixelPos.top < 0) && i > 1) {
                continue;
            }

            var style = (this.cursors[cursorIndex++] || this.addCursor()).style;
            
            if (!this.drawCursor) {
                style.left = pixelPos.left + "px";
                style.top = pixelPos.top + "px";
                style.width = config.characterWidth + "px";
                style.height = config.lineHeight + "px";
            } else {
                this.drawCursor(style, pixelPos, config, selections[i], this.session);
            }
        }
        while (this.cursors.length > cursorIndex)
            this.removeCursor();

        var overwrite = this.session.getOverwrite();
        this.$setOverwrite(overwrite);

        // cache for textarea and gutter highlight
        this.$pixelPos = pixelPos;
        this.restartTimer();
    };
    
    this.drawCursor = null;

    this.$setOverwrite = function(overwrite) {
        if (overwrite != this.overwrite) {
            this.overwrite = overwrite;
            if (overwrite)
                dom.addCssClass(this.element, "ace_overwrite-cursors");
            else
                dom.removeCssClass(this.element, "ace_overwrite-cursors");
        }
    };

    this.destroy = function() {
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
    };

}).call(Cursor.prototype);

exports.Cursor = Cursor;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/scrollbar',['require','exports','module','./lib/oop','./lib/dom','./lib/event','./lib/event_emitter'],function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var dom = require("./lib/dom");
var event = require("./lib/event");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
// on ie maximal element height is smaller than what we get from 4-5K line document
// so scrollbar doesn't work, as a workaround we do not set height higher than MAX_SCROLL_H
// and rescale scrolltop
var MAX_SCROLL_H = 0x8000;

/**
 * An abstract class representing a native scrollbar control.
 * @class ScrollBar
 **/

/**
 * Creates a new `ScrollBar`. `parent` is the owner of the scroll bar.
 * @param {DOMElement} parent A DOM element 
 *
 * @constructor
 **/
var ScrollBar = function(parent) {
    this.element = dom.createElement("div");
    this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;

    this.inner = dom.createElement("div");
    this.inner.className = "ace_scrollbar-inner";
    this.element.appendChild(this.inner);

    parent.appendChild(this.element);

    this.setVisible(false);
    this.skipEvent = false;

    event.addListener(this.element, "scroll", this.onScroll.bind(this));
    event.addListener(this.element, "mousedown", event.preventDefault);
};

(function() {
    oop.implement(this, EventEmitter);

    this.setVisible = function(isVisible) {
        this.element.style.display = isVisible ? "" : "none";
        this.isVisible = isVisible;
        this.coeff = 1;
    };
}).call(ScrollBar.prototype);

/**
 * Represents a vertical scroll bar.
 * @class VScrollBar
 **/

/**
 * Creates a new `VScrollBar`. `parent` is the owner of the scroll bar.
 * @param {DOMElement} parent A DOM element
 * @param {Object} renderer An editor renderer
 *
 * @constructor
 **/
var VScrollBar = function(parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollTop = 0;
    this.scrollHeight = 0;

    // in OSX lion the scrollbars appear to have no width. In this case resize the
    // element to show the scrollbar but still pretend that the scrollbar has a width
    // of 0px
    // in Firefox 6+ scrollbar is hidden if element has the same width as scrollbar
    // make element a little bit wider to retain scrollbar when page is zoomed 
    renderer.$scrollbarWidth = 
    this.width = dom.scrollbarWidth(parent.ownerDocument);
    this.inner.style.width =
    this.element.style.width = (this.width || 15) + 5 + "px";
};

oop.inherits(VScrollBar, ScrollBar);

(function() {

    this.classSuffix = '-v';

    /**
     * Emitted when the scroll bar, well, scrolls.
     * @event scroll
     * @param {Object} e Contains one property, `"data"`, which indicates the current scroll top position
     **/
    this.onScroll = function() {
        if (!this.skipEvent) {
            this.scrollTop = this.element.scrollTop;
            if (this.coeff != 1) {
                var h = this.element.clientHeight / this.scrollHeight;
                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
            }
            this._emit("scroll", {data: this.scrollTop});
        }
        this.skipEvent = false;
    };

    /**
     * Returns the width of the scroll bar.
     * @returns {Number}
     **/
    this.getWidth = function() {
        return this.isVisible ? this.width : 0;
    };

    /**
     * Sets the height of the scroll bar, in pixels.
     * @param {Number} height The new height
     **/
    this.setHeight = function(height) {
        this.element.style.height = height + "px";
    };

    /**
     * Sets the inner height of the scroll bar, in pixels.
     * @param {Number} height The new inner height
     * @deprecated Use setScrollHeight instead
     **/
    this.setInnerHeight = 
    /**
     * Sets the scroll height of the scroll bar, in pixels.
     * @param {Number} height The new scroll height
     **/
    this.setScrollHeight = function(height) {
        this.scrollHeight = height;
        if (height > MAX_SCROLL_H) {
            this.coeff = MAX_SCROLL_H / height;
            height = MAX_SCROLL_H;
        } else if (this.coeff != 1) {
            this.coeff = 1
        }
        this.inner.style.height = height + "px";
    };

    /**
     * Sets the scroll top of the scroll bar.
     * @param {Number} scrollTop The new scroll top
     **/
    this.setScrollTop = function(scrollTop) {
        // on chrome 17+ for small zoom levels after calling this function
        // this.element.scrollTop != scrollTop which makes page to scroll up.
        if (this.scrollTop != scrollTop) {
            this.skipEvent = true;
            this.scrollTop = scrollTop;
            this.element.scrollTop = scrollTop * this.coeff;
        }
    };

}).call(VScrollBar.prototype);

/**
 * Represents a horisontal scroll bar.
 * @class HScrollBar
 **/

/**
 * Creates a new `HScrollBar`. `parent` is the owner of the scroll bar.
 * @param {DOMElement} parent A DOM element
 * @param {Object} renderer An editor renderer
 *
 * @constructor
 **/
var HScrollBar = function(parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollLeft = 0;

    // in OSX lion the scrollbars appear to have no width. In this case resize the
    // element to show the scrollbar but still pretend that the scrollbar has a width
    // of 0px
    // in Firefox 6+ scrollbar is hidden if element has the same width as scrollbar
    // make element a little bit wider to retain scrollbar when page is zoomed 
    this.height = renderer.$scrollbarWidth;
    this.inner.style.height =
    this.element.style.height = (this.height || 15) + 5 + "px";
};

oop.inherits(HScrollBar, ScrollBar);

(function() {

    this.classSuffix = '-h';

    /**
     * Emitted when the scroll bar, well, scrolls.
     * @event scroll
     * @param {Object} e Contains one property, `"data"`, which indicates the current scroll left position
     **/
    this.onScroll = function() {
        if (!this.skipEvent) {
            this.scrollLeft = this.element.scrollLeft;
            this._emit("scroll", {data: this.scrollLeft});
        }
        this.skipEvent = false;
    };

    /**
     * Returns the height of the scroll bar.
     * @returns {Number}
     **/
    this.getHeight = function() {
        return this.isVisible ? this.height : 0;
    };

    /**
     * Sets the width of the scroll bar, in pixels.
     * @param {Number} width The new width
     **/
    this.setWidth = function(width) {
        this.element.style.width = width + "px";
    };

    /**
     * Sets the inner width of the scroll bar, in pixels.
     * @param {Number} width The new inner width
     * @deprecated Use setScrollWidth instead
     **/
    this.setInnerWidth = function(width) {
        this.inner.style.width = width + "px";
    };

    /**
     * Sets the scroll width of the scroll bar, in pixels.
     * @param {Number} width The new scroll width
     **/
    this.setScrollWidth = function(width) {
        this.inner.style.width = width + "px";
    };

    /**
     * Sets the scroll left of the scroll bar.
     * @param {Number} scrollTop The new scroll left
     **/
    this.setScrollLeft = function(scrollLeft) {
        // on chrome 17+ for small zoom levels after calling this function
        // this.element.scrollTop != scrollTop which makes page to scroll up.
        if (this.scrollLeft != scrollLeft) {
            this.skipEvent = true;
            this.scrollLeft = this.element.scrollLeft = scrollLeft;
        }
    };

}).call(HScrollBar.prototype);


exports.ScrollBar = VScrollBar; // backward compatibility
exports.ScrollBarV = VScrollBar; // backward compatibility
exports.ScrollBarH = HScrollBar; // backward compatibility

exports.VScrollBar = VScrollBar;
exports.HScrollBar = HScrollBar;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/renderloop',['require','exports','module','./lib/event'],function(require, exports, module) {
"use strict";

var event = require("./lib/event");

/** 
 *
 *
 * Batches changes (that force something to be redrawn) in the background.
 * @class RenderLoop
 **/


var RenderLoop = function(onRender, win) {
    this.onRender = onRender;
    this.pending = false;
    this.changes = 0;
    this.window = win || window;
};

(function() {


    this.schedule = function(change) {
        //this.onRender(change);
        //return;
        this.changes = this.changes | change;
        if (!this.pending && this.changes) {
            this.pending = true;
            var _self = this;
            event.nextFrame(function() {
                _self.pending = false;
                var changes;
                while (changes = _self.changes) {
                    _self.changes = 0;
                    _self.onRender(changes);
                }
            }, this.window);
        }
    };

}).call(RenderLoop.prototype);

exports.RenderLoop = RenderLoop;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/layer/font_metrics',['require','exports','module','../lib/oop','../lib/dom','../lib/lang','../lib/useragent','../lib/event_emitter'],function(require, exports, module) {

var oop = require("../lib/oop");
var dom = require("../lib/dom");
var lang = require("../lib/lang");
var useragent = require("../lib/useragent");
var EventEmitter = require("../lib/event_emitter").EventEmitter;

var CHAR_COUNT = 0;

var FontMetrics = exports.FontMetrics = function(parentEl) {
    this.el = dom.createElement("div");
    this.$setMeasureNodeStyles(this.el.style, true);
    
    this.$main = dom.createElement("div");
    this.$setMeasureNodeStyles(this.$main.style);
    
    this.$measureNode = dom.createElement("div");
    this.$setMeasureNodeStyles(this.$measureNode.style);
    
    
    this.el.appendChild(this.$main);
    this.el.appendChild(this.$measureNode);
    parentEl.appendChild(this.el);
    
    if (!CHAR_COUNT)
        this.$testFractionalRect();
    this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);
    
    this.$characterSize = {width: 0, height: 0};
    this.checkForSizeChanges();
};

(function() {

    oop.implement(this, EventEmitter);
        
    this.$characterSize = {width: 0, height: 0};
    
    this.$testFractionalRect = function() {
        var el = dom.createElement("div");
        this.$setMeasureNodeStyles(el.style);
        el.style.width = "0.2px";
        document.documentElement.appendChild(el);
        var w = el.getBoundingClientRect().width;
        if (w > 0 && w < 1)
            CHAR_COUNT = 50;
        else
            CHAR_COUNT = 100;
        el.parentNode.removeChild(el);
    };
    
    this.$setMeasureNodeStyles = function(style, isRoot) {
        style.width = style.height = "auto";
        style.left = style.top = "0px";
        style.visibility = "hidden";
        style.position = "absolute";
        style.whiteSpace = "pre";

        if (useragent.isIE < 8) {
            style["font-family"] = "inherit";
        } else {
            style.font = "inherit";
        }
        style.overflow = isRoot ? "hidden" : "visible";
    };

    this.checkForSizeChanges = function() {
        var size = this.$measureSizes();
        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
            this.$measureNode.style.fontWeight = "bold";
            var boldSize = this.$measureSizes();
            this.$measureNode.style.fontWeight = "";
            this.$characterSize = size;
            this.charSizes = Object.create(null);
            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
            this._emit("changeCharacterSize", {data: size});
        }
    };

    this.$pollSizeChanges = function() {
        if (this.$pollSizeChangesTimer)
            return this.$pollSizeChangesTimer;
        var self = this;
        return this.$pollSizeChangesTimer = setInterval(function() {
            self.checkForSizeChanges();
        }, 500);
    };
    
    this.setPolling = function(val) {
        if (val) {
            this.$pollSizeChanges();
        } else if (this.$pollSizeChangesTimer) {
            clearInterval(this.$pollSizeChangesTimer);
            this.$pollSizeChangesTimer = 0;
        }
    };

    this.$measureSizes = function() {
        if (CHAR_COUNT === 50) {
            var rect = null;
            try { 
               rect = this.$measureNode.getBoundingClientRect();
            } catch(e) {
               rect = {width: 0, height:0 };
            }
            var size = {
                height: rect.height,
                width: rect.width / CHAR_COUNT
            };
        } else {
            var size = {
                height: this.$measureNode.clientHeight,
                width: this.$measureNode.clientWidth / CHAR_COUNT
            };
        }
        // Size and width can be null if the editor is not visible or
        // detached from the document
        if (size.width === 0 || size.height === 0)
            return null;
        return size;
    };

    this.$measureCharWidth = function(ch) {
        this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
        var rect = this.$main.getBoundingClientRect();
        return rect.width / CHAR_COUNT;
    };
    
    this.getCharacterWidth = function(ch) {
        var w = this.charSizes[ch];
        if (w === undefined) {
            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
        }
        return w;
    };

    this.destroy = function() {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.el && this.el.parentNode)
            this.el.parentNode.removeChild(this.el);
    };

}).call(FontMetrics.prototype);

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

/*
 * Extremely simplified version of the requireJS text plugin
 */
 
(function() {
    
var globalRequire = typeof require != "undefined" && require;
if (typeof define !== "function") // running in webpack
    return module.exports = function(source) { return source; };

define('bower_components/ace/lib/ace/requirejs/text',['require','exports','module','../lib/net'],function (require, exports, module) {
    "use strict";
    if (globalRequire && globalRequire.nodeRequire) {
        module.exports = globalRequire.nodeRequire(require.toUrl("./text_build"));
    } else {
        exports.load = function(name, req, onLoad, config) {    
            require("../lib/net").get(req.toUrl(name), onLoad);
        };
    }
});

})();


define('bower_components/ace/lib/ace/requirejs/text!bower_components/ace/lib/ace/css/editor.css',[],function () { return '.ace_editor {\n    position: relative;\n    overflow: hidden;\n    font: 12px/normal \'Monaco\', \'Menlo\', \'Ubuntu Mono\', \'Consolas\', \'source-code-pro\', monospace;\n    direction: ltr;\n    text-align: left;\n}\n\n.ace_scroller {\n    position: absolute;\n    overflow: hidden;\n    top: 0;\n    bottom: 0;\n    background-color: inherit;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    cursor: text;\n}\n\n.ace_content {\n    position: absolute;\n    -moz-box-sizing: border-box;\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n    min-width: 100%;\n}\n\n.ace_dragging .ace_scroller:before{\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    content: \'\';\n    background: rgba(250, 250, 250, 0.01);\n    z-index: 1000;\n}\n.ace_dragging.ace_dark .ace_scroller:before{\n    background: rgba(0, 0, 0, 0.01);\n}\n\n.ace_selecting, .ace_selecting * {\n    cursor: text !important;\n}\n\n.ace_gutter {\n    position: absolute;\n    overflow : hidden;\n    width: auto;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    cursor: default;\n    z-index: 4;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n}\n\n.ace_gutter-active-line {\n    position: absolute;\n    left: 0;\n    right: 0;\n}\n\n.ace_scroller.ace_scroll-left {\n    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\n}\n\n.ace_gutter-cell {\n    padding-left: 19px;\n    padding-right: 6px;\n    background-repeat: no-repeat;\n}\n\n.ace_gutter-cell.ace_error {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n\n.ace_gutter-cell.ace_warning {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");\n    background-position: 2px center;\n}\n\n.ace_gutter-cell.ace_info {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");\n    background-position: 2px center;\n}\n.ace_dark .ace_gutter-cell.ace_info {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");\n}\n\n.ace_scrollbar {\n    position: absolute;\n    right: 0;\n    bottom: 0;\n    z-index: 6;\n}\n\n.ace_scrollbar-inner {\n    position: absolute;\n    cursor: text;\n    left: 0;\n    top: 0;\n}\n\n.ace_scrollbar-v{\n    overflow-x: hidden;\n    overflow-y: scroll;\n    top: 0;\n}\n\n.ace_scrollbar-h {\n    overflow-x: scroll;\n    overflow-y: hidden;\n    left: 0;\n}\n\n.ace_print-margin {\n    position: absolute;\n    height: 100%;\n}\n\n.ace_text-input {\n    position: absolute;\n    z-index: 0;\n    width: 0.5em;\n    height: 1em;\n    opacity: 0;\n    background: transparent;\n    -moz-appearance: none;\n    appearance: none;\n    border: none;\n    resize: none;\n    outline: none;\n    overflow: hidden;\n    font: inherit;\n    padding: 0 1px;\n    margin: 0 -1px;\n    text-indent: -1em;\n    -ms-user-select: text;\n    -moz-user-select: text;\n    -webkit-user-select: text;\n    user-select: text;\n    /*with `pre-line` chrome inserts &nbsp; instead of space*/\n    white-space: pre!important;\n}\n\n.ace_text-input.ace_composition {\n    background: inherit;\n    color: inherit;\n    z-index: 1000;\n    opacity: 1;\n    text-indent: 0;\n}\n\n.ace_layer {\n    z-index: 1;\n    position: absolute;\n    overflow: hidden;\n    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/\n    word-wrap: normal;\n    white-space: pre;\n    height: 100%;\n    width: 100%;\n    -moz-box-sizing: border-box;\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n    /* setting pointer-events: auto; on node under the mouse, which changes\n        during scroll, will break mouse wheel scrolling in Safari */\n    pointer-events: none;\n}\n\n.ace_gutter-layer {\n    position: relative;\n    width: auto;\n    text-align: right;\n    pointer-events: auto;\n}\n\n.ace_text-layer {\n    font: inherit !important;\n}\n\n.ace_cjk {\n    display: inline-block;\n    text-align: center;\n}\n\n.ace_cursor-layer {\n    z-index: 4;\n}\n\n.ace_cursor {\n    z-index: 4;\n    position: absolute;\n    -moz-box-sizing: border-box;\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n    border-left: 2px solid;\n    /* workaround for smooth cursor repaintng whole screen in chrome */\n    transform: translatez(0);\n}\n\n.ace_slim-cursors .ace_cursor {\n    border-left-width: 1px;\n}\n\n.ace_overwrite-cursors .ace_cursor {\n    border-left-width: 0;\n    border-bottom: 1px solid;\n}\n\n.ace_hidden-cursors .ace_cursor {\n    opacity: 0.2;\n}\n\n.ace_smooth-blinking .ace_cursor {\n    -webkit-transition: opacity 0.18s;\n            transition: opacity 0.18s;\n}\n\n.ace_editor.ace_multiselect .ace_cursor {\n    border-left-width: 1px;\n}\n\n.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\n    position: absolute;\n    z-index: 3;\n}\n\n.ace_marker-layer .ace_selection {\n    position: absolute;\n    z-index: 5;\n}\n\n.ace_marker-layer .ace_bracket {\n    position: absolute;\n    z-index: 6;\n}\n\n.ace_marker-layer .ace_active-line {\n    position: absolute;\n    z-index: 2;\n}\n\n.ace_marker-layer .ace_selected-word {\n    position: absolute;\n    z-index: 4;\n    -moz-box-sizing: border-box;\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n}\n\n.ace_line .ace_fold {\n    -moz-box-sizing: border-box;\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n\n    display: inline-block;\n    height: 11px;\n    margin-top: -2px;\n    vertical-align: middle;\n\n    background-image:\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");\n    background-repeat: no-repeat, repeat-x;\n    background-position: center center, top left;\n    color: transparent;\n\n    border: 1px solid black;\n    border-radius: 2px;\n\n    cursor: pointer;\n    pointer-events: auto;\n}\n\n.ace_dark .ace_fold {\n}\n\n.ace_fold:hover{\n    background-image:\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");\n}\n\n.ace_tooltip {\n    background-color: #FFF;\n    background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\n    background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\n    border: 1px solid gray;\n    border-radius: 1px;\n    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\n    color: black;\n    max-width: 100%;\n    padding: 3px 4px;\n    position: fixed;\n    z-index: 999999;\n    -moz-box-sizing: border-box;\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n    cursor: default;\n    white-space: pre;\n    word-wrap: break-word;\n    line-height: normal;\n    font-style: normal;\n    font-weight: normal;\n    letter-spacing: normal;\n    pointer-events: none;\n}\n\n.ace_folding-enabled > .ace_gutter-cell {\n    padding-right: 13px;\n}\n\n.ace_fold-widget {\n    -moz-box-sizing: border-box;\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n\n    margin: 0 -12px 0 1px;\n    display: none;\n    width: 11px;\n    vertical-align: top;\n\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");\n    background-repeat: no-repeat;\n    background-position: center;\n\n    border-radius: 3px;\n    \n    border: 1px solid transparent;\n    cursor: pointer;\n}\n\n.ace_folding-enabled .ace_fold-widget {\n    display: inline-block;   \n}\n\n.ace_fold-widget.ace_end {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");\n}\n\n.ace_fold-widget.ace_closed {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");\n}\n\n.ace_fold-widget:hover {\n    border: 1px solid rgba(0, 0, 0, 0.3);\n    background-color: rgba(255, 255, 255, 0.2);\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\n}\n\n.ace_fold-widget:active {\n    border: 1px solid rgba(0, 0, 0, 0.4);\n    background-color: rgba(0, 0, 0, 0.05);\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\n}\n/**\n * Dark version for fold widgets\n */\n.ace_dark .ace_fold-widget {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");\n}\n.ace_dark .ace_fold-widget.ace_end {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");\n}\n.ace_dark .ace_fold-widget.ace_closed {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");\n}\n.ace_dark .ace_fold-widget:hover {\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\n    background-color: rgba(255, 255, 255, 0.1);\n}\n.ace_dark .ace_fold-widget:active {\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\n}\n\n.ace_fold-widget.ace_invalid {\n    background-color: #FFB4B4;\n    border-color: #DE5555;\n}\n\n.ace_fade-fold-widgets .ace_fold-widget {\n    -webkit-transition: opacity 0.4s ease 0.05s;\n            transition: opacity 0.4s ease 0.05s;\n    opacity: 0;\n}\n\n.ace_fade-fold-widgets:hover .ace_fold-widget {\n    -webkit-transition: opacity 0.05s ease 0.05s;\n            transition: opacity 0.05s ease 0.05s;\n    opacity:1;\n}\n\n.ace_underline {\n    text-decoration: underline;\n}\n\n.ace_bold {\n    font-weight: bold;\n}\n\n.ace_nobold .ace_bold {\n    font-weight: normal;\n}\n\n.ace_italic {\n    font-style: italic;\n}\n\n\n.ace_error-marker {\n    background-color: rgba(255, 0, 0,0.2);\n    position: absolute;\n    z-index: 9;\n}\n\n.ace_highlight-marker {\n    background-color: rgba(255, 255, 0,0.2);\n    position: absolute;\n    z-index: 8;\n}\n\n/*\nstyles = []\nfor (var i = 1; i < 16; i++) {\n    styles.push(".ace_br" + i + "{" + (\n        ["top-left", "top-right", "bottom-right", "bottom-left"]\n    ).map(function(x, j) {\n        return i & (1<<j) ? "border-" + x + "-radius: 3px;" : "" \n    }).filter(Boolean).join(" ") + "}")\n}\nstyles.join("\\n")\n*/\n.ace_br1 {border-top-left-radius    : 3px;}\n.ace_br2 {border-top-right-radius   : 3px;}\n.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\n.ace_br4 {border-bottom-right-radius: 3px;}\n.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\n.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\n.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\n.ace_br8 {border-bottom-left-radius : 3px;}\n.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\n.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\n.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\n.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\n';});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/virtual_renderer',['require','exports','module','./lib/oop','./lib/dom','./config','./lib/useragent','./layer/gutter','./layer/marker','./layer/text','./layer/cursor','./scrollbar','./scrollbar','./renderloop','./layer/font_metrics','./lib/event_emitter','./requirejs/text!./css/editor.css'],function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var dom = require("./lib/dom");
var config = require("./config");
var useragent = require("./lib/useragent");
var GutterLayer = require("./layer/gutter").Gutter;
var MarkerLayer = require("./layer/marker").Marker;
var TextLayer = require("./layer/text").Text;
var CursorLayer = require("./layer/cursor").Cursor;
var HScrollBar = require("./scrollbar").HScrollBar;
var VScrollBar = require("./scrollbar").VScrollBar;
var RenderLoop = require("./renderloop").RenderLoop;
var FontMetrics = require("./layer/font_metrics").FontMetrics;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var editorCss = require("./requirejs/text!./css/editor.css");

dom.importCssString(editorCss, "ace_editor.css");

/**
 * The class that is responsible for drawing everything you see on the screen!
 * @related editor.renderer 
 * @class VirtualRenderer
 **/

/**
 * Constructs a new `VirtualRenderer` within the `container` specified, applying the given `theme`.
 * @param {DOMElement} container The root element of the editor
 * @param {String} theme The starting theme
 *
 * @constructor
 **/

var VirtualRenderer = function(container, theme) {
    var _self = this;

    this.container = container || dom.createElement("div");

    // TODO: this breaks rendering in Cloud9 with multiple ace instances
    // // Imports CSS once per DOM document ('ace_editor' serves as an identifier).
    // dom.importCssString(editorCss, "ace_editor", container.ownerDocument);

    // in IE <= 9 the native cursor always shines through
    this.$keepTextAreaAtCursor = !useragent.isOldIE;

    dom.addCssClass(this.container, "ace_editor");

    this.setTheme(theme);

    this.$gutter = dom.createElement("div");
    this.$gutter.className = "ace_gutter";
    this.container.appendChild(this.$gutter);

    this.scroller = dom.createElement("div");
    this.scroller.className = "ace_scroller";
    this.container.appendChild(this.scroller);

    this.content = dom.createElement("div");
    this.content.className = "ace_content";
    this.scroller.appendChild(this.content);

    this.$gutterLayer = new GutterLayer(this.$gutter);
    this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

    this.$markerBack = new MarkerLayer(this.content);

    var textLayer = this.$textLayer = new TextLayer(this.content);
    this.canvas = textLayer.element;

    this.$markerFront = new MarkerLayer(this.content);

    this.$cursorLayer = new CursorLayer(this.content);

    // Indicates whether the horizontal scrollbar is visible
    this.$horizScroll = false;
    this.$vScroll = false;

    this.scrollBar = 
    this.scrollBarV = new VScrollBar(this.container, this);
    this.scrollBarH = new HScrollBar(this.container, this);
    this.scrollBarV.addEventListener("scroll", function(e) {
        if (!_self.$scrollAnimation)
            _self.session.setScrollTop(e.data - _self.scrollMargin.top);
    });
    this.scrollBarH.addEventListener("scroll", function(e) {
        if (!_self.$scrollAnimation)
            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
    });

    this.scrollTop = 0;
    this.scrollLeft = 0;

    this.cursorPos = {
        row : 0,
        column : 0
    };

    this.$fontMetrics = new FontMetrics(this.container);
    this.$textLayer.$setFontMetrics(this.$fontMetrics);
    this.$textLayer.addEventListener("changeCharacterSize", function(e) {
        _self.updateCharacterSize();
        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
        _self._signal("changeCharacterSize", e);
    });

    this.$size = {
        width: 0,
        height: 0,
        scrollerHeight: 0,
        scrollerWidth: 0,
        $dirty: true
    };

    this.layerConfig = {
        width : 1,
        padding : 0,
        firstRow : 0,
        firstRowScreen: 0,
        lastRow : 0,
        lineHeight : 0,
        characterWidth : 0,
        minHeight : 1,
        maxHeight : 1,
        offset : 0,
        height : 1,
        gutterOffset: 1
    };
    
    this.scrollMargin = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        v: 0,
        h: 0
    };

    this.$loop = new RenderLoop(
        this.$renderChanges.bind(this),
        this.container.ownerDocument.defaultView
    );
    this.$loop.schedule(this.CHANGE_FULL);

    this.updateCharacterSize();
    this.setPadding(4);
    config.resetOptions(this);
    config._emit("renderer", this);
};

(function() {

    this.CHANGE_CURSOR = 1;
    this.CHANGE_MARKER = 2;
    this.CHANGE_GUTTER = 4;
    this.CHANGE_SCROLL = 8;
    this.CHANGE_LINES = 16;
    this.CHANGE_TEXT = 32;
    this.CHANGE_SIZE = 64;
    this.CHANGE_MARKER_BACK = 128;
    this.CHANGE_MARKER_FRONT = 256;
    this.CHANGE_FULL = 512;
    this.CHANGE_H_SCROLL = 1024;

    // this.$logChanges = function(changes) {
    //     var a = ""
    //     if (changes & this.CHANGE_CURSOR) a += " cursor";
    //     if (changes & this.CHANGE_MARKER) a += " marker";
    //     if (changes & this.CHANGE_GUTTER) a += " gutter";
    //     if (changes & this.CHANGE_SCROLL) a += " scroll";
    //     if (changes & this.CHANGE_LINES) a += " lines";
    //     if (changes & this.CHANGE_TEXT) a += " text";
    //     if (changes & this.CHANGE_SIZE) a += " size";
    //     if (changes & this.CHANGE_MARKER_BACK) a += " marker_back";
    //     if (changes & this.CHANGE_MARKER_FRONT) a += " marker_front";
    //     if (changes & this.CHANGE_FULL) a += " full";
    //     if (changes & this.CHANGE_H_SCROLL) a += " h_scroll";
    //     console.log(a.trim())
    // };

    oop.implement(this, EventEmitter);

    this.updateCharacterSize = function() {
        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
            this.setStyle("ace_nobold", !this.$allowBoldFonts);
        }

        this.layerConfig.characterWidth =
        this.characterWidth = this.$textLayer.getCharacterWidth();
        this.layerConfig.lineHeight =
        this.lineHeight = this.$textLayer.getLineHeight();
        this.$updatePrintMargin();
    };

    /**
     *
     * Associates the renderer with an [[EditSession `EditSession`]].
     **/
    this.setSession = function(session) {
        if (this.session)
            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
            
        this.session = session;
        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
            session.setScrollTop(-this.scrollMargin.top);

        this.$cursorLayer.setSession(session);
        this.$markerBack.setSession(session);
        this.$markerFront.setSession(session);
        this.$gutterLayer.setSession(session);
        this.$textLayer.setSession(session);
        if (!session)
            return;
        
        this.$loop.schedule(this.CHANGE_FULL);
        this.session.$setFontMetrics(this.$fontMetrics);
        this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
        
        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
        this.onChangeNewLineMode()
        this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
    };

    /**
     * Triggers a partial update of the text, from the range given by the two parameters.
     * @param {Number} firstRow The first row to update
     * @param {Number} lastRow The last row to update
     *
     **/
    this.updateLines = function(firstRow, lastRow, force) {
        if (lastRow === undefined)
            lastRow = Infinity;

        if (!this.$changedLines) {
            this.$changedLines = {
                firstRow: firstRow,
                lastRow: lastRow
            };
        }
        else {
            if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;

            if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
        }

        // If the change happened offscreen above us then it's possible
        // that a new line wrap will affect the position of the lines on our
        // screen so they need redrawn.
        // TODO: better solution is to not change scroll position when text is changed outside of visible area
        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
            if (force)
                this.$changedLines.lastRow = this.layerConfig.lastRow;
            else
                return;
        }
        if (this.$changedLines.firstRow > this.layerConfig.lastRow)
            return;
        this.$loop.schedule(this.CHANGE_LINES);
    };

    this.onChangeNewLineMode = function() {
        this.$loop.schedule(this.CHANGE_TEXT);
        this.$textLayer.$updateEolChar();
    };
    
    this.onChangeTabSize = function() {
        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
        this.$textLayer.onChangeTabSize();
    };

    /**
     * Triggers a full update of the text, for all the rows.
     **/
    this.updateText = function() {
        this.$loop.schedule(this.CHANGE_TEXT);
    };

    /**
     * Triggers a full update of all the layers, for all the rows.
     * @param {Boolean} force If `true`, forces the changes through
     *
     **/
    this.updateFull = function(force) {
        if (force)
            this.$renderChanges(this.CHANGE_FULL, true);
        else
            this.$loop.schedule(this.CHANGE_FULL);
    };

    /**
     * Updates the font size.
     **/
    this.updateFontSize = function() {
        this.$textLayer.checkForSizeChanges();
    };

    this.$changes = 0;
    this.$updateSizeAsync = function() {
        if (this.$loop.pending)
            this.$size.$dirty = true;
        else
            this.onResize();
    };
    /**
     * [Triggers a resize of the editor.]{: #VirtualRenderer.onResize}
     * @param {Boolean} force If `true`, recomputes the size, even if the height and width haven't changed
     * @param {Number} gutterWidth The width of the gutter in pixels
     * @param {Number} width The width of the editor in pixels
     * @param {Number} height The hiehgt of the editor, in pixels
     *
     **/
    this.onResize = function(force, gutterWidth, width, height) {
        if (this.resizing > 2)
            return;
        else if (this.resizing > 0)
            this.resizing++;
        else
            this.resizing = force ? 1 : 0;
        // `|| el.scrollHeight` is required for outosizing editors on ie
        // where elements with clientHeight = 0 alsoe have clientWidth = 0
        var el = this.container;
        if (!height)
            height = el.clientHeight || el.scrollHeight;
        if (!width)
            width = el.clientWidth || el.scrollWidth;
        var changes = this.$updateCachedSize(force, gutterWidth, width, height);

        
        if (!this.$size.scrollerHeight || (!width && !height))
            return this.resizing = 0;

        if (force)
            this.$gutterLayer.$padding = null;

        if (force)
            this.$renderChanges(changes | this.$changes, true);
        else
            this.$loop.schedule(changes | this.$changes);

        if (this.resizing)
            this.resizing = 0;
        // reset cached values on scrollbars, needs to be removed when switching to non-native scrollbars
        // see https://github.com/ajaxorg/ace/issues/2195
        this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
    };
    
    this.$updateCachedSize = function(force, gutterWidth, width, height) {
        height -= (this.$extraHeight || 0);
        var changes = 0;
        var size = this.$size;
        var oldSize = {
            width: size.width,
            height: size.height,
            scrollerHeight: size.scrollerHeight,
            scrollerWidth: size.scrollerWidth
        };
        if (height && (force || size.height != height)) {
            size.height = height;
            changes |= this.CHANGE_SIZE;

            size.scrollerHeight = size.height;
            if (this.$horizScroll)
                size.scrollerHeight -= this.scrollBarH.getHeight();
                
            // this.scrollBarV.setHeight(size.scrollerHeight);
            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

            changes = changes | this.CHANGE_SCROLL;
        }

        if (width && (force || size.width != width)) {
            changes |= this.CHANGE_SIZE;
            size.width = width;
            
            if (gutterWidth == null)
                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
            
            this.gutterWidth = gutterWidth;
            
            this.scrollBarH.element.style.left = 
            this.scroller.style.left = gutterWidth + "px";
            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());           
            
            this.scrollBarH.element.style.right = 
            this.scroller.style.right = this.scrollBarV.getWidth() + "px";
            this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";
                
            // this.scrollBarH.element.style.setWidth(size.scrollerWidth);

            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
                changes |= this.CHANGE_FULL;
        }
        
        size.$dirty = !width || !height;

        if (changes)
            this._signal("resize", oldSize);

        return changes;
    };

    this.onGutterResize = function() {
        var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
        if (gutterWidth != this.gutterWidth)
            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
            this.$loop.schedule(this.CHANGE_FULL);
        } else if (this.$size.$dirty) {
            this.$loop.schedule(this.CHANGE_FULL);
        } else {
            this.$computeLayerConfig();
            this.$loop.schedule(this.CHANGE_MARKER);
        }
    };

    /**
     * Adjusts the wrap limit, which is the number of characters that can fit within the width of the edit area on screen.
     **/
    this.adjustWrapLimit = function() {
        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
        var limit = Math.floor(availableWidth / this.characterWidth);
        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
    };

    /**
     * Identifies whether you want to have an animated scroll or not.
     * @param {Boolean} shouldAnimate Set to `true` to show animated scrolls
     *
     **/
    this.setAnimatedScroll = function(shouldAnimate){
        this.setOption("animatedScroll", shouldAnimate);
    };

    /**
     * Returns whether an animated scroll happens or not.
     * @returns {Boolean}
     **/
    this.getAnimatedScroll = function() {
        return this.$animatedScroll;
    };

    /**
     * Identifies whether you want to show invisible characters or not.
     * @param {Boolean} showInvisibles Set to `true` to show invisibles
     *
     **/
    this.setShowInvisibles = function(showInvisibles) {
        this.setOption("showInvisibles", showInvisibles);
    };

    /**
     * Returns whether invisible characters are being shown or not.
     * @returns {Boolean}
     **/
    this.getShowInvisibles = function() {
        return this.getOption("showInvisibles");
    };
    this.getDisplayIndentGuides = function() {
        return this.getOption("displayIndentGuides");
    };

    this.setDisplayIndentGuides = function(display) {
        this.setOption("displayIndentGuides", display);
    };

    /**
     * Identifies whether you want to show the print margin or not.
     * @param {Boolean} showPrintMargin Set to `true` to show the print margin
     *
     **/
    this.setShowPrintMargin = function(showPrintMargin) {
        this.setOption("showPrintMargin", showPrintMargin);
    };

    /**
     * Returns whether the print margin is being shown or not.
     * @returns {Boolean}
     **/
    this.getShowPrintMargin = function() {
        return this.getOption("showPrintMargin");
    };
    /**
     * Identifies whether you want to show the print margin column or not.
     * @param {Boolean} showPrintMargin Set to `true` to show the print margin column
     *
     **/
    this.setPrintMarginColumn = function(showPrintMargin) {
        this.setOption("printMarginColumn", showPrintMargin);
    };

    /**
     * Returns whether the print margin column is being shown or not.
     * @returns {Boolean}
     **/
    this.getPrintMarginColumn = function() {
        return this.getOption("printMarginColumn");
    };

    /**
     * Returns `true` if the gutter is being shown.
     * @returns {Boolean}
     **/
    this.getShowGutter = function(){
        return this.getOption("showGutter");
    };

    /**
     * Identifies whether you want to show the gutter or not.
     * @param {Boolean} show Set to `true` to show the gutter
     *
     **/
    this.setShowGutter = function(show){
        return this.setOption("showGutter", show);
    };

    this.getFadeFoldWidgets = function(){
        return this.getOption("fadeFoldWidgets")
    };

    this.setFadeFoldWidgets = function(show) {
        this.setOption("fadeFoldWidgets", show);
    };

    this.setHighlightGutterLine = function(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    };

    this.getHighlightGutterLine = function() {
        return this.getOption("highlightGutterLine");
    };

    this.$updateGutterLineHighlight = function() {
        var pos = this.$cursorLayer.$pixelPos;
        var height = this.layerConfig.lineHeight;
        if (this.session.getUseWrapMode()) {
            var cursor = this.session.selection.getCursor();
            cursor.column = 0;
            pos = this.$cursorLayer.getPixelPosition(cursor, true);
            height *= this.session.getRowLength(cursor.row);
        }
        this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
        this.$gutterLineHighlight.style.height = height + "px";
    };

    this.$updatePrintMargin = function() {
        if (!this.$showPrintMargin && !this.$printMarginEl)
            return;

        if (!this.$printMarginEl) {
            var containerEl = dom.createElement("div");
            containerEl.className = "ace_layer ace_print-margin-layer";
            this.$printMarginEl = dom.createElement("div");
            this.$printMarginEl.className = "ace_print-margin";
            containerEl.appendChild(this.$printMarginEl);
            this.content.insertBefore(containerEl, this.content.firstChild);
        }

        var style = this.$printMarginEl.style;
        style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + "px";
        style.visibility = this.$showPrintMargin ? "visible" : "hidden";
        
        if (this.session && this.session.$wrap == -1)
            this.adjustWrapLimit();
    };

    /**
     *
     * Returns the root element containing this renderer.
     * @returns {DOMElement}
     **/
    this.getContainerElement = function() {
        return this.container;
    };

    /**
     *
     * Returns the element that the mouse events are attached to
     * @returns {DOMElement}
     **/
    this.getMouseEventTarget = function() {
        return this.scroller;
    };

    /**
     *
     * Returns the element to which the hidden text area is added.
     * @returns {DOMElement}
     **/
    this.getTextAreaContainer = function() {
        return this.container;
    };

    // move text input over the cursor
    // this is required for iOS and IME
    this.$moveTextAreaToCursor = function() {
        if (!this.$keepTextAreaAtCursor)
            return;
        var config = this.layerConfig;
        var posTop = this.$cursorLayer.$pixelPos.top;
        var posLeft = this.$cursorLayer.$pixelPos.left;
        posTop -= config.offset;

        var style = this.textarea.style;
        var h = this.lineHeight;
        if (posTop < 0 || posTop > config.height - h) {
            style.top = style.left = "0";
            return;
        }

        var w = this.characterWidth;
        if (this.$composition) {
            var val = this.textarea.value.replace(/^\x01+/, "");
            w *= (this.session.$getStringScreenWidth(val)[0]+2);
            h += 2;
        }
        posLeft -= this.scrollLeft;
        if (posLeft > this.$size.scrollerWidth - w)
            posLeft = this.$size.scrollerWidth - w;

        posLeft += this.gutterWidth;
        style.height = h + "px";
        style.width = w + "px";
        style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
        style.top = Math.min(posTop, this.$size.height - h) + "px";
    };

    /**
     * [Returns the index of the first visible row.]{: #VirtualRenderer.getFirstVisibleRow}
     * @returns {Number}
     **/
    this.getFirstVisibleRow = function() {
        return this.layerConfig.firstRow;
    };

    /**
     *
     * Returns the index of the first fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
     * @returns {Number}
     **/
    this.getFirstFullyVisibleRow = function() {
        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
    };

    /**
     *
     * Returns the index of the last fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
     * @returns {Number}
     **/
    this.getLastFullyVisibleRow = function() {
        var config = this.layerConfig;
        var lastRow = config.lastRow
        var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
        if (top - this.session.getScrollTop() > config.height - config.lineHeight)
            return lastRow - 1;
        return lastRow;
    };

    /**
     *
     * [Returns the index of the last visible row.]{: #VirtualRenderer.getLastVisibleRow}
     * @returns {Number}
     **/
    this.getLastVisibleRow = function() {
        return this.layerConfig.lastRow;
    };

    this.$padding = null;

    /**
     * Sets the padding for all the layers.
     * @param {Number} padding A new padding value (in pixels)
     *
     **/
    this.setPadding = function(padding) {
        this.$padding = padding;
        this.$textLayer.setPadding(padding);
        this.$cursorLayer.setPadding(padding);
        this.$markerFront.setPadding(padding);
        this.$markerBack.setPadding(padding);
        this.$loop.schedule(this.CHANGE_FULL);
        this.$updatePrintMargin();
    };
    
    this.setScrollMargin = function(top, bottom, left, right) {
        var sm = this.scrollMargin;
        sm.top = top|0;
        sm.bottom = bottom|0;
        sm.right = right|0;
        sm.left = left|0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        if (sm.top && this.scrollTop <= 0 && this.session)
            this.session.setScrollTop(-sm.top);
        this.updateFull();
    };

    /**
     * Returns whether the horizontal scrollbar is set to be always visible.
     * @returns {Boolean}
     **/
    this.getHScrollBarAlwaysVisible = function() {
        return this.$hScrollBarAlwaysVisible;
    };

    /**
     * Identifies whether you want to show the horizontal scrollbar or not.
     * @param {Boolean} alwaysVisible Set to `true` to make the horizontal scroll bar visible
     **/
    this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
        this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
    };
    /**
     * Returns whether the horizontal scrollbar is set to be always visible.
     * @returns {Boolean}
     **/
    this.getVScrollBarAlwaysVisible = function() {
        return this.$vScrollBarAlwaysVisible;
    };

    /**
     * Identifies whether you want to show the horizontal scrollbar or not.
     * @param {Boolean} alwaysVisible Set to `true` to make the horizontal scroll bar visible
     **/
    this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
    };

    this.$updateScrollBarV = function() {
        var scrollHeight = this.layerConfig.maxHeight;
        var scrollerHeight = this.$size.scrollerHeight;
        if (!this.$maxLines && this.$scrollPastEnd) {
            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
            if (this.scrollTop > scrollHeight - scrollerHeight) {
                scrollHeight = this.scrollTop + scrollerHeight;
                this.scrollBarV.scrollTop = null;
            }
        }
        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
    };
    this.$updateScrollBarH = function() {
        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
    };
    
    this.$frozen = false;
    this.freeze = function() {
        this.$frozen = true;
    };
    
    this.unfreeze = function() {
        this.$frozen = false;
    };

    this.$renderChanges = function(changes, force) {
        if (this.$changes) {
            changes |= this.$changes;
            this.$changes = 0;
        }
        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
            this.$changes |= changes;
            return; 
        } 
        if (this.$size.$dirty) {
            this.$changes |= changes;
            return this.onResize(true);
        }
        if (!this.lineHeight) {
            this.$textLayer.checkForSizeChanges();
        }
        // this.$logChanges(changes);
        
        this._signal("beforeRender");
        var config = this.layerConfig;
        // text, scrolling and resize changes can cause the view port size to change
        if (changes & this.CHANGE_FULL ||
            changes & this.CHANGE_SIZE ||
            changes & this.CHANGE_TEXT ||
            changes & this.CHANGE_LINES ||
            changes & this.CHANGE_SCROLL ||
            changes & this.CHANGE_H_SCROLL
        ) {
            changes |= this.$computeLayerConfig();
            // If a change is made offscreen and wrapMode is on, then the onscreen
            // lines may have been pushed down. If so, the first screen row will not
            // have changed, but the first actual row will. In that case, adjust 
            // scrollTop so that the cursor and onscreen content stays in the same place.
            // TODO: find a better way to handle this, that works non wrapped case and doesn't compute layerConfig twice
            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                if (st > 0) {
                    // this check is needed as a workaround for the documentToScreenRow returning -1 if document.length == 0
                    this.scrollTop = st;
                    changes = changes | this.CHANGE_SCROLL;
                    changes |= this.$computeLayerConfig();
                }
            }
            config = this.layerConfig;
            // update scrollbar first to not lose scroll position when gutter calls resize
            this.$updateScrollBarV();
            if (changes & this.CHANGE_H_SCROLL)
                this.$updateScrollBarH();
            this.$gutterLayer.element.style.marginTop = (-config.offset) + "px";
            this.content.style.marginTop = (-config.offset) + "px";
            this.content.style.width = config.width + 2 * this.$padding + "px";
            this.content.style.height = config.minHeight + "px";
        }
        
        // horizontal scrolling
        if (changes & this.CHANGE_H_SCROLL) {
            this.content.style.marginLeft = -this.scrollLeft + "px";
            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
        }

        // full
        if (changes & this.CHANGE_FULL) {
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
            this._signal("afterRender");
            return;
        }

        // scrolling
        if (changes & this.CHANGE_SCROLL) {
            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                this.$textLayer.update(config);
            else
                this.$textLayer.scrollLines(config);

            if (this.$showGutter)
                this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
            this.$moveTextAreaToCursor();
            this._signal("afterRender");
            return;
        }

        if (changes & this.CHANGE_TEXT) {
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
        }
        else if (changes & this.CHANGE_LINES) {
            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
                this.$gutterLayer.update(config);
        }
        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
            if (this.$showGutter)
                this.$gutterLayer.update(config);
        }

        if (changes & this.CHANGE_CURSOR) {
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
            this.$markerFront.update(config);
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
            this.$markerBack.update(config);
        }

        this._signal("afterRender");
    };

    
    this.$autosize = function() {
        var height = this.session.getScreenLength() * this.lineHeight;
        var maxHeight = this.$maxLines * this.lineHeight;
        var desiredHeight = Math.min(maxHeight, 
            Math.max((this.$minLines || 1) * this.lineHeight, height)
        ) + this.scrollMargin.v + (this.$extraHeight || 0);
        if (this.$horizScroll)
            desiredHeight += this.scrollBarH.getHeight();
        if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
            desiredHeight = this.$maxPixelHeight;
        var vScroll = height > maxHeight;
        
        if (desiredHeight != this.desiredHeight ||
            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
            if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
            }
            
            var w = this.container.clientWidth;
            this.container.style.height = desiredHeight + "px";
            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
            // this.$loop.changes = 0;
            this.desiredHeight = desiredHeight;
            
            this._signal("autosize");
        }
    };
    
    this.$computeLayerConfig = function() {
        var session = this.session;
        var size = this.$size;
        
        var hideScrollbars = size.height <= 2 * this.lineHeight;
        var screenLines = this.session.getScreenLength();
        var maxHeight = screenLines * this.lineHeight;

        var longestLine = this.$getLongestLine();
        
        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
            size.scrollerWidth - longestLine - 2 * this.$padding < 0);

        var hScrollChanged = this.$horizScroll !== horizScroll;
        if (hScrollChanged) {
            this.$horizScroll = horizScroll;
            this.scrollBarH.setVisible(horizScroll);
        }
        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
        // autoresize only after updating hscroll to include scrollbar height in desired height
        if (this.$maxLines && this.lineHeight > 1)
            this.$autosize();

        var offset = this.scrollTop % this.lineHeight;
        var minHeight = size.scrollerHeight + this.lineHeight;
        
        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
            : 0;
        maxHeight += scrollPastEnd;
        
        var sm = this.scrollMargin;
        this.session.setScrollTop(Math.max(-sm.top,
            Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));

        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, 
            longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
        
        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
        var vScrollChanged = vScrollBefore !== vScroll;
        if (vScrollChanged) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
        }

        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
        var lastRow = firstRow + lineCount;

        // Map lines on the screen to lines in the document.
        var firstRowScreen, firstRowHeight;
        var lineHeight = this.lineHeight;
        firstRow = session.screenToDocumentRow(firstRow, 0);

        // Check if firstRow is inside of a foldLine. If true, then use the first
        // row of the foldLine.
        var foldLine = session.getFoldLine(firstRow);
        if (foldLine) {
            firstRow = foldLine.start.row;
        }

        firstRowScreen = session.documentToScreenRow(firstRow, 0);
        firstRowHeight = session.getRowLength(firstRow) * lineHeight;

        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
                                                firstRowHeight;

        offset = this.scrollTop - firstRowScreen * lineHeight;

        var changes = 0;
        if (this.layerConfig.width != longestLine) 
            changes = this.CHANGE_H_SCROLL;
        // Horizontal scrollbar visibility may have changed, which changes
        // the client height of the scroller
        if (hScrollChanged || vScrollChanged) {
            changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
            this._signal("scrollbarVisibilityChanged");
            if (vScrollChanged)
                longestLine = this.$getLongestLine();
        }
        
        this.layerConfig = {
            width : longestLine,
            padding : this.$padding,
            firstRow : firstRow,
            firstRowScreen: firstRowScreen,
            lastRow : lastRow,
            lineHeight : lineHeight,
            characterWidth : this.characterWidth,
            minHeight : minHeight,
            maxHeight : maxHeight,
            offset : offset,
            gutterOffset : lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
            height : this.$size.scrollerHeight
        };

        // For debugging.
        // console.log(JSON.stringify(this.layerConfig));

        return changes;
    };

    this.$updateLines = function() {
        var firstRow = this.$changedLines.firstRow;
        var lastRow = this.$changedLines.lastRow;
        this.$changedLines = null;

        var layerConfig = this.layerConfig;

        if (firstRow > layerConfig.lastRow + 1) { return; }
        if (lastRow < layerConfig.firstRow) { return; }

        // if the last row is unknown -> redraw everything
        if (lastRow === Infinity) {
            if (this.$showGutter)
                this.$gutterLayer.update(layerConfig);
            this.$textLayer.update(layerConfig);
            return;
        }

        // else update only the changed rows
        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
        return true;
    };

    this.$getLongestLine = function() {
        var charCount = this.session.getScreenWidth();
        if (this.showInvisibles && !this.session.$useWrapMode)
            charCount += 1;

        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
    };

    /**
     * Schedules an update to all the front markers in the document.
     **/
    this.updateFrontMarkers = function() {
        this.$markerFront.setMarkers(this.session.getMarkers(true));
        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
    };

    /**
     *
     * Schedules an update to all the back markers in the document.
     **/
    this.updateBackMarkers = function() {
        this.$markerBack.setMarkers(this.session.getMarkers());
        this.$loop.schedule(this.CHANGE_MARKER_BACK);
    };

    /**
     *
     * Deprecated; (moved to [[EditSession]])
     * @deprecated
     **/
    this.addGutterDecoration = function(row, className){
        this.$gutterLayer.addGutterDecoration(row, className);
    };

    /**
     * Deprecated; (moved to [[EditSession]])
     * @deprecated
     **/
    this.removeGutterDecoration = function(row, className){
        this.$gutterLayer.removeGutterDecoration(row, className);
    };

    /**
     *
     * Redraw breakpoints.
     **/
    this.updateBreakpoints = function(rows) {
        this.$loop.schedule(this.CHANGE_GUTTER);
    };

    /**
     * Sets annotations for the gutter.
     * @param {Array} annotations An array containing annotations
     *
     **/
    this.setAnnotations = function(annotations) {
        this.$gutterLayer.setAnnotations(annotations);
        this.$loop.schedule(this.CHANGE_GUTTER);
    };

    /**
     *
     * Updates the cursor icon.
     **/
    this.updateCursor = function() {
        this.$loop.schedule(this.CHANGE_CURSOR);
    };

    /**
     *
     * Hides the cursor icon.
     **/
    this.hideCursor = function() {
        this.$cursorLayer.hideCursor();
    };

    /**
     *
     * Shows the cursor icon.
     **/
    this.showCursor = function() {
        this.$cursorLayer.showCursor();
    };

    this.scrollSelectionIntoView = function(anchor, lead, offset) {
        // first scroll anchor into view then scroll lead into view
        this.scrollCursorIntoView(anchor, offset);
        this.scrollCursorIntoView(lead, offset);
    };

    /**
     *
     * Scrolls the cursor into the first visibile area of the editor
     **/
    this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
        // the editor is not visible
        if (this.$size.scrollerHeight === 0)
            return;

        var pos = this.$cursorLayer.getPixelPosition(cursor);

        var left = pos.left;
        var top = pos.top;
        
        var topMargin = $viewMargin && $viewMargin.top || 0;
        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
        
        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
        
        if (scrollTop + topMargin > top) {
            if (offset && scrollTop + topMargin > top + this.lineHeight)
                top -= offset * this.$size.scrollerHeight;
            if (top === 0)
                top = -this.scrollMargin.top;
            this.session.setScrollTop(top);
        } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
            if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top -  this.lineHeight)
                top += offset * this.$size.scrollerHeight;
            this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
        }

        var scrollLeft = this.scrollLeft;

        if (scrollLeft > left) {
            if (left < this.$padding + 2 * this.layerConfig.characterWidth)
                left = -this.scrollMargin.left;
            this.session.setScrollLeft(left);
        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
            this.session.setScrollLeft(0);
        }
    };

    /**
     * {:EditSession.getScrollTop}
     * @related EditSession.getScrollTop
     * @returns {Number}
     **/
    this.getScrollTop = function() {
        return this.session.getScrollTop();
    };

    /**
     * {:EditSession.getScrollLeft}
     * @related EditSession.getScrollLeft
     * @returns {Number}
     **/
    this.getScrollLeft = function() {
        return this.session.getScrollLeft();
    };

    /**
     * Returns the first visible row, regardless of whether it's fully visible or not.
     * @returns {Number}
     **/
    this.getScrollTopRow = function() {
        return this.scrollTop / this.lineHeight;
    };

    /**
     * Returns the last visible row, regardless of whether it's fully visible or not.
     * @returns {Number}
     **/
    this.getScrollBottomRow = function() {
        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
    };

    /**
     * Gracefully scrolls from the top of the editor to the row indicated.
     * @param {Number} row A row id
     *
     * @related EditSession.setScrollTop
     **/
    this.scrollToRow = function(row) {
        this.session.setScrollTop(row * this.lineHeight);
    };

    this.alignCursor = function(cursor, alignment) {
        if (typeof cursor == "number")
            cursor = {row: cursor, column: 0};

        var pos = this.$cursorLayer.getPixelPosition(cursor);
        var h = this.$size.scrollerHeight - this.lineHeight;
        var offset = pos.top - h * (alignment || 0);

        this.session.setScrollTop(offset);
        return offset;
    };

    this.STEPS = 8;
    this.$calcSteps = function(fromValue, toValue){
        var i = 0;
        var l = this.STEPS;
        var steps = [];

        var func  = function(t, x_min, dx) {
            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
        };

        for (i = 0; i < l; ++i)
            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

        return steps;
    };

    /**
     * Gracefully scrolls the editor to the row indicated.
     * @param {Number} line A line number
     * @param {Boolean} center If `true`, centers the editor the to indicated line
     * @param {Boolean} animate If `true` animates scrolling
     * @param {Function} callback Function to be called after the animation has finished
     *
     **/
    this.scrollToLine = function(line, center, animate, callback) {
        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
        var offset = pos.top;
        if (center)
            offset -= this.$size.scrollerHeight / 2;

        var initialScroll = this.scrollTop;
        this.session.setScrollTop(offset);
        if (animate !== false)
            this.animateScrolling(initialScroll, callback);
    };

    this.animateScrolling = function(fromValue, callback) {
        var toValue = this.scrollTop;
        if (!this.$animatedScroll)
            return;
        var _self = this;
        
        if (fromValue == toValue)
            return;
        
        if (this.$scrollAnimation) {
            var oldSteps = this.$scrollAnimation.steps;
            if (oldSteps.length) {
                fromValue = oldSteps[0];
                if (fromValue == toValue)
                    return;
            }
        }
        
        var steps = _self.$calcSteps(fromValue, toValue);
        this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};

        clearInterval(this.$timer);

        _self.session.setScrollTop(steps.shift());
        // trick session to think it's already scrolled to not loose toValue
        _self.session.$scrollTop = toValue;
        this.$timer = setInterval(function() {
            if (steps.length) {
                _self.session.setScrollTop(steps.shift());
                _self.session.$scrollTop = toValue;
            } else if (toValue != null) {
                _self.session.$scrollTop = -1;
                _self.session.setScrollTop(toValue);
                toValue = null;
            } else {
                // do this on separate step to not get spurious scroll event from scrollbar
                _self.$timer = clearInterval(_self.$timer);
                _self.$scrollAnimation = null;
                callback && callback();
            }
        }, 10);
    };

    /**
     * Scrolls the editor to the y pixel indicated.
     * @param {Number} scrollTop The position to scroll to
     *
     * @returns {Number}
     **/
    this.scrollToY = function(scrollTop) {
        // after calling scrollBar.setScrollTop
        // scrollbar sends us event with same scrollTop. ignore it
        if (this.scrollTop !== scrollTop) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollTop = scrollTop;
        }
    };

    /**
     * Scrolls the editor across the x-axis to the pixel indicated.
     * @param {Number} scrollLeft The position to scroll to
     *
     * @returns {Number}
     **/
    this.scrollToX = function(scrollLeft) {
        if (this.scrollLeft !== scrollLeft)
            this.scrollLeft = scrollLeft;
        this.$loop.schedule(this.CHANGE_H_SCROLL);
    };

    /**
     * Scrolls the editor across both x- and y-axes.
     * @param {Number} x The x value to scroll to
     * @param {Number} y The y value to scroll to
     **/
    this.scrollTo = function(x, y) {
        this.session.setScrollTop(y);
        this.session.setScrollLeft(y);
    };
    
    /**
     * Scrolls the editor across both x- and y-axes.
     * @param {Number} deltaX The x value to scroll by
     * @param {Number} deltaY The y value to scroll by
     **/
    this.scrollBy = function(deltaX, deltaY) {
        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
    };

    /**
     * Returns `true` if you can still scroll by either parameter; in other words, you haven't reached the end of the file or line.
     * @param {Number} deltaX The x value to scroll by
     * @param {Number} deltaY The y value to scroll by
     *
     * @returns {Boolean}
     **/
    this.isScrollableBy = function(deltaX, deltaY) {
        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
           return true;
        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
           return true;
        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
            return true;
        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
            - this.layerConfig.width < -1 + this.scrollMargin.right)
           return true;
    };

    this.pixelToScreenCoordinates = function(x, y) {
        var canvasPos = this.scroller.getBoundingClientRect();

        var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
        var col = Math.round(offset);

        return {row: row, column: col, side: offset - col > 0 ? 1 : -1};
    };

    this.screenToTextCoordinates = function(x, y) {
        var canvasPos = this.scroller.getBoundingClientRect();

        var col = Math.round(
            (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth
        );

        var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;

        return this.session.screenToDocumentPosition(row, Math.max(col, 0));
    };

    /**
     * Returns an object containing the `pageX` and `pageY` coordinates of the document position.
     * @param {Number} row The document row position
     * @param {Number} column The document column position
     *
     * @returns {Object}
     **/
    this.textToScreenCoordinates = function(row, column) {
        var canvasPos = this.scroller.getBoundingClientRect();
        var pos = this.session.documentToScreenPosition(row, column);

        var x = this.$padding + Math.round(pos.column * this.characterWidth);
        var y = pos.row * this.lineHeight;

        return {
            pageX: canvasPos.left + x - this.scrollLeft,
            pageY: canvasPos.top + y - this.scrollTop
        };
    };

    /**
     *
     * Focuses the current container.
     **/
    this.visualizeFocus = function() {
        dom.addCssClass(this.container, "ace_focus");
    };

    /**
     *
     * Blurs the current container.
     **/
    this.visualizeBlur = function() {
        dom.removeCssClass(this.container, "ace_focus");
    };

    /**
     * @param {Number} position
     *
     * @private
     **/
    this.showComposition = function(position) {
        if (!this.$composition)
            this.$composition = {
                keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
                cssText: this.textarea.style.cssText
            };

        this.$keepTextAreaAtCursor = true;
        dom.addCssClass(this.textarea, "ace_composition");
        this.textarea.style.cssText = "";
        this.$moveTextAreaToCursor();
    };

    /**
     * @param {String} text A string of text to use
     *
     * Sets the inner text of the current composition to `text`.
     **/
    this.setCompositionText = function(text) {
        this.$moveTextAreaToCursor();
    };

    /**
     *
     * Hides the current composition.
     **/
    this.hideComposition = function() {
        if (!this.$composition)
            return;

        dom.removeCssClass(this.textarea, "ace_composition");
        this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
        this.textarea.style.cssText = this.$composition.cssText;
        this.$composition = null;
    };

    /**
     * [Sets a new theme for the editor. `theme` should exist, and be a directory path, like `ace/theme/textmate`.]{: #VirtualRenderer.setTheme}
     * @param {String} theme The path to a theme
     * @param {Function} cb optional callback
     *
     **/
    this.setTheme = function(theme, cb) {
        var _self = this;
        this.$themeId = theme;
        _self._dispatchEvent('themeChange',{theme:theme});

        if (!theme || typeof theme == "string") {
            var moduleName = theme || this.$options.theme.initialValue;
            config.loadModule(["theme", moduleName], afterLoad);
        } else {
            afterLoad(theme);
        }

        function afterLoad(module) {
            if (_self.$themeId != theme)
                return cb && cb();
            if (!module || !module.cssClass)
                throw new Error("couldn't load module " + theme + " or it didn't call define");
            dom.importCssString(
                module.cssText,
                module.cssClass,
                _self.container.ownerDocument
            );

            if (_self.theme)
                dom.removeCssClass(_self.container, _self.theme.cssClass);

            var padding = "padding" in module ? module.padding 
                : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
            if (_self.$padding && padding != _self.$padding)
                _self.setPadding(padding);
                
            // this is kept only for backwards compatibility
            _self.$theme = module.cssClass;

            _self.theme = module;
            dom.addCssClass(_self.container, module.cssClass);
            dom.setCssClass(_self.container, "ace_dark", module.isDark);

            // force re-measure of the gutter width
            if (_self.$size) {
                _self.$size.width = 0;
                _self.$updateSizeAsync();
            }

            _self._dispatchEvent('themeLoaded', {theme:module});
            cb && cb();
        }
    };

    /**
     * [Returns the path of the current theme.]{: #VirtualRenderer.getTheme}
     * @returns {String}
     **/
    this.getTheme = function() {
        return this.$themeId;
    };

    // Methods allows to add / remove CSS classnames to the editor element.
    // This feature can be used by plug-ins to provide a visual indication of
    // a certain mode that editor is in.

    /**
     * [Adds a new class, `style`, to the editor.]{: #VirtualRenderer.setStyle}
     * @param {String} style A class name
     *
     **/
    this.setStyle = function(style, include) {
        dom.setCssClass(this.container, style, include !== false);
    };

    /**
     * [Removes the class `style` from the editor.]{: #VirtualRenderer.unsetStyle}
     * @param {String} style A class name
     *
     **/
    this.unsetStyle = function(style) {
        dom.removeCssClass(this.container, style);
    };
    
    this.setCursorStyle = function(style) {
        if (this.scroller.style.cursor != style)
            this.scroller.style.cursor = style;
    };

    /**
     * @param {String} cursorStyle A css cursor style
     *
     **/
    this.setMouseCursor = function(cursorStyle) {
        this.scroller.style.cursor = cursorStyle;
    };

    /**
     * Destroys the text and cursor layers for this renderer.
     **/
    this.destroy = function() {
        this.$textLayer.destroy();
        this.$cursorLayer.destroy();
    };

}).call(VirtualRenderer.prototype);


config.defineOptions(VirtualRenderer.prototype, "renderer", {
    animatedScroll: {initialValue: false},
    showInvisibles: {
        set: function(value) {
            if (this.$textLayer.setShowInvisibles(value))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: false
    },
    showPrintMargin: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: true
    },
    printMarginColumn: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: 80
    },
    printMargin: {
        set: function(val) {
            if (typeof val == "number")
                this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
        },
        get: function() {
            return this.$showPrintMargin && this.$printMarginColumn; 
        }
    },
    showGutter: {
        set: function(show){
            this.$gutter.style.display = show ? "block" : "none";
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
        },
        initialValue: true
    },
    fadeFoldWidgets: {
        set: function(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
        },
        initialValue: false
    },
    showFoldWidgets: {
        set: function(show) {this.$gutterLayer.setShowFoldWidgets(show)},
        initialValue: true
    },
    showLineNumbers: {
        set: function(show) {
            this.$gutterLayer.setShowLineNumbers(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
    },
    displayIndentGuides: {
        set: function(show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: true
    },
    highlightGutterLine: {
        set: function(shouldHighlight) {
            if (!this.$gutterLineHighlight) {
                this.$gutterLineHighlight = dom.createElement("div");
                this.$gutterLineHighlight.className = "ace_gutter-active-line";
                this.$gutter.appendChild(this.$gutterLineHighlight);
                return;
            }

            this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
            // if cursorlayer have never been updated there's nothing on screen to update
            if (this.$cursorLayer.$pixelPos)
                this.$updateGutterLineHighlight();
        },
        initialValue: false,
        value: true
    },
    hScrollBarAlwaysVisible: {
        set: function(val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    vScrollBarAlwaysVisible: {
        set: function(val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    fontSize:  {
        set: function(size) {
            if (typeof size == "number")
                size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
        },
        initialValue: 12
    },
    fontFamily: {
        set: function(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
        }
    },
    maxLines: {
        set: function(val) {
            this.updateFull();
        }
    },
    minLines: {
        set: function(val) {
            this.updateFull();
        }
    },
    maxPixelHeight: {
        set: function(val) {
            this.updateFull();
        },
        initialValue: 0
    },
    scrollPastEnd: {
        set: function(val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
                return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: 0,
        handlesSet: true
    },
    fixedWidthGutter: {
        set: function(val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
        }
    },
    theme: {
        set: function(val) { this.setTheme(val) },
        get: function() { return this.$themeId || this.theme; },
        initialValue: "./theme/textmate",
        handlesSet: true
    }
});

exports.VirtualRenderer = VirtualRenderer;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/worker/worker_client',['require','exports','module','../lib/oop','../lib/net','../lib/event_emitter','../config'],function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var net = require("../lib/net");
var EventEmitter = require("../lib/event_emitter").EventEmitter;
var config = require("../config");

var WorkerClient = function(topLevelNamespaces, mod, classname, workerUrl) {
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.onMessage = this.onMessage.bind(this);

    // nameToUrl is renamed to toUrl in requirejs 2
    if (require.nameToUrl && !require.toUrl)
        require.toUrl = require.nameToUrl;
    
    if (config.get("packaged") || !require.toUrl) {
        workerUrl = workerUrl || config.moduleUrl(mod, "worker");
    } else {
        var normalizePath = this.$normalizePath;
        workerUrl = workerUrl || normalizePath(require.toUrl("ace/worker/worker.js", null, "_"));

        var tlns = {};
        topLevelNamespaces.forEach(function(ns) {
            tlns[ns] = normalizePath(require.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
        });
    }

    try {
        this.$worker = new Worker(workerUrl);
    } catch(e) {
        if (e instanceof window.DOMException) {
            // Likely same origin problem. Use importScripts from a shim Worker
            var blob = this.$workerBlob(workerUrl);
            var URL = window.URL || window.webkitURL;
            var blobURL = URL.createObjectURL(blob);

            this.$worker = new Worker(blobURL);
            URL.revokeObjectURL(blobURL);
        } else {
            throw e;
        }
    }
    this.$worker.postMessage({
        init : true,
        tlns : tlns,
        module : mod,
        classname : classname
    });

    this.callbackId = 1;
    this.callbacks = {};

    this.$worker.onmessage = this.onMessage;
};

(function(){

    oop.implement(this, EventEmitter);

    this.onMessage = function(e) {
        var msg = e.data;
        switch(msg.type) {
            case "event":
                this._signal(msg.name, {data: msg.data});
                break;
            case "call":
                var callback = this.callbacks[msg.id];
                if (callback) {
                    callback(msg.data);
                    delete this.callbacks[msg.id];
                }
                break;
            case "error":
                this.reportError(msg.data);
                break;
            case "log":
                window.console && console.log && console.log.apply(console, msg.data);
                break;
        }
    };
    
    this.reportError = function(err) {
        window.console && console.error && console.error(err);
    };

    this.$normalizePath = function(path) {
        return net.qualifyURL(path);
    };

    this.terminate = function() {
        this._signal("terminate", {});
        this.deltaQueue = null;
        this.$worker.terminate();
        this.$worker = null;
        if (this.$doc)
            this.$doc.off("change", this.changeListener);
        this.$doc = null;
    };

    this.send = function(cmd, args) {
        this.$worker.postMessage({command: cmd, args: args});
    };

    this.call = function(cmd, args, callback) {
        if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
        }
        this.send(cmd, args);
    };

    this.emit = function(event, data) {
        try {
            // firefox refuses to clone objects which have function properties
            // TODO: cleanup event
            this.$worker.postMessage({event: event, data: {data: data.data}});
        }
        catch(ex) {
            console.error(ex.stack);
        }
    };

    this.attachToDocument = function(doc) {
        if(this.$doc)
            this.terminate();

        this.$doc = doc;
        this.call("setValue", [doc.getValue()]);
        doc.on("change", this.changeListener);
    };

    this.changeListener = function(delta) {
        if (!this.deltaQueue) {
            this.deltaQueue = [];
            setTimeout(this.$sendDeltaQueue, 0);
        }
        if (delta.action == "insert")
            this.deltaQueue.push(delta.start, delta.lines);
        else
            this.deltaQueue.push(delta.start, delta.end);
    };

    this.$sendDeltaQueue = function() {
        var q = this.deltaQueue;
        if (!q) return;
        this.deltaQueue = null;
        if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
            this.call("setValue", [this.$doc.getValue()]);
        } else
            this.emit("change", {data: q});
    };

    this.$workerBlob = function(workerUrl) {
        // workerUrl can be protocol relative
        // importScripts only takes fully qualified urls
        var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
        try {
            return new Blob([script], {"type": "application/javascript"});
        } catch (e) { // Backwards-compatibility
            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
            var blobBuilder = new BlobBuilder();
            blobBuilder.append(script);
            return blobBuilder.getBlob("application/javascript");
        }
    };

}).call(WorkerClient.prototype);


var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.callbackId = 1;
    this.callbacks = {};
    this.messageBuffer = [];

    var main = null;
    var emitSync = false;
    var sender = Object.create(EventEmitter);
    var _self = this;

    this.$worker = {};
    this.$worker.terminate = function() {};
    this.$worker.postMessage = function(e) {
        _self.messageBuffer.push(e);
        if (main) {
            if (emitSync)
                setTimeout(processNext);
            else
                processNext();
        }
    };
    this.setEmitSync = function(val) { emitSync = val };

    var processNext = function() {
        var msg = _self.messageBuffer.shift();
        if (msg.command)
            main[msg.command].apply(main, msg.args);
        else if (msg.event)
            sender._signal(msg.event, msg.data);
    };

    sender.postMessage = function(msg) {
        _self.onMessage({data: msg});
    };
    sender.callback = function(data, callbackId) {
        this.postMessage({type: "call", id: callbackId, data: data});
    };
    sender.emit = function(name, data) {
        this.postMessage({type: "event", name: name, data: data});
    };

    config.loadModule(["worker", mod], function(Main) {
        main = new Main[classname](sender);
        while (_self.messageBuffer.length)
            processNext();
    });
};

UIWorkerClient.prototype = WorkerClient.prototype;

exports.UIWorkerClient = UIWorkerClient;
exports.WorkerClient = WorkerClient;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */
define('bower_components/ace/lib/ace/placeholder',['require','exports','module','./range','./lib/event_emitter','./lib/oop'],function(require, exports, module) {
"use strict";

var Range = require("./range").Range;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var oop = require("./lib/oop");

/**
 * @class PlaceHolder
 *
 **/

/**
 * - session (Document): The document to associate with the anchor
 * - length (Number): The starting row position
 * - pos (Number): The starting column position
 * - others (String):
 * - mainClass (String):
 * - othersClass (String):
 * 
 * @constructor
 **/

var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
    var _self = this;
    this.length = length;
    this.session = session;
    this.doc = session.getDocument();
    this.mainClass = mainClass;
    this.othersClass = othersClass;
    this.$onUpdate = this.onUpdate.bind(this);
    this.doc.on("change", this.$onUpdate);
    this.$others = others;
    
    this.$onCursorChange = function() {
        setTimeout(function() {
            _self.onCursorChange();
        });
    };
    
    this.$pos = pos;
    // Used for reset
    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
    this.$undoStackDepth = undoStack.length;
    this.setup();

    session.selection.on("changeCursor", this.$onCursorChange);
};

(function() {

    oop.implement(this, EventEmitter);

    /**
     * PlaceHolder.setup()
     *
     * TODO
     *
     **/
    this.setup = function() {
        var _self = this;
        var doc = this.doc;
        var session = this.session;
        
        this.selectionBefore = session.selection.toJSON();
        if (session.selection.inMultiSelectMode)
            session.selection.toSingleRange();

        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
        var pos = this.pos;
        pos.$insertRight = true;
        pos.detach();
        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
        this.others = [];
        this.$others.forEach(function(other) {
            var anchor = doc.createAnchor(other.row, other.column);
            anchor.$insertRight = true;
            anchor.detach();
            _self.others.push(anchor);
        });
        session.setUndoSelect(false);
    };
    
    /**
     * PlaceHolder.showOtherMarkers()
     *
     * TODO
     *
     **/
    this.showOtherMarkers = function() {
        if (this.othersActive) return;
        var session = this.session;
        var _self = this;
        this.othersActive = true;
        this.others.forEach(function(anchor) {
            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
        });
    };
    
    /**
     * PlaceHolder.hideOtherMarkers()
     *
     * Hides all over markers in the [[EditSession `EditSession`]] that are not the currently selected one.
     *
     **/
    this.hideOtherMarkers = function() {
        if (!this.othersActive) return;
        this.othersActive = false;
        for (var i = 0; i < this.others.length; i++) {
            this.session.removeMarker(this.others[i].markerId);
        }
    };

    /**
     * PlaceHolder@onUpdate(e)
     * 
     * Emitted when the place holder updates.
     *
     **/
    this.onUpdate = function(delta) {
        if (this.$updating)
            return this.updateAnchors(delta);
            
        var range = delta;
        if (range.start.row !== range.end.row) return;
        if (range.start.row !== this.pos.row) return;
        this.$updating = true;
        var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
        var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
        var distanceFromStart = range.start.column - this.pos.column;
        
        this.updateAnchors(delta);
        
        if (inMainRange)
            this.length += lengthDiff;

        if (inMainRange && !this.session.$fromUndo) {
            if (delta.action === 'insert') {
                for (var i = this.others.length - 1; i >= 0; i--) {
                    var otherPos = this.others[i];
                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                    this.doc.insertMergedLines(newPos, delta.lines);
                }
            } else if (delta.action === 'remove') {
                for (var i = this.others.length - 1; i >= 0; i--) {
                    var otherPos = this.others[i];
                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                }
            }
        }
        
        this.$updating = false;
        this.updateMarkers();
    };
    
    this.updateAnchors = function(delta) {
        this.pos.onChange(delta);
        for (var i = this.others.length; i--;)
            this.others[i].onChange(delta);
        this.updateMarkers();
    };
    
    this.updateMarkers = function() {
        if (this.$updating)
            return;
        var _self = this;
        var session = this.session;
        var updateMarker = function(pos, className) {
            session.removeMarker(pos.markerId);
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column+_self.length), className, null, false);
        };
        updateMarker(this.pos, this.mainClass);
        for (var i = this.others.length; i--;)
            updateMarker(this.others[i], this.othersClass);
    };
    
    /**
     * PlaceHolder@onCursorChange(e)
     * 
     * Emitted when the cursor changes.
     *
     **/

    this.onCursorChange = function(event) {
        if (this.$updating || !this.session) return;
        var pos = this.session.selection.getCursor();
        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
            this.showOtherMarkers();
            this._emit("cursorEnter", event);
        } else {
            this.hideOtherMarkers();
            this._emit("cursorLeave", event);
        }
    };
    
    /**
     * PlaceHolder.detach()
     * 
     * TODO
     *
     **/    
    this.detach = function() {
        this.session.removeMarker(this.pos && this.pos.markerId);
        this.hideOtherMarkers();
        this.doc.removeEventListener("change", this.$onUpdate);
        this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
        this.session.setUndoSelect(true);
        this.session = null;
    };
    
    /**
     * PlaceHolder.cancel()
     * 
     * TODO
     *
     **/
    this.cancel = function() {
        if (this.$undoStackDepth === -1)
            return;
        var undoManager = this.session.getUndoManager();
        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
        for (var i = 0; i < undosRequired; i++) {
            undoManager.undo(true);
        }
        if (this.selectionBefore)
            this.session.selection.fromJSON(this.selectionBefore);
    };
}).call(PlaceHolder.prototype);


exports.PlaceHolder = PlaceHolder;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mouse/multi_select_handler',['require','exports','module','../lib/event','../lib/useragent'],function(require, exports, module) {

var event = require("../lib/event");
var useragent = require("../lib/useragent");

// mouse
function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}

function onMouseDown(e) {
    var ev = e.domEvent;
    var alt = ev.altKey;
    var shift = ev.shiftKey;
    var ctrl = ev.ctrlKey;
    var accel = e.getAccelKey();
    var button = e.getButton();
    
    if (ctrl && useragent.isMac)
        button = ev.button;

    if (e.editor.inMultiSelectMode && button == 2) {
        e.editor.textInput.onContextMenu(e.domEvent);
        return;
    }
    
    if (!ctrl && !alt && !accel) {
        if (button === 0 && e.editor.inMultiSelectMode)
            e.editor.exitMultiSelectMode();
        return;
    }
    
    if (button !== 0)
        return;

    var editor = e.editor;
    var selection = editor.selection;
    var isMultiSelect = editor.inMultiSelectMode;
    var pos = e.getDocumentPosition();
    var cursor = selection.getCursor();
    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));

    var mouseX = e.x, mouseY = e.y;
    var onMouseSelection = function(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
    };
    
    var session = editor.session;
    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
    var screenCursor = screenAnchor;
    
    var selectionMode;
    if (editor.$mouseHandler.$enableJumpToDef) {
        if (ctrl && alt || accel && alt)
            selectionMode = shift ? "block" : "add";
        else if (alt && editor.$blockSelectEnabled)
            selectionMode = "block";
    } else {
        if (accel && !alt) {
            selectionMode = "add";
            if (!isMultiSelect && shift)
                return;
        } else if (alt && editor.$blockSelectEnabled) {
            selectionMode = "block";
        }
    }
    
    if (selectionMode && useragent.isMac && ev.ctrlKey) {
        editor.$mouseHandler.cancelContextMenu();
    }

    if (selectionMode == "add") {
        if (!isMultiSelect && inSelection)
            return; // dragging

        if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
        }

        var oldRange = selection.rangeList.rangeAtPoint(pos);
        
        
        editor.$blockScrolling++;
        editor.inVirtualSelectionMode = true;
        
        if (shift) {
            oldRange = null;
            range = selection.ranges[0] || range;
            editor.removeSelectionMarker(range);
        }
        editor.once("mouseup", function() {
            var tmpSel = selection.toOrientedRange();

            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
                selection.substractPoint(tmpSel.cursor);
            else {
                if (shift) {
                    selection.substractPoint(range.cursor);
                } else if (range) {
                    editor.removeSelectionMarker(range);
                    selection.addRange(range);
                }
                selection.addRange(tmpSel);
            }
            editor.$blockScrolling--;
            editor.inVirtualSelectionMode = false;
        });

    } else if (selectionMode == "block") {
        e.stop();
        editor.inVirtualSelectionMode = true;        
        var initialRange;
        var rectSel = [];
        var blockSelect = function() {
            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);

            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
                return;
            screenCursor = newCursor;
            
            editor.$blockScrolling++;
            editor.selection.moveToPosition(cursor);
            editor.renderer.scrollCursorIntoView();

            editor.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor.addSelectionMarker, editor);
            editor.updateSelectionMarkers();
            editor.$blockScrolling--;
        };
        editor.$blockScrolling++;
        if (isMultiSelect && !accel) {
            selection.toSingleRange();
        } else if (!isMultiSelect && accel) {
            initialRange = selection.toOrientedRange();
            editor.addSelectionMarker(initialRange);
        }
        
        if (shift)
            screenAnchor = session.documentToScreenPosition(selection.lead);            
        else
            selection.moveToPosition(pos);
        editor.$blockScrolling--;
        
        screenCursor = {row: -1, column: -1};

        var onMouseSelectionEnd = function(e) {
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            if (!rectSel.length)
                rectSel = [selection.toOrientedRange()];
            editor.$blockScrolling++;
            if (initialRange) {
                editor.removeSelectionMarker(initialRange);
                selection.toSingleRange(initialRange);
            }
            for (var i = 0; i < rectSel.length; i++)
                selection.addRange(rectSel[i]);
            editor.inVirtualSelectionMode = false;
            editor.$mouseHandler.$clickSelection = null;
            editor.$blockScrolling--;
        };

        var onSelectionInterval = blockSelect;

        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
        var timerId = setInterval(function() {onSelectionInterval();}, 20);

        return e.preventDefault();
    }
}


exports.onMouseDown = onMouseDown;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/commands/multi_select_commands',['require','exports','module','../keyboard/hash_handler'],function(require, exports, module) {

// commands to enter multiselect mode
exports.defaultCommands = [{
    name: "addCursorAbove",
    exec: function(editor) { editor.selectMoreLines(-1); },
    bindKey: {win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorBelow",
    exec: function(editor) { editor.selectMoreLines(1); },
    bindKey: {win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorAboveSkipCurrent",
    exec: function(editor) { editor.selectMoreLines(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorBelowSkipCurrent",
    exec: function(editor) { editor.selectMoreLines(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectMoreBefore",
    exec: function(editor) { editor.selectMore(-1); },
    bindKey: {win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectMoreAfter",
    exec: function(editor) { editor.selectMore(1); },
    bindKey: {win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectNextBefore",
    exec: function(editor) { editor.selectMore(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectNextAfter",
    exec: function(editor) { editor.selectMore(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "splitIntoLines",
    exec: function(editor) { editor.multiSelect.splitIntoLines(); },
    bindKey: {win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L"},
    readOnly: true
}, {
    name: "alignCursors",
    exec: function(editor) { editor.alignCursors(); },
    bindKey: {win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A"},
    scrollIntoView: "cursor"
}, {
    name: "findAll",
    exec: function(editor) { editor.findAll(); },
    bindKey: {win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G"},
    scrollIntoView: "cursor",
    readOnly: true
}];

// commands active only in multiselect mode
exports.multiSelectCommands = [{
    name: "singleSelection",
    bindKey: "esc",
    exec: function(editor) { editor.exitMultiSelectMode(); },
    scrollIntoView: "cursor",
    readOnly: true,
    isAvailable: function(editor) {return editor && editor.inMultiSelectMode}
}];

var HashHandler = require("../keyboard/hash_handler").HashHandler;
exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/multi_select',['require','exports','module','./range_list','./range','./selection','./mouse/multi_select_handler','./lib/event','./lib/lang','./commands/multi_select_commands','./search','./edit_session','./editor','./config'],function(require, exports, module) {

var RangeList = require("./range_list").RangeList;
var Range = require("./range").Range;
var Selection = require("./selection").Selection;
var onMouseDown = require("./mouse/multi_select_handler").onMouseDown;
var event = require("./lib/event");
var lang = require("./lib/lang");
var commands = require("./commands/multi_select_commands");
exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);

// Todo: session.find or editor.findVolatile that returns range
var Search = require("./search").Search;
var search = new Search();

function find(session, needle, dir) {
    search.$options.wrap = true;
    search.$options.needle = needle;
    search.$options.backwards = dir == -1;
    return search.find(session);
}

// extend EditSession
var EditSession = require("./edit_session").EditSession;
(function() {
    this.getSelectionMarkers = function() {
        return this.$selectionMarkers;
    };
}).call(EditSession.prototype);

// extend Selection
(function() {
    // list of ranges in reverse addition order
    this.ranges = null;

    // automatically sorted list of ranges
    this.rangeList = null;

    /** 
     * Adds a range to a selection by entering multiselect mode, if necessary.
     * @param {Range} range The new range to add
     * @param {Boolean} $blockChangeEvents Whether or not to block changing events
     * @method Selection.addRange
     **/
    this.addRange = function(range, $blockChangeEvents) {
        if (!range)
            return;

        if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
                this.rangeList.removeAll();
                return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
        }

        if (!range.cursor)
            range.cursor = range.end;

        var removed = this.rangeList.add(range);

        this.$onAddRange(range);

        if (removed.length)
            this.$onRemoveRange(removed);

        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._signal("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
        }

        return $blockChangeEvents || this.fromOrientedRange(range);
    };

    /**
     * @method Selection.toSingleRange
     **/

    this.toSingleRange = function(range) {
        range = range || this.ranges[0];
        var removed = this.rangeList.removeAll();
        if (removed.length)
            this.$onRemoveRange(removed);

        range && this.fromOrientedRange(range);
    };

    /**
     * Removes a Range containing pos (if it exists).
     * @param {Range} pos The position to remove, as a `{row, column}` object
     * @method Selection.substractPoint
     **/
    this.substractPoint = function(pos) {
        var removed = this.rangeList.substractPoint(pos);
        if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
        }
    };

    /**
     * Merges overlapping ranges ensuring consistency after changes
     * @method Selection.mergeOverlappingRanges
     **/
    this.mergeOverlappingRanges = function() {
        var removed = this.rangeList.merge();
        if (removed.length)
            this.$onRemoveRange(removed);
        else if(this.ranges[0])
            this.fromOrientedRange(this.ranges[0]);
    };

    this.$onAddRange = function(range) {
        this.rangeCount = this.rangeList.ranges.length;
        this.ranges.unshift(range);
        this._signal("addRange", {range: range});
    };

    this.$onRemoveRange = function(removed) {
        this.rangeCount = this.rangeList.ranges.length;
        if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
        }

        for (var i = removed.length; i--; ) {
            var index = this.ranges.indexOf(removed[i]);
            this.ranges.splice(index, 1);
        }

        this._signal("removeRange", {ranges: removed});

        if (this.rangeCount === 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal("singleSelect");
            this.session.$undoSelect = true;
            this.rangeList.detach(this.session);
        }

        lastRange = lastRange || this.ranges[0];
        if (lastRange && !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
    };

    // adds multicursor support to selection
    this.$initRangeList = function() {
        if (this.rangeList)
            return;

        this.rangeList = new RangeList();
        this.ranges = [];
        this.rangeCount = 0;
    };

    /**
     * Returns a concatenation of all the ranges.
     * @returns {Array}
     * @method Selection.getAllRanges
     **/
    this.getAllRanges = function() {
        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
    };

    /**
     * Splits all the ranges into lines.
     * @method Selection.splitIntoLines
     **/

    this.splitIntoLines = function () {
        if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);

            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        } else {
            var range = this.getRange();
            var isBackwards = this.isBackwards();
            var startRow = range.start.row;
            var endRow = range.end.row;
            if (startRow == endRow) {
                if (isBackwards)
                    var start = range.end, end = range.start;
                else
                    var start = range.start, end = range.end;
                
                this.addRange(Range.fromPoints(end, end));
                this.addRange(Range.fromPoints(start, start));
                return;
            }

            var rectSel = [];
            var r = this.getLineRange(startRow, true);
            r.start.column = range.start.column;
            rectSel.push(r);

            for (var i = startRow + 1; i < endRow; i++)
                rectSel.push(this.getLineRange(i, true));

            r = this.getLineRange(endRow, true);
            r.end.column = range.end.column;
            rectSel.push(r);

            rectSel.forEach(this.addRange, this);
        }
    };

    /**
     * @method Selection.toggleBlockSelection
     **/
    this.toggleBlockSelection = function () {
        if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);

            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        } else {
            var cursor = this.session.documentToScreenPosition(this.selectionLead);
            var anchor = this.session.documentToScreenPosition(this.selectionAnchor);

            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            rectSel.forEach(this.addRange, this);
        }
    };

    /**
     * 
     * Gets list of ranges composing rectangular block on the screen
     * 
     * @param {Cursor} screenCursor The cursor to use
     * @param {Anchor} screenAnchor The anchor to use
     * @param {Boolean} includeEmptyLines If true, this includes ranges inside the block which are empty due to clipping
     * @returns {Range}
     * @method Selection.rectangularRangeBlock
     **/
    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
        var rectSel = [];

        var xBackwards = screenCursor.column < screenAnchor.column;
        if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
        } else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
        }

        var yBackwards = screenCursor.row < screenAnchor.row;
        if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
        } else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
        }

        if (startColumn < 0)
            startColumn = 0;
        if (startRow < 0)
            startRow = 0;

        if (startRow == endRow)
            includeEmptyLines = true;

        for (var row = startRow; row <= endRow; row++) {
            var range = Range.fromPoints(
                this.session.screenToDocumentPosition(row, startColumn),
                this.session.screenToDocumentPosition(row, endColumn)
            );
            if (range.isEmpty()) {
                if (docEnd && isSamePoint(range.end, docEnd))
                    break;
                var docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
        }

        if (yBackwards)
            rectSel.reverse();

        if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0)
                end--;
            if (end > 0) {
                var start = 0;
                while (rectSel[start].isEmpty())
                    start++;
            }
            for (var i = end; i >= start; i--) {
                if (rectSel[i].isEmpty())
                    rectSel.splice(i, 1);
            }
        }

        return rectSel;
    };
}).call(Selection.prototype);

// extend Editor
var Editor = require("./editor").Editor;
(function() {

    /** 
     * 
     * Updates the cursor and marker layers.
     * @method Editor.updateSelectionMarkers
     *
     **/
    this.updateSelectionMarkers = function() {
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    /** 
     * Adds the selection and cursor.
     * @param {Range} orientedRange A range containing a cursor
     * @returns {Range}
     * @method Editor.addSelectionMarker
     **/
    this.addSelectionMarker = function(orientedRange) {
        if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;

        var style = this.getSelectionStyle();
        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

        this.session.$selectionMarkers.push(orientedRange);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        return orientedRange;
    };

    /** 
     * Removes the selection marker.
     * @param {Range} range The selection range added with [[Editor.addSelectionMarker `addSelectionMarker()`]].
     * @method Editor.removeSelectionMarker
     **/
    this.removeSelectionMarker = function(range) {
        if (!range.marker)
            return;
        this.session.removeMarker(range.marker);
        var index = this.session.$selectionMarkers.indexOf(range);
        if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
    };

    this.removeSelectionMarkers = function(ranges) {
        var markerList = this.session.$selectionMarkers;
        for (var i = ranges.length; i--; ) {
            var range = ranges[i];
            if (!range.marker)
                continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
                markerList.splice(index, 1);
        }
        this.session.selectionMarkerCount = markerList.length;
    };

    this.$onAddRange = function(e) {
        this.addSelectionMarker(e.range);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onRemoveRange = function(e) {
        this.removeSelectionMarkers(e.ranges);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onMultiSelect = function(e) {
        if (this.inMultiSelectMode)
            return;
        this.inMultiSelectMode = true;

        this.setStyle("ace_multiselect");
        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onSingleSelect = function(e) {
        if (this.session.multiSelect.inVirtualMode)
            return;
        this.inMultiSelectMode = false;

        this.unsetStyle("ace_multiselect");
        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
        this._emit("changeSelection");
    };

    this.$onMultiSelectExec = function(e) {
        var command = e.command;
        var editor = e.editor;
        if (!editor.multiSelect)
            return;
        if (!command.multiSelectAction) {
            var result = command.exec(editor, e.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
        } else if (command.multiSelectAction == "forEach") {
            result = editor.forEachSelection(command, e.args);
        } else if (command.multiSelectAction == "forEachLine") {
            result = editor.forEachSelection(command, e.args, true);
        } else if (command.multiSelectAction == "single") {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e.args || {});
        } else {
            result = command.multiSelectAction(editor, e.args || {});
        }
        return result;
    };

    /** 
     * Executes a command for each selection range.
     * @param {Object} cmd The command to execute
     * @param {String} args Any arguments for the command
     * @method Editor.forEachSelection
     **/ 
    this.forEachSelection = function(cmd, args, options) {
        if (this.inVirtualSelectionMode)
            return;
        var keepOrder = options && options.keepOrder;
        var $byLines = options == true || options && options.$byLines
        var session = this.session;
        var selection = this.selection;
        var rangeList = selection.rangeList;
        var ranges = (keepOrder ? selection : rangeList).ranges;
        var result;
        
        if (!ranges.length)
            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
        
        var reg = selection._eventRegistry;
        selection._eventRegistry = {};

        var tmpSel = new Selection(session);
        this.inVirtualSelectionMode = true;
        for (var i = ranges.length; i--;) {
            if ($byLines) {
                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                    i--;
            }
            tmpSel.fromOrientedRange(ranges[i]);
            tmpSel.index = i;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result && cmdResult !== undefined)
                result = cmdResult;
            tmpSel.toOrientedRange(ranges[i]);
        }
        tmpSel.detach();

        this.selection = session.selection = selection;
        this.inVirtualSelectionMode = false;
        selection._eventRegistry = reg;
        selection.mergeOverlappingRanges();
        
        var anim = this.renderer.$scrollAnimation;
        this.onCursorChange();
        this.onSelectionChange();
        if (anim && anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);
        
        return result;
    };

    /** 
    * Removes all the selections except the last added one.
    * @method Editor.exitMultiSelectMode
    **/
    this.exitMultiSelectMode = function() {
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return;
        this.multiSelect.toSingleRange();
    };

    this.getSelectedText = function() {
        var text = "";
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i = 0; i < ranges.length; i++) {
                buf.push(this.session.getTextRange(ranges[i]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length)
                text = "";
        } else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
        }
        return text;
    };
    
    this.$checkMultiselectChange = function(e, anchor) {
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
                return;
            var pos = anchor == this.multiSelect.anchor
                ? range.cursor == range.start ? range.end : range.start
                : range.cursor;
            if (pos.row != anchor.row 
                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
        }
    };

    /**
     * Finds and selects all the occurences of `needle`.
     * @param {String} The text to find
     * @param {Object} The search options
     * @param {Boolean} keeps
     *
     * @returns {Number} The cumulative count of all found matches 
     * @method Editor.findAll
     **/
    this.findAll = function(needle, options, additive) {
        options = options || {};
        options.needle = needle || options.needle;
        if (options.needle == undefined) {
            var range = this.selection.isEmpty()
                ? this.selection.getWordRange()
                : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
        }    
        this.$search.set(options);
        
        var ranges = this.$search.findAll(this.session);
        if (!ranges.length)
            return 0;

        this.$blockScrolling += 1;
        var selection = this.multiSelect;

        if (!additive)
            selection.toSingleRange(ranges[0]);

        for (var i = ranges.length; i--; )
            selection.addRange(ranges[i], true);

        // keep old selection as primary if possible
        if (range && selection.rangeList.rangeAtPoint(range.start))
            selection.addRange(range, true);
        
        this.$blockScrolling -= 1;

        return ranges.length;
    };

    /**
     * Adds a cursor above or below the active cursor.
     * 
     * @param {Number} dir The direction of lines to select: -1 for up, 1 for down
     * @param {Boolean} skip If `true`, removes the active selection range
     *
     * @method Editor.selectMoreLines 
     */
    this.selectMoreLines = function(dir, skip) {
        var range = this.selection.toOrientedRange();
        var isBackwards = range.cursor == range.end;

        var screenLead = this.session.documentToScreenPosition(range.cursor);
        if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;

        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

        if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
        } else {
            var anchor = lead;
        }

        if (isBackwards) {
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
        } else {
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
        }

        newRange.desiredColumn = screenLead.column;
        if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
        } else {
            if (skip)
                var toRemove = range.cursor;
        }

        this.selection.addRange(newRange);
        if (toRemove)
            this.selection.substractPoint(toRemove);
    };

    /** 
     * Transposes the selected ranges.
     * @param {Number} dir The direction to rotate selections
     * @method Editor.transposeSelections
     **/
    this.transposeSelections = function(dir) {
        var session = this.session;
        var sel = session.multiSelect;
        var all = sel.ranges;

        for (var i = all.length; i--; ) {
            var range = all[i];
            if (range.isEmpty()) {
                var tmp = session.getWordRange(range.start.row, range.start.column);
                range.start.row = tmp.start.row;
                range.start.column = tmp.start.column;
                range.end.row = tmp.end.row;
                range.end.column = tmp.end.column;
            }
        }
        sel.mergeOverlappingRanges();

        var words = [];
        for (var i = all.length; i--; ) {
            var range = all[i];
            words.unshift(session.getTextRange(range));
        }

        if (dir < 0)
            words.unshift(words.pop());
        else
            words.push(words.shift());

        for (var i = all.length; i--; ) {
            var range = all[i];
            var tmp = range.clone();
            session.replace(range, words[i]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
        }
    };

    /** 
     * Finds the next occurence of text in an active selection and adds it to the selections.
     * @param {Number} dir The direction of lines to select: -1 for up, 1 for down
     * @param {Boolean} skip If `true`, removes the active selection range
     * @method Editor.selectMore
     **/
    this.selectMore = function(dir, skip, stopAtFirst) {
        var session = this.session;
        var sel = session.multiSelect;

        var range = sel.toOrientedRange();
        if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst)
                return;
        }
        var needle = session.getTextRange(range);

        var newRange = find(session, needle, dir);
        if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.$blockScrolling += 1;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.$blockScrolling -= 1;
            this.renderer.scrollCursorIntoView(null, 0.5);
        }
        if (skip)
            this.multiSelect.substractPoint(range.cursor);
    };

    /** 
     * Aligns the cursors or selected text.
     * @method Editor.alignCursors
     **/
    this.alignCursors = function() {
        var session = this.session;
        var sel = session.multiSelect;
        var ranges = sel.ranges;
        // filter out ranges on same row
        var row = -1;
        var sameRowRanges = ranges.filter(function(r) {
            if (r.cursor.row == row)
                return true;
            row = r.cursor.row;
        });
        
        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr = range.start.row, lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
                var max = this.session.getLength();
                var line;
                do {
                    line = this.session.getLine(lr);
                } while (/[=:]/.test(line) && ++lr < max);
                do {
                    line = this.session.getLine(fr);
                } while (/[=:]/.test(line) && --fr > 0);
                
                if (fr < 0) fr = 0;
                if (lr >= max) lr = max - 1;
            }
            var lines = this.session.removeFullLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.insert({row: fr, column: 0}, lines.join("\n") + "\n");
            if (!guessRange) {
                range.start.column = 0;
                range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
        } else {
            sameRowRanges.forEach(function(r) {
                sel.substractPoint(r.cursor);
            });

            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function(r) {
                var p = r.cursor;
                var line = session.getLine(p.row);
                var spaceOffset = line.substr(p.column).search(/\S/g);
                if (spaceOffset == -1)
                    spaceOffset = 0;

                if (p.column > maxCol)
                    maxCol = p.column;
                if (spaceOffset < minSpace)
                    minSpace = spaceOffset;
                return spaceOffset;
            });
            ranges.forEach(function(r, i) {
                var p = r.cursor;
                var l = maxCol - p.column;
                var d = spaceOffsets[i] - minSpace;
                if (l > d)
                    session.insert(p, lang.stringRepeat(" ", l - d));
                else
                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

                r.start.column = r.end.column = maxCol;
                r.start.row = r.end.row = p.row;
                r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        }
    };

    this.$reAlignText = function(lines, forceLeft) {
        var isLeftAligned = true, isRightAligned = true;
        var startW, textW, endW;

        return lines.map(function(line) {
            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m)
                return [line];

            if (startW == null) {
                startW = m[1].length;
                textW = m[2].length;
                endW = m[3].length;
                return m;
            }

            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
                isRightAligned = false;
            if (startW != m[1].length)
                isLeftAligned = false;

            if (startW > m[1].length)
                startW = m[1].length;
            if (textW < m[2].length)
                textW = m[2].length;
            if (endW > m[3].length)
                endW = m[3].length;

            return m;
        }).map(forceLeft ? alignLeft :
            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

        function spaces(n) {
            return lang.stringRepeat(" ", n);
        }

        function alignLeft(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(textW - m[2].length + endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function alignRight(m) {
            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
                + spaces(endW, " ")
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function unAlign(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
    };
}).call(Editor.prototype);


function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}

// patch
// adds multicursor support to a session
exports.onSessionChange = function(e) {
    var session = e.session;
    if (session && !session.multiSelect) {
        session.$selectionMarkers = [];
        session.selection.$initRangeList();
        session.multiSelect = session.selection;
    }
    this.multiSelect = session && session.multiSelect;

    var oldSession = e.oldSession;
    if (oldSession) {
        oldSession.multiSelect.off("addRange", this.$onAddRange);
        oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
        oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
        oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
        oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
        oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
    }

    if (session) {
        session.multiSelect.on("addRange", this.$onAddRange);
        session.multiSelect.on("removeRange", this.$onRemoveRange);
        session.multiSelect.on("multiSelect", this.$onMultiSelect);
        session.multiSelect.on("singleSelect", this.$onSingleSelect);
        session.multiSelect.lead.on("change", this.$checkMultiselectChange);
        session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
    }

    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
        if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
        else
            this.$onSingleSelect();
    }
};

// MultiSelect(editor)
// adds multiple selection support to the editor
// (note: should be called only once for each editor instance)
function MultiSelect(editor) {
    if (editor.$multiselectOnSessionChange)
        return;
    editor.$onAddRange = editor.$onAddRange.bind(editor);
    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);

    editor.$multiselectOnSessionChange(editor);
    editor.on("changeSession", editor.$multiselectOnSessionChange);

    editor.on("mousedown", onMouseDown);
    editor.commands.addCommands(commands.defaultCommands);

    addAltCursorListeners(editor);
}

function addAltCursorListeners(editor){
    var el = editor.textInput.getElement();
    var altCursor = false;
    event.addListener(el, "keydown", function(e) {
        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
        if (editor.$blockSelectEnabled && altDown) {
            if (!altCursor) {
                editor.renderer.setMouseCursor("crosshair");
                altCursor = true;
            }
        } else if (altCursor) {
            reset();
        }
    });

    event.addListener(el, "keyup", reset);
    event.addListener(el, "blur", reset);
    function reset(e) {
        if (altCursor) {
            editor.renderer.setMouseCursor("");
            altCursor = false;
            // TODO disable menu poping up
            // e && e.preventDefault()
        }
    }
}

exports.MultiSelect = MultiSelect;


require("./config").defineOptions(Editor.prototype, "editor", {
    enableMultiselect: {
        set: function(val) {
            MultiSelect(this);
            if (val) {
                this.on("changeSession", this.$multiselectOnSessionChange);
                this.on("mousedown", onMouseDown);
            } else {
                this.off("changeSession", this.$multiselectOnSessionChange);
                this.off("mousedown", onMouseDown);
            }
        },
        value: true
    },
    enableBlockSelect: {
        set: function(val) {
            this.$blockSelectEnabled = val;
        },
        value: true
    }
});



});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/folding/fold_mode',['require','exports','module','../../range'],function(require, exports, module) {
"use strict";

var Range = require("../../range").Range;

var FoldMode = exports.FoldMode = function() {};

(function() {

    this.foldingStartMarker = null;
    this.foldingStopMarker = null;

    // must return "" if there's no fold, to enable caching
    this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.foldingStartMarker.test(line))
            return "start";
        if (foldStyle == "markbeginend"
                && this.foldingStopMarker
                && this.foldingStopMarker.test(line))
            return "end";
        return "";
    };

    this.getFoldWidgetRange = function(session, foldStyle, row) {
        return null;
    };

    this.indentationBlock = function(session, row, column) {
        var re = /\S/;
        var line = session.getLine(row);
        var startLevel = line.search(re);
        if (startLevel == -1)
            return;

        var startColumn = column || line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;

        while (++row < maxRow) {
            var level = session.getLine(row).search(re);

            if (level == -1)
                continue;

            if (level <= startLevel)
                break;

            endRow = row;
        }

        if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
        }
    };

    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
        var start = {row: row, column: column + 1};
        var end = session.$findClosingBracket(bracket, start, typeRe);
        if (!end)
            return;

        var fw = session.foldWidgets[end.row];
        if (fw == null)
            fw = session.getFoldWidget(end.row);

        if (fw == "start" && end.row > start.row) {
            end.row --;
            end.column = session.getLine(end.row).length;
        }
        return Range.fromPoints(start, end);
    };

    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
        var end = {row: row, column: column};
        var start = session.$findOpeningBracket(bracket, end);

        if (!start)
            return;

        start.column++;
        end.column--;

        return  Range.fromPoints(start, end);
    };
}).call(FoldMode.prototype);

});


define('bower_components/ace/lib/ace/requirejs/text!bower_components/ace/lib/ace/theme/textmate.css',[],function () { return '.ace-tm .ace_gutter {\n  background: #f0f0f0;\n  color: #333;\n}\n\n.ace-tm .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-tm .ace_fold {\n    background-color: #6B72E6;\n}\n\n.ace-tm {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-tm .ace_cursor {\n  color: black;\n}\n        \n.ace-tm .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-tm .ace_storage,\n.ace-tm .ace_keyword {\n  color: blue;\n}\n\n.ace-tm .ace_constant {\n  color: rgb(197, 6, 11);\n}\n\n.ace-tm .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-tm .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-tm .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_invalid {\n  background-color: rgba(255, 0, 0, 0.1);\n  color: red;\n}\n\n.ace-tm .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-tm .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_support.ace_type,\n.ace-tm .ace_support.ace_class {\n  color: rgb(109, 121, 222);\n}\n\n.ace-tm .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-tm .ace_string {\n  color: rgb(3, 106, 7);\n}\n\n.ace-tm .ace_comment {\n  color: rgb(76, 136, 107);\n}\n\n.ace-tm .ace_comment.ace_doc {\n  color: rgb(0, 102, 255);\n}\n\n.ace-tm .ace_comment.ace_doc.ace_tag {\n  color: rgb(128, 159, 191);\n}\n\n.ace-tm .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-tm .ace_variable {\n  color: rgb(49, 132, 149);\n}\n\n.ace-tm .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-tm .ace_entity.ace_name.ace_function {\n  color: #0000A2;\n}\n\n\n.ace-tm .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-tm .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-tm .ace_meta.ace_tag {\n  color:rgb(0, 22, 142);\n}\n\n.ace-tm .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-tm .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n.ace-tm.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px white;\n}\n.ace-tm .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-tm .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-tm .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-tm .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-tm .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-tm .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-tm .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n';});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/theme/textmate',['require','exports','module','../requirejs/text!./textmate.css','../lib/dom'],function(require, exports, module) {
"use strict";

exports.isDark = false;
exports.cssClass = "ace-tm";
exports.cssText = require("../requirejs/text!./textmate.css");

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass);
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/line_widgets',['require','exports','module','./lib/oop','./lib/dom','./range'],function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var dom = require("./lib/dom");
var Range = require("./range").Range;


function LineWidgets(session) {
    this.session = session;
    this.session.widgetManager = this;
    this.session.getRowLength = this.getRowLength;
    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
    this.updateOnChange = this.updateOnChange.bind(this);
    this.renderWidgets = this.renderWidgets.bind(this);
    this.measureWidgets = this.measureWidgets.bind(this);
    this.session._changedWidgets = [];
    this.$onChangeEditor = this.$onChangeEditor.bind(this);
    
    this.session.on("change", this.updateOnChange);
    this.session.on("changeFold", this.updateOnFold);
    this.session.on("changeEditor", this.$onChangeEditor);
}

(function() {
    this.getRowLength = function(row) {
        var h;
        if (this.lineWidgets)
            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        else 
            h = 0;
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
        } else {
            return this.$wrapData[row].length + 1 + h;
        }
    };

    this.$getWidgetScreenLength = function() {
        var screenRows = 0;
        this.lineWidgets.forEach(function(w){
            if (w && w.rowCount && !w.hidden)
                screenRows += w.rowCount;
        });
        return screenRows;
    };    
    
    this.$onChangeEditor = function(e) {
        this.attach(e.editor);
    };
    
    this.attach = function(editor) {
        if (editor  && editor.widgetManager && editor.widgetManager != this)
            editor.widgetManager.detach();

        if (this.editor == editor)
            return;

        this.detach();
        this.editor = editor;
        
        if (editor) {
            editor.widgetManager = this;
            editor.renderer.on("beforeRender", this.measureWidgets);
            editor.renderer.on("afterRender", this.renderWidgets);
        }
    };
    this.detach = function(e) {
        var editor = this.editor;
        if (!editor)
            return;
        
        this.editor = null;
        editor.widgetManager = null;
        
        editor.renderer.off("beforeRender", this.measureWidgets);
        editor.renderer.off("afterRender", this.renderWidgets);
        var lineWidgets = this.session.lineWidgets;
        lineWidgets && lineWidgets.forEach(function(w) {
            if (w && w.el && w.el.parentNode) {
                w._inDocument = false;
                w.el.parentNode.removeChild(w.el);
            }
        });
    };

    this.updateOnFold = function(e, session) {
        var lineWidgets = session.lineWidgets;
        if (!lineWidgets || !e.action)
            return;
        var fold = e.data;
        var start = fold.start.row;
        var end = fold.end.row;
        var hide = e.action == "add";
        for (var i = start + 1; i < end; i++) {
            if (lineWidgets[i])
                lineWidgets[i].hidden = hide;
        }
        if (lineWidgets[end]) {
            if (hide) {
                if (!lineWidgets[start])
                    lineWidgets[start] = lineWidgets[end];
                else
                    lineWidgets[end].hidden = hide;
            } else {
                if (lineWidgets[start] == lineWidgets[end])
                    lineWidgets[start] = undefined;
                lineWidgets[end].hidden = hide;
            }
        }
    };
    
    this.updateOnChange = function(delta) {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets) return;
        
        var startRow = delta.start.row;
        var len = delta.end.row - startRow;

        if (len === 0) {
            // return
        } else if (delta.action == 'remove') {
            var removed = lineWidgets.splice(startRow + 1, len);
            removed.forEach(function(w) {
                w && this.removeLineWidget(w);
            }, this);
            this.$updateRows();
        } else {
            var args = new Array(len);
            args.unshift(startRow, 0);
            lineWidgets.splice.apply(lineWidgets, args);
            this.$updateRows();
        }
    };
    
    this.$updateRows = function() {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets) return;
        var noWidgets = true;
        lineWidgets.forEach(function(w, i) {
            if (w) {
                noWidgets = false;
                w.row = i;
                while (w.$oldWidget) {
                    w.$oldWidget.row = i;
                    w = w.$oldWidget;
                }
            }
        });
        if (noWidgets)
            this.session.lineWidgets = null;
    };

    this.addLineWidget = function(w) {
        if (!this.session.lineWidgets)
            this.session.lineWidgets = new Array(this.session.getLength());
        
        var old = this.session.lineWidgets[w.row];
        if (old) {
            w.$oldWidget = old;
            if (old.el && old.el.parentNode) {
                old.el.parentNode.removeChild(old.el);
                old._inDocument = false;
            }
        }
            
        this.session.lineWidgets[w.row] = w;
        
        w.session = this.session;
        
        var renderer = this.editor.renderer;
        if (w.html && !w.el) {
            w.el = dom.createElement("div");
            w.el.innerHTML = w.html;
        }
        if (w.el) {
            dom.addCssClass(w.el, "ace_lineWidgetContainer");
            w.el.style.position = "absolute";
            w.el.style.zIndex = 5;
            renderer.container.appendChild(w.el);
            w._inDocument = true;
        }
        
        if (!w.coverGutter) {
            w.el.style.zIndex = 3;
        }
        if (w.pixelHeight == null) {
            w.pixelHeight = w.el.offsetHeight;
        }
        if (w.rowCount == null) {
            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
        }
        
        var fold = this.session.getFoldAt(w.row, 0);
        w.$fold = fold;
        if (fold) {
            var lineWidgets = this.session.lineWidgets;
            if (w.row == fold.end.row && !lineWidgets[fold.start.row])
                lineWidgets[fold.start.row] = w;
            else
                w.hidden = true;
        }
            
        this.session._emit("changeFold", {data:{start:{row: w.row}}});
        
        this.$updateRows();
        this.renderWidgets(null, renderer);
        this.onWidgetChanged(w);
        return w;
    };
    
    this.removeLineWidget = function(w) {
        w._inDocument = false;
        w.session = null;
        if (w.el && w.el.parentNode)
            w.el.parentNode.removeChild(w.el);
        if (w.editor && w.editor.destroy) try {
            w.editor.destroy();
        } catch(e){}
        if (this.session.lineWidgets) {
            var w1 = this.session.lineWidgets[w.row]
            if (w1 == w) {
                this.session.lineWidgets[w.row] = w.$oldWidget;
                if (w.$oldWidget)
                    this.onWidgetChanged(w.$oldWidget);
            } else {
                while (w1) {
                    if (w1.$oldWidget == w) {
                        w1.$oldWidget = w.$oldWidget;
                        break;
                    }
                    w1 = w1.$oldWidget;
                }
            }
        }
        this.session._emit("changeFold", {data:{start:{row: w.row}}});
        this.$updateRows();
    };
    
    this.getWidgetsAtRow = function(row) {
        var lineWidgets = this.session.lineWidgets;
        var w = lineWidgets && lineWidgets[row];
        var list = [];
        while (w) {
            list.push(w);
            w = w.$oldWidget;
        }
        return list;
    };
    
    this.onWidgetChanged = function(w) {
        this.session._changedWidgets.push(w);
        this.editor && this.editor.renderer.updateFull();
    };
    
    this.measureWidgets = function(e, renderer) {
        var changedWidgets = this.session._changedWidgets;
        var config = renderer.layerConfig;
        
        if (!changedWidgets || !changedWidgets.length) return;
        var min = Infinity;
        for (var i = 0; i < changedWidgets.length; i++) {
            var w = changedWidgets[i];
            if (!w || !w.el) continue;
            if (w.session != this.session) continue;
            if (!w._inDocument) {
                if (this.session.lineWidgets[w.row] != w)
                    continue;
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            
            w.h = w.el.offsetHeight;
            
            if (!w.fixedWidth) {
                w.w = w.el.offsetWidth;
                w.screenWidth = Math.ceil(w.w / config.characterWidth);
            }
            
            var rowCount = w.h / config.lineHeight;
            if (w.coverLine) {
                rowCount -= this.session.getRowLineCount(w.row);
                if (rowCount < 0)
                    rowCount = 0;
            }
            if (w.rowCount != rowCount) {
                w.rowCount = rowCount;
                if (w.row < min)
                    min = w.row;
            }
        }
        if (min != Infinity) {
            this.session._emit("changeFold", {data:{start:{row: min}}});
            this.session.lineWidgetWidth = null;
        }
        this.session._changedWidgets = [];
    };
    
    this.renderWidgets = function(e, renderer) {
        var config = renderer.layerConfig;
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
            return;
        var first = Math.min(this.firstRow, config.firstRow);
        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
        
        while (first > 0 && !lineWidgets[first])
            first--;
        
        this.firstRow = config.firstRow;
        this.lastRow = config.lastRow;

        renderer.$cursorLayer.config = config;
        for (var i = first; i <= last; i++) {
            var w = lineWidgets[i];
            if (!w || !w.el) continue;
            if (w.hidden) {
                w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                continue;
            }
            if (!w._inDocument) {
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;
            if (!w.coverLine)
                top += config.lineHeight * this.session.getRowLineCount(w.row);
            w.el.style.top = top - config.offset + "px";
            
            var left = w.coverGutter ? 0 : renderer.gutterWidth;
            if (!w.fixedWidth)
                left -= renderer.scrollLeft;
            w.el.style.left = left + "px";
            
            if (w.fullWidth && w.screenWidth) {
                w.el.style.minWidth = config.width + 2 * config.padding + "px";
            }
            
            if (w.fixedWidth) {
                w.el.style.right = renderer.scrollBar.getWidth() + "px";
            } else {
                w.el.style.right = "";
            }
        }
    };
    
}).call(LineWidgets.prototype);


exports.LineWidgets = LineWidgets;

});


    


/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2012, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/ext/error_marker',['require','exports','module','../line_widgets','../lib/dom','../range'],function(require, exports, module) {
"use strict";
var LineWidgets = require("../line_widgets").LineWidgets;
var dom = require("../lib/dom");
var Range = require("../range").Range;

function binarySearch(array, needle, comparator) {
    var first = 0;
    var last = array.length - 1;

    while (first <= last) {
        var mid = (first + last) >> 1;
        var c = comparator(needle, array[mid]);
        if (c > 0)
            first = mid + 1;
        else if (c < 0)
            last = mid - 1;
        else
            return mid;
    }

    // Return the nearest lesser index, "-1" means "0, "-2" means "1", etc.
    return -(first + 1);
}

function findAnnotations(session, row, dir) {
    var annotations = session.getAnnotations().sort(Range.comparePoints);
    if (!annotations.length)
        return;
    
    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);
    if (i < 0)
        i = -i - 1;
    
    if (i >= annotations.length)
        i = dir > 0 ? 0 : annotations.length - 1;
    else if (i === 0 && dir < 0)
        i = annotations.length - 1;
    
    var annotation = annotations[i];
    if (!annotation || !dir)
        return;

    if (annotation.row === row) {
        do {
            annotation = annotations[i += dir];
        } while (annotation && annotation.row === row);
        if (!annotation)
            return annotations.slice();
    }
    
    
    var matched = [];
    row = annotation.row;
    do {
        matched[dir < 0 ? "unshift" : "push"](annotation);
        annotation = annotations[i += dir];
    } while (annotation && annotation.row == row);
    return matched.length && matched;
}

exports.showErrorMarker = function(editor, dir) {
    var session = editor.session;
    if (!session.widgetManager) {
        session.widgetManager = new LineWidgets(session);
        session.widgetManager.attach(editor);
    }
    
    var pos = editor.getCursorPosition();
    var row = pos.row;
    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {
        return w.type == "errorMarker";
    })[0];
    if (oldWidget) {
        oldWidget.destroy();
    } else {
        row -= dir;
    }
    var annotations = findAnnotations(session, row, dir);
    var gutterAnno;
    if (annotations) {
        var annotation = annotations[0];
        pos.column = (annotation.pos && typeof annotation.column != "number"
            ? annotation.pos.sc
            : annotation.column) || 0;
        pos.row = annotation.row;
        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
    } else if (oldWidget) {
        return;
    } else {
        gutterAnno = {
            text: ["Looks good!"],
            className: "ace_ok"
        };
    }
    editor.session.unfold(pos.row);
    editor.selection.moveToPosition(pos);
    
    var w = {
        row: pos.row, 
        fixedWidth: true,
        coverGutter: true,
        el: dom.createElement("div"),
        type: "errorMarker"
    };
    var el = w.el.appendChild(dom.createElement("div"));
    var arrow = w.el.appendChild(dom.createElement("div"));
    arrow.className = "error_widget_arrow " + gutterAnno.className;
    
    var left = editor.renderer.$cursorLayer
        .getPixelPosition(pos).left;
    arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
    
    w.el.className = "error_widget_wrapper";
    el.className = "error_widget " + gutterAnno.className;
    el.innerHTML = gutterAnno.text.join("<br>");
    
    el.appendChild(dom.createElement("div"));
    
    var kb = function(_, hashId, keyString) {
        if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
            w.destroy();
            return {command: "null"};
        }
    };
    
    w.destroy = function() {
        if (editor.$mouseHandler.isMousePressed)
            return;
        editor.keyBinding.removeKeyboardHandler(kb);
        session.widgetManager.removeLineWidget(w);
        editor.off("changeSelection", w.destroy);
        editor.off("changeSession", w.destroy);
        editor.off("mouseup", w.destroy);
        editor.off("change", w.destroy);
    };
    
    editor.keyBinding.addKeyboardHandler(kb);
    editor.on("changeSelection", w.destroy);
    editor.on("changeSession", w.destroy);
    editor.on("mouseup", w.destroy);
    editor.on("change", w.destroy);
    
    editor.session.widgetManager.addLineWidget(w);
    
    w.el.onmousedown = editor.focus.bind(editor);
    
    editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
};


dom.importCssString("\
    .error_widget_wrapper {\
        background: inherit;\
        color: inherit;\
        border:none\
    }\
    .error_widget {\
        border-top: solid 2px;\
        border-bottom: solid 2px;\
        margin: 5px 0;\
        padding: 10px 40px;\
        white-space: pre-wrap;\
    }\
    .error_widget.ace_error, .error_widget_arrow.ace_error{\
        border-color: #ff5a5a\
    }\
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
        border-color: #F1D817\
    }\
    .error_widget.ace_info, .error_widget_arrow.ace_info{\
        border-color: #5a5a5a\
    }\
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
        border-color: #5aaa5a\
    }\
    .error_widget_arrow {\
        position: absolute;\
        border: solid 5px;\
        border-top-color: transparent!important;\
        border-right-color: transparent!important;\
        border-left-color: transparent!important;\
        top: -5px;\
    }\
", "");

});
/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * The main class required to set up an Ace instance in the browser.
 *
 * @class Ace
 **/

define('bower_components/ace/lib/ace/ace',['require','exports','module','./lib/fixoldbrowsers','./lib/dom','./lib/event','./editor','./edit_session','./undomanager','./virtual_renderer','./worker/worker_client','./keyboard/hash_handler','./placeholder','./multi_select','./mode/folding/fold_mode','./theme/textmate','./ext/error_marker','./config'],function(require, exports, module) {
"use strict";

require("./lib/fixoldbrowsers");

var dom = require("./lib/dom");
var event = require("./lib/event");

var Editor = require("./editor").Editor;
var EditSession = require("./edit_session").EditSession;
var UndoManager = require("./undomanager").UndoManager;
var Renderer = require("./virtual_renderer").VirtualRenderer;

// The following require()s are for inclusion in the built ace file
require("./worker/worker_client");
require("./keyboard/hash_handler");
require("./placeholder");
require("./multi_select");
require("./mode/folding/fold_mode");
require("./theme/textmate");
require("./ext/error_marker");

exports.config = require("./config");

/**
 * Provides access to require in packed noconflict mode
 * @param {String} moduleName
 * @returns {Object}
 **/
exports.require = require;

if (typeof define === "function")
    exports.define = define;

/**
 * Embeds the Ace editor into the DOM, at the element provided by `el`.
 * @param {String | DOMElement} el Either the id of an element, or the element itself
 *
 **/
exports.edit = function(el) {
    if (typeof el == "string") {
        var _id = el;
        el = document.getElementById(_id);
        if (!el)
            throw new Error("ace.edit can't find div #" + _id);
    }

    if (el && el.env && el.env.editor instanceof Editor)
        return el.env.editor;

    var value = "";
    if (el && /input|textarea/i.test(el.tagName)) {
        var oldNode = el;
        value = oldNode.value;
        el = dom.createElement("pre");
        oldNode.parentNode.replaceChild(el, oldNode);
    } else if (el) {
        value = dom.getInnerText(el);
        el.innerHTML = "";
    }

    var doc = exports.createEditSession(value);

    var editor = new Editor(new Renderer(el));
    editor.setSession(doc);

    var env = {
        document: doc,
        editor: editor,
        onResize: editor.resize.bind(editor, null)
    };
    if (oldNode) env.textarea = oldNode;
    event.addListener(window, "resize", env.onResize);
    editor.on("destroy", function() {
        event.removeListener(window, "resize", env.onResize);
        env.editor.container.env = null; // prevent memory leak on old ie
    });
    editor.container.env = editor.env = env;
    return editor;
};

/**
 * Creates a new [[EditSession]], and returns the associated [[Document]].
 * @param {Document | String} text {:textParam}
 * @param {TextMode} mode {:modeParam}
 * 
 **/
exports.createEditSession = function(text, mode) {
    var doc = new EditSession(text, mode);
    doc.setUndoManager(new UndoManager());
    return doc;
}
exports.EditSession = EditSession;
exports.UndoManager = UndoManager;
exports.version = "1.2.6";
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/behaviour/css',['require','exports','module','../../lib/oop','../behaviour','./cstyle','../../token_iterator'],function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Behaviour = require("../behaviour").Behaviour;
var CstyleBehaviour = require("./cstyle").CstyleBehaviour;
var TokenIterator = require("../../token_iterator").TokenIterator;

var CssBehaviour = function () {

    this.inherit(CstyleBehaviour);

    this.add("colon", "insertion", function (state, action, editor, session, text) {
        if (text === ':') {
            var cursor = editor.getCursorPosition();
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token && token.value.match(/\s+/)) {
                token = iterator.stepBackward();
            }
            if (token && token.type === 'support.type') {
                var line = session.doc.getLine(cursor.row);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar === ':') {
                    return {
                       text: '',
                       selection: [1, 1]
                    }
                }
                if (!line.substring(cursor.column).match(/^\s*;/)) {
                    return {
                       text: ':;',
                       selection: [1, 1]
                    }
                }
            }
        }
    });

    this.add("colon", "deletion", function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected === ':') {
            var cursor = editor.getCursorPosition();
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token && token.value.match(/\s+/)) {
                token = iterator.stepBackward();
            }
            if (token && token.type === 'support.type') {
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.end.column, range.end.column + 1);
                if (rightChar === ';') {
                    range.end.column ++;
                    return range;
                }
            }
        }
    });

    this.add("semicolon", "insertion", function (state, action, editor, session, text) {
        if (text === ';') {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === ';') {
                return {
                   text: '',
                   selection: [1, 1]
                }
            }
        }
    });

}
oop.inherits(CssBehaviour, CstyleBehaviour);

exports.CssBehaviour = CssBehaviour;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/behaviour/xml',['require','exports','module','../../lib/oop','../behaviour','../../token_iterator','../../lib/lang'],function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Behaviour = require("../behaviour").Behaviour;
var TokenIterator = require("../../token_iterator").TokenIterator;
var lang = require("../../lib/lang");

function is(token, type) {
    return token.type.lastIndexOf(type + ".xml") > -1;
}

var XmlBehaviour = function () {

    this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
        if (text == '"' || text == "'") {
            var quote = text;
            var selected = session.doc.getTextRange(editor.getSelectionRange());
            if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
                return {
                    text: quote + selected + quote,
                    selection: false
                };
            }

            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();

            if (rightChar == quote && (is(token, "attribute-value") || is(token, "string"))) {
                // Ignore input and move right one if we're typing over the closing quote.
                return {
                    text: "",
                    selection: [1, 1]
                };
            }

            if (!token)
                token = iterator.stepBackward();

            if (!token)
                return;

            while (is(token, "tag-whitespace") || is(token, "whitespace")) {
                token = iterator.stepBackward();
            }
            var rightSpace = !rightChar || rightChar.match(/\s/);
            if (is(token, "attribute-equals") && (rightSpace || rightChar == '>') || (is(token, "decl-attribute-equals") && (rightSpace || rightChar == '?'))) {
                return {
                    text: quote + quote,
                    selection: [1, 1]
                };
            }
        }
    });

    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("autoclosing", "insertion", function (state, action, editor, session, text) {
        if (text == '>') {
            var position = editor.getSelectionRange().start;
            var iterator = new TokenIterator(session, position.row, position.column);
            var token = iterator.getCurrentToken() || iterator.stepBackward();

            // exit if we're not in a tag
            if (!token || !(is(token, "tag-name") || is(token, "tag-whitespace") || is(token, "attribute-name") || is(token, "attribute-equals") || is(token, "attribute-value")))
                return;

            // exit if we're inside of a quoted attribute value
            if (is(token, "reference.attribute-value"))
                return;
            if (is(token, "attribute-value")) {
                var firstChar = token.value.charAt(0);
                if (firstChar == '"' || firstChar == "'") {
                    var lastChar = token.value.charAt(token.value.length - 1);
                    var tokenEnd = iterator.getCurrentTokenColumn() + token.value.length;
                    if (tokenEnd > position.column || tokenEnd == position.column && firstChar != lastChar)
                        return;
                }
            }

            // find tag name
            while (!is(token, "tag-name")) {
                token = iterator.stepBackward();
                if (token.value == "<") {
                    token = iterator.stepForward();
                    break;
                }
            }

            var tokenRow = iterator.getCurrentTokenRow();
            var tokenColumn = iterator.getCurrentTokenColumn();

            // exit if the tag is ending
            if (is(iterator.stepBackward(), "end-tag-open"))
                return;

            var element = token.value;
            if (tokenRow == position.row)
                element = element.substring(0, position.column - tokenColumn);

            if (this.voidElements.hasOwnProperty(element.toLowerCase()))
                 return;

            return {
               text: ">" + "</" + element + ">",
               selection: [1, 1]
            };
        }
    });

    this.add("autoindent", "insertion", function (state, action, editor, session, text) {
        if (text == "\n") {
            var cursor = editor.getCursorPosition();
            var line = session.getLine(cursor.row);
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();

            if (token && token.type.indexOf("tag-close") !== -1) {
                if (token.value == "/>")
                    return;
                //get tag name
                while (token && token.type.indexOf("tag-name") === -1) {
                    token = iterator.stepBackward();
                }

                if (!token) {
                    return;
                }

                var tag = token.value;
                var row = iterator.getCurrentTokenRow();

                //don't indent after closing tag
                token = iterator.stepBackward();
                if (!token || token.type.indexOf("end-tag") !== -1) {
                    return;
                }

                if (this.voidElements && !this.voidElements[tag]) {
                    var nextToken = session.getTokenAt(cursor.row, cursor.column+1);
                    var line = session.getLine(row);
                    var nextIndent = this.$getIndent(line);
                    var indent = nextIndent + session.getTabString();

                    if (nextToken && nextToken.value === "</") {
                        return {
                            text: "\n" + indent + "\n" + nextIndent,
                            selection: [1, indent.length, 1, indent.length]
                        };
                    } else {
                        return {
                            text: "\n" + indent
                        };
                    }
                }
            }
        }
    });

};

oop.inherits(XmlBehaviour, Behaviour);

exports.XmlBehaviour = XmlBehaviour;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/css_highlight_rules',['require','exports','module','../lib/oop','../lib/lang','./text_highlight_rules'],function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var lang = require("../lib/lang");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;


/* Exports are for Stylus and Less highlighters */
var supportType = exports.supportType = "align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration|animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image|background-origin|background-position|background-repeat|background-size|border|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-left|border-left-color|border-left-style|border-left-width|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|bottom|box-shadow|box-sizing|caption-side|clear|clip|color|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|content|counter-increment|counter-reset|cursor|direction|display|empty-cells|filter|flex|flex-basis|flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|font|font-family|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|hanging-punctuation|height|justify-content|left|letter-spacing|line-height|list-style|list-style-image|list-style-position|list-style-type|margin|margin-bottom|margin-left|margin-right|margin-top|max-height|max-width|min-height|min-width|nav-down|nav-index|nav-left|nav-right|nav-up|opacity|order|outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-x|overflow-y|padding|padding-bottom|padding-left|padding-right|padding-top|page-break-after|page-break-before|page-break-inside|perspective|perspective-origin|position|quotes|resize|right|tab-size|table-layout|text-align|text-align-last|text-decoration|text-decoration-color|text-decoration-line|text-decoration-style|text-indent|text-justify|text-overflow|text-shadow|text-transform|top|transform|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function|unicode-bidi|vertical-align|visibility|white-space|width|word-break|word-spacing|word-wrap|z-index";
var supportFunction = exports.supportFunction = "rgb|rgba|url|attr|counter|counters";
var supportConstant = exports.supportConstant = "absolute|after-edge|after|all-scroll|all|alphabetic|always|antialiased|armenian|auto|avoid-column|avoid-page|avoid|balance|baseline|before-edge|before|below|bidi-override|block-line-height|block|bold|bolder|border-box|both|bottom|box|break-all|break-word|capitalize|caps-height|caption|center|central|char|circle|cjk-ideographic|clone|close-quote|col-resize|collapse|column|consider-shifts|contain|content-box|cover|crosshair|cubic-bezier|dashed|decimal-leading-zero|decimal|default|disabled|disc|disregard-shifts|distribute-all-lines|distribute-letter|distribute-space|distribute|dotted|double|e-resize|ease-in|ease-in-out|ease-out|ease|ellipsis|end|exclude-ruby|fill|fixed|georgian|glyphs|grid-height|groove|hand|hanging|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographic|inactive|include-ruby|inherit|initial|inline-block|inline-box|inline-line-height|inline-table|inline|inset|inside|inter-ideograph|inter-word|invert|italic|justify|katakana-iroha|katakana|keep-all|last|left|lighter|line-edge|line-through|line|linear|list-item|local|loose|lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|mathematical|max-height|max-size|medium|menu|message-box|middle|move|n-resize|ne-resize|newspaper|no-change|no-close-quote|no-drop|no-open-quote|no-repeat|none|normal|not-allowed|nowrap|nw-resize|oblique|open-quote|outset|outside|overline|padding-box|page|pointer|pre-line|pre-wrap|pre|preserve-3d|progress|relative|repeat-x|repeat-y|repeat|replaced|reset-size|ridge|right|round|row-resize|rtl|s-resize|scroll|se-resize|separate|slice|small-caps|small-caption|solid|space|square|start|static|status-bar|step-end|step-start|steps|stretch|strict|sub|super|sw-resize|table-caption|table-cell|table-column-group|table-column|table-footer-group|table-header-group|table-row-group|table-row|table|tb-rl|text-after-edge|text-before-edge|text-bottom|text-size|text-top|text|thick|thin|transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|use-script|vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|z-index|zero";
var supportConstantColor = exports.supportConstantColor = "aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow";
var supportConstantFonts = exports.supportConstantFonts = "arial|century|comic|courier|cursive|fantasy|garamond|georgia|helvetica|impact|lucida|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif|monospace";

var numRe = exports.numRe = "\\-?(?:(?:[0-9]+)|(?:[0-9]*\\.[0-9]+))";
var pseudoElements = exports.pseudoElements = "(\\:+)\\b(after|before|first-letter|first-line|moz-selection|selection)\\b";
var pseudoClasses  = exports.pseudoClasses =  "(:)\\b(active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|indeterminate|invalid|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-child|only-of-type|required|root|target|valid|visited)\\b";

var CssHighlightRules = function() {

    var keywordMapper = this.createKeywordMapper({
        "support.function": supportFunction,
        "support.constant": supportConstant,
        "support.type": supportType,
        "support.constant.color": supportConstantColor,
        "support.constant.fonts": supportConstantFonts
    }, "text", true);

    // regexp must not have capturing parentheses. Use (?:) instead.
    // regexps are ordered -> the first match is used

    this.$rules = {
        "start" : [{
            token : "comment", // multi line comment
            regex : "\\/\\*",
            push : "comment"
        }, {
            token: "paren.lparen",
            regex: "\\{",
            push:  "ruleset"
        }, {
            token: "string",
            regex: "@.*?{",
            push:  "media"
        }, {
            token: "keyword",
            regex: "#[a-z0-9-_]+"
        }, {
            token: "variable",
            regex: "\\.[a-z0-9-_]+"
        }, {
            token: "string",
            regex: ":[a-z0-9-_]+"
        }, {
            token: "constant",
            regex: "[a-z0-9-_]+"
        }, {
            caseInsensitive: true
        }],

        "media" : [{
            token : "comment", // multi line comment
            regex : "\\/\\*",
            push : "comment"
        }, {
            token: "paren.lparen",
            regex: "\\{",
            push:  "ruleset"
        }, {
            token: "string",
            regex: "\\}",
            next:  "pop"
        }, {
            token: "keyword",
            regex: "#[a-z0-9-_]+"
        }, {
            token: "variable",
            regex: "\\.[a-z0-9-_]+"
        }, {
            token: "string",
            regex: ":[a-z0-9-_]+"
        }, {
            token: "constant",
            regex: "[a-z0-9-_]+"
        }, {
            caseInsensitive: true
        }],

        "comment" : [{
            token : "comment",
            regex : "\\*\\/",
            next : "pop"
        }, {
            defaultToken : "comment"
        }],

        "ruleset" : [
        {
            token : "paren.rparen",
            regex : "\\}",
            next:   "pop"
        }, {
            token : "comment", // multi line comment
            regex : "\\/\\*",
            push : "comment"
        }, {
            token : "string", // single line
            regex : '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]'
        }, {
            token : "string", // single line
            regex : "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
        }, {
            token : ["constant.numeric", "keyword"],
            regex : "(" + numRe + ")(ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vm|vw|%)"
        }, {
            token : "constant.numeric",
            regex : numRe
        }, {
            token : "constant.numeric",  // hex6 color
            regex : "#[a-f0-9]{6}"
        }, {
            token : "constant.numeric", // hex3 color
            regex : "#[a-f0-9]{3}"
        }, {
            token : ["punctuation", "entity.other.attribute-name.pseudo-element.css"],
            regex : pseudoElements
        }, {
            token : ["punctuation", "entity.other.attribute-name.pseudo-class.css"],
            regex : pseudoClasses
        }, {
            token : ["support.function", "string", "support.function"],
            regex : "(url\\()(.*)(\\))"
        }, {
            token : keywordMapper,
            regex : "\\-?[a-zA-Z_][a-zA-Z0-9_\\-]*"
        }, {
            caseInsensitive: true
        }]
    };

    this.normalizeRules();
};

oop.inherits(CssHighlightRules, TextHighlightRules);

exports.CssHighlightRules = CssHighlightRules;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/matching_brace_outdent',['require','exports','module','../range'],function(require, exports, module) {
"use strict";

var Range = require("../range").Range;

var MatchingBraceOutdent = function() {};

(function() {

    this.checkOutdent = function(line, input) {
        if (! /^\s+$/.test(line))
            return false;

        return /^\s*\}/.test(input);
    };

    this.autoOutdent = function(doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\})/);

        if (!match) return 0;

        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({row: row, column: column});

        if (!openBracePos || openBracePos.row == row) return 0;

        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        doc.replace(new Range(row, 0, row, column-1), indent);
    };

    this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
    };

}).call(MatchingBraceOutdent.prototype);

exports.MatchingBraceOutdent = MatchingBraceOutdent;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/css_completions',['require','exports','module'],function(require, exports, module) {
"use strict";

var propertyMap = {
    "background": {"#$0": 1},
    "background-color": {"#$0": 1, "transparent": 1, "fixed": 1},
    "background-image": {"url('/$0')": 1},
    "background-repeat": {"repeat": 1, "repeat-x": 1, "repeat-y": 1, "no-repeat": 1, "inherit": 1},
    "background-position": {"bottom":2, "center":2, "left":2, "right":2, "top":2, "inherit":2},
    "background-attachment": {"scroll": 1, "fixed": 1},
    "background-size": {"cover": 1, "contain": 1},
    "background-clip": {"border-box": 1, "padding-box": 1, "content-box": 1},
    "background-origin": {"border-box": 1, "padding-box": 1, "content-box": 1},
    "border": {"solid $0": 1, "dashed $0": 1, "dotted $0": 1, "#$0": 1},
    "border-color": {"#$0": 1},
    "border-style": {"solid":2, "dashed":2, "dotted":2, "double":2, "groove":2, "hidden":2, "inherit":2, "inset":2, "none":2, "outset":2, "ridged":2},
    "border-collapse": {"collapse": 1, "separate": 1},
    "bottom": {"px": 1, "em": 1, "%": 1},
    "clear": {"left": 1, "right": 1, "both": 1, "none": 1},
    "color": {"#$0": 1, "rgb(#$00,0,0)": 1},
    "cursor": {"default": 1, "pointer": 1, "move": 1, "text": 1, "wait": 1, "help": 1, "progress": 1, "n-resize": 1, "ne-resize": 1, "e-resize": 1, "se-resize": 1, "s-resize": 1, "sw-resize": 1, "w-resize": 1, "nw-resize": 1},
    "display": {"none": 1, "block": 1, "inline": 1, "inline-block": 1, "table-cell": 1},
    "empty-cells": {"show": 1, "hide": 1},
    "float": {"left": 1, "right": 1, "none": 1},
    "font-family": {"Arial":2,"Comic Sans MS":2,"Consolas":2,"Courier New":2,"Courier":2,"Georgia":2,"Monospace":2,"Sans-Serif":2, "Segoe UI":2,"Tahoma":2,"Times New Roman":2,"Trebuchet MS":2,"Verdana": 1},
    "font-size": {"px": 1, "em": 1, "%": 1},
    "font-weight": {"bold": 1, "normal": 1},
    "font-style": {"italic": 1, "normal": 1},
    "font-variant": {"normal": 1, "small-caps": 1},
    "height": {"px": 1, "em": 1, "%": 1},
    "left": {"px": 1, "em": 1, "%": 1},
    "letter-spacing": {"normal": 1},
    "line-height": {"normal": 1},
    "list-style-type": {"none": 1, "disc": 1, "circle": 1, "square": 1, "decimal": 1, "decimal-leading-zero": 1, "lower-roman": 1, "upper-roman": 1, "lower-greek": 1, "lower-latin": 1, "upper-latin": 1, "georgian": 1, "lower-alpha": 1, "upper-alpha": 1},
    "margin": {"px": 1, "em": 1, "%": 1},
    "margin-right": {"px": 1, "em": 1, "%": 1},
    "margin-left": {"px": 1, "em": 1, "%": 1},
    "margin-top": {"px": 1, "em": 1, "%": 1},
    "margin-bottom": {"px": 1, "em": 1, "%": 1},
    "max-height": {"px": 1, "em": 1, "%": 1},
    "max-width": {"px": 1, "em": 1, "%": 1},
    "min-height": {"px": 1, "em": 1, "%": 1},
    "min-width": {"px": 1, "em": 1, "%": 1},
    "overflow": {"hidden": 1, "visible": 1, "auto": 1, "scroll": 1},
    "overflow-x": {"hidden": 1, "visible": 1, "auto": 1, "scroll": 1},
    "overflow-y": {"hidden": 1, "visible": 1, "auto": 1, "scroll": 1},
    "padding": {"px": 1, "em": 1, "%": 1},
    "padding-top": {"px": 1, "em": 1, "%": 1},
    "padding-right": {"px": 1, "em": 1, "%": 1},
    "padding-bottom": {"px": 1, "em": 1, "%": 1},
    "padding-left": {"px": 1, "em": 1, "%": 1},
    "page-break-after": {"auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1},
    "page-break-before": {"auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1},
    "position": {"absolute": 1, "relative": 1, "fixed": 1, "static": 1},
    "right": {"px": 1, "em": 1, "%": 1},
    "table-layout": {"fixed": 1, "auto": 1},
    "text-decoration": {"none": 1, "underline": 1, "line-through": 1, "blink": 1},
    "text-align": {"left": 1, "right": 1, "center": 1, "justify": 1},
    "text-transform": {"capitalize": 1, "uppercase": 1, "lowercase": 1, "none": 1},
    "top": {"px": 1, "em": 1, "%": 1},
    "vertical-align": {"top": 1, "bottom": 1},
    "visibility": {"hidden": 1, "visible": 1},
    "white-space": {"nowrap": 1, "normal": 1, "pre": 1, "pre-line": 1, "pre-wrap": 1},
    "width": {"px": 1, "em": 1, "%": 1},
    "word-spacing": {"normal": 1},

    // opacity
    "filter": {"alpha(opacity=$0100)": 1},

    "text-shadow": {"$02px 2px 2px #777": 1},
    "text-overflow": {"ellipsis-word": 1, "clip": 1, "ellipsis": 1},

    // border radius
    "-moz-border-radius": 1,
    "-moz-border-radius-topright": 1,
    "-moz-border-radius-bottomright": 1,
    "-moz-border-radius-topleft": 1,
    "-moz-border-radius-bottomleft": 1,
    "-webkit-border-radius": 1,
    "-webkit-border-top-right-radius": 1,
    "-webkit-border-top-left-radius": 1,
    "-webkit-border-bottom-right-radius": 1,
    "-webkit-border-bottom-left-radius": 1,

    // dropshadows
    "-moz-box-shadow": 1,
    "-webkit-box-shadow": 1,

    // transformations
    "transform": {"rotate($00deg)": 1, "skew($00deg)": 1},
    "-moz-transform": {"rotate($00deg)": 1, "skew($00deg)": 1},
    "-webkit-transform": {"rotate($00deg)": 1, "skew($00deg)": 1 }
};

var CssCompletions = function() {

};

(function() {

    this.completionsDefined = false;

    this.defineCompletions = function() {
        //fill in missing properties
        if (document) {
            var style = document.createElement('c').style;

            for (var i in style) {
                if (typeof style[i] !== 'string')
                    continue;

                var name = i.replace(/[A-Z]/g, function(x) {
                    return '-' + x.toLowerCase();
                });

                if (!propertyMap.hasOwnProperty(name))
                    propertyMap[name] = 1;
            }
        }

        this.completionsDefined = true;
    }

    this.getCompletions = function(state, session, pos, prefix) {
        if (!this.completionsDefined) {
            this.defineCompletions();
        }

        var token = session.getTokenAt(pos.row, pos.column);

        if (!token)
            return [];
        if (state==='ruleset'){
            //css attribute value
            var line = session.getLine(pos.row).substr(0, pos.column);
            if (/:[^;]+$/.test(line)) {
                /([\w\-]+):[^:]*$/.test(line);

                return this.getPropertyValueCompletions(state, session, pos, prefix);
            } else {
                return this.getPropertyCompletions(state, session, pos, prefix);
            }
        }

        return [];
    };

    this.getPropertyCompletions = function(state, session, pos, prefix) {
        var properties = Object.keys(propertyMap);
        return properties.map(function(property){
            return {
                caption: property,
                snippet: property + ': $0',
                meta: "property",
                score: Number.MAX_VALUE
            };
        });
    };

    this.getPropertyValueCompletions = function(state, session, pos, prefix) {
        var line = session.getLine(pos.row).substr(0, pos.column);
        var property = (/([\w\-]+):[^:]*$/.exec(line) || {})[1];

        if (!property)
            return [];
        var values = [];
        if (property in propertyMap && typeof propertyMap[property] === "object") {
            values = Object.keys(propertyMap[property]);
        }
        return values.map(function(value){
            return {
                caption: value,
                snippet: value,
                meta: "property value",
                score: Number.MAX_VALUE
            };
        });
    };

}).call(CssCompletions.prototype);

exports.CssCompletions = CssCompletions;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/folding/cstyle',['require','exports','module','../../lib/oop','../../range','./fold_mode'],function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Range = require("../../range").Range;
var BaseFoldMode = require("./fold_mode").FoldMode;

var FoldMode = exports.FoldMode = function(commentRegex) {
    if (commentRegex) {
        this.foldingStartMarker = new RegExp(
            this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
        );
        this.foldingStopMarker = new RegExp(
            this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
        );
    }
};
oop.inherits(FoldMode, BaseFoldMode);

(function() {
    
    this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
    this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
    this.singleLineBlockCommentRe= /^\s*(\/\*).*\*\/\s*$/;
    this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
    this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
    
    //prevent naming conflict with any modes that inherit from cstyle and override this (like csharp)
    this._getFoldWidgetBase = this.getFoldWidget;
    
    /**
     * Gets fold widget with some non-standard extras:
     *
     * @example lineCommentRegionStart
     *      //#region [optional description]
     *
     * @example blockCommentRegionStart
     *      /*#region [optional description] *[/]
     *
     * @example tripleStarFoldingSection
     *      /*** this folds even though 1 line because it has 3 stars ***[/]
     * 
     * @note the pound symbol for region tags is optional
     */
    this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
    
        if (this.singleLineBlockCommentRe.test(line)) {
            // No widget for single line block comment unless region or triple star
            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
                return "";
        }
    
        var fw = this._getFoldWidgetBase(session, foldStyle, row);
    
        if (!fw && this.startRegionRe.test(line))
            return "start"; // lineCommentRegionStart
    
        return fw;
    };

    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
        var line = session.getLine(row);
        
        if (this.startRegionRe.test(line))
            return this.getCommentRegionBlock(session, line, row);
        
        var match = line.match(this.foldingStartMarker);
        if (match) {
            var i = match.index;

            if (match[1])
                return this.openingBracketBlock(session, match[1], row, i);
                
            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
            
            if (range && !range.isMultiLine()) {
                if (forceMultiline) {
                    range = this.getSectionRange(session, row);
                } else if (foldStyle != "all")
                    range = null;
            }
            
            return range;
        }

        if (foldStyle === "markbegin")
            return;

        var match = line.match(this.foldingStopMarker);
        if (match) {
            var i = match.index + match[0].length;

            if (match[1])
                return this.closingBracketBlock(session, match[1], row, i);

            return session.getCommentFoldRange(row, i, -1);
        }
    };
    
    this.getSectionRange = function(session, row) {
        var line = session.getLine(row);
        var startIndent = line.search(/\S/);
        var startRow = row;
        var startColumn = line.length;
        row = row + 1;
        var endRow = row;
        var maxRow = session.getLength();
        while (++row < maxRow) {
            line = session.getLine(row);
            var indent = line.search(/\S/);
            if (indent === -1)
                continue;
            if  (startIndent > indent)
                break;
            var subRange = this.getFoldWidgetRange(session, "all", row);
            
            if (subRange) {
                if (subRange.start.row <= startRow) {
                    break;
                } else if (subRange.isMultiLine()) {
                    row = subRange.end.row;
                } else if (startIndent == indent) {
                    break;
                }
            }
            endRow = row;
        }
        
        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
    };
    
    /**
     * gets comment region block with end region assumed to be start of comment in any cstyle mode or SQL mode (--) which inherits from this.
     * There may optionally be a pound symbol before the region/endregion statement
     */
    this.getCommentRegionBlock = function(session, line, row) {
        var startColumn = line.search(/\s*$/);
        var maxRow = session.getLength();
        var startRow = row;
        
        var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
        var depth = 1;
        while (++row < maxRow) {
            line = session.getLine(row);
            var m = re.exec(line);
            if (!m) continue;
            if (m[1]) depth--;
            else depth++;

            if (!depth) break;
        }

        var endRow = row;
        if (endRow > startRow) {
            return new Range(startRow, startColumn, endRow, line.length);
        }
    };

}).call(FoldMode.prototype);

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/css',['require','exports','module','../lib/oop','./text','./css_highlight_rules','./matching_brace_outdent','../worker/worker_client','./css_completions','./behaviour/css','./folding/cstyle'],function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var CssHighlightRules = require("./css_highlight_rules").CssHighlightRules;
var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
var WorkerClient = require("../worker/worker_client").WorkerClient;
var CssCompletions = require("./css_completions").CssCompletions;
var CssBehaviour = require("./behaviour/css").CssBehaviour;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;

var Mode = function() {
    this.HighlightRules = CssHighlightRules;
    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CssBehaviour();
    this.$completer = new CssCompletions();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);

(function() {

    this.foldingRules = "cStyle";
    this.blockComment = {start: "/*", end: "*/"};

    this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);

        // ignore braces in comments
        var tokens = this.getTokenizer().getLineTokens(line, state).tokens;
        if (tokens.length && tokens[tokens.length-1].type == "comment") {
            return indent;
        }

        var match = line.match(/^.*\{\s*$/);
        if (match) {
            indent += tab;
        }

        return indent;
    };

    this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };

    this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };

    this.getCompletions = function(state, session, pos, prefix) {
        return this.$completer.getCompletions(state, session, pos, prefix);
    };

    this.createWorker = function(session) {
        var worker = new WorkerClient(["ace"], "ace/mode/css_worker", "Worker");
        worker.attachToDocument(session.getDocument());

        worker.on("annotate", function(e) {
            session.setAnnotations(e.data);
        });

        worker.on("terminate", function() {
            session.clearAnnotations();
        });

        return worker;
    };

    this.$id = "ace/mode/css";
}).call(Mode.prototype);

exports.Mode = Mode;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/doc_comment_highlight_rules',['require','exports','module','../lib/oop','./text_highlight_rules'],function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var DocCommentHighlightRules = function() {
    this.$rules = {
        "start" : [ {
            token : "comment.doc.tag",
            regex : "@[\\w\\d_]+" // TODO: fix email addresses
        }, 
        DocCommentHighlightRules.getTagRule(),
        {
            defaultToken : "comment.doc",
            caseInsensitive: true
        }]
    };
};

oop.inherits(DocCommentHighlightRules, TextHighlightRules);

DocCommentHighlightRules.getTagRule = function(start) {
    return {
        token : "comment.doc.tag.storage.type",
        regex : "\\b(?:TODO|FIXME|XXX|HACK)\\b"
    };
}

DocCommentHighlightRules.getStartRule = function(start) {
    return {
        token : "comment.doc", // doc comment
        regex : "\\/\\*(?=\\*)",
        next  : start
    };
};

DocCommentHighlightRules.getEndRule = function (start) {
    return {
        token : "comment.doc", // closing comment
        regex : "\\*\\/",
        next  : start
    };
};


exports.DocCommentHighlightRules = DocCommentHighlightRules;

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/folding/mixed',['require','exports','module','../../lib/oop','./fold_mode'],function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var BaseFoldMode = require("./fold_mode").FoldMode;

var FoldMode = exports.FoldMode = function(defaultMode, subModes) {
    this.defaultMode = defaultMode;
    this.subModes = subModes;
};
oop.inherits(FoldMode, BaseFoldMode);

(function() {


    this.$getMode = function(state) {
        if (typeof state != "string") 
            state = state[0];
        for (var key in this.subModes) {
            if (state.indexOf(key) === 0)
                return this.subModes[key];
        }
        return null;
    };
    
    this.$tryMode = function(state, session, foldStyle, row) {
        var mode = this.$getMode(state);
        return (mode ? mode.getFoldWidget(session, foldStyle, row) : "");
    };

    this.getFoldWidget = function(session, foldStyle, row) {
        return (
            this.$tryMode(session.getState(row-1), session, foldStyle, row) ||
            this.$tryMode(session.getState(row), session, foldStyle, row) ||
            this.defaultMode.getFoldWidget(session, foldStyle, row)
        );
    };

    this.getFoldWidgetRange = function(session, foldStyle, row) {
        var mode = this.$getMode(session.getState(row-1));
        
        if (!mode || !mode.getFoldWidget(session, foldStyle, row))
            mode = this.$getMode(session.getState(row));
        
        if (!mode || !mode.getFoldWidget(session, foldStyle, row))
            mode = this.defaultMode;
        
        return mode.getFoldWidgetRange(session, foldStyle, row);
    };

}).call(FoldMode.prototype);

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/folding/xml',['require','exports','module','../../lib/oop','../../lib/lang','../../range','./fold_mode','../../token_iterator'],function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var lang = require("../../lib/lang");
var Range = require("../../range").Range;
var BaseFoldMode = require("./fold_mode").FoldMode;
var TokenIterator = require("../../token_iterator").TokenIterator;

var FoldMode = exports.FoldMode = function(voidElements, optionalEndTags) {
    BaseFoldMode.call(this);
    this.voidElements = voidElements || {};
    this.optionalEndTags = oop.mixin({}, this.voidElements);
    if (optionalEndTags)
        oop.mixin(this.optionalEndTags, optionalEndTags);
    
};
oop.inherits(FoldMode, BaseFoldMode);

var Tag = function() {
    this.tagName = "";
    this.closing = false;
    this.selfClosing = false;
    this.start = {row: 0, column: 0};
    this.end = {row: 0, column: 0};
};

function is(token, type) {
    return token.type.lastIndexOf(type + ".xml") > -1;
}

(function() {

    this.getFoldWidget = function(session, foldStyle, row) {
        var tag = this._getFirstTagInLine(session, row);

        if (!tag)
            return "";

        if (tag.closing || (!tag.tagName && tag.selfClosing))
            return foldStyle == "markbeginend" ? "end" : "";

        if (!tag.tagName || tag.selfClosing || this.voidElements.hasOwnProperty(tag.tagName.toLowerCase()))
            return "";

        if (this._findEndTagInLine(session, row, tag.tagName, tag.end.column))
            return "";

        return "start";
    };

    /*
     * returns a first tag (or a fragment) in a line
     */
    this._getFirstTagInLine = function(session, row) {
        var tokens = session.getTokens(row);
        var tag = new Tag();

        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (is(token, "tag-open")) {
                tag.end.column = tag.start.column + token.value.length;
                tag.closing = is(token, "end-tag-open");
                token = tokens[++i];
                if (!token)
                    return null;
                tag.tagName = token.value;
                tag.end.column += token.value.length;
                for (i++; i < tokens.length; i++) {
                    token = tokens[i];
                    tag.end.column += token.value.length;
                    if (is(token, "tag-close")) {
                        tag.selfClosing = token.value == '/>';
                        break;
                    }
                }
                return tag;
            } else if (is(token, "tag-close")) {
                tag.selfClosing = token.value == '/>';
                return tag;
            }
            tag.start.column += token.value.length;
        }

        return null;
    };

    this._findEndTagInLine = function(session, row, tagName, startColumn) {
        var tokens = session.getTokens(row);
        var column = 0;
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            column += token.value.length;
            if (column < startColumn)
                continue;
            if (is(token, "end-tag-open")) {
                token = tokens[i + 1];
                if (token && token.value == tagName)
                    return true;
            }
        }
        return false;
    };

    /*
     * reads a full tag and places the iterator after the tag
     */
    this._readTagForward = function(iterator) {
        var token = iterator.getCurrentToken();
        if (!token)
            return null;

        var tag = new Tag();
        do {
            if (is(token, "tag-open")) {
                tag.closing = is(token, "end-tag-open");
                tag.start.row = iterator.getCurrentTokenRow();
                tag.start.column = iterator.getCurrentTokenColumn();
            } else if (is(token, "tag-name")) {
                tag.tagName = token.value;
            } else if (is(token, "tag-close")) {
                tag.selfClosing = token.value == "/>";
                tag.end.row = iterator.getCurrentTokenRow();
                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
                iterator.stepForward();
                return tag;
            }
        } while(token = iterator.stepForward());

        return null;
    };
    
    this._readTagBackward = function(iterator) {
        var token = iterator.getCurrentToken();
        if (!token)
            return null;

        var tag = new Tag();
        do {
            if (is(token, "tag-open")) {
                tag.closing = is(token, "end-tag-open");
                tag.start.row = iterator.getCurrentTokenRow();
                tag.start.column = iterator.getCurrentTokenColumn();
                iterator.stepBackward();
                return tag;
            } else if (is(token, "tag-name")) {
                tag.tagName = token.value;
            } else if (is(token, "tag-close")) {
                tag.selfClosing = token.value == "/>";
                tag.end.row = iterator.getCurrentTokenRow();
                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
            }
        } while(token = iterator.stepBackward());

        return null;
    };
    
    this._pop = function(stack, tag) {
        while (stack.length) {
            
            var top = stack[stack.length-1];
            if (!tag || top.tagName == tag.tagName) {
                return stack.pop();
            }
            else if (this.optionalEndTags.hasOwnProperty(top.tagName)) {
                stack.pop();
                continue;
            } else {
                return null;
            }
        }
    };
    
    this.getFoldWidgetRange = function(session, foldStyle, row) {
        var firstTag = this._getFirstTagInLine(session, row);
        
        if (!firstTag)
            return null;
        
        var isBackward = firstTag.closing || firstTag.selfClosing;
        var stack = [];
        var tag;
        
        if (!isBackward) {
            var iterator = new TokenIterator(session, row, firstTag.start.column);
            var start = {
                row: row,
                column: firstTag.start.column + firstTag.tagName.length + 2
            };
            if (firstTag.start.row == firstTag.end.row)
                start.column = firstTag.end.column;
            while (tag = this._readTagForward(iterator)) {
                if (tag.selfClosing) {
                    if (!stack.length) {
                        tag.start.column += tag.tagName.length + 2;
                        tag.end.column -= 2;
                        return Range.fromPoints(tag.start, tag.end);
                    } else
                        continue;
                }
                
                if (tag.closing) {
                    this._pop(stack, tag);
                    if (stack.length == 0)
                        return Range.fromPoints(start, tag.start);
                }
                else {
                    stack.push(tag);
                }
            }
        }
        else {
            var iterator = new TokenIterator(session, row, firstTag.end.column);
            var end = {
                row: row,
                column: firstTag.start.column
            };
            
            while (tag = this._readTagBackward(iterator)) {
                if (tag.selfClosing) {
                    if (!stack.length) {
                        tag.start.column += tag.tagName.length + 2;
                        tag.end.column -= 2;
                        return Range.fromPoints(tag.start, tag.end);
                    } else
                        continue;
                }
                
                if (!tag.closing) {
                    this._pop(stack, tag);
                    if (stack.length == 0) {
                        tag.start.column += tag.tagName.length + 2;
                        if (tag.start.row == tag.end.row && tag.start.column < tag.end.column)
                            tag.start.column = tag.end.column;
                        return Range.fromPoints(tag.start, end);
                    }
                }
                else {
                    stack.push(tag);
                }
            }
        }
        
    };

}).call(FoldMode.prototype);

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/folding/html',['require','exports','module','../../lib/oop','./mixed','./xml','./cstyle'],function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var MixedFoldMode = require("./mixed").FoldMode;
var XmlFoldMode = require("./xml").FoldMode;
var CStyleFoldMode = require("./cstyle").FoldMode;

var FoldMode = exports.FoldMode = function(voidElements, optionalTags) {
    MixedFoldMode.call(this, new XmlFoldMode(voidElements, optionalTags), {
        "js-": new CStyleFoldMode(),
        "css-": new CStyleFoldMode()
    });
};

oop.inherits(FoldMode, MixedFoldMode);

});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/javascript_highlight_rules',['require','exports','module','../lib/oop','./doc_comment_highlight_rules','./text_highlight_rules'],function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

// TODO: Unicode escape sequences
var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*";

var JavaScriptHighlightRules = function(options) {
    // see: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects
    var keywordMapper = this.createKeywordMapper({
        "variable.language":
            "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|"  + // Constructors
            "Namespace|QName|XML|XMLList|"                                             + // E4X
            "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|"   +
            "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|"                    +
            "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|"   + // Errors
            "SyntaxError|TypeError|URIError|"                                          +
            "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
            "isNaN|parseFloat|parseInt|"                                               +
            "JSON|Math|"                                                               + // Other
            "this|arguments|prototype|window|document"                                 , // Pseudo
        "keyword":
            "const|yield|import|get|set|async|await|" +
            "break|case|catch|continue|default|delete|do|else|finally|for|function|" +
            "if|in|of|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" +
            // invalid or reserved
            "__parent__|__count__|escape|unescape|with|__proto__|" +
            "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
        "storage.type":
            "const|let|var|function",
        "constant.language":
            "null|Infinity|NaN|undefined",
        "support.function":
            "alert",
        "constant.language.boolean": "true|false"
    }, "identifier");

    // keywords which can be followed by regular expressions
    var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";

    var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
        "u[0-9a-fA-F]{4}|" + // unicode
        "u{[0-9a-fA-F]{1,6}}|" + // es6 unicode
        "[0-2][0-7]{0,2}|" + // oct
        "3[0-7][0-7]?|" + // oct
        "[4-7][0-7]?|" + //oct
        ".)";
    // regexp must not have capturing parentheses. Use (?:) instead.
    // regexps are ordered -> the first match is used

    this.$rules = {
        "no_regex" : [
            DocCommentHighlightRules.getStartRule("doc-start"),
            comments("no_regex"),
            {
                token : "string",
                regex : "'(?=.)",
                next  : "qstring"
            }, {
                token : "string",
                regex : '"(?=.)',
                next  : "qqstring"
            }, {
                token : "constant.numeric", // hex
                regex : /0(?:[xX][0-9a-fA-F]+|[bB][01]+)\b/
            }, {
                token : "constant.numeric", // float
                regex : /[+-]?\d[\d_]*(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
            }, {
                // Sound.prototype.play =
                token : [
                    "storage.type", "punctuation.operator", "support.function",
                    "punctuation.operator", "entity.name.function", "text","keyword.operator"
                ],
                regex : "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe +")(\\s*)(=)",
                next: "function_arguments"
            }, {
                // Sound.play = function() {  }
                token : [
                    "storage.type", "punctuation.operator", "entity.name.function", "text",
                    "keyword.operator", "text", "storage.type", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                // play = function() {  }
                token : [
                    "entity.name.function", "text", "keyword.operator", "text", "storage.type",
                    "text", "paren.lparen"
                ],
                regex : "(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                // Sound.play = function play() {  }
                token : [
                    "storage.type", "punctuation.operator", "entity.name.function", "text",
                    "keyword.operator", "text",
                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                // function myFunc(arg) { }
                token : [
                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                ],
                regex : "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                next: "function_arguments"
            }, {
                // foobar: function() { }
                token : [
                    "entity.name.function", "text", "punctuation.operator",
                    "text", "storage.type", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                // : function() { } (this is for issues with 'foo': function() { })
                token : [
                    "text", "text", "storage.type", "text", "paren.lparen"
                ],
                regex : "(:)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : "keyword",
                regex : "(?:" + kwBeforeRe + ")\\b",
                next : "start"
            }, {
                token : ["support.constant"],
                regex : /that\b/
            }, {
                token : ["storage.type", "punctuation.operator", "support.function.firebug"],
                regex : /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
            }, {
                token : keywordMapper,
                regex : identifierRe
            }, {
                token : "punctuation.operator",
                regex : /[.](?![.])/,
                next  : "property"
            }, {
                token : "keyword.operator",
                regex : /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?:|[!$%&*+\-~\/^]=?/,
                next  : "start"
            }, {
                token : "punctuation.operator",
                regex : /[?:,;.]/,
                next  : "start"
            }, {
                token : "paren.lparen",
                regex : /[\[({]/,
                next  : "start"
            }, {
                token : "paren.rparen",
                regex : /[\])}]/
            }, {
                token: "comment",
                regex: /^#!.*$/
            }
        ],
        property: [{
                token : "text",
                regex : "\\s+"
            }, {
                // Sound.play = function play() {  }
                token : [
                    "storage.type", "punctuation.operator", "entity.name.function", "text",
                    "keyword.operator", "text",
                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(?:(\\s+)(\\w+))?(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : "punctuation.operator",
                regex : /[.](?![.])/
            }, {
                token : "support.function",
                regex : /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
            }, {
                token : "support.function.dom",
                regex : /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
            }, {
                token :  "support.constant",
                regex : /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
            }, {
                token : "identifier",
                regex : identifierRe
            }, {
                regex: "",
                token: "empty",
                next: "no_regex"
            }
        ],
        // regular expressions are only allowed after certain tokens. This
        // makes sure we don't mix up regexps with the divison operator
        "start": [
            DocCommentHighlightRules.getStartRule("doc-start"),
            comments("start"),
            {
                token: "string.regexp",
                regex: "\\/",
                next: "regex"
            }, {
                token : "text",
                regex : "\\s+|^$",
                next : "start"
            }, {
                // immediately return to the start mode without matching
                // anything
                token: "empty",
                regex: "",
                next: "no_regex"
            }
        ],
        "regex": [
            {
                // escapes
                token: "regexp.keyword.operator",
                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
            }, {
                // flag
                token: "string.regexp",
                regex: "/[sxngimy]*",
                next: "no_regex"
            }, {
                // invalid operators
                token : "invalid",
                regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
            }, {
                // operators
                token : "constant.language.escape",
                regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
            }, {
                token : "constant.language.delimiter",
                regex: /\|/
            }, {
                token: "constant.language.escape",
                regex: /\[\^?/,
                next: "regex_character_class"
            }, {
                token: "empty",
                regex: "$",
                next: "no_regex"
            }, {
                defaultToken: "string.regexp"
            }
        ],
        "regex_character_class": [
            {
                token: "regexp.charclass.keyword.operator",
                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
            }, {
                token: "constant.language.escape",
                regex: "]",
                next: "regex"
            }, {
                token: "constant.language.escape",
                regex: "-"
            }, {
                token: "empty",
                regex: "$",
                next: "no_regex"
            }, {
                defaultToken: "string.regexp.charachterclass"
            }
        ],
        "function_arguments": [
            {
                token: "variable.parameter",
                regex: identifierRe
            }, {
                token: "punctuation.operator",
                regex: "[, ]+"
            }, {
                token: "punctuation.operator",
                regex: "$"
            }, {
                token: "empty",
                regex: "",
                next: "no_regex"
            }
        ],
        "qqstring" : [
            {
                token : "constant.language.escape",
                regex : escapedRe
            }, {
                token : "string",
                regex : "\\\\$",
                next  : "qqstring"
            }, {
                token : "string",
                regex : '"|$',
                next  : "no_regex"
            }, {
                defaultToken: "string"
            }
        ],
        "qstring" : [
            {
                token : "constant.language.escape",
                regex : escapedRe
            }, {
                token : "string",
                regex : "\\\\$",
                next  : "qstring"
            }, {
                token : "string",
                regex : "'|$",
                next  : "no_regex"
            }, {
                defaultToken: "string"
            }
        ]
    };
    
    
    if (!options || !options.noES6) {
        this.$rules.no_regex.unshift({
            regex: "[{}]", onMatch: function(val, state, stack) {
                this.next = val == "{" ? this.nextState : "";
                if (val == "{" && stack.length) {
                    stack.unshift("start", state);
                }
                else if (val == "}" && stack.length) {
                    stack.shift();
                    this.next = stack.shift();
                    if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1)
                        return "paren.quasi.end";
                }
                return val == "{" ? "paren.lparen" : "paren.rparen";
            },
            nextState: "start"
        }, {
            token : "string.quasi.start",
            regex : /`/,
            push  : [{
                token : "constant.language.escape",
                regex : escapedRe
            }, {
                token : "paren.quasi.start",
                regex : /\${/,
                push  : "start"
            }, {
                token : "string.quasi.end",
                regex : /`/,
                next  : "pop"
            }, {
                defaultToken: "string.quasi"
            }]
        });
        
        if (!options || options.jsx != false)
            JSX.call(this);
    }
    
    this.embedRules(DocCommentHighlightRules, "doc-",
        [ DocCommentHighlightRules.getEndRule("no_regex") ]);
    
    this.normalizeRules();
};

oop.inherits(JavaScriptHighlightRules, TextHighlightRules);

function JSX() {
    var tagRegex = identifierRe.replace("\\d", "\\d\\-");
    var jsxTag = {
        onMatch : function(val, state, stack) {
            var offset = val.charAt(1) == "/" ? 2 : 1;
            if (offset == 1) {
                if (state != this.nextState)
                    stack.unshift(this.next, this.nextState, 0);
                else
                    stack.unshift(this.next);
                stack[2]++;
            } else if (offset == 2) {
                if (state == this.nextState) {
                    stack[1]--;
                    if (!stack[1] || stack[1] < 0) {
                        stack.shift();
                        stack.shift();
                    }
                }
            }
            return [{
                type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
                value: val.slice(0, offset)
            }, {
                type: "meta.tag.tag-name.xml",
                value: val.substr(offset)
            }];
        },
        regex : "</?" + tagRegex + "",
        next: "jsxAttributes",
        nextState: "jsx"
    };
    this.$rules.start.unshift(jsxTag);
    var jsxJsRule = {
        regex: "{",
        token: "paren.quasi.start",
        push: "start"
    };
    this.$rules.jsx = [
        jsxJsRule,
        jsxTag,
        {include : "reference"},
        {defaultToken: "string"}
    ];
    this.$rules.jsxAttributes = [{
        token : "meta.tag.punctuation.tag-close.xml", 
        regex : "/?>", 
        onMatch : function(value, currentState, stack) {
            if (currentState == stack[0])
                stack.shift();
            if (value.length == 2) {
                if (stack[0] == this.nextState)
                    stack[1]--;
                if (!stack[1] || stack[1] < 0) {
                    stack.splice(0, 2);
                }
            }
            this.next = stack[0] || "start";
            return [{type: this.token, value: value}];
        },
        nextState: "jsx"
    }, 
    jsxJsRule,
    comments("jsxAttributes"),
    {
        token : "entity.other.attribute-name.xml",
        regex : tagRegex
    }, {
        token : "keyword.operator.attribute-equals.xml",
        regex : "="
    }, {
        token : "text.tag-whitespace.xml",
        regex : "\\s+"
    }, {
        token : "string.attribute-value.xml",
        regex : "'",
        stateName : "jsx_attr_q",
        push : [
            {token : "string.attribute-value.xml", regex: "'", next: "pop"},
            {include : "reference"},
            {defaultToken : "string.attribute-value.xml"}
        ]
    }, {
        token : "string.attribute-value.xml",
        regex : '"',
        stateName : "jsx_attr_qq",
        push : [
            {token : "string.attribute-value.xml", regex: '"', next: "pop"},
            {include : "reference"},
            {defaultToken : "string.attribute-value.xml"}
        ]
    },
    jsxTag
    ];
    this.$rules.reference = [{
        token : "constant.language.escape.reference.xml",
        regex : "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
    }];
}

function comments(next) {
    return [
        {
            token : "comment", // multi line comment
            regex : /\/\*/,
            next: [
                DocCommentHighlightRules.getTagRule(),
                {token : "comment", regex : "\\*\\/", next : next || "pop"},
                {defaultToken : "comment", caseInsensitive: true}
            ]
        }, {
            token : "comment",
            regex : "\\/\\/",
            next: [
                DocCommentHighlightRules.getTagRule(),
                {token : "comment", regex : "$|^", next : next || "pop"},
                {defaultToken : "comment", caseInsensitive: true}
            ]
        }
    ];
}
exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/javascript',['require','exports','module','../lib/oop','./text','./javascript_highlight_rules','./matching_brace_outdent','../worker/worker_client','./behaviour/cstyle','./folding/cstyle'],function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
var WorkerClient = require("../worker/worker_client").WorkerClient;
var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;

var Mode = function() {
    this.HighlightRules = JavaScriptHighlightRules;
    
    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CstyleBehaviour();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);

(function() {

    this.lineCommentStart = "//";
    this.blockComment = {start: "/*", end: "*/"};

    this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);

        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
        var tokens = tokenizedLine.tokens;
        var endState = tokenizedLine.state;

        if (tokens.length && tokens[tokens.length-1].type == "comment") {
            return indent;
        }

        if (state == "start" || state == "no_regex") {
            var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
            if (match) {
                indent += tab;
            }
        } else if (state == "doc-start") {
            if (endState == "start" || endState == "no_regex") {
                return "";
            }
            var match = line.match(/^\s*(\/?)\*/);
            if (match) {
                if (match[1]) {
                    indent += " ";
                }
                indent += "* ";
            }
        }

        return indent;
    };

    this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };

    this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };

    this.createWorker = function(session) {
        var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
        worker.attachToDocument(session.getDocument());

        worker.on("annotate", function(results) {
            session.setAnnotations(results.data);
        });

        worker.on("terminate", function() {
            session.clearAnnotations();
        });

        return worker;
    };

    this.$id = "ace/mode/javascript";
}).call(Mode.prototype);

exports.Mode = Mode;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/xml_highlight_rules',['require','exports','module','../lib/oop','./text_highlight_rules'],function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var XmlHighlightRules = function(normalize) {
    // http://www.w3.org/TR/REC-xml/#NT-NameChar
	// NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
	// NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
    var tagRegex = "[_:a-zA-Z\xc0-\uffff][-_:.a-zA-Z0-9\xc0-\uffff]*";

    this.$rules = {
        start : [
            {token : "string.cdata.xml", regex : "<\\!\\[CDATA\\[", next : "cdata"},
            {
                token : ["punctuation.xml-decl.xml", "keyword.xml-decl.xml"],
                regex : "(<\\?)(xml)(?=[\\s])", next : "xml_decl", caseInsensitive: true
            },
            {
                token : ["punctuation.instruction.xml", "keyword.instruction.xml"],
                regex : "(<\\?)(" + tagRegex + ")", next : "processing_instruction"
            },
            {token : "comment.xml", regex : "<\\!--", next : "comment"},
            {
                token : ["xml-pe.doctype.xml", "xml-pe.doctype.xml"],
                regex : "(<\\!)(DOCTYPE)(?=[\\s])", next : "doctype", caseInsensitive: true
            },
            {include : "tag"},
            {token : "text.end-tag-open.xml", regex: "</"},
            {token : "text.tag-open.xml", regex: "<"},
            {include : "reference"},
            {defaultToken : "text.xml"}
        ],

        xml_decl : [{
            token : "entity.other.attribute-name.decl-attribute-name.xml",
            regex : "(?:" + tagRegex + ":)?" + tagRegex + ""
        }, {
            token : "keyword.operator.decl-attribute-equals.xml",
            regex : "="
        }, {
            include: "whitespace"
        }, {
            include: "string"
        }, {
            token : "punctuation.xml-decl.xml",
            regex : "\\?>",
            next : "start"
        }],

        processing_instruction : [
            {token : "punctuation.instruction.xml", regex : "\\?>", next : "start"},
            {defaultToken : "instruction.xml"}
        ],

        doctype : [
            {include : "whitespace"},
            {include : "string"},
            {token : "xml-pe.doctype.xml", regex : ">", next : "start"},
            {token : "xml-pe.xml", regex : "[-_a-zA-Z0-9:]+"},
            {token : "punctuation.int-subset", regex : "\\[", push : "int_subset"}
        ],

        int_subset : [{
            token : "text.xml",
            regex : "\\s+"
        }, {
            token: "punctuation.int-subset.xml",
            regex: "]",
            next: "pop"
        }, {
            token : ["punctuation.markup-decl.xml", "keyword.markup-decl.xml"],
            regex : "(<\\!)(" + tagRegex + ")",
            push : [{
                token : "text",
                regex : "\\s+"
            },
            {
                token : "punctuation.markup-decl.xml",
                regex : ">",
                next : "pop"
            },
            {include : "string"}]
        }],

        cdata : [
            {token : "string.cdata.xml", regex : "\\]\\]>", next : "start"},
            {token : "text.xml", regex : "\\s+"},
            {token : "text.xml", regex : "(?:[^\\]]|\\](?!\\]>))+"}
        ],

        comment : [
            {token : "comment.xml", regex : "-->", next : "start"},
            {defaultToken : "comment.xml"}
        ],

        reference : [{
            token : "constant.language.escape.reference.xml",
            regex : "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
        }],

        attr_reference : [{
            token : "constant.language.escape.reference.attribute-value.xml",
            regex : "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
        }],

        tag : [{
            token : ["meta.tag.punctuation.tag-open.xml", "meta.tag.punctuation.end-tag-open.xml", "meta.tag.tag-name.xml"],
            regex : "(?:(<)|(</))((?:" + tagRegex + ":)?" + tagRegex + ")",
            next: [
                {include : "attributes"},
                {token : "meta.tag.punctuation.tag-close.xml", regex : "/?>", next : "start"}
            ]
        }],

        tag_whitespace : [
            {token : "text.tag-whitespace.xml", regex : "\\s+"}
        ],
        // for doctype and processing instructions
        whitespace : [
            {token : "text.whitespace.xml", regex : "\\s+"}
        ],

        // for doctype and processing instructions
        string: [{
            token : "string.xml",
            regex : "'",
            push : [
                {token : "string.xml", regex: "'", next: "pop"},
                {defaultToken : "string.xml"}
            ]
        }, {
            token : "string.xml",
            regex : '"',
            push : [
                {token : "string.xml", regex: '"', next: "pop"},
                {defaultToken : "string.xml"}
            ]
        }],

        attributes: [{
            token : "entity.other.attribute-name.xml",
            regex : "(?:" + tagRegex + ":)?" + tagRegex + ""
        }, {
            token : "keyword.operator.attribute-equals.xml",
            regex : "="
        }, {
            include: "tag_whitespace"
        }, {
            include: "attribute_value"
        }],

        attribute_value: [{
            token : "string.attribute-value.xml",
            regex : "'",
            push : [
                {token : "string.attribute-value.xml", regex: "'", next: "pop"},
                {include : "attr_reference"},
                {defaultToken : "string.attribute-value.xml"}
            ]
        }, {
            token : "string.attribute-value.xml",
            regex : '"',
            push : [
                {token : "string.attribute-value.xml", regex: '"', next: "pop"},
                {include : "attr_reference"},
                {defaultToken : "string.attribute-value.xml"}
            ]
        }]
    };

    if (this.constructor === XmlHighlightRules)
        this.normalizeRules();
};


(function() {

    this.embedTagRules = function(HighlightRules, prefix, tag){
        this.$rules.tag.unshift({
            token : ["meta.tag.punctuation.tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
            regex : "(<)(" + tag + "(?=\\s|>|$))",
            next: [
                {include : "attributes"},
                {token : "meta.tag.punctuation.tag-close.xml", regex : "/?>", next : prefix + "start"}
            ]
        });

        this.$rules[tag + "-end"] = [
            {include : "attributes"},
            {token : "meta.tag.punctuation.tag-close.xml", regex : "/?>",  next: "start",
                onMatch : function(value, currentState, stack) {
                    stack.splice(0);
                    return this.token;
            }}
        ]

        this.embedRules(HighlightRules, prefix, [{
            token: ["meta.tag.punctuation.end-tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
            regex : "(</)(" + tag + "(?=\\s|>|$))",
            next: tag + "-end"
        }, {
            token: "string.cdata.xml",
            regex : "<\\!\\[CDATA\\["
        }, {
            token: "string.cdata.xml",
            regex : "\\]\\]>"
        }]);
    };

}).call(TextHighlightRules.prototype);

oop.inherits(XmlHighlightRules, TextHighlightRules);

exports.XmlHighlightRules = XmlHighlightRules;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/html_highlight_rules',['require','exports','module','../lib/oop','../lib/lang','./css_highlight_rules','./javascript_highlight_rules','./xml_highlight_rules'],function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var lang = require("../lib/lang");
var CssHighlightRules = require("./css_highlight_rules").CssHighlightRules;
var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
var XmlHighlightRules = require("./xml_highlight_rules").XmlHighlightRules;

var tagMap = lang.createMap({
    a           : 'anchor',
    button 	    : 'form',
    form        : 'form',
    img         : 'image',
    input       : 'form',
    label       : 'form',
    option      : 'form',
    script      : 'script',
    select      : 'form',
    textarea    : 'form',
    style       : 'style',
    table       : 'table',
    tbody       : 'table',
    td          : 'table',
    tfoot       : 'table',
    th          : 'table',
    tr          : 'table'
});

var HtmlHighlightRules = function() {
    XmlHighlightRules.call(this);

    this.addRules({
        attributes: [{
            include : "tag_whitespace"
        }, {
            token : "entity.other.attribute-name.xml",
            regex : "[-_a-zA-Z0-9:.]+"
        }, {
            token : "keyword.operator.attribute-equals.xml",
            regex : "=",
            push : [{
                include: "tag_whitespace"
            }, {
                token : "string.unquoted.attribute-value.html",
                regex : "[^<>='\"`\\s]+",
                next : "pop"
            }, {
                token : "empty",
                regex : "",
                next : "pop"
            }]
        }, {
            include : "attribute_value"
        }],
        tag: [{
            token : function(start, tag) {
                var group = tagMap[tag];
                return ["meta.tag.punctuation." + (start == "<" ? "" : "end-") + "tag-open.xml",
                    "meta.tag" + (group ? "." + group : "") + ".tag-name.xml"];
            },
            regex : "(</?)([-_a-zA-Z0-9:.]+)",
            next: "tag_stuff"
        }],
        tag_stuff: [
            {include : "attributes"},
            {token : "meta.tag.punctuation.tag-close.xml", regex : "/?>", next : "start"}
        ]
    });

    this.embedTagRules(CssHighlightRules, "css-", "style");
    this.embedTagRules(new JavaScriptHighlightRules({jsx: false}).getRules(), "js-", "script");

    if (this.constructor === HtmlHighlightRules)
        this.normalizeRules();
};

oop.inherits(HtmlHighlightRules, XmlHighlightRules);

exports.HtmlHighlightRules = HtmlHighlightRules;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/html_completions',['require','exports','module','../token_iterator'],function(require, exports, module) {
"use strict";

var TokenIterator = require("../token_iterator").TokenIterator;

var commonAttributes = [
    "accesskey",
    "class",
    "contenteditable",
    "contextmenu",
    "dir",
    "draggable",
    "dropzone",
    "hidden",
    "id",
    "inert",
    "itemid",
    "itemprop",
    "itemref",
    "itemscope",
    "itemtype",
    "lang",
    "spellcheck",
    "style",
    "tabindex",
    "title",
    "translate"
];

var eventAttributes = [
    "onabort",
    "onblur",
    "oncancel",
    "oncanplay",
    "oncanplaythrough",
    "onchange",
    "onclick",
    "onclose",
    "oncontextmenu",
    "oncuechange",
    "ondblclick",
    "ondrag",
    "ondragend",
    "ondragenter",
    "ondragleave",
    "ondragover",
    "ondragstart",
    "ondrop",
    "ondurationchange",
    "onemptied",
    "onended",
    "onerror",
    "onfocus",
    "oninput",
    "oninvalid",
    "onkeydown",
    "onkeypress",
    "onkeyup",
    "onload",
    "onloadeddata",
    "onloadedmetadata",
    "onloadstart",
    "onmousedown",
    "onmousemove",
    "onmouseout",
    "onmouseover",
    "onmouseup",
    "onmousewheel",
    "onpause",
    "onplay",
    "onplaying",
    "onprogress",
    "onratechange",
    "onreset",
    "onscroll",
    "onseeked",
    "onseeking",
    "onselect",
    "onshow",
    "onstalled",
    "onsubmit",
    "onsuspend",
    "ontimeupdate",
    "onvolumechange",
    "onwaiting"
];

var globalAttributes = commonAttributes.concat(eventAttributes);

var attributeMap = {
    "html": {"manifest": 1},
    "head": {},
    "title": {},
    "base": {"href": 1, "target": 1},
    "link": {"href": 1, "hreflang": 1, "rel": {"stylesheet": 1, "icon": 1}, "media": {"all": 1, "screen": 1, "print": 1}, "type": {"text/css": 1, "image/png": 1, "image/jpeg": 1, "image/gif": 1}, "sizes": 1},
    "meta": {"http-equiv": {"content-type": 1}, "name": {"description": 1, "keywords": 1}, "content": {"text/html; charset=UTF-8": 1}, "charset": 1},
    "style": {"type": 1, "media": {"all": 1, "screen": 1, "print": 1}, "scoped": 1},
    "script": {"charset": 1, "type": {"text/javascript": 1}, "src": 1, "defer": 1, "async": 1},
    "noscript": {"href": 1},
    "body": {"onafterprint": 1, "onbeforeprint": 1, "onbeforeunload": 1, "onhashchange": 1, "onmessage": 1, "onoffline": 1, "onpopstate": 1, "onredo": 1, "onresize": 1, "onstorage": 1, "onundo": 1, "onunload": 1},
    "section": {},
    "nav": {},
    "article": {"pubdate": 1},
    "aside": {},
    "h1": {},
    "h2": {},
    "h3": {},
    "h4": {},
    "h5": {},
    "h6": {},
    "header": {},
    "footer": {},
    "address": {},
    "main": {},
    "p": {},
    "hr": {},
    "pre": {},
    "blockquote": {"cite": 1},
    "ol": {"start": 1, "reversed": 1},
    "ul": {},
    "li": {"value": 1},
    "dl": {},
    "dt": {},
    "dd": {},
    "figure": {},
    "figcaption": {},
    "div": {},
    "a": {"href": 1, "target": {"_blank": 1, "top": 1}, "ping": 1, "rel": {"nofollow": 1, "alternate": 1, "author": 1, "bookmark": 1, "help": 1, "license": 1, "next": 1, "noreferrer": 1, "prefetch": 1, "prev": 1, "search": 1, "tag": 1}, "media": 1, "hreflang": 1, "type": 1},
    "em": {},
    "strong": {},
    "small": {},
    "s": {},
    "cite": {},
    "q": {"cite": 1},
    "dfn": {},
    "abbr": {},
    "data": {},
    "time": {"datetime": 1},
    "code": {},
    "var": {},
    "samp": {},
    "kbd": {},
    "sub": {},
    "sup": {},
    "i": {},
    "b": {},
    "u": {},
    "mark": {},
    "ruby": {},
    "rt": {},
    "rp": {},
    "bdi": {},
    "bdo": {},
    "span": {},
    "br": {},
    "wbr": {},
    "ins": {"cite": 1, "datetime": 1},
    "del": {"cite": 1, "datetime": 1},
    "img": {"alt": 1, "src": 1, "height": 1, "width": 1, "usemap": 1, "ismap": 1},
    "iframe": {"name": 1, "src": 1, "height": 1, "width": 1, "sandbox": {"allow-same-origin": 1, "allow-top-navigation": 1, "allow-forms": 1, "allow-scripts": 1}, "seamless": {"seamless": 1}},
    "embed": {"src": 1, "height": 1, "width": 1, "type": 1},
    "object": {"param": 1, "data": 1, "type": 1, "height" : 1, "width": 1, "usemap": 1, "name": 1, "form": 1, "classid": 1},
    "param": {"name": 1, "value": 1},
    "video": {"src": 1, "autobuffer": 1, "autoplay": {"autoplay": 1}, "loop": {"loop": 1}, "controls": {"controls": 1}, "width": 1, "height": 1, "poster": 1, "muted": {"muted": 1}, "preload": {"auto": 1, "metadata": 1, "none": 1}},
    "audio": {"src": 1, "autobuffer": 1, "autoplay": {"autoplay": 1}, "loop": {"loop": 1}, "controls": {"controls": 1}, "muted": {"muted": 1}, "preload": {"auto": 1, "metadata": 1, "none": 1 }},
    "source": {"src": 1, "type": 1, "media": 1},
    "track": {"kind": 1, "src": 1, "srclang": 1, "label": 1, "default": 1},
    "canvas": {"width": 1, "height": 1},
    "map": {"name": 1},
    "area": {"shape": 1, "coords": 1, "href": 1, "hreflang": 1, "alt": 1, "target": 1, "media": 1, "rel": 1, "ping": 1, "type": 1},
    "svg": {},
    "math": {},
    "table": {"summary": 1},
    "caption": {},
    "colgroup": {"span": 1},
    "col": {"span": 1},
    "tbody": {},
    "thead": {},
    "tfoot": {},
    "tr": {},
    "td": {"headers": 1, "rowspan": 1, "colspan": 1},
    "th": {"headers": 1, "rowspan": 1, "colspan": 1, "scope": 1},
    "form": {"accept-charset": 1, "action": 1, "autocomplete": 1, "enctype": {"multipart/form-data": 1, "application/x-www-form-urlencoded": 1}, "method": {"get": 1, "post": 1}, "name": 1, "novalidate": 1, "target": {"_blank": 1, "top": 1}},
    "fieldset": {"disabled": 1, "form": 1, "name": 1},
    "legend": {},
    "label": {"form": 1, "for": 1},
    "input": {
        "type": {"text": 1, "password": 1, "hidden": 1, "checkbox": 1, "submit": 1, "radio": 1, "file": 1, "button": 1, "reset": 1, "image": 31, "color": 1, "date": 1, "datetime": 1, "datetime-local": 1, "email": 1, "month": 1, "number": 1, "range": 1, "search": 1, "tel": 1, "time": 1, "url": 1, "week": 1},
        "accept": 1, "alt": 1, "autocomplete": {"on": 1, "off": 1}, "autofocus": {"autofocus": 1}, "checked": {"checked": 1}, "disabled": {"disabled": 1}, "form": 1, "formaction": 1, "formenctype": {"application/x-www-form-urlencoded": 1, "multipart/form-data": 1, "text/plain": 1}, "formmethod": {"get": 1, "post": 1}, "formnovalidate": {"formnovalidate": 1}, "formtarget": {"_blank": 1, "_self": 1, "_parent": 1, "_top": 1}, "height": 1, "list": 1, "max": 1, "maxlength": 1, "min": 1, "multiple": {"multiple": 1}, "name": 1, "pattern": 1, "placeholder": 1, "readonly": {"readonly": 1}, "required": {"required": 1}, "size": 1, "src": 1, "step": 1, "width": 1, "files": 1, "value": 1},
    "button": {"autofocus": 1, "disabled": {"disabled": 1}, "form": 1, "formaction": 1, "formenctype": 1, "formmethod": 1, "formnovalidate": 1, "formtarget": 1, "name": 1, "value": 1, "type": {"button": 1, "submit": 1}},
    "select": {"autofocus": 1, "disabled": 1, "form": 1, "multiple": {"multiple": 1}, "name": 1, "size": 1, "readonly":{"readonly": 1}},
    "datalist": {},
    "optgroup": {"disabled": 1, "label": 1},
    "option": {"disabled": 1, "selected": 1, "label": 1, "value": 1},
    "textarea": {"autofocus": {"autofocus": 1}, "disabled": {"disabled": 1}, "form": 1, "maxlength": 1, "name": 1, "placeholder": 1, "readonly": {"readonly": 1}, "required": {"required": 1}, "rows": 1, "cols": 1, "wrap": {"on": 1, "off": 1, "hard": 1, "soft": 1}},
    "keygen": {"autofocus": 1, "challenge": {"challenge": 1}, "disabled": {"disabled": 1}, "form": 1, "keytype": {"rsa": 1, "dsa": 1, "ec": 1}, "name": 1},
    "output": {"for": 1, "form": 1, "name": 1},
    "progress": {"value": 1, "max": 1},
    "meter": {"value": 1, "min": 1, "max": 1, "low": 1, "high": 1, "optimum": 1},
    "details": {"open": 1},
    "summary": {},
    "command": {"type": 1, "label": 1, "icon": 1, "disabled": 1, "checked": 1, "radiogroup": 1, "command": 1},
    "menu": {"type": 1, "label": 1},
    "dialog": {"open": 1}
};

var elements = Object.keys(attributeMap);

function is(token, type) {
    return token.type.lastIndexOf(type + ".xml") > -1;
}

function findTagName(session, pos) {
    var iterator = new TokenIterator(session, pos.row, pos.column);
    var token = iterator.getCurrentToken();
    while (token && !is(token, "tag-name")){
        token = iterator.stepBackward();
    }
    if (token)
        return token.value;
}

function findAttributeName(session, pos) {
    var iterator = new TokenIterator(session, pos.row, pos.column);
    var token = iterator.getCurrentToken();
    while (token && !is(token, "attribute-name")){
        token = iterator.stepBackward();
    }
    if (token)
        return token.value;
}

var HtmlCompletions = function() {

};

(function() {

    this.getCompletions = function(state, session, pos, prefix) {
        var token = session.getTokenAt(pos.row, pos.column);

        if (!token)
            return [];

        // tag name
        if (is(token, "tag-name") || is(token, "tag-open") || is(token, "end-tag-open"))
            return this.getTagCompletions(state, session, pos, prefix);

        // tag attribute
        if (is(token, "tag-whitespace") || is(token, "attribute-name"))
            return this.getAttributeCompletions(state, session, pos, prefix);
            
        // tag attribute values
        if (is(token, "attribute-value"))
            return this.getAttributeValueCompletions(state, session, pos, prefix);
            
        // HTML entities
        var line = session.getLine(pos.row).substr(0, pos.column);
        if (/&[a-z]*$/i.test(line))
            return this.getHTMLEntityCompletions(state, session, pos, prefix);

        return [];
    };

    this.getTagCompletions = function(state, session, pos, prefix) {
        return elements.map(function(element){
            return {
                value: element,
                meta: "tag",
                score: Number.MAX_VALUE
            };
        });
    };

    this.getAttributeCompletions = function(state, session, pos, prefix) {
        var tagName = findTagName(session, pos);
        if (!tagName)
            return [];
        var attributes = globalAttributes;
        if (tagName in attributeMap) {
            attributes = attributes.concat(Object.keys(attributeMap[tagName]));
        }
        return attributes.map(function(attribute){
            return {
                caption: attribute,
                snippet: attribute + '="$0"',
                meta: "attribute",
                score: Number.MAX_VALUE
            };
        });
    };

    this.getAttributeValueCompletions = function(state, session, pos, prefix) {
        var tagName = findTagName(session, pos);
        var attributeName = findAttributeName(session, pos);
        
        if (!tagName)
            return [];
        var values = [];
        if (tagName in attributeMap && attributeName in attributeMap[tagName] && typeof attributeMap[tagName][attributeName] === "object") {
            values = Object.keys(attributeMap[tagName][attributeName]);
        }
        return values.map(function(value){
            return {
                caption: value,
                snippet: value,
                meta: "attribute value",
                score: Number.MAX_VALUE
            };
        });
    };

    this.getHTMLEntityCompletions = function(state, session, pos, prefix) {
        var values = ['Aacute;', 'aacute;', 'Acirc;', 'acirc;', 'acute;', 'AElig;', 'aelig;', 'Agrave;', 'agrave;', 'alefsym;', 'Alpha;', 'alpha;', 'amp;', 'and;', 'ang;', 'Aring;', 'aring;', 'asymp;', 'Atilde;', 'atilde;', 'Auml;', 'auml;', 'bdquo;', 'Beta;', 'beta;', 'brvbar;', 'bull;', 'cap;', 'Ccedil;', 'ccedil;', 'cedil;', 'cent;', 'Chi;', 'chi;', 'circ;', 'clubs;', 'cong;', 'copy;', 'crarr;', 'cup;', 'curren;', 'Dagger;', 'dagger;', 'dArr;', 'darr;', 'deg;', 'Delta;', 'delta;', 'diams;', 'divide;', 'Eacute;', 'eacute;', 'Ecirc;', 'ecirc;', 'Egrave;', 'egrave;', 'empty;', 'emsp;', 'ensp;', 'Epsilon;', 'epsilon;', 'equiv;', 'Eta;', 'eta;', 'ETH;', 'eth;', 'Euml;', 'euml;', 'euro;', 'exist;', 'fnof;', 'forall;', 'frac12;', 'frac14;', 'frac34;', 'frasl;', 'Gamma;', 'gamma;', 'ge;', 'gt;', 'hArr;', 'harr;', 'hearts;', 'hellip;', 'Iacute;', 'iacute;', 'Icirc;', 'icirc;', 'iexcl;', 'Igrave;', 'igrave;', 'image;', 'infin;', 'int;', 'Iota;', 'iota;', 'iquest;', 'isin;', 'Iuml;', 'iuml;', 'Kappa;', 'kappa;', 'Lambda;', 'lambda;', 'lang;', 'laquo;', 'lArr;', 'larr;', 'lceil;', 'ldquo;', 'le;', 'lfloor;', 'lowast;', 'loz;', 'lrm;', 'lsaquo;', 'lsquo;', 'lt;', 'macr;', 'mdash;', 'micro;', 'middot;', 'minus;', 'Mu;', 'mu;', 'nabla;', 'nbsp;', 'ndash;', 'ne;', 'ni;', 'not;', 'notin;', 'nsub;', 'Ntilde;', 'ntilde;', 'Nu;', 'nu;', 'Oacute;', 'oacute;', 'Ocirc;', 'ocirc;', 'OElig;', 'oelig;', 'Ograve;', 'ograve;', 'oline;', 'Omega;', 'omega;', 'Omicron;', 'omicron;', 'oplus;', 'or;', 'ordf;', 'ordm;', 'Oslash;', 'oslash;', 'Otilde;', 'otilde;', 'otimes;', 'Ouml;', 'ouml;', 'para;', 'part;', 'permil;', 'perp;', 'Phi;', 'phi;', 'Pi;', 'pi;', 'piv;', 'plusmn;', 'pound;', 'Prime;', 'prime;', 'prod;', 'prop;', 'Psi;', 'psi;', 'quot;', 'radic;', 'rang;', 'raquo;', 'rArr;', 'rarr;', 'rceil;', 'rdquo;', 'real;', 'reg;', 'rfloor;', 'Rho;', 'rho;', 'rlm;', 'rsaquo;', 'rsquo;', 'sbquo;', 'Scaron;', 'scaron;', 'sdot;', 'sect;', 'shy;', 'Sigma;', 'sigma;', 'sigmaf;', 'sim;', 'spades;', 'sub;', 'sube;', 'sum;', 'sup;', 'sup1;', 'sup2;', 'sup3;', 'supe;', 'szlig;', 'Tau;', 'tau;', 'there4;', 'Theta;', 'theta;', 'thetasym;', 'thinsp;', 'THORN;', 'thorn;', 'tilde;', 'times;', 'trade;', 'Uacute;', 'uacute;', 'uArr;', 'uarr;', 'Ucirc;', 'ucirc;', 'Ugrave;', 'ugrave;', 'uml;', 'upsih;', 'Upsilon;', 'upsilon;', 'Uuml;', 'uuml;', 'weierp;', 'Xi;', 'xi;', 'Yacute;', 'yacute;', 'yen;', 'Yuml;', 'yuml;', 'Zeta;', 'zeta;', 'zwj;', 'zwnj;'];

        return values.map(function(value){
            return {
                caption: value,
                snippet: value,
                meta: "html entity",
                score: Number.MAX_VALUE
            };
        });
    };

}).call(HtmlCompletions.prototype);

exports.HtmlCompletions = HtmlCompletions;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/html',['require','exports','module','../lib/oop','../lib/lang','./text','./javascript','./css','./html_highlight_rules','./behaviour/xml','./folding/html','./html_completions','../worker/worker_client'],function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var lang = require("../lib/lang");
var TextMode = require("./text").Mode;
var JavaScriptMode = require("./javascript").Mode;
var CssMode = require("./css").Mode;
var HtmlHighlightRules = require("./html_highlight_rules").HtmlHighlightRules;
var XmlBehaviour = require("./behaviour/xml").XmlBehaviour;
var HtmlFoldMode = require("./folding/html").FoldMode;
var HtmlCompletions = require("./html_completions").HtmlCompletions;
var WorkerClient = require("../worker/worker_client").WorkerClient;

// http://www.w3.org/TR/html5/syntax.html#void-elements
var voidElements = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "menuitem", "param", "source", "track", "wbr"];
var optionalEndTags = ["li", "dt", "dd", "p", "rt", "rp", "optgroup", "option", "colgroup", "td", "th"];

var Mode = function(options) {
    this.fragmentContext = options && options.fragmentContext;
    this.HighlightRules = HtmlHighlightRules;
    this.$behaviour = new XmlBehaviour();
    this.$completer = new HtmlCompletions();
    
    this.createModeDelegates({
        "js-": JavaScriptMode,
        "css-": CssMode
    });
    
    this.foldingRules = new HtmlFoldMode(this.voidElements, lang.arrayToMap(optionalEndTags));
};
oop.inherits(Mode, TextMode);

(function() {

    this.blockComment = {start: "<!--", end: "-->"};

    this.voidElements = lang.arrayToMap(voidElements);

    this.getNextLineIndent = function(state, line, tab) {
        return this.$getIndent(line);
    };

    this.checkOutdent = function(state, line, input) {
        return false;
    };

    this.getCompletions = function(state, session, pos, prefix) {
        return this.$completer.getCompletions(state, session, pos, prefix);
    };

    this.createWorker = function(session) {
        if (this.constructor != Mode)
            return;
        var worker = new WorkerClient(["ace"], "ace/mode/html_worker", "Worker");
        worker.attachToDocument(session.getDocument());

        if (this.fragmentContext)
            worker.call("setOptions", [{context: this.fragmentContext}]);

        worker.on("error", function(e) {
            session.setAnnotations(e.data);
        });

        worker.on("terminate", function() {
            session.clearAnnotations();
        });

        return worker;
    };

    this.$id = "ace/mode/html";
}).call(Mode.prototype);

exports.Mode = Mode;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/json_highlight_rules',['require','exports','module','../lib/oop','./text_highlight_rules'],function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var JsonHighlightRules = function() {

    // regexp must not have capturing parentheses. Use (?:) instead.
    // regexps are ordered -> the first match is used
    this.$rules = {
        "start" : [
            {
                token : "variable", // single line
                regex : '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]\\s*(?=:)'
            }, {
                token : "string", // single line
                regex : '"',
                next  : "string"
            }, {
                token : "constant.numeric", // hex
                regex : "0[xX][0-9a-fA-F]+\\b"
            }, {
                token : "constant.numeric", // float
                regex : "[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"
            }, {
                token : "constant.language.boolean",
                regex : "(?:true|false)\\b"
            }, {
                token : "invalid.illegal", // single quoted strings are not allowed
                regex : "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
            }, {
                token : "invalid.illegal", // comments are not allowed
                regex : "\\/\\/.*$"
            }, {
                token : "paren.lparen",
                regex : "[[({]"
            }, {
                token : "paren.rparen",
                regex : "[\\])}]"
            }, {
                token : "text",
                regex : "\\s+"
            }
        ],
        "string" : [
            {
                token : "constant.language.escape",
                regex : /\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|["\\\/bfnrt])/
            }, {
                token : "string",
                regex : '[^"\\\\]+'
            }, {
                token : "string",
                regex : '"',
                next  : "start"
            }, {
                token : "string",
                regex : "",
                next  : "start"
            }
        ]
    };
    
};

oop.inherits(JsonHighlightRules, TextHighlightRules);

exports.JsonHighlightRules = JsonHighlightRules;
});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/mode/json',['require','exports','module','../lib/oop','./text','./json_highlight_rules','./matching_brace_outdent','./behaviour/cstyle','./folding/cstyle','../worker/worker_client'],function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var HighlightRules = require("./json_highlight_rules").JsonHighlightRules;
var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;
var WorkerClient = require("../worker/worker_client").WorkerClient;

var Mode = function() {
    this.HighlightRules = HighlightRules;
    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CstyleBehaviour();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);

(function() {

    this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);

        if (state == "start") {
            var match = line.match(/^.*[\{\(\[]\s*$/);
            if (match) {
                indent += tab;
            }
        }

        return indent;
    };

    this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };

    this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };

    this.createWorker = function(session) {
        var worker = new WorkerClient(["ace"], "ace/mode/json_worker", "JsonWorker");
        worker.attachToDocument(session.getDocument());

        worker.on("annotate", function(e) {
            session.setAnnotations(e.data);
        });

        worker.on("terminate", function() {
            session.clearAnnotations();
        });

        return worker;
    };


    this.$id = "ace/mode/json";
}).call(Mode.prototype);

exports.Mode = Mode;
});


define('bower_components/ace/lib/ace/requirejs/text!bower_components/ace/lib/ace/theme/eclipse.css',[],function () { return '.ace-eclipse .ace_gutter {\n  background: #ebebeb;\n  border-right: 1px solid rgb(159, 159, 159);\n  color: rgb(136, 136, 136);\n}\n\n.ace-eclipse .ace_print-margin {\n  width: 1px;\n  background: #ebebeb;\n}\n\n.ace-eclipse {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-eclipse .ace_fold {\n    background-color: rgb(60, 76, 114);\n}\n\n.ace-eclipse .ace_cursor {\n  color: black;\n}\n\n.ace-eclipse .ace_storage,\n.ace-eclipse .ace_keyword,\n.ace-eclipse .ace_variable {\n  color: rgb(127, 0, 85);\n}\n\n.ace-eclipse .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-eclipse .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-eclipse .ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-eclipse .ace_string {\n  color: rgb(42, 0, 255);\n}\n\n.ace-eclipse .ace_comment {\n  color: rgb(113, 150, 130);\n}\n\n.ace-eclipse .ace_comment.ace_doc {\n  color: rgb(63, 95, 191);\n}\n\n.ace-eclipse .ace_comment.ace_doc.ace_tag {\n  color: rgb(127, 159, 191);\n}\n\n.ace-eclipse .ace_constant.ace_numeric {\n  color: darkblue;\n}\n\n.ace-eclipse .ace_tag {\n  color: rgb(25, 118, 116);\n}\n\n.ace-eclipse .ace_type {\n  color: rgb(127, 0, 127);\n}\n\n.ace-eclipse .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-eclipse .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n\n.ace-eclipse .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-eclipse .ace_meta.ace_tag {\n  color:rgb(25, 118, 116);\n}\n\n.ace-eclipse .ace_invisible {\n  color: #ddd;\n}\n\n.ace-eclipse .ace_entity.ace_other.ace_attribute-name {\n  color:rgb(127, 0, 127);\n}\n.ace-eclipse .ace_marker-layer .ace_step {\n  background: rgb(255, 255, 0);\n}\n\n.ace-eclipse .ace_active-line {\n  background: rgb(232, 242, 254);\n}\n\n.ace-eclipse .ace_gutter-active-line {\n  background-color : #DADADA;\n}\n\n.ace-eclipse .ace_marker-layer .ace_selected-word {\n  border: 1px solid rgb(181, 213, 255);\n}\n\n.ace-eclipse .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}';});

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define('bower_components/ace/lib/ace/theme/eclipse',['require','exports','module','../requirejs/text!./eclipse.css','../lib/dom'],function(require, exports, module) {
"use strict";

exports.isDark = false;
exports.cssText = require("../requirejs/text!./eclipse.css");

exports.cssClass = "ace-eclipse";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass);
});

define('cavalion.org/util/Ajax',[],function() {

	return {

		/**
		 * This value may be returned by {Ajax.get}, {Ajax.post} and/or {Ajax.request}
		 * indicating that a HTTP request has failed.
		 */
		REQUEST_FAILED: {},

		/**
		 * Returns a XMLHttpRequest object instance. Note: The first time this function is
		 * called it will reset the function referenced by {Command.getXMLHttpRequest}.
		 */
		getXMLHttpRequest: function() {
	        var tryThese; tryThese = [
	            function () { return new XMLHttpRequest(); },
	            function () { return new ActiveXObject('Msxml2.XMLHTTP'); },
	            function () { return new ActiveXObject('Microsoft.XMLHTTP'); },
	            function () { return new ActiveXObject('Msxml2.XMLHTTP.4.0'); },
	            function () {
	                throw new Error("Browser does not support XMLHttpRequest");
	            }
	        ];
	        for (var i = 0; i < tryThese.length; i++) {
	            var func = tryThese[i];
	            try {
	                this.getXMLHttpRequest = func;
	                return func.apply(this, []);
	            } catch (e) {
	                // pass
	            }
	        }
	        return this.getXMLHttpRequest();
		},

		/**
		 * Performs a HTTP request for the specified uri. The method can be blocking or non-blocking.
		 * In order to be non-blocking the user must specify a callback function for the parameter
		 * async_cb.
		 *
		 * @param method
		 * @param uri
		 * @param async_cb
		 * @param fail_ok
		 * @param content
		 * @returns
		 */
		request: function(method, uri, async_cb, fail_ok, content) {
		    var req = this.getXMLHttpRequest();
		    if (async_cb !== undefined) {
		        req.onreadystatechange = function() {
		        	if (4 === req.readyState && req.status !== undefined) {
		        		if (fail_ok === true || (req.status >= 200 && req.status < 300)) {
		        			async_cb(req.responseText, req, uri);
		        		} else {
	        				throw new Error("Failed to request " + uri);
		        		}
		        	}
		        };
		    }
		    req.open(method, uri, async_cb !== undefined ? true : false);
		    if(typeof req.overrideMimeType === "function") {
			    req.overrideMimeType("application/json");
		    }
		    req.setRequestHeader("Content-Type", "application/json");
		    try {
		        req.send(content || null);
			    if(async_cb === undefined && (req.status < 200 || req.status >= 300)) {
			    	if(fail_ok) {
			    		return undefined;
			    	}
			    	var err = new Error(req.status + " - " + uri);
			    	err.request = req;
			    	throw err;
			    }
			    return async_cb !== undefined ? undefined : req.responseText;
		    } catch (e) {
		        if (fail_ok === true && async_cb === undefined) {
		            return this.REQUEST_FAILED;
		        } else {
		        	throw e;
		        }
		    }
		},

		/**
		 * Lowlevel method to get a resource (using the HTTP GET method).
		 * The method can be blocking or non-blocking. In order to be non-blocking the
		 * user must specify a callback function for the parameter
		 * async_cb.
		 *
		 * @param uri
		 * @param async_cb
		 * @param fail_ok
		 * @returns
		 */
		get: function(uri, async_cb, fail_ok) {
			return this.request("GET", uri, async_cb, fail_ok);
		},

		/**
		 * Lowlevel method to get a resource (using HTTP POST method).
		 * The method can be blocking or non-blocking. In order to be non-blocking the
		 * user must specify a callback function for the parameter
		 * async_cb.
		 *
		 * @param uri
		 * @param content
		 * @param async_cb
		 * @param fail_ok
		 * @returns
		 */
		post: function(uri, content, async_cb, fail_ok) {
			return this.request("POST", uri, async_cb, fail_ok, content);
		}
	};
});
define('cavalion.org/Command',['require','js/Deferred','js','./util/Ajax'],function(require) {

	var Deferred = require("js/Deferred");
	var js = require("js");
	var Ajax = require("./util/Ajax");

	return {

		basePath: "",

		/**
		 *
		 */
		getQueryString: function(obj) {
			var str; str = [];
			for(var k in obj) {
				if(obj[k] !== undefined) {
					str.push(String.format("%s=%s", k, window.escape(
							obj[k]).replace(/\+/g, "%2B")));
				}
			}
			return str.join("&");
		},

		/**
		 *
		 */
		execute: function(command, params, content, parse) {
			var deferred = new Deferred();
			var request = {
				command: command,
				params: params,
				content: content
			};
			var POST = command.indexOf("POST:") === 0;
			if(POST) {
				command = command.substring(5);
			}

			if(typeof content !== "string") {
				content = JSON.stringify(content);
			}
			if(typeof params !== "string") {
				params = this.getQueryString(params || {});
			}

			var uri = String.format("%s%s%s%s", this.basePath, command,
					command.indexOf("?") === -1 ? "?" : "", params);

			var args;
			args = [uri, content, function(resp, req, uri) {
				try {
					var result = parse !== false ? JSON.parse(resp) : resp;
					request.result = result;
					request.req = req;
					request.uri = uri;
					if(req.status >= 200 && req.status < 300) {
						deferred.callback(result);
					} else {
						var msg = String.format("%d - %s", req.status, result.message);
						deferred.errback(js.mixIn(new Error(msg), {
							status: req.status,
							result: result,
							request: request
						}));
					}
				} catch(ex) {
					if(deferred.fired === -1) {
						var obj = {
								status: req.status,
								response: "" + resp,
								request: request,
								exception: ex
							};

						if(obj.response.indexOf("<html") === 0) {
//							var node = document.createElement("div");
//							node.innerHTML = obj.response;
//							obj.response = node.textContent;
						}
						if(req.status === 0) {
							deferred.errback(js.mixIn(new Error("Fatal: No network"), obj));
						} else {
							deferred.errback(js.mixIn(new Error(
									String.format("Fatal: Invalid response from server (%d)",
											req.status)), obj));
						}
					}
				}
			}, true];

			// no content? -> GET otherwise POST
			if(!POST && args[1] === undefined) {
				args.splice(1, 1);
				Ajax.get.apply(Ajax, args);
			} else {
				Ajax.post.apply(Ajax, args);
			}
			return deferred;
		}
	};

});

/**
 * SourceState.js
 */
define('cavalion.org/data/SourceState',['require'],function(require) {
	return {
		busy: 0x0001,
	//	opening: 0x0002,
	//	closing: 0x0004,
	//	deleting: 0x0008,
	//	posting: 0x0010,
	//	canceling: 0x0020,
	//	scrolling: 0x0040,
		updating: 0x0080,
		active: 0x0100,
		readOnly: 0x0200,
	//	editing: 0x0400,
	//	appending: 0x0800,
		eof: 0x1000,
		bof: 0x2000,
		hasAttributes: 0x4000,
		objectChanged: 0x8000
	};
});

define('cavalion.org/data/SourceEvent',['require'],function(require) {
	return {
		changed: "changed",
		updated: "updated",
		activeChanged: "activeChanged",
		busyChanged: "busyChanged",
		dirtyChanged: "dirtyChanged",
		attributesChanged: "attributesChanged",
		layoutChanged: "layoutChanged"
	};
});

define('cavalion.org/data/Source',['require','./SourceState','./SourceEvent'],function(require) {

//	var Interface = require("js/Interface");
	var SourceState = require("./SourceState");
	var SourceEvent = require("./SourceEvent");

	var Source = {

		prototype: {
			getSize: function() {
				/** Returns the number of objects this source manages */
			},
			getObject: function(index) { 
				/** Returns the 'index'th object */ 
			},
			getObjects: function(start, end) { 
				/** Returns a js/Deferred */ 
			},
			getMonitor: function(start, end) { 
				/** Returns a ./SourceMonitor */ 
			},
			releaseMonitor: function(monitor) {},
			isActive: function() {
				return true;
			},
			isBusy: function() {
				return false;
			},
			isDirty: function() {},
			notifyEvent: function(event, data) {},
			getAttributeNames: function() {},
			getAttributeValue: function(name, index) {},
			setAttributeValue: function(name, value, index) {}

		},

		/**
		 *
		 */
		statics: {

			State: SourceState,
			Event: SourceEvent
		},

		Pending: {}

	};

//	return (Source = Interface.define(require, Source));
	return Source;
});
/**
 * DocumentHook.js
 */
define('cavalion.org/util/DocumentHook',['require','js/defineClass','./Event','./Browser','module'],function(require) {

	var DocumentHook = require("js/defineClass");
	var Event = require("./Event");
	var Browser = require("./Browser");
	var module = require("module");

	var registry = module.id;

	DocumentHook = DocumentHook(require, {

		prototype: {

			// _saved: null,
			_events: [
			    "ontransitionend",
			    "ontouchstart", "ontouchend", "ontouchmove", "ontap", "ondbltap", "ongesture",
				"onclick", "ondblclick",
				"onmousemove", "onmousedown", "onmouseup", "onmousewheel", "onmouseenter", "onmouseleave",
				"onkeydown", "onkeyup", "onkeypress",
				"onfocus", "onblur",
				"ondragstart", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondrag", "ondrop"
			],

			_parent: null,
			_bubbleUp: true,
			_evt: null,
			_saved: null,

			_startDragDelay: 100,  // 16 is the resolution?  2 ticks?, let's try higher
			_startDragPixels: 3,  // have to move at least 3 pixels

			/**
			 *
			 * @param events
			 * @param bubbleUp
			 */
			constructor: function(events, bubbleUp, impl) {
				if(events !== undefined) {
					this._events = events;
				}
				if(bubbleUp !== undefined) {
					this._bubbleUp = bubbleUp;
				}

				impl && this.override(impl, true);
			},

			/**
			 *
			 */
			activate: function() {
				var saved;
				if(document[registry] === this) {
					throw new Error("Already active");
				}
				this._parent = document[registry] || null;
	//			if(this._parent === null) {
					saved = this._saved = {};
					this._events.forEach(function(name) {
						if(name === "onmousewheel") {
							name = "onwheel";
						}
						saved[name] = document[name] || DocumentHook.NULL;
						document[name] = DocumentHook.handleEvent;
					});
	//			}
				document[registry] = this;
			},

			/**
			 *
			 */
			release: function() {
				if(document[registry] !== this) {
					throw new Error("Not active");
				}
				if(this._parent !== null) {
					document[registry] = this._parent;
				} else {
					for(var k in this._saved) {
						document[k] = this._saved[k];
					}
					delete document[registry];
				}
			},

			/**
			 *
			 */
			isActive: function() {
				return document[registry] === this;
			},

			/**
			 *
			 */
			bubbleUp: function(evt, type) {
				var r;

				if(type === "mousewheel") {
					type = "wheel";
				}

				if(this._parent !== null) {
					r = this._parent.handle(evt);
				} else {
					var f = this._saved["on" + type];
					if(f === undefined) {
						// FIXME
						//f = document["on" + type];
					}
					if(typeof f === "function") {
						r = f.apply(document, arguments);
					} else {
						// console.log(String.format("%s can't be bubbled up", evt.type));
					}
				}

				return r;
			},

			/**
			 *
			 */
			getType: function(evt) {
				var type = evt.type;
				if(Browser.mozilla && type === "DOMMouseScroll") {
					type = "mousewheel";
				} else if(type === "webkitTransitionEnd") {
					type = "transitionend";
				}
				return type;
			},

			/**
			 *
			 */
			handle: function(evt) {
				var type = this.getType(evt);
				var r;

				if(this._events[0] === "*" || this._events.indexOf("on" + type) !== -1) {
					r = this.handleEvent(evt, type);
					if(r === DocumentHook.BUBBLE_UP || (this._bubbleUp === true && evt.bubbleUp !== false)) {
						r = this.bubbleUp(evt, type);
					}
				} else {
	//				console.log(this, String.format("ignoring event type: %s - bubbleUp", evt.type));
					r = this.bubbleUp(evt, type);
				}
				return r;
			},

			/**
			 *
			 */
			handleEvent: function(evt, type) {
				var f = this[type];
				if(typeof f === "function") {
					return f.apply(this, [evt]);
				}
			}
		},

		statics: {

			NULL: {},

			BUBBLE_UP: {},

			/**
			 *
			 */
			handleEvent: function(e) {
				var evt = Event.fix(e);
				var hook = document[registry];
evt.time = Date.now();
				if(hook) {
					hook.handle(evt);
				} else {
					console.log(String.format("received event type %s, but there is no handler active", evt.type));
				}
			}

		}
	});

	document.onwheel = function(evt) {};

	/**
	 *
	 */
	document.ondragstart = function() {
		return false;
	};

	document.ontransitionend = function(evt) {};

	/**
	 *
	 * @param e
	 * @return
	 */
	function wheelIE(e) {
		var delta = 0;
	    var evt = window.event;
        if(evt.wheelDelta) {
            delta = evt.wheelDelta / 120;
            if (window.opera) {
	            delta = -delta;
            }
        }
        evt.mouseWheelDelta = delta;
        document.onwheel(evt);
	}

	/**
	 *
	 * @param evt
	 * @return
	 */
	function wheelMozilla(evt) {
		var delta = 0;
        if (evt.detail) {
            delta = -evt.detail / 3;
        }
        evt.mouseWheelDelta = delta;
        document.onwheel(evt);
	}

	/**
	 *
	 * @param evt
	 * @return
	 */
	function wheelWebkit(evt) {
        evt.mouseWheelDelta = evt.wheelDelta / 120;
        document.onwheel(evt);
	}

	if(window.addEventListener) {
		if(Browser.webkit) {
			window.addEventListener('mousewheel', wheelWebkit, false);
		} else {
			window.addEventListener('DOMMouseScroll', wheelMozilla, false);
		}
	} else {
		window.onmousewheel = document.onmousewheel = wheelIE;
	}

	if(document.addEventListener) {
		//if(Browser.webkit) {
			document.addEventListener("webkitTransitionEnd", function(evt) {
				document.ontransitionend(evt);
			}, false);

			document.addEventListener("focus", function(evt) {
				document.onfocus(evt);
			}, true);

			document.addEventListener("blur", function(evt) {
				document.onblur(evt);
			}, true);

			document.addEventListener("dragstart", function(evt) {
				document.ondragstart(evt);
			}, false);

		//}
	}

	return DocumentHook;
});
define('cavalion.org/util/Fullscreen',[],function() {

	var requested = false;

	return {

		request: function(element) {
		    if (element.requestFullscreen) {
		        element.requestFullscreen();
		    } else if (element.mozRequestFullScreen) {
		        element.mozRequestFullScreen();
		    } else if (element.webkitRequestFullscreen) {
		        element.webkitRequestFullscreen();
		    } else if (element.msRequestFullscreen) {
		        element.msRequestFullscreen();
		    }
		    requested = true;
		},

		exit: function() {
		    if (document.exitFullscreen) {
		        document.exitFullscreen();
		    } else if (document.mozCancelFullScreen) {
		        document.mozCancelFullScreen();
		    } else if (document.webkitExitFullscreen) {
		        document.webkitExitFullscreen();
		    }
		},

		getElement: function() {
			return document.fullscreenElement ||
				document.mozFullScreenElement ||
				document.webkitFullscreenElement ||
				document.msFullscreenElement;
		},

		isFullscreen: function() {
			return !!this.getElement();
		},

		hasRequested: function() {
			return requested;
		},

		addChangeEventListener: function(listener, capture) {
		    if (document.exitFullscreen) {
		        document.addEventListener("fullscreenchange", listener, capture);
		    } else if (document.mozCancelFullScreen) {
		        document.addEventListener("mozfullscreenchange", listener, capture);
		    } else if (document.webkitExitFullscreen) {
		        document.addEventListener("webkitfullscreenchange", listener, capture);
		    } else if (document.msExitFullscreen) {
		        document.addEventListener("msfullscreenchange", listener, capture);
		    }
		},

		removeChangeEventListener: function(listener) {
		    if (document.exitFullscreen) {
		        document.removeEventListener("fullscreenchange", listener);
		    } else if (document.mozCancelFullScreen) {
		        document.removeEventListener("mozfullscreenchange", listener);
		    } else if (document.webkitExitFullscreen) {
		        document.removeEventListener("webkitfullscreenchange", listener);
		    } else if (document.msExitFullscreen) {
		        document.removeEventListener("msfullscreenchange", listener);
		    }
		}

	};

});
/**
 * Keyboard.js
 */
define('cavalion.org/util/Keyboard',[],function () {

    var specialKeys = {
        8: 'KEY_BACKSPACE',
        9: 'KEY_TAB',
        12: 'KEY_NUM_PAD_CLEAR',
        // weird, for Safari and Mac FF only
        13: 'KEY_ENTER',
        16: 'KEY_SHIFT',
        17: 'KEY_CTRL',
        18: 'KEY_ALT',
        19: 'KEY_PAUSE',
        20: 'KEY_CAPSLOCK',
        27: 'KEY_ESCAPE',
        32: 'KEY_SPACEBAR',
        33: 'KEY_PAGEUP',
        34: 'KEY_PAGEDOWN',
        35: 'KEY_END',
        36: 'KEY_HOME',
        37: 'KEY_LEFT',
        38: 'KEY_UP',
        39: 'KEY_RIGHT',
        40: 'KEY_DOWN',
        44: 'KEY_PRINTSCREEN',
        45: 'KEY_INSERT',
        46: 'KEY_DELETE',
        59: 'KEY_SEMICOLON',
        // weird, for Safari and IE only
        91: 'KEY_WINDOWS_LEFT',
        92: 'KEY_WINDOWS_RIGHT',
        93: 'KEY_SELECT',
        106: 'KEY_NUM_PAD_ASTERISK',
        107: 'KEY_NUM_PAD_PLUS_SIGN',
        109: 'KEY_NUM_PAD_HYPHEN-MINUS',
        110: 'KEY_NUM_PAD_FULL_STOP',
        111: 'KEY_NUM_PAD_SOLIDUS',

        112: 'KEY_F1',
        113: 'KEY_F2',
        114: 'KEY_F3',
        115: 'KEY_F4',
        116: 'KEY_F5',
        117: 'KEY_F6',
        118: 'KEY_F7',
        119: 'KEY_F9',
        120: 'KEY_F10',
        121: 'KEY_F11',
        122: 'KEY_F12',

        144: 'KEY_NUM_LOCK',
        145: 'KEY_SCROLLLOCK',
        186: 'KEY_SEMICOLON',
        187: 'KEY_EQUALS_SIGN',
        188: 'KEY_COMMA',
        189: 'KEY_HYPHEN-MINUS',
        190: 'KEY_FULL_STOP',
        191: 'KEY_SOLIDUS',
        192: 'KEY_GRAVE_ACCENT',
        219: 'KEY_LEFT_SQUARE_BRACKET',
        220: 'KEY_REVERSE_SOLIDUS',
        221: 'KEY_RIGHT_SQUARE_BRACKET',
        222: 'KEY_APOSTROPHE'
        // undefined: 'KEY_UNKNOWN'
    };

    return {

        /**
         *
         */
        getKeyNames: function () {
            var r;
            r = [];
            for (var k in specialKeys) {
                r.push(specialKeys[k]);
            }
            return r;
        },

        /**
         *
         */
        getKeyCode: function (keyName) {
            for (var k in specialKeys) {
                if (specialKeys[k] === keyName) {
                    return parseInt(k, 10);
                }
            }
        }
    };

});
define('cavalion.org/util/HotkeyManager',['require','js/defineClass','./DocumentHook','./Event','./Keyboard'],function(require) {

	var HotkeyManager = require("js/defineClass");
	var DocumentHook = require("./DocumentHook");
	var Event = require("./Event");
    var Keyboard = require("./Keyboard");

	function checkAndCall(li, evt, type) {
		if((!li.hasOwnProperty("type") || li.type === "*" || li.type === type) 
		    && (!li.hasOwnProperty("modifiers") || Event.modifiersMatch(evt, 
		    li.modifiers)) && (typeof li.isEnabled !== "function" || 
		    li.isEnabled(evt, type))
        ) {
            return li.callback(evt, type);
		}
	}

	return (HotkeyManager = HotkeyManager(require, {

		inherits: DocumentHook,

		prototype: {

			/**
			 *
			 */
			constructor: function() {
				this._listeners = {};
			},

			_events: ["onkeydown", "onkeyup", "onkeypress"],
			_listeners: null,

			/**
			 *
			 */
			register: function(hotkey, li) {
				if(typeof li === "object") {
					if(typeof hotkey === "string") {					
						li.modifiers = hotkey.toLowerCase().split("+");
						if((li.keyCode = li.modifiers.pop()) !== "*") {
							if(li.keyCode < "0" || li.keyCode > "9") {
	                            if(li.keyCode.length === 1) {
	                                li.keyCode = li.keyCode.toUpperCase()
	                                	.charCodeAt(0);
	                            } else {
	                                li.keyCode = Keyboard.getKeyCode("KEY_" + 
	                                	li.keyCode.toUpperCase());
	                            }
							} else {
								li.keyCode = parseInt(li.keyCode, 10);
							}
						}
					} else {
						li.modifiers = [];
						li.keyCode = hotkey;
					}
					li = this.register(li);
				} else {
					li = hotkey;

					var arr = this._listeners[li.keyCode];
					if(arr === undefined) {
						arr = this._listeners[li.keyCode] = [];
					}
					arr.push(li);
				}
				return li;
			},

			/**
			 *
			 */
			unregister: function(li) {
				var arr = this._listeners[li.keyCode];
				if(arr === undefined) {
					throw new Error("Listener was not registered");
				}
				var index = arr.indexOf(li);
				if(index === -1) {
					throw new Error("Listener was not registered");
				}
				arr.splice(index, 1);
				if(arr.length === 0) {
					delete this._listeners[li.keyCode];
				}
			},

			/**
			 *
			 */
			handleEvent: function(evt, type) {
				var i, arr;
				if((arr = this._listeners[evt.keyCode]) !== undefined) {
					for(i = 0; i < arr.length; ++i) {
					    checkAndCall(arr[i], evt, type);
					}
				}
				if((arr = this._listeners["*"]) !== undefined) {
					for(i = 0; i < arr.length; ++i) {
                        checkAndCall(arr[i], evt, type);
					}
				}
			}
		},

		statics: {

			instance: null,

			/**
			 *
			 */
			getInstance: function() {
				if(this.instance === null) {
					this.instance = new HotkeyManager();
					this.instance.activate();
				}
				return this.instance;
			},

			/**
			 *
			 */
			initialize: function() {
				return this.getInstance();
			},

			/**
			 *
			 */
			register: function() {
				return HotkeyManager.prototype.register.apply(this.getInstance(), arguments);
			},

			/**
			 *
			 */
			unregister: function(li) {
				return HotkeyManager.prototype.unregister.apply(this.getInstance(), arguments);
				//return this.getInstance().unregister(li);
			}
		}
	}));
});
define('cavalion.org/util/Rest',['require','./Ajax','cavalion.org/Command'],function(require) {

	var Ajax = require("./Ajax");
	var Command = require("cavalion.org/Command");

	var Rest = {

		call: function(method, url, options) {

			if(options.parameters !== undefined) {
				url += Command.getQueryString(options.parameters);
			}

			Ajax.request(method, url,
					options.callback, true, options.content);
		}
	};


	return Rest;

});
define('cavalion.org/util/Stylesheet',['require','js','./Browser','./Ajax','module'],function(require) {

	var js = require("js");
	var Browser = require("./Browser");
	var Ajax = require("./Ajax");
	var module = require("module");

	var cssRuleCount = 0;
	var namePath = module.id.replace(/\//g, "-");
	var selectors = [];
	var loaded = [];

	var Stylesheet = {

		/**
		 *
		 */
		require: function(uri, version, insert, callback) {
			if(loaded.indexOf(uri) === -1) {
				if(insert === true) {
					var head = document.getElementsByTagName("head")[0];
					var link = document.createElement("link");

					if(callback) {
						link.onload = function() {
							callback();
						};
					}

					link.setAttribute("rel", "stylesheet");
					link.setAttribute("href", uri);
					head.insertBefore(link, head.childNodes[loaded.length]);
				} else {
					var css = Ajax.get(uri);
					var head = document.getElementsByTagName("head")[0];
					var style = document.createElement("style");
					style.setAttribute("type", "text/css");
					if (style.styleSheet) {
						style.styleSheet.cssText = css;
					} else {
						var cssText = document.createTextNode(css);
						style.appendChild(cssText);
					}
					head.appendChild(style);
				}
				loaded.push(uri);
			}
		},

		/**
		 *
		 */
		generateSelector: function(prefix) {

			// FIXME String.format("%x/X", i);
			function intToHex(i) {
				var r = i ? "" : "0";
				for(; i > 0; i >>= 4) {
					var d = i & 15;
					if(d >= 10) {
						d = "ABCDEF".charAt(d - 10);
					}
					r = d + r;
				}
				return r;
			}

			if(prefix === undefined) {
				return ".z" + intToHex(cssRuleCount++);
			}

			if(selectors.indexOf(prefix) !== -1) {
				var i = 1;
				while(selectors.indexOf(prefix + intToHex(++i)) !== -1);
				prefix += intToHex(i);
			}

			return "." + prefix;
		},

		/**
		 *
		 */
		validateStyle: function(style) {
			if(Browser.webkit) {
				return style;
			}
			if(style && style['float'] !== undefined) {
				style.cssFloat = style.styleFloat = style['float'];
				delete style['float'];
			}
			var r = {};
			for(var key in style) {
				var value = style[key];
				if(key.indexOf("-") !== -1) {
					key = key.split("-");
					for(var i = 1, l = key.length; i < l; ++i) {
						key[i] = key[i].charAt(0).toUpperCase() + key[i].substring(1);
					}
					key = key.join("");
				}
				r[key] = value;
			}
			return r;
		},

		/**
		 *
		 */
		getStylesheet: function(priority) {
			var id = namePath + "_" + priority;
			var el = document.getElementById(id);

			if(el === null) {
				if(priority > 0) {
					this.getStylesheet(priority - 1);
				}
				el = document.createElement("style");
			    el.setAttribute("type", "text/css");
				el.id = id;
				document.getElementsByTagName("head")[0].appendChild(el);
			}

			return el.sheet || el.styleSheet;
		},

		/**
		 *
		 */
		createCssRule: function(style, priority, selector) {
			// TODO more of these bugs?

			if(typeof style === "string") {
				style = js.str2obj(style);
			}

			style = this.validateStyle(style);

			var sheet = this.getStylesheet(priority);

			var index;
			if(sheet.cssRules !== undefined) { // W3
				index = sheet.cssRules.length;
			} else if(sheet.rules !== undefined) { // IE
				index = sheet.rules.length;
			} else {
				// fail
				console.log(this, String.format("Could not create cssRule with priority %d", priority));
				return null;
			}

			if(selector === undefined) {
				selector = this.generateSelector();
			}

			if(sheet.insertRule) { // W3
				try {
					sheet.insertRule(selector + "{}", index);
				} catch(e) {
					//console.error(selector);
					//throw e;
				}
			} else if(sheet.addRule) { // IE
				sheet.addRule(selector, null, index);
			} else {
				// fail
				throw new Error(String.format("Could not add or insert rule with priority %d", priority));
			}

			var rules = sheet.rules || sheet.cssRules;
			var rule = rules[rules.length - 1];
			Stylesheet.styleToRule(style, rule);
			return rule;
		},

		/**
		 *
		 *
		 * @param style
		 * @param rule
		 */
		styleToRule: function(style, rule) {
			var set = rule.style.setAttribute ?
				function(key, value) {
					this.style.setAttribute(key, value);
				}
			:
				function(key, value) {
					this.style[key] = value;
				};

			var get = rule.style.setAttribute ?
					function(key) {
						return this.style.getAttribute(key);
					}
				:
					function(key) {
						return this.style[key];
					};

			for(var key in style) {
				try {
					var value = style[key];
					if(typeof value !== "object") {
						set.apply(rule, [key, value]);
					} else {
						if(get.apply(rule, [key]) !== "") {
							throw new Error("Can not safely do this");
						}
						for(var i = 0; i < value.length; ++i) {
							var val = String(value[i]);
							set.apply(rule, [key, val]);
							if(get.apply(rule, [key]) !== "") {
								break;
							}
							console.log(get.apply(rule, [key]).toLowerCase(), "!==", val);
						}
					}
				} catch(e) {
					console.log(String.format("%s := %s -> %s", key, value, e.message));
				}
			}
		},

		/**
		 *
		 */
		destroyCssRule: function(rule) {
			rule.style.cssText = "";
			//TODO js.print(this, "not implemented yet");
		}

	};

	return Stylesheet;
});
define('cavalion.org/util/Xml',[],function() {
    
    var Xml = {
        
        /**
         * 
         */
        beautify: function (xml) {
            var formatted = "";
            var reg = /(>)(<)(\/*)/g;
            xml = xml.replace(reg, "$1\n$2$3");
            var pad = 0;
            xml.split("\n").forEach(function (node, index) {
                var indent = 0;
                if (node.match(/.+<\/\w[^>]*>$/)) {
                    indent = 0;
                } else if (node.match(/^<\/\w/)) {
                    if (pad !== 0) {
                        pad -= 1;
                    }
                } else if (node.match(/^<\w[^>]*[^\/]>.*$/)) {
                    indent = 1;
                } else {
                    indent = 0;
                }
        
                var padding = "";
                for (var i = 0; i < pad; i++) {
                    padding += "\t";
                }
        
                formatted += padding + node + "\n";
                pad += indent;
            });
        
            return formatted;
        }
    };
    
    return Xml;
});

define('vcl/EventDispatcher',['require','js/defineClass','js','js/referenceClass!./ui/Panel','cavalion.org/util/DocumentHook'],function(require) {

	var EventDispatcher = require("js/defineClass");
	var js = require("js");
	var Panel = require("js/referenceClass!./ui/Panel");
	var DocumentHook = require("cavalion.org/util/DocumentHook");

	var elementKey = "@vcl";

	var timeout;
	window.addEventListener("resize", function() {
		if(timeout !== undefined) {
			clearTimeout(timeout);
		}

		timeout = setTimeout(function(evt) {
			timeout = undefined;
			var nodes = document.body.childNodes;
			for(var i = 0; i < nodes.length; ++i) {
				var component = nodes[i][elementKey];
				if(component instanceof Panel) {
					if(component._align && component._align !== "none") {
						component.dispatch("resize", evt);
					}
				}
			}
		}, 30);

	}, false);

	return (EventDispatcher = EventDispatcher(require, {

		inherits: DocumentHook,

		prototype: {

			_component: null,
			_mousemove_evt: null,

			/**
			 *
			 */
			constructor: function() {
				this._events = ["*"].concat(this._events);
			},

			/**
			 *
			 */
			dispatch: function(component, name, evt) {
				var r;
				if(typeof this[name] === "function") {
					r = this[name](evt, component);
					// TODO can events be cancelled?
				}
				if(component !== null) {
					r = component.dispatch(name, evt);
				}
				if(r === undefined && this._bubbleUp === true) {
					r = DocumentHook.BUBBLE_UP;
				}

				return r;
			},

			/**
			 *
			 */
			handle: function(evt) {

				/**
				 *
				 */
                function dispatch_hint() {
					this.dispatch(this._component, "hint", this._mousemove_evt);
				}

				var type = this.getType(evt);
				var node = evt.target || null; // IE
				var r;

				while(node !== null && node[elementKey] === undefined) {
					node = node.parentNode || null; // IE
				}

				var component = node !== null ? node[elementKey] : null;
				evt.component = component;

				r = this.dispatch(component, type, evt);

				if(evt.type === "mousemove") {
					this._mousemove_evt = evt;
					if(this._component !== component) {
						if(this._component !== null) {
							this.dispatch(this._component, "mouseleave", evt);
							js.clearTimeout(this._timeout);
						}
						this._component = component;
						if(this._component !== null) {
							this.dispatch(this._component, "mouseenter", evt);
							this._timeout = js.setTimeout(dispatch_hint.bind(this), 250);
						}
					}
					if(this._mousedown_drag !== undefined && this._component === this._mousedown_drag.component) {
						var dt = new Date().getTime() - this._mousedown_drag.time;
						var dx = Math.abs(evt.clientX - this._mousedown_drag.evt.clientX);
						var dy = Math.abs(evt.clientY - this._mousedown_drag.evt.clientY);
						if(dt > this._startDragDelay || dx > this._startDragPixels || dy > this._startDragPixels) {
							this.dispatch(this._component, "dragstart", evt);
							delete this._mousedown_drag;
						}
					}
					//FIXME dragend?
				} else if(evt.type === "mousedown") {// && evt.which === 1) {
					this._mousedown_drag = {
						component: this._component,
						evt: evt,
						time: new Date().getTime()
					};
					this._mousedown_component = this._component;

				} else if(evt.type === "mouseup") {

					// When dragging, the mousebutton can be released while the mouse is no longer
					// positioned over the original component. If this is the case, fire a mouseup event
					// for the original component as well.
					if(this._mousedown_component !== undefined && this._mousedown_component !== component) {
						this.dispatch(this._mousedown_component, type, evt);
					}

					delete this._mousedown_drag;
					delete this._mousedown_component;
				}

				if(r === DocumentHook.BUBBLE_UP && evt.bubbleUp !== false) {
					r = this.bubbleUp.apply(this, arguments);
				}
				return r;
			}
		},

		statics: {

			elementKey: elementKey,

			/**
			 * @overrides DocumentHook.handleEvent
			 */
			handleEvent: DocumentHook.handleEvent

		}
	}));
});



define('vcl/Action',['require','js/defineClass','js/referenceClass!./Action','./Component','js/Type','js/Method','js/referenceClass!./Control','cavalion.org/util/HotkeyManager'],function (require) {

    var Action = require("js/defineClass");
    var Action_Referenced = require("js/referenceClass!./Action");
    var Component = require("./Component");
    var Type = require("js/Type");
    var Method = require("js/Method");
    var Control = require("js/referenceClass!./Control");

    var HotkeyManager = require("cavalion.org/util/HotkeyManager");

    var ActionProperty = [true, false, "state", "notState", "parent", "leave"];
    var ActionState = [true, false, "parent"];

    return (Action = Action(require, {

        inherits: Component,

        prototype: {
            _onExecute: null,
            _onUpdate: null,
            _onChange: null,
            _onGetContent: null,

            _content: "",
            _checked: "leave",
            _enabled: true,
            _hint: "",
            _visible: true,
            _state: true,
            _selected: "leave",
            _stateIndex: -1,

            _hotkey: "",
            _hotkeyListeners: null,

            _parent: null,
            _parentExecute: false,
            
            destroy: function () {
	            /**
	             * @overrides ./Component.prototype.destroy
	             */
                this.setParent(null);
                this.inherited(arguments);
            },
            getRunningState: function () {
                if (this._state === "parent") {
                    return this._parent !== null ? 
                    		this._parent.getRunningState() : false;
                }
                return this._state;
            },
            updateStates: function () {
                var components = this._owner._components;
                if (components !== undefined) {
                    for (var i = 0; i < components.length; ++i) {
                        var action = components[i];
                        if (action instanceof Action && action !== this && 
                        		action._stateIndex === this._stateIndex) {
                            action.setState(false);
                        }
                    }
                }
            },
            execute: function (evt, sender) {
            	if(evt) evt.sender = evt.sender || sender;
                if (this._parent !== null && this._parentExecute === true) {
                    return this._parent.execute(evt, sender);
                } else if (this._onExecute !== null) {
                    return this.fire("onExecute", arguments);
                }
            },
            update: function() {
            	this.fire("onUpdate", js.copy_args(arguments));	
            },
            toggleState: function () {
                this.setState(!this.getState());
                return this._state;
            },
            onchange: function (evt) {
                if (!this.isDesigning()) {
                    this.fire("onChange", arguments);
                }
            },
            isChecked: function () {
                switch (this._checked) {
                case "state":
                    return this.getRunningState();

                case "notState":
                    return !this.getRunningState();

                case "parent":
                    return this._parent !== null ? this._parent.isChecked() : false;

                default:
                    return this._checked;
                }
            },
            isEnabled: function () {
                switch (this._enabled) {
                case "state":
                    return this.getRunningState();

                case "notState":
                    return !this.getRunningState();

                case "parent":
                    return this._parent !== null ? this._parent.isEnabled() : false;

                default:
                    return this._enabled;
                }
                return false;
            },
            isVisible: function () {
                switch (this._visible) {
                case "state":
                    return this.getRunningState();

                case "notState":
                    return !this.getRunningState();

                case "parent":
                    return this._parent !== null ? this._parent.isVisible() : false;

                default:
                    return this._visible;
                }
                return false;
            },
            isSelected: function () {
                switch (this._selected) {
                case "state":
                    return this.getRunningState();

                case "notState":
                    return !this.getRunningState();

                case "parent":
                    return this._parent !== null ? this._parent.isSelected() : false;

                default:
                    return this._selected;
                }
            },
            isHotkeyEnabled: function() {
                if(this._owner instanceof Control) {
                    if(this._owner.isEnabled() === false || this._owner.isVisible() === false) {
                    	// console.log(this, "hotkey not enabled/visible");
                        return false;
                    }
                } else if(this._owner === null) {
                    return false;
                }

                return true;
            },
            parentChanged: function () {
                this.dispatch("change", {what:["parent"]});
            },
            parentDestroyed: function () {
                this.setParent(null);
            },
            getParent: function () {
                return this._parent;
            },
            setParent: function (value) {
                if (this._parent !== value) {

                    // FIXME need a hasParent()
                    if (value === this) {
                        throw new Error("Circular reference");
                    }

                    if (this._parent !== null) {
                        Method.disconnect(this._parent, "onchange", this, "parentChanged");
                        Method.disconnect(this._parent, "destroy", this, "parentDestroyed");
                    }
                    this._parent = value;
                    if (this._parent !== null) {
                        Method.connect(this._parent, "onchange", this, "parentChanged");
                        Method.connect(this._parent, "destroy", this, "parentDestroyed", "before");
                    }
                    this.dispatch("change", {what:["parent"]});
                }
            },
            getOnExecute: function () {
	            /**
	             * Returns the -onExecute- property.
	             */
                return this._onExecute;
            },
            setOnExecute: function (value) {
	            /**
	             * Sets the -onExecute- property.
	             */
                if (this._onExecute !== value) {
                    this._onExecute = value;
                    this.dispatch("change", {what:["onExecute"]});
                }
            },
            getOnUpdate: function () {
	            /**
	             * Returns the -onUpdate- property.
	             */
                return this._onUpdate;
            },
            setOnUpdate: function (value) {
	            /**
	             * Sets the -onUpdate- property.
	             */
                if (this._onUpdate !== value) {
                    this._onUpdate = value;
                    this.dispatch("change", {what:["onUpdate"]});
                }
            },
            getOnGetContent: function () {
	            /**
	             * Returns the -onGetContent- property.
	             */
                return this._onGetContent;
            },
            setOnGetContent: function (value) {
	            /**
	             * Sets the -onGetContent- property.
	             */
                if (this._onGetContent !== value) {
                    this._onGetContent = value;
                    this.dispatch("change", {what:["onGetContent"]});
                }
            },
            getContent: function (control) {
	            /**
	             * Returns the -content- property.
	             */
                if (this._onGetContent !== null) {
                    if (!this.isDesigning()) {
                        return this.fire("onGetContent", arguments);
                    }
                    return String.format("*%s", this._name);
                }
                return this._content;
            },
            setContent: function (value) {
	            /**
	             * Sets the -content- property.
	             */
                if (this._content !== value) {
                    this._content = value;
                    this.dispatch("change", {what:["content"]});
                }
            },
            getChecked: function () {
	            /**
	             * Returns the -checked- property.
	             */
                return this._checked;
            },
            setChecked: function (value) {
	            /**
	             * Sets the -checked- property.
	             */
                if (this._checked !== value) {
                    this._checked = value;
                    this.dispatch("change", {what:["checked"]});
                }
            },
            getEnabled: function () {
	            /**
	             * Returns the -enabled- property.
	             */
                return this._enabled;
            },
            setEnabled: function (value) {
	            /**
	             * Sets the -enabled- property.
	             */
                if (this._enabled !== value) {
                    this._enabled = value;
                    this.dispatch("change", {what:["enabled"]});
                }
            },
            getHint: function () {
	            /**
	             * Returns the -hint- property.
	             */
                return this._hint;
            },
            setHint: function (value) {
	            /**
	             * Sets the -hint- property.
	             */
                if (this._hint !== value) {
                    this._hint = value;
                    this.dispatch("change", {what:["hint"]});
                }
            },
            getHotkey: function () {
	            /**
	             * Returns the -hotkey-property.
	             */
                return this._hotkey;
            },
            setHotkey: function (value) {
	            /**
	             * Sets the -hotkey-property.
	             */
                if (this._hotkey !== value) {
                    this._hotkey = value;

                    if (this.hasOwnProperty("_hotkeyListeners")) {
                        this._hotkeyListeners.forEach(function (listener) {
                            HotkeyManager.unregister(listener);
                        });
                    }

                    var me = this;
                    var arr = this._hotkey.split("|");

                    this._hotkeyListeners = [];

                    arr.forEach(function(hotkey, type) {
                        hotkey = String.trim(hotkey).split(":");
                        type = hotkey.length === 1 ? "keydown" : hotkey.shift();
                        hotkey = hotkey.shift();

                        this._hotkeyListeners.push(HotkeyManager.register(hotkey, {
                            type: type,
                            isEnabled: function() {
                                return me.isHotkeyEnabled();
                            },
                            callback: function (evt, type) {
                                if (this.type.indexOf(type) !== -1) {
                                    if (value !== "*") {
                                        evt.preventDefault(); // FIXME property?
                                    }
                                    me.execute(evt);
                                }
                            }
                        }));
                    }, this);
                }
            },
            getVisible: function () {
	            /**
	             * Returns the -visible- property.
	             */
                return this._visible;
            },
            setVisible: function (value) {
	            /**
	             * Sets the -visible- property.
	             */
                if (this._visible !== value) {
                    this._visible = value;
                    this.dispatch("change", {what:["visible"]});
                }
            },
            getSelected: function () {
	            /**
	             * Returns the -selected- property.
	             */
                return this._selected;
            },
            setSelected: function (value) {
	            /**
	             * Sets the -selected- property.
	             */
                if (this._selected !== value) {
                    this._selected = value;
                    this.dispatch("change", {what:["selected"]});
                }
            },
            getState: function () {
	            /**
	             * Returns the -state- property.
	             */
                return this._state;
            },
            setState: function (value) {
	            /**
	             * Sets the -state- property.
	             */
                if (this._state !== value) {
                    this._state = value;
                    this.dispatch("change", {what:["state"]});
                    if (this._state === true && this._stateIndex !== -1) {
                        this.updateStates();
                    }
                }
            },
            getStateIndex: function () {
	            /**
	             * Returns the -stateIndex- property.
	             */
                return this._stateIndex;
            },
            setStateIndex: function (value) {
	            /**
	             * Sets the -stateIndex- property.
	             */
                if (this._stateIndex !== value) {
                    this._stateIndex = value;
                    this.dispatch("change", {what:["stateIndex"]});
                    if (this._stateIndex !== -1 && !this.isLoading() && this._state === true && this._owner !== null) {
                        this.updateStates();
                    }
                }
            },
            getParentExecute: function () {
	            /**
	             * Returns the -parentParentExecute- property.
	             */
                return this._parentExecute;
            },
            setParentExecute: function (value) {
	            /**
	             * Sets the -parentParentExecute- property.
	             */
                if (this._parentExecute !== value) {
                    this._parentExecute = value;
                }
            },
            getOnChange: function () {
                return this._onChange;
            },
            setOnChange: function (value) {
                if (this._onChange !== value) {
                    this._onChange = value;
                }
            }
        },

        properties: {
            "content": {
                type: Type.STRING,
                set: Function
            },
            "checked": {
                type: ActionProperty,
                set: Function
            },
            "hint": {
                type: Type.STRING,
                set: Function
            },
            "enabled": {
                set: Function,
                type: ActionProperty
            },
            "visible": {
                set: Function,
                type: ActionProperty
            },
            "state": {
                set: Function,
                type: ActionState
            },
            "selected": {
                set: Function,
                type: ActionProperty
            },
            "parent": {
                set: Function,
                type: Action_Referenced
            },
            "parentExecute": {
                type: Type.BOOLEAN,
                set: Function
            },
            "hotkey": {
                type: Type.STRING,
                get: Function,
                set: Function
            },
            "onExecute": {
                type: Type.EVENT,
                set: Function
            },
            "onUpdate": {
                type: Type.EVENT,
                set: Function
            }
        }
    }));
});
define('vcl/CssRules',['require','js','js/Class','js/referenceClass!./Control','cavalion.org/util/Stylesheet'],function(require) {

	var js = require("js");
	var Class = require("js/Class");
	var Control = require("js/referenceClass!./Control");
	var Stylesheet = require("cavalion.org/util/Stylesheet");

	var CssRules = {

		prototype: {

			/**
			 *
			 */
			constructor: function() {
				this._rules = {};
				CssRules.instances.push(this);
			},

			_rules: null,
			_selector: "",

			/**
			 *
			 */
			apply: function(css) {
				var selector = this.getSelector();
				var set, get;

				js.keys(css).forEach(function(name, index) {
					var obj = Stylesheet.validateStyle(css[name]);
					var rule = this._rules[name];
					var priority;
					if(obj === undefined) {
						if(rule !== undefined) {
							Stylesheet.destroyCssRule(this._rules[name]);
							delete this._rules[name];
						}
					} else {
						if(rule === undefined) {
							if(name.indexOf("!") !== -1) {
								name = name.split("!");
								priority = parseInt(name[1], 10) || 0;
								name = name[0];
							} else {
								priority = 10;
							}
							this._rules[name] = Stylesheet.createCssRule(obj, priority,
									String.format("%s%s", selector, name));
						} else {
							//FIXME This block is a repetition of code in Stylesheet.styleToRule
							rule.style.cssText = "";
							if(set === undefined) {
								set = rule.style.setAttribute ?
									function(key, value) { this.style.setAttribute(key, value); } :
									function(key, value) { this.style[key] = value;	};
								get = rule.style.setAttribute ?
										function(key) { return this.style.getAttribute(key); } :
										function(key) { return this.style[key];	};
							}
							for(var key in obj) {
								try {
									var value = obj[key];
									if(typeof value === "string") {
										set.apply(rule, [key, value]);
									} else if(value instanceof Array) {
										if(get.apply(rule, [key]) !== "") {
											throw new Error(String.format("Can not safely do this (%s)", key));
										}
										for(var i = 0; i < value.length; ++i) {
											var val = String(value[i]);
											set.apply(rule, [key, val]);
											if(get.apply(rule, [key]).toLowerCase() === val.toLowerCase()) {
												console.log("!");
												break;
											}
											//console.log(get.apply(rule, [key]).toLowerCase(), "!==", val);
										}
									}
								} catch(e) {
									console.log(String.format("%s := %s -> %s", key, value, e.message));
								}
							}
						}
					}
				}, this);
			},

			/**
			 *
			 */
			getRule: function(name, create) {
				return this._rules[name] || null;
			},

			/**
			 *
			 */
			getRuleStyle: function(name) {
				return this.getRule(name).style;
			},

			/**
			 *
			 */
			getSelector: function() {
				if(this._selector === "") {
					this._selector = Stylesheet.generateSelector();
				}
				return this._selector;
			},

			/**
			 *
			 */
			setSelector: function(value) {
				if(js.keys(this._rules).length !== 0) {
					throw new Error("Can not change selector while rules are already created");
				}
				this._selector = value;
			},

			/**
			 *
			 */
			setRules: function(value) {
				var rules = {};

				function loop(value, key) {
					function adjust(name) {
						if(name.charAt(0) === " " || name.charAt(0) === ":") {
							return name;
						} else if(name.charAt(0) === "&") {
							return name.substring(1);
						}
						return " " + name;
					}

					if(key.indexOf(",") !== -1) {
						throw new Error(String.format("Comma operator not supported (yet?) - %s", key));
					}
					rules[key] = value;
					for(var k in value) {
						var v = value[k];
						if(typeof v === "string" && v.charAt(v.length - 1) === ";") {
							value[k] = (v = js.str2obj(v));
						}
						if(typeof v === "object") {
							if(v instanceof Array) {
								//v = js.str2obj(v.join(""));
							} else {
								delete value[k];
								loop(js.mixIn(v), String.format("%s%s", key, adjust(k)));
							}
						}
					}
					if(js.keys(rules[key]).length === 0) {
						//delete rules[key];
					}
				}
				
				/*- Make a copy of value */
				value = js.mixIn(value);

				(function split(obj) {
					js.keys(obj).forEach(function(key) {
						var val = obj[key];
						var keys = key.split(",");
						if(keys.length > 1) {
							delete obj[key];
							keys.forEach(function(key) {
								obj[key] = val;
							});
						}
						if(typeof val === "object") {
							split(val);
						}
					});
				}(value));

				loop(value, "");
				this.apply(rules);
			},

			/**
			 *
			 */
			getClassName: function() {
				if(this._selector === "") {
					this.apply();
				}
				if(this._selector.substring(0, 1) === ".") {
					return this._selector.substring(1);
				}
				throw new Error("CssRules is not class based");
			}
		},

		statics: {
			instances: [],

			normalize: function(relativeTo, obj, sender) {

				function normalize(base, name) {
					var r = base.split("/");
					r.pop();
					name.split("/").forEach(function(part) {
						if(part === "..") {
							r.pop();
						} else if(part === ".") {

						} else {
							r.push(part);
						}
					});
					return r.join("/");
				}

				function replace(relativeTo, value, k) {
					var v = value[k];
					delete value[k];
					
					/*- Replace all occurences of # without leading backslash
						with ".\#". this is used for match component names in the 
						class of a DOM node
						
							<div class="vcl-ui-Panel #panel-top"> ... </div>
							
							css: {
								"#panel-top": "color: red;"
							}
							
						TODO This method seems to be called twice after the keys
							 have been replaced...
							
						if(k.indexOf("#") !== -1) {
							debugger;
							console.log(k, "-->", k.replace(/([^\\]|^)#/g, "$1.\\#"))
						}
					*/
					k = k.replace(/([^\\]|^)#/g, "$1.\\#");
					
					if(k.indexOf("[id$=-") !== -1 || k.indexOf("[id$='-") !== -1) {
						console.warn((sender && sender._uri) || "<unknown>", k, "[id$=-...] should be written as #...");
					}
					
					if(k.indexOf("{") !== -1) {
						var i;

						while((i = k.indexOf("{")) !== -1) {
							var before = k.substring(0, i);
							var between = k.substring(i + 1).split("}")[0];
							var after = k.substring(i + between.length + 2);
							between = normalize(relativeTo, between);
							try {
								between = require(between);
							} catch (e) {
								throw new Error(String
										.format("Referencing class %s via css: %s", between, e.message));
							}
							between = Control.getClassNameFor(between).split(" ")[0];
							k = String.format("%s%s%s", before, between, after);
						}
					}
					value[k] = v;
					if(typeof v === "object") {
						for(k in v) {
							replace(relativeTo, v, k);
						}
					}
				}

				// normalize classes' class names
				for(var key in obj) {
					replace(relativeTo, obj, key);
				}

				return obj;
			}
		}

	};

	return (CssRules = Class.define(require, CssRules));
});
define('vcl/ControlUpdater',['require'],function(require) {
	return {
		controls: [],
		timeout: undefined,
		interval: 2000,
		updating: false,

		queue: function(control) {
			if(this.controls.indexOf(control) !== -1) {
				return;
			}

			//Method.stack2console(String.format("ControlUpdater.queue(%n)", control));

			if(!this.updating) {

				this.controls.push(control);

				if(this.timeout === undefined) {
					this.timeout = setTimeout(this.update.bind(this, true), 0);
				}
			} else {
				//this.controls = [control].concat(this.controls);
				this.controls.push(control);
			}
		},
		dequeue: function(control) {
			while((index = this.controls.indexOf(control)) !== -1) {
				this.controls.splice(index, 1);
			}
		},
		update: function(fromTimeout) {
			if(fromTimeout) {
				delete this.timeout;
			} else if(this.timeout) {
				clearTimeout(this.timeout);
				delete this.timeout;
			}

			var end = Date.now() + this.interval;
			var counter = 0;

			this.updating = true;
			try {
				while (this.controls.length && Date.now() < end) {
					var control = this.controls.splice(0, 1)[0];
					var queue = this.controls;
					this.controls = [];
					control._update();
// TODO What's going on here?
// New updates are placed in front?
					this.controls = queue.concat(this.controls);
					counter++;
				}
			//} catch (e) {
				//throw new Error("Update failed; " + e.message, e);
			} finally {
				this.updating = false;
				if(this.controls.length) {
					this.timeout = setTimeout(this.update.bind(this, true), 0);
				}
			}
		}
	};
});
define('vcl/Dragger',['require','js/defineClass','cavalion.org/util/DocumentHook','cavalion.org/util/HtmlElement'],function(require) {

	var Dragger = require("js/defineClass");
	var DocumentHook = require("cavalion.org/util/DocumentHook");
	var HtmlElement = require("cavalion.org/util/HtmlElement");

	return (Dragger = Dragger(require, {

		prototype: {

			_control: null,
			_hook: null,

			_sx: 0,
			_sy: 0,

			_cursor: null,

			/**
			 * Constructor
			 */
			constructor: function(control, overrides) {
				this._hook = new DocumentHook(undefined, false);
				this._control = control;

				var me = this;
				this._hook.handleEvent = function(evt, type) {
					return me.handleEvent(evt, type);
				};

				if(typeof overrides === "object") {
					this.override(overrides);
				}
			},

			/**
			 *
			 */
			handleEvent: function(evt, type) {
				var f = this[type];
				if(f !== undefined) {
					f.apply(this, arguments);
				}
			},

			/**
			 *
			 */
			swapDocCursor: function() {
				if(this.hasOwnProperty("_cursor")) {
					var style = document.body.style;
					var cursor = style.cursor;
					style.cursor = this._cursor;
					this._cursor = cursor;
				}
			},

			/**
			 *
			 */
			getCursor: function() {
				return this._cursor;
			},

			/**
			 *
			 */
			setCursor: function(value) {
				if( /* isdragging */ 0) {
					document.body.style.cursor = value;
				} else if(this._cursor !== value) {
					this._cursor = value;
				}
			},

			/**
			 *
			 */
			start: function(evt) {
				HtmlElement.disableSelection();
				this.swapDocCursor();
				this._sx = evt.clientX;
				this._sy = evt.clientY;
				this._hook.activate();
				this.createHandles(evt);
			},

			/**
			 *
			 */
			end: function(evt) {
				this.destroyHandles(evt);
				this._hook.release();
				this.swapDocCursor();
				HtmlElement.enableSelection();
			},

			/**
			 *
			 */
			drop: function(evt) {

			},

			/**
			 *
			 */
			keyup: function(evt) {
				if(evt.keyCode === 27) {
					evt.preventDefault();
					this._cancelled = true;
					this.end(evt);
				}
			},

			/**
			 *
			 */
			mouseup: function(evt) {
				if(this._cancelled !== true) {
					this.drop(evt);
					this.end(evt);
				}
			},

			/**
			 *
			 */
			mousemove: function(evt) {
				this.updateHandles(evt);
			},

			/**
			 *
			 */
			createHandles: function() {
			},

			/**
			 *
			 */
			destroyHandles: function() {
			},

			/**
			 * This will just move the control, override to change behaviour
			 */
			updateHandles: function(evt) {
				var x = this._sx;
				var y = this._sy;

				x = evt.clientX - x + this._control.getLeft();
				y = evt.clientY - y + this._control.getTop();

				this._control.setBounds(x, y);

				this._sx = evt.clientX;
				this._sy = evt.clientY;
			}

		}
	}));

});
define('vcl/Control',['require','js/defineClass','js/Type','js/Class','js','cavalion.org/util/HtmlElement','cavalion.org/util/Stylesheet','cavalion.org/util/DocumentHook','./Component','./Action','./EventDispatcher','./CssRules','./ControlUpdater','./Dragger'],function(require) {

	var Control = require("js/defineClass");
	var Type = require("js/Type");
	var Class = require("js/Class");
	var js = require("js");

	var HtmlElement = require("cavalion.org/util/HtmlElement");
	var Stylesheet = require("cavalion.org/util/Stylesheet");
	var DocumentHook = require("cavalion.org/util/DocumentHook");

	var Component = require("./Component");
	var Action = require("./Action");
	var EventDispatcher = require("./EventDispatcher");
	var CssRules = require("./CssRules");
	var ControlUpdater = require("./ControlUpdater");
	var Dragger = require("./Dragger");

	// FIXME
	var MustBeEnabledEvents = [].concat(DocumentHook.prototype._events);
	MustBeEnabledEvents.splice(0, 1); //ontransitionend

	var ControlState = {
		enabled: 0x0001,
		readonly: 0x0002,
		showing: 0x0004,
		selected: 0x0008,
		focused: 0x0010,
		hovered: 0x0020,
		expanded: 0x0040,
		designing: 0x0080,
		dragging: 0x0100,
		classesInvalidated: 0x0400,
		invalidated: 0x0800,
		//draggable: 0x1000,
		//0x1200,
		notVisibleDesigning: 0x4000,
		acceptChildNodes: 0x8000
	};

	return (Control = Control(require, {
		inherits: Component,
		prototype: {

			_node: null,
			_nodes: null,
			_element: "div",
			_content: "",
			_parentNode: null,

			_controls: null,
			_parent: null,
			_parentComponent: null,

			_draggable: false,
			_dragger: null,

			// position
			_align: "none",

			// styling
			_className: null,
			_classes: "",
			_cssRules: null,
			_classes_rt: null,
			_computedStyle: null,

			// state
			_action: null,
			_visible: true,
			_enabled: true,
			_selected: false,
			_hovered: false,
			_focused: false,
			_readonly: false,
			_state: ControlState.enabled | ControlState.acceptChildNodes,
			_executesAction: "No",
			_groupIndex: -1,
			_tabIndex: -1,

			_removeNodeWhenHidden: false,

			// mouse events
			_onClick: null,
			_onDblClick: null,
			// _onNodeNeeded: null,
			_onNodeCreated: null,
			_onNodeInserted: null,
			_onMouseDown: null,
			_onMouseUp: null,
			_onMouseWheel: null,
			_onMouseMove: null,
			_onMouseEnter: null,
			_onMouseLeave: null,
			_onDraggerNeeded: null,
			_onDragStart: null,
			_onDragEvent: null,
			_onDragCancel: null,
			_onDragEnd: null,

			// keyboard event
			_onKeyDown: null,
			_onKeyUp: null,
			_onKeyPress: null,

			_onFocus: null,
			_onBlur: null,
			_onHint: null,

			_onShow: null,
			_onHide: null,

			_onScroll: null,
			_onResize: null,
			_onTransitionEnd: null,

			_onRender: null,

			// touch events
			_onTap: null,
			_onDblTap: null,
			_onTouchStart: null,
			_onTouchEnd: null,
			_onTouchCancel: null,
			_onTouchMove: null,
			_onGesture: null,


/**--		./Component.prototype overrides */
			destroy: function() {
			/** @overrides ./Component.prototype.destroy */
				// make sure no more updates are handled
				ControlUpdater.dequeue(this);

				this.destroyControls();
				this.setAction(null, true);
				this.setParent(null, true);
				this.destroyNode();
				return this.inherited(arguments);
			},
			getParentComponent: function() {
			/** @overrides ./Component.prototype.getParentComponent */
				// TODO This doesn't seem right...
				if(this._parent !== null && (this._parent === this._owner || this._parent._owner === this._owner)) {
					return this._parent;
				}
				return this._parentComponent || this._owner || null;
			},
			setParentComponent: function(value) {
			/** @overrides ./Component.prototype.setParentComponent */
				if(value instanceof Control) {
					this.setParent(value);
					delete this._parentComponent;
				} else {
					this._parentComponent = value;
				}
			},
			getChildren: function(func, root) {
			/** @overrides ./Component.prototype.getChildren */
				if(root === this) {
					this.inherited(arguments);
				} else {
					if(this.hasOwnProperty("_controls")) {
						this._controls.forEach(function getChildren$forEach(control) {
							if(control.getOwner() === root) {
								func(control);
							}
						}, this);
					}
				}
			},
			isEventEnabled: function(name, evt, f, args) {
			/** @overrides ./Component.prototype.isEventEnabled */
				var r = this.inherited(arguments) &&
					(this.isEnabled() || MustBeEnabledEvents.indexOf(
					    "on" + name) === -1);

				if(r === true && this._parent !== null) {
					r = this._parent.dispatchChildEvent(this, name, evt, f, args);
				}
				return r;
			},
			dispatchChildEvent: function(component, name, evt, f, args) {
			/** @overrides ./Component.prototype.dispatchChildEvent */
				// FIXME Pure non-Control instances do not fwd to owner
				return this.inherited(arguments) &&
					this._parent !== null ?	this._parent.dispatchChildEvent(
							component, name, evt, f, args) :
						this._owner !== null ? this._owner.dispatchChildEvent(
									component, name, evt, f, args) : true;
			},
			isContainer: function() {
				return false;
			},
			assertContainer: function() {
				if(this.isContainer() === false) {
					throw new Error("Not a container");
				}
			},


/**--		controls */
			insertControl: function(control, index) {
				if(!this.hasOwnProperty("_controls")) {
					this._controls = [];
				}

				this.assertContainer();

				this._controls.push(control);
				control._parent = this;

				if(index !== undefined) {
					var begin = this._controls.splice(0, index);
					var end = this._controls.splice(0, this._controls.length - 1);
					this._controls = begin.concat(this._controls).concat(end);
				}
			},
			removeControl: function(control) {
				this.assertContainer();

				this._controls.splice(this._controls.indexOf(control), 1);
				delete control._parent;
			},
			destroyControls: function() {
				// this.disableAlign();
				if(this.hasOwnProperty("_controls")) {
					this.beginLoading();
					try {
						var controls = [].concat(this._controls || []);
						var control;
						while(controls.length > 0) {
							control = controls.splice(0, 1)[0];
							if(control._owner === null || control._owner === this /*|| control._owner === this._owner*/) {
								control.destroy();
							} else {
								control.setParent(null);
							}
						}
					} finally {
						// this.enableAlign();
						this.endLoading();
					}
				}
			},
			getControlCount: function() {
				this.assertContainer();
				if(this.hasOwnProperty("_controls")) {
					return this._controls.length;
				}
				return 0;
			},
			getControl: function(i) {
				this.assertContainer();
				if(this.hasOwnProperty("_controls")) {
					return this._controls[i];
				}
			},
			getControls: function(groupIndex) {
                if(groupIndex === undefined || !this.hasOwnProperty("_controls")) {
                    return this._controls || [];
                }
                return this._controls.reduce(function(arr, current) {
                    if(current.getGroupIndex() === groupIndex) {
                        arr.push(current);
                    }
                    return arr;
                }, []);
			},
			selectControl: function(control) {
				this.assertContainer();

				if(this.hasOwnProperty("_controls")) {
					this._controls.forEach(function(c) {
						if(c !== control && c._groupIndex === control._groupIndex) {
							c.setSelected(false);
						}
					});
					control._selected = true;
					control.update();
				}
			},
			getSelectedControl: function(groupIndex) {
				this.assertContainer();

				if(this.hasOwnProperty("_controls")) {
					for( var i = 0; i < this._controls.length; ++i) {
						var c = this._controls[i];
						if(c._groupIndex === groupIndex && c.isSelected() === true) {
							return c;
						}
					}
				}
				return null;
			},


/**--		index */
			getIndex: function() {
			/**
			 * Returns the index of the calling in the parents control array.
			 */
				return this._parent !== null && this._parent.hasOwnProperty("_controls") ?
						this._parent._controls.indexOf(this) : -1;
			},
			setIndex: function(control, value) {
			/**
			 * Sets the index of the calling control in the parents control
			 * array (hopefully making it visible)
			 */
				if(value === undefined) {
					if(this._parent !== null) {
						this._parent.setIndex(this, control);
					}
				} else {
					// this.assertContainer(); actually this should only be
					// called through if-statement above
					if(this.hasOwnProperty("_controls")) {
						if(control.getIndex() !== value && value >= 0 && value < this._controls.length) {
							this._controls = Array.move(this._controls, control.getIndex(), value);
							if(this.hasState(ControlState.acceptChildNodes) === true) {
								if(control.isShowing()) {
									control.hideNode(true);
									control.showNode();
								}
							}
						}
					}
				}
			},
			bringToFront: function() {
				this.setIndex(this._parent.getControlCount() - 1);
			},
			sendToBack: function() {
				this.setIndex(0);
			},

			
/**--		parent */
			hasParent: function(parent) {
			/**
			 * Indicates whether -parent- is a (in)direct parent of the calling
			 * control.
			 */
				if(this._parent === parent) {
					return true;
				} else if(this._parent) {
					return this._parent.hasParent(parent);
				}
				return false;
			},
			getParent: function() {
				return this._parent;
			},
			setParent: function(value, destroying) {
				var parent = this._parent;
				if(parent !== value) {
					var loading = this.isLoading();
					var visible = loading || this.isVisible();
					if(parent !== null) {
						parent.removeControl(this);
						if((this._state & ControlState.showing) !== 0) {
							this.hideNode();
						} else if(this._node !== null && this._node.parentNode !== null) {
							// TODO there must be a better way than hacking into
							// _node here
							this._node.parentNode.removeChild(this._node);
							this._node.style.display = "";
						}
					}
					if(value !== null) {
						value.insertControl(this);
					}
					if(destroying !== true && loading === false) {
						this.update();
						if(visible !== this.isVisible()) {
							this.visibleChanged();
						}
					}
				}
			},
			isParentOf: function(kid) {
				return kid instanceof Control && kid.hasParent(this) === true;
			},


/**--		node/element */
			getInsertReference: function(parentNode) {
			/**
			 * @return {HtmlElement}
			 */
				var index, lastIndex;
				var reference;

				if(this._parent !== null
						&& (index = this.getIndex()) !== (lastIndex = this._parent.getControlCount() - 1)) {
					parentNode = parentNode || this.getParentNode();
					for(reference = null; reference === null && ++index <= lastIndex;) {
						reference = this._parent.getControl(index)._node;
						if(reference !== null && reference.parentNode !== parentNode) {
							reference = null;
						}
					}
				} else {
					reference = null;
				}
				return reference;
			},
			getParentNode: function() {
			/**
			 * @return {HtmlElement}
			 */
				if(this._parentNode !== null) {
					return this._parentNode;
				} else if(this._parent !== null) {
					return this._parent.getClientNode(this);
				}
				return null;
			},
			setParentNode: function(value) {
				if(this._parentNode !== value) {
					if(value !== null) {
						this._parentNode = value;
					} else {
						delete this._parentNode;
					}
					this.update();
				}
			},
			getNode: function(recursive) {
				if(typeof recursive === "string") {
					// treat recursive as string to id a key of _nodes
					this.getNode();
					return this._nodes[recursive];
				}

				var node = this.nodeNeeded();
				if(recursive === true) {
					if(node.parentNode === null) {
						var reference = this.getInsertReference();
						if(reference !== null) {
							this.getParentNode().insertBefore(this._node, reference);
						} else {
							this.getParentNode().appendChild(this._node);
						}
						this.dispatch("nodeinserted")
					}
					if(this.hasOwnProperty("_controls")) {
						this._controls.forEach(function(control) {
							control.getNode(true);
						});
					}
				} else if(typeof recursive === "string") {
					node = (recursive !== "" ? this._nodes[recursive] : node);
				}
				return node;
			},
			getNodeId: function() {
                return String.format("vcl-%d%s%s", this.hashCode(), this._name !== "" ? "-" : "", this._name);
			},
			setNodeId: function(node, suffix) {
				return (node.id = String.format("%s--%s", this.getNodeId(), suffix));
			},
			createNode: function(documentNode) {
				this._node = documentNode.createElement(this.getElement());
				this._node.id = this.getNodeId();
				this._node.innerHTML = this.getInnerHtml();
				if(this._tabIndex !== -1) {
					this._node.tabIndex = this._tabIndex;
				}
				this._nodes = {};
				this.initializeNodes();
				this.dispatch("nodecreated", this._node, this._nodes);
				this.render();
			},
			recreateNode: function() {
				if(this._node !== null) {
					var accept = this.hasState("acceptChildNodes");
					var showing = this.hasState("showing");
					if(showing === true) {
						this.hideNode();
					}
					if(accept === true) {
						this.clearState("acceptChildNodes", true, true);
					}
					this.destroyNode();
					if(accept === true) {
						this.setState("acceptChildNodes", true, true);
					} else {
						this.update();
					}
				}
			},
			destroyNode: function() {
				this.finalizeNodes();
				if(this._node !== null && this._node.parentNode !== null) {
					this._node.parentNode.removeChild(this._node);
				}
				delete this._node;
				delete this._nodes;
			},
			nodeNeeded: function() {
				if(this._node === null) {
					this.createNode(document);
					this._node[EventDispatcher.elementKey] = this;
					this.applyClasses();
				}
				return this._node;
			},
			onnodecreated: function() {
				this.fire("onNodeCreated", arguments, !this.isDesigning());
			},
			onnodeinserted: function() {
				this.fire("onNodeInserted", arguments, !this.isDesigning());
			},
			getClientNode: function(control) {
				return this._node || this.nodeNeeded();
			},
			getChildNode: function() {
				var node = this.nodeNeeded();
				for( var i = 0, l = arguments.length; i < l && node !== null; ++i) {
					node = node.childNodes[arguments[i]] || null;
				}
				return node;
			},
			getNodes: function() {
				this.nodeNeeded();
				return this._nodes;
			},
			initializeNodes: function() {
				this._node.onscroll = EventDispatcher.handleEvent;
				// FIXME there are more events that might need to be hooked (oncopy,oncut,onsearch, etc)
			},
			finalizeNodes: function() {},

			createDragger: function() {
				return new Dragger(this);
			},
			getInnerHtml: function() {
				return this._content || (this._action ?
				        this._action.getContent(this) : "");
			},
			render: function() {
			    this.fire("onRender", arguments);
			},
			layoutChanged: function() {
				if(this._parent !== null) {
					this._parent.contentChanged();
				}
			},
			contentChanged: function() {
				// As far as know the same applies...
				this.layoutChanged();
			},
			scrollIntoView: function() {
			/**
			 * Makes sure that the calling node is visible by scrolling it into view when necessary.
			 */
				this.nodeNeeded().scrollIntoView();
			},

			documentToClient: function(x, y) {
				var ar = this.getAbsoluteRect();
				if(x.y !== undefined) {
					y = x.y;
					x = x.x;
				}

				return {
					x: x - ar.left,
					y: y - ar.top
				};
			},
			clientToDocument: function(x, y, includeScroll) {
				var ar = this.getAbsoluteRect();
				if(x.y !== undefined) {
					y = x.y;
					x = x.x;
				}

				if(includeScroll === true && this._node !== null) {
					x -= this._node.scrollLeft;
					y -= this._node.scrollTop;
				}

				return {
					x: ar.left + x,
					y: ar.top + y
				};
			},
			getAbsoluteRect: function(includeScroll) {
				return HtmlElement.getAbsoluteRect(this.nodeNeeded(), includeScroll);
			},


/**--		style/css/classes */
			getComputedStyle: function() {
				if(this._computedStyle === null) {
					this._computedStyle = HtmlElement.getComputedStyle(this.nodeNeeded());
				}
				return this._computedStyle;
			},
			getComputedStylePropValue: function(name) {
				if(this._computedStyle === null) {
					this.getComputedStyle();
				}
				return this._computedStyle.getPropertyValue(name);
			},
			setStyleProp: function(name, value, unit) {
				var style = this._node.style;
				if(value !== undefined) {
					if(unit !== undefined) {
						value = value + unit;
					}
				} else {
					value = "";
				}
				try {
					if(style[name] !== value) {
						style[name] = value;
						return true;
					}
				} catch(e) {
					// squeech.. for Android
					// TODO optimize this exception handler
				}
				return false;
			},
			determineClasses: function() {
				/**
				 * Determines the classes that should be applied on the DOM node.
				 * Override this method when dynamic custom classes are needed. In
				 * order to refresh the classes programmatically use:
				 *
				 * control.setState("classesInvalidated"[, true]);
				 */
				var classes = [];
				var designing = this.isDesigning();
				var stateObj = {
					disabled: !this.isEnabled(),
					readonly: this.isReadonly(),
					selected: this.isSelected(),
					hovered: this._hovered,// isHovered(),
					focused: this._focused,// isFocused()
					expanded: this.isExpanded(),
					designing: designing,
					invisible: !this.getVisible() && designing
				};
				
				classes.push(this.getClassName());
				classes.push(String.format("#%d", this.hashCode()));
				
				if(this._name !== "") {
					classes.push("#" + this._name);
				}
				if(this._classes) {
					classes = classes.concat(this._classes.split(" "));
				}
				if(this._classes_rt !== null) {
					classes = classes.concat(this._classes_rt);
				}
				if(this._cssRules !== null) {
					//classes.push(this._cssRules.getSelector().split(".").pop());
				}

				if(stateObj.disabled) {
					classes.push("disabled");
				}
				if(stateObj.readonly) {
					classes.push("readonly");
				}
				if(stateObj.selected) {
					classes.push("selected");
				}
				if(stateObj.hovered) {
					classes.push("hovered");
				}
				if(stateObj.focused) {
					classes.push("focused");
				}
				if(stateObj.expanded) {
					classes.push("expanded");
				}
				if(stateObj.dragging) {
					classes.push("dragging");
				}
				if(stateObj.readonly) {
					classes.push("readonly");
				}
				if(stateObj.designing) {
					classes.push("designing");
				}
				if(stateObj.invisible) {
					classes.push("invisible");
				}

				return classes;
			},
			applyClasses: function() {
				var classes = this.determineClasses();
				delete this._computedStyle;
				classes = String.trim(classes.join(" "));
				//if(classes !== this._node.className) {
				    this._node.className = classes;
    				if(this.inDocument()) {
    					this.layoutChanged();
    				}
				// } else {
				//     console.trace("Control.applyClasses-blocked", 
				//          this.hashCode(), this);
				// }
			},
			toggleClass: function(classes) {
				if(this._classes_rt === null) {
					this.addClasses(classes);
				} else {
					var changed = false;
					if(!(classes instanceof Array)) {
						classes = classes.split(" ");
					}
					classes.forEach(function(cls, index) {
						if((index = this._classes_rt.indexOf(cls)) === -1) {
							this._classes_rt.push(cls);
							changed = true;
						} else {
							this._classes_rt.splice(index, 1);
							changed = true;
						}
					}, this);
					if(changed) {
						this.setState(ControlState.classesInvalidated, true);
					}
				}
			},
			replaceClass: function(find, replace) {
				if(this._classes_rt !== null) {
					var changed = false;
					this._classes_rt.forEach(function(cls, i) {
						if(cls === find) {
							this._classes_rt[i] = replace;
							changed = true;
						}
					}, this);
					if(changed) {
						this.setState(ControlState.classesInvalidated, true);
					}
				}
			},
			addClass: function(value, directly) {

				//directly && console.warn("addClass directly can be replaced with a call to _update");

				if(this._classes_rt === null) {
					this._classes_rt = [value];
				} else {
					this._classes_rt.push(value);
				}
				if(directly === true) {
					if(this._node !== null) {
						this.applyClasses();
					}
				} else if(directly !== "none") {
					this.setState(ControlState.classesInvalidated, true);
				}
			},
			addClasses: function(classes, directly) {
				if(typeof classes === "string") {
					classes = classes.split(" ");
				}
				classes.forEach(function(className) {
					this.addClass(className, "none");
				}, this);
				if(directly === true) {
					if(this._node !== null) {
						this.applyClasses();
					}
				}
			},
			removeClass: function(value, directly, dontCheckClasses) {
			/**
			 * @param value
			 * @param directly When true the changes reflected immediately
			 * @param dontCheckClasses
			 *            Determines whether the classes property should be
			 *            considered, default=true {Boolean}
			 */
				var i;
				var changed = false;

				// It turned out to be very confusing that removeClass would not
				// seem to work when classes are set by means of a component
				// resource (property). So remove the class also from classes if
				// dontCheckClasses is not explicitly set to false.
				if(!this.isDesigning() && dontCheckClasses !== false && this._classes !== "") {
					var classes = this._classes.split(" ");
					if((i = classes.indexOf(value)) !== -1) {
						classes.splice(i, 1);
						this._classes = classes.join(" ");
						changed = true;
					}
				}
				if(this._classes_rt !== null) {
					i = this._classes_rt.indexOf(value);
					if(i !== -1 && this._classes_rt.splice(i, 1)[0] === value) {
						changed = true;
					}
				}
				if(changed === true) {
					if(directly === true) {
						if(this._node !== null) {
							this.applyClasses();
						}
					} else if(directly !== "none") {
						this.setState(ControlState.classesInvalidated, true);
					}
				}
			},
			removeClasses: function(classes, directly) {
				if(typeof classes === "string") {
					classes = classes.split(" ");
				}
				classes.forEach(function(className) {
					this.removeClass(className, "none");
				}, this);
				if(directly === true) {
					if(this._node !== null) {
						this.applyClasses();
					}
				}
			},
			hasClass: function(value, dontCheckClasses) {
				if(dontCheckClasses !== false && this._classes !== "") {
					var classes = this._classes.split(" ");
					var i = classes.indexOf(value);
					if(i !== -1) {
						return true;
					}
				}
				return this._classes_rt !== null ? this._classes_rt.indexOf(value) !== -1 : false;
			},

			hasState: function(state) {
			/**
			 *
			 * @param state
			 *            {String} ControlState
			 * @returns
			 */
				if(typeof state === "string") {
					state = ControlState[state];
				}
				return (this._state & state) !== 0;
			},
			getStateNames: function() {
				var r; r = [];
				for( var k in ControlState) {
					if(this.hasState(ControlState[k])) {
						r.push(k);
					}
				}
				return r;
			},
			setState: function(state, update, updateChildren) {
			/**
			 * @param state {String} ControlState
			 * @param update {Boolean} (optional, default = false}
			 */
				if(typeof state === "string") {
					state = ControlState[state];
				}

				this._state = this._state | state;

				// Propogate this to all children since nested nodes (maintained
				// by children) may be affected as well
				if(this.hasOwnProperty("_controls") && updateChildren !== false
						&& state === ControlState.classesInvalidated) {
					this._controls.forEach(function(c) {
						c.setState(state, false);
					});
				}

				if(update === true && this._node !== null) {
					this.update();
					if(state === ControlState.acceptChildNodes || state === ControlState.classesInvalidated) {
						this.updateChildren();
					}
				}
			},
			clearState: function(state, update, directly) {
			/**
			 *
			 * @param state
			 *            {String} ControlState
			 * @param update
			 *            {Boolean} optional, default = true
			 */
				if(typeof state === "string") {
					state = ControlState[state];
				}

				if(this.hasState(state)) {
					this._state = this._state ^ state;
					if(update === true && this._node !== null) {
						this.update();
						if(state === ControlState.acceptChildNodes) {
							this.updateChildren(false, directly);
						}
					}
				}
			},

			inDocument: function() {
				var node = this._node;
				while(node !== null && node !== document) {
					node = node.parentNode;
				}
				return node === document;
			},
			isShowing: function() {
				var r = (this._state & ControlState.showing) !== 0;

				if(r && this._parent) {
					r = r && this._parent.isShowing();
				}
				return r;
			},
			isContainerShowing: function() {
				return this.isShowing();
			},
			isVisible: function() {
				var r, designer = this.getDesignerHook();
				if(designer !== null) {
					r = designer.isControlVisible(this);
				} else {
					r = this._visible === true || this._visible === "always";
				}

				if(r === true) {
					if(this._parent === null) {
						r = this._parentNode !== null ? this._visible : false;
					} else if(this._parent.isControlVisible(this)) {
						r = designer === null ? this._visible : !this.hasState(
							ControlState.notVisibleDesigning)
					} else {
						r = false;
					}

					if(r === true && designer === null && this._action !== null) {
						var v = this._action.isVisible();
						if(v !== "leave") {
							r = v;
						}
					}
				}

				return r === true ? r : r === "always";
			},
			isControlVisible: function(control) {
				return this.hasState(ControlState.acceptChildNodes) && this.isVisible();
			},
			isDraggable: function() {
			/**
			 * Returns whether the calling control is draggable based upon the
			 * -dragMode- property.
			 */
				switch(this._draggable) {
					case true:
						return true;

					case "parent":
						if(this._parent !== null) {
							return this._parent.isDraggable();
                        }

					case false:
						return false;
				}
			},
			isEnabled: function() {
				if(this.isDesigning()) {
					return true;
				}

				var r = this._enabled;
				if(r === true && this._parent !== null) {
					r = r && this._parent.isEnabled() === true;
				}
				if(r === true && this._action !== null) {
					var e = this._action.isEnabled();
					if(e !== "leave") {
						r = r && e === true;
					}
				}
				return r === true ? r : r === "always";
			},
			isReadonly: function() {
				var r = this._readonly;
				if(r === false && this._parent !== null) {
					r = this._parent.isReadonly();
				}
				return r;
			},
			isSelected: function() {
				if(this._selected === true || this._selected === false) {
					if(this._action !== null) {
						var s = this._action.isSelected();
						return s === "leave" ? this._selected : s;
					}
				}
				return this._selected === true || this._selected === "always";
			},
			isFocused: function() {
				return this._focused;
			},
			isHovered: function() {
				return this._hovered;
			},
			isExpanded: function() {
				return false;
			},
			show: function(callback) {
				this.setVisible(true);
			},
			hide: function() {
				this.setVisible(false);
			},

			allowsUpdateChildren: function() {
				return this.isShowing();
			},
			update: function(f) {
				if(this.isLoading() || (this._parent !== null && this._parent.allowsUpdateChildren() === false)) {
					if(f !== undefined) {
						setTimeout(f, 0);
					}
					return "nothing-to-do";
				} else {
					f && this.postUpdate(f);
					ControlUpdater.queue(this);
					return "queued";
				}
			},
			postUpdate: function(f) {
				this._post_update = this._post_update || [];
				if(f !== undefined) {
					this._post_update.push(f);
				}
			},
			updateChildren: function(recursive, directly) {
				// this.assertContainer();
				if(this.hasOwnProperty("_controls")) {
					if(recursive !== true) {
						this._controls.forEach(function(control) {
							if(directly !== true) {
								control.update();
							} else if(control._node !== null) {
								control._update();
							}
						}, this);
					} else {
						this._controls.forEach(function(control) {
							if(directly !== true) {
								control.update();
							} else if(control._node !== null) {
								control._update();
							}
							control.updateChildren(recursive, directly);
						}, this);
					}
				}
			},
			visibleChanged: function() {
				var isVisible = this.isVisible();
				if (isVisible === false && this.isFocused() === true) {
					if (this._nodes !== null) {
						for (var k in this._nodes) {
							if (typeof this._nodes[k].blur === "function") {
								this._nodes[k].blur();
							}
						}
					} else {
						this.setFocused(false);
					}
				}
				
				if(this._node !== null && isVisible && this.hasState(ControlState.invalidated)) {
					// console.log("extra render", this);
					this.update(this.render.bind(this));
				}

				if(this._controls !== null) {
					this._controls.forEach(function(item) {
						if (isVisible === true && item.isVisible() === false) {
							item.update(item.visibleChanged.bind(item));
						} else {
							item.visibleChanged();
						}
					});
				}
			},

			_update: function() {
				if(this._parent && this._parent.allowsUpdateChildren() === false) {
				// if(this._parent && this._parent.inDocument() === false) {
					//console.warn(this, "_update not allowed, move to ControlUpdater");
					return false;
				}

				var calls = [];
				var isVisible = this.isVisible();
				var isEnabled = this.isEnabled();
				var isHovered = this.isHovered();
				var isSelected = this.isSelected();
				var isFocused = this.isFocused();
				var isExpanded = this.isExpanded();
				var isReadonly = this.isReadonly();
				var isDesigning = this.isDesigning();

				var showing = this._state & ControlState.showing;
				var enabled = this._state & ControlState.enabled;
				var hovered = this._state & ControlState.hovered;
				var selected = this._state & ControlState.selected;
				var focused = this._state & ControlState.focused;
				var expanded = this._state & ControlState.expanded;
				var readonly = this._state & ControlState.readonly;
				// var designing = this._state & ControlState.designing;

				var updateChildren = false;
				var visibleChanged = false;
				var classesInvalidated = false;

				if(hovered && isEnabled === false) {
					this.clearState(ControlState.hovered);
					this._hovered = false;
					isHovered = false;
				}

				if(isEnabled === true && !enabled) {
					calls.push(this.enable);
					this._state = this._state | ControlState.enabled;
					classesInvalidated = true;
					updateChildren = true;
				} else if(isEnabled === false && enabled) {
					calls.push(this.disable);
					this._state = this._state ^ ControlState.enabled;
					classesInvalidated = true;
					updateChildren = true;
				}

				if(isSelected === true && !selected) {
					calls.push(this.select);
					this._state = this._state | ControlState.selected;
					classesInvalidated = true;
				} else if(isSelected === false && selected) {
					calls.push(this.unselect);
					this._state = this._state ^ ControlState.selected;
					classesInvalidated = true;
				}

				if(isReadonly === true && !readonly) {
					calls.push(this.activateReadonly);
					this._state = this._state | ControlState.readonly;
					classesInvalidated = true;
				} else if(isReadonly === false && readonly) {
					calls.push(this.deactivateReadonly);
					this._state = this._state ^ ControlState.readonly;
					classesInvalidated = true;
				}

				if(isFocused === true && !focused) {
					calls.push(this.focus);
					this._state = this._state | ControlState.focused;
					classesInvalidated = true;
				} else if(isFocused === false && focused) {
					calls.push(this.blur);
					this._state = this._state ^ ControlState.focused;
					classesInvalidated = true;
				}

				if(isHovered === true && !hovered) {
					calls.push(this.hover);
					this._state = this._state | ControlState.hovered;
					classesInvalidated = true;
				} else if(isHovered === false && hovered) {
					calls.push(this.unhover);
					this._state = this._state ^ ControlState.hovered;
					classesInvalidated = true;
				}

				if(isExpanded === true && !expanded) {
					this._state = this._state | ControlState.expanded;
					classesInvalidated = true;
					updateChildren = true;
				} else if(isExpanded === false && expanded) {
					this._state = this._state ^ ControlState.expanded;
					classesInvalidated = true;
					updateChildren = true;
				}

				if(classesInvalidated === true) {
					this.setState(ControlState.classesInvalidated, false);
				}

				if(isVisible === true && !showing) {
					this.nodeNeeded();
					this.showNode();
					updateChildren = true;
					visibleChanged = true;
				} else if(isVisible === false && showing) {
					this.hideNode();
					visibleChanged = true;
				}

				if(this._node !== null) {
					if(this.hasState(ControlState.invalidated)) {
						this.render();
						this.clearState(ControlState.invalidated);
					}
					if(this.hasState(ControlState.classesInvalidated)) {
						this.applyClasses();
						this.clearState(ControlState.classesInvalidated);
					}
				}

				for( var i = 0, l = calls.length; i < l; ++i) {
					calls[i].apply(this, []);
				}

				if(updateChildren === true && this.hasOwnProperty("_controls") && this._controls.length) {
					if(this._aligning !== true) {
						this.updateChildren();
					}
				}

				if(visibleChanged === true) {
					this.visibleChanged();
				}

				if(this._post_update !== undefined) {
					while(this._post_update.length > 0) {
						this._post_update.shift()();
					}
					if(this._post_update.length === 0) {
						delete this._post_update;
					}
				}
			},

			showNode: function() {
				if(this._node.style.display === "none") {
					this._node.style.display = "";
					if(this._parent !== null) {
						this._parent.contentChanged();
					}
				} else {
					var pn = this.getParentNode();
					if(this._node.parentNode !== pn) {
						pn.insertBefore(this._node || this.nodeNeeded(), this.getInsertReference(pn));
						this.dispatch("nodeinserted");
					}
					if(this.hasState(ControlState.classesInvalidated)) {
						this.applyClasses();
						this.clearState(ControlState.classesInvalidated);
					} else {
						this.layoutChanged();
					}
				}
				this._state = this._state | ControlState.showing;
				this.shown();
				this.restoreScroll();
				this.dispatch("show");
			},
			shown: function() {

			},
			hideNode: function(remove) {
				this.storeScroll();
				if(remove === undefined) {
				    remove = this._removeNodeWhenHidden; // FIXME this speed up is/was? necessary for listviews
				}
				if(remove !== true && this._parent !== null) {
					if(this._parent.hasState(ControlState.acceptChildNodes) === false) {
						if(this._node.parentNode !== null) {
							this._node.parentNode.removeChild(this._node);
						}
					} else if(this._parent.isContainerShowing()) {
						this._node.style.display = "none";
					}
					this._parent.contentChanged();
				} else {
					if(this._node.parentNode !== null) {
						this._node.parentNode.removeChild(this._node);
					}
					if(this._parent !== null) {
						this._parent.contentChanged();
					}
				}
				this.hidden();
				this._state = this._state ^ ControlState.showing;
				this.dispatch("hide");
			},
			hidden: function() {},
			setFocus: function() {
				this.nodeNeeded().focus();
			},
			enable: function() {},
			disable: function() {},
			focus: function() {
				Control.setFocused(this);
			},
			blur: function() {
				if(Control.focused === this) {
					Control.setFocused(null);
				}
			},
			expand: function() {},
			collapse: function() {},
			activateReadonly: function() {},
			deactivateReadonly: function() {},
			hover: function() {},
			unhover: function() {},
			select: function() {
				this.dispatch("selected", arguments);
			},
			unselect: function() {
				this.dispatch("unselected", arguments);
			},
			storeScroll: function() {
				if(this._node !== null) {
					this._scrollLeft = this._node.scrollLeft;
					this._scrollTop = this._node.scrollTop;
				}
			},
			restoreScroll: function() {
				// leave as is for IE
				if(this._node !== null
						&& (this._scrollLeft !== this._node.scrollLeft || this._scrollTop !== this._node.scrollTop)) {
					this._node.scrollLeft = this._scrollLeft;
					this._node.scrollTop = this._scrollTop;
				}
			},
			onkeydown: function() {
				return this.fire("onKeyDown", arguments);
			},
			onkeypress: function() {
				return this.fire("onKeyPress", arguments);
			},
			onkeyup: function() {
				return this.fire("onKeyUp", arguments);
			},
			ondraggerneeded: function() {
				if(this.hasOwnProperty("_onDraggerNeeded")) {
					if(!((this._dragger = this.fire("onDraggerNeeded", arguments)) instanceof Dragger)) {
						if(this._dragger === undefined) {
							this._dragger = this.createDragger();
						} else {
							delete this._dragger;
						}
					}
				} else {
					this._dragger = this.createDragger();
				}
			},
			ondragstart: function() {
				if(this.isDraggable() && this.fire("onDragStart", arguments) !== false) {
					this.dispatch("draggerneeded", {});
					if(this.hasOwnProperty("_dragger")) {
						this._dragging = true;
						this._dragger.start.apply(this._dragger, arguments);
						this.update();
					}
				}
			},
			ondragevent: function() {},
			ondragcancel: function() {},
			ondragend: function() {},
			ondragenter: function(evt) {
				this.fire("onDragEnter", arguments);
			},
			ondragover: function(evt) {
				this.fire("onDragOver", arguments);
			},
			ondragleave: function(evt) {
				this.fire("onDragLeave", arguments);
			},
			ondrop: function(evt) {
				this.fire("onDrop", arguments);
			},
			onclick: function(evt) {
				if(this.fire("onClick", arguments) !== false) {
					if(this._executesAction === "onClick" && this._action) {
						this._action.execute(evt, this);
					}
				}

				// FIXME
				this.dispatch("tap", evt);
			},
			ondblclick: function(evt) {
				this.fire("onDblClick", arguments);

				// FIXME
				this.dispatch("dbltap", evt);
			},
			onmousedown: function(evt) {
				if(evt.target === this._node && this.isDraggable()) {
					evt.preventDefault();
				}
				this.fire("onMouseDown", arguments);
			},
			onmousemove: function() {
				this.fire("onMouseMove", arguments);
			},
			onmouseup: function() {
				this.fire("onMouseUp", arguments);
			},
			onmouseenter: function() {},
			onmouseleave: function() {},
			ontap: function() {
				this.fire("onTap", arguments);
			},
			ondbltap: function() {
				this.fire("onDblTap", arguments);
			},
			ontaphold: function() {
				this.fire("onTapHold", arguments);
			},
			ontouchstart: function(evt) {
				this._touchstartInfo = {
					time: Date.now(),
					clientX: evt.touches[0].clientX,
					clientY: evt.touches[0].clientY
				};
				this.fire("onTouchStart", arguments);
			},
			ontouchmove: function(evt) {
				this._touchstartInfo.deltaX = Math.abs(
						evt.touches[0].clientX - this._touchstartInfo.clientX);
				this._touchstartInfo.deltaY = Math.abs(
						evt.touches[0].clientY - this._touchstartInfo.clientY);
				this.fire("onTouchMove", arguments);
			},
			ontouchend: function(evt) {
				// FIXME Is this the right way to simulate tap?
				var ms = Date.now() - this._touchstartInfo.time;
				if(this._touchstartInfo.deltaX === undefined)  {
					this.dispatch("tap", evt);
				}

				this.fire("onTouchEnd", arguments);
			},
			onshow: function() {
				this.fire("onShow", arguments);
			},
			onhide: function() {
				this.fire("onHide", arguments);
			},
			onfocus: function() {
				// this.setFocused(true);
				// Control.setFocusedControl(this);
				if(this.fire("onFocus", arguments) !== false) {
					this._focused = true;
					this.update();
					// Control.setFocusedControl(this);
				}
			},
			onblur: function() {
				// this.setFocused(false);
				// Control.setFocusedControl(null);
				if(this.fire("onBlur", arguments) !== false) {
					this._focused = false;
					this.update();
				}
			},
			onresize: function() {
				this.fire("onResize", arguments);
			},
			ontransitionend: function() {
			    this.fire("onTransitionEnd", arguments);
			},
			getAction: function() {
				return this._action;
			},
			setAction: function(value, destroying) {
				if(this._action !== value) {
					if(this._action !== null) {
						this._action.un(this._actionListeners);
						delete this._actionListeners;
					}

					this._action = value;

					var me = this;
					if(this._action !== null) {
						this._actionListeners = this._action.on({
							"change": function() {
								me.update();
							},
							"destroy": function() {
								me.setAction(null);
							}
						});
					}

					if(destroying !== true) {
						this.update();
					}
				}
			},


// PROPERTIES
			getElement: function() {
			/**
			 *
			 * @returns {String}
			 */
				return this._element;
			},
			setElement: function(value) {
			/**
			 *
			 * @param value
			 */
				if(this._element !== value) {
					this._element = value;
					this.recreateNode();
				}
			},
			getContent: function() {
				return this._content;
			},
			getTextContent: function() {
				return this.nodeNeeded().textContent;
			},
			setContent: function(value) {
				if(this._content !== value) {
					this._content = value;
					if(this._node !== null) {
						// TODO Can we be sure that all childNodes have
						// disappeared after following call to clearState?
						this.clearState("acceptChildNodes", true, true);
						this._node.innerHTML = this.getInnerHtml();
						this._nodes = {};
						this.initializeNodes();
						this.setState("acceptChildNodes", true);
						this.layoutChanged();
					}
				}
			},
			setFocused: function(value) {
				if(value) {
					this.setFocus();
				} else {
					this.blur();
				}
			},
			getDraggable: function() {
			/**
			 * Property accessor
			 */
				return this._draggable;
			},
			setDraggable: function(value) {
			/**
			 *
			 * @param value
			 *            {Boolean}
			 */
				if(this._draggable !== value) {
					this._draggable = value;
					this.update();
				}
			},
			getEnabled: function() {
			/**
			 * Property accessor
			 */
				return this._enabled;
			},
			setEnabled: function(value) {
			/**
			 *
			 * @param value
			 *            {Boolean}
			 */
				if(this._enabled !== value) {
					this._enabled = value;
					this.update();
				}
			},
			getReadonly: function() {
			/**
			 * Property accessor
			 */
				return this._readonly;
			},
			setReadonly: function(value) {
			/**
			 *
			 * @param value
			 *            {Boolean}
			 */
				if(this._readonly !== value) {
					this._readonly = value;
					this.update();
				}
			},
			setTabIndex: function(value) {
				if(this._tabIndex !== value) {
					this._tabIndex = value;
					if(this._node !== null) {
						this._node.tabIndex = value;
					}
				}
			},
			getVisible: function() {
			/**
			 * Property accessor
			 */
				return this._visible;
			},
			setVisible: function(value) {
			/**
			 *
			 * @param value
			 *            {Boolean}
			 */
				if(this._visible !== value) {
					this._visible = value;
					// FIXME is this too heavy?
					if(this.isDesigning() === true) {
						this.setState(ControlState.classesInvalidated, false);
					}
					this.update();
				}
			},
			getSelected: function() {
			/**
			 * Property accessor
			 */
				return this._selected;
			},
			setSelected: function(value) {
			/**
			 *
			 * @param value
			 *            {Boolean}
			 */
				if(this._selected !== value) {
					if(value === true && this._groupIndex !== -1 && this._parent !== null) {
						this._parent.selectControl(this);
					} else {
						this._selected = value;
						this.update();
					}
				}
			},
			getGroupIndex: function() {
			/**
			 * Property accessor
			 */
				return this._groupIndex;
			},
			setGroupIndex: function(value) {
			/**
			 *
			 * @param value
			 *            {Number}
			 */
				if(this._groupIndex !== value) {
					this._groupIndex = value;
				}
			},
			getClassName: function() {
				return this._className || Control.getClassNameFor(this.constructor);
			},
			setClassName: function(value) {
				if(this._className !== value) {
					if(value !== null) {
						this._className = value;
					} else {
						delete this._className;
					}
					this.setState(ControlState.classesInvalidated, !this.isLoading());
				}
			},
			getClasses: function() {
				return this._classes;
			},
			setClasses: function(value) {
				if(this._classes !== value) {
					if(value !== "") {
						this._classes = value;
					} else {
						delete this._classes;
					}
					this.setState(ControlState.classesInvalidated, !this.isLoading());
				}
			},
			getCssRules: function() {
			/**
			 *
			 * @returns {CssRules}
			 */
				return this._cssRules;
			},
			getCss: function() {
				return this._css;
			},
			setCss: function(value) {
				if(value === null || (typeof value === "object" && js.keys(value).length === 0)) {
					this._cssRules = null;
				} else {
					if(typeof value === "string") {
						value = js.str2obj(value);
					} else if(value instanceof Array) {
						value = js.str2obj(value.join(""));
					}

                    /*- Resolve references to other classes and apply other transformations */
					CssRules.normalize(String.of(this.constructor), value, this);

					if(this._cssRules === null) {
						//var element = this.getElement();
						var className = this.getClassName();
						var hashCode = this.hashCode();

						if(className !== "") {
							className = String.format(".%s", className.replace(/ /g, "."));
						}

						this._cssRules = new CssRules();
						//this._cssRules.setSelector(String.format("%s%s#x%d", element, className, hashCode));
						this._cssRules.setSelector(String.format("#%s", this.getNodeId()));
						this._cssRules.setRules(value);
					} else {
						this._cssRules.setRules(value);
					}
				}
				this._css = value;
				this.setState(ControlState.classesInvalidated, !this.isLoading());
			},
			isIndexStored: function() {
				return Component.getInheritedPropertyValue(this, "index") !== undefined;
			}
		},
		statics: {

			focused: null,

			findByNode: function(node) {
				while(node !== null && node[EventDispatcher.elementKey] === undefined) {
					node = node.parentNode || null; // IE
				}
				return node !== null ? node[EventDispatcher.elementKey] : null;
			},
			setFocused: function(control) {
				if(this.focused !== control) {
					this.focused = control;
				}
			},
			update: function(f) {
				if(this.isLoading() || (this._parent !== null && this._parent.allowsUpdateChildren() === false)) {
					if(f !== undefined) {
						setTimeout(f, 0);
						// f();
					}
					return "nothing-to-do";
				} else {
					this._post_update = this._post_update || [];
					if(f !== undefined) {
						this._post_update.push(f);
					}
					ControlUpdater.queue(this);
					return "queued";
				}
			},
			getClassNameFor: function(ctor) {
				var proto = ctor.prototype;
				var className = proto["@className"];
				var own = proto.hasOwnProperty("@className");

				// Once per prototype...
				if(own === false) {
					var superctor = Class.getSuperClass(ctor);
					own = proto.hasOwnProperty("@css");
					if(own === true) {
						var rules = (proto["@css-rules"] = new CssRules());
						var selector = Stylesheet.generateSelector(String.of(ctor).replace(/\//g, "-"));
						className = selector.substring(1);
						//rules.setSelector(".vcl" + selector);
						rules.setSelector(selector + "[id^='vcl-']");
						rules.setRules(CssRules.normalize(String.of(ctor), proto["@css"]));
					} else {
						className = "";// Stylesheet.generateSelector(cls.getName().split("/").pop()).substring(1);
					}

					if(superctor !== null && superctor !== Component) {
						var scn = Control.getClassNameFor(superctor);
						if(scn !== "") {
							if(className !== "") {
								className += " ";
							}
							className += scn;
						}
					}

					proto["@className"] = className;
				}
				return className;
			}
		},
		properties: {

			"parent": {
				type: Component,
				visible: false,
				stored: false,
				set: Function
			},
			"index": {
				set: Function,
				get: Function,
				stored: Function,
				type: Type.INTEGER,
				fixUp: true, /*- FIXME Does this work? */
				def: -1
			},
			// node
			"element": {
				set: Function,
				type: Type.STRING
			},
			"content": {
				type: Type.STRING,
				set: Function
			},
			"tabIndex": {
				type: Type.INTEGER,
				set: Function	
			},
			// css, classes, style
			"className": {
				get: Function,
				set: Function,
				type: Type.STRING,
				def: null
			},
			"classes": {
				set: Function,
				type: Type.STRING
			},
			"css": {
				Set: Function,
				set: function(value) {
					if(typeof value === "string") {
						value = js.str2obj(value);
					} else if(value instanceof Array) {
						value = js.str2obj(value.join(""));
					}

					function superMixIn(dest, src) {
						for(var k in src) {
							if(src.hasOwnProperty(k)) {
								var v = src[k];
								if(v !== null && Object.prototype.toString.apply(v, []) === "[object Object]") {
									dest[k] = dest[k] || {};
									superMixIn(dest[k], v);
								} else {
									dest[k] = v;
								}
							}
						}
						return dest;
					}

					if(this.hasOwnProperty("_css")) {
						value = superMixIn(js.mixIn(this._css), value);
					}

					this.setCss(value, true);
				},
				type: Type.OBJECT,
				def: null
			},
			// state
			"action": {
				set: Function,
				type: Action
			},
			"groupIndex": {
				set: Function,
				type: Type.INTEGER
			},
			"draggable": {
				set: Function,
				type: [true, false, "parent"]
			},
			"enabled": {
				set: Function,
				type: [true, false, "always", "never"]
			},
			"readonly": {
				set: Function,
				type: Type.BOOLEAN
			},
			"selected": {
				set: Function,
				type: [true, false, "always", "never"]
			},
			"visible": {
				set: Function,
				type: [true, false, "always", "never"]
			},
			"executesAction": {
				type: ["No", "onClick"]
			},
			// events
			"onClick": {
				type: Type.EVENT
			},
			"onDblClick": {
				type: Type.EVENT
			},
			"onMouseDown": {
				type: Type.EVENT
			},
			"onMouseUp": {
				type: Type.EVENT
			},
			"onMouseMove": {
				type: Type.EVENT
			},
			"onMouseEnter": {
				type: Type.EVENT
			},
			"onMouseLeave": {
				type: Type.EVENT
			},
			"onNodeCreated": {
				type: Type.EVENT
			},
			"onNodeInserted": {
				type: Type.EVENT
			},
			"onKeyPress": {
				type: Type.EVENT
			},
			"onKeyUp": {
				type: Type.EVENT
			},
			"onKeyDown": {
				type: Type.EVENT
			},
			"onDragStart": {
				type: Type.EVENT
			},
			"onDragEvent": {
				type: Type.EVENT
			},
			"onDragCancel": {
				type: Type.EVENT
			},
			"onDragEnd": {
				type: Type.EVENT
			},
			"onDraggerNeeded": {
				type: Type.EVENT
			},
			"onDragEnter": {
				type: Type.EVENT
			},
			"onDragOver": {
				type: Type.EVENT
			},
			"onDragLeave": {
				type: Type.EVENT
			},
			"onDrop": {
				type: Type.EVENT
			},
			"onResize": {
				type: Type.EVENT
			},
			"onScroll": {
				type: Type.EVENT
			},
			"onRender": {
				type: Type.EVENT
			},
			"onHint": {
				type: Type.EVENT
			},
			"onFocus": {
				type: Type.EVENT
			},
			"onBlur": {
				type: Type.EVENT
			},
			"onShow": {
				type: Type.EVENT
			},
			"onHide": {
				type: Type.EVENT
			},
			"onTap": {
				type: Type.EVENT
			},
			"onDblTap": {
				type: Type.EVENT
			},
			"onTouchStart": {
				type: Type.EVENT
			},
			"onTouchMove": {
				type: Type.EVENT
			},
			"onTouchEnd": {
				type: Type.EVENT
			},
			"onTouchCancel": {
				type: Type.EVENT
			},
			"onGesture": {
				type: Type.EVENT
			},
			"onTransitionEnd": {
				type: Type.EVENT
			}
		}
	}));
});
define('vcl/ui/Element',['require','js/defineClass','../Control','js/Type','js/Method','cavalion.org/data/SourceEvent'],function(require) {

	var Element = require("js/defineClass");
	var Control = require("../Control");
	var Type = require("js/Type");
	var Method = require("js/Method");
	var SourceEvent = require("cavalion.org/data/SourceEvent");

	return (Element = Element(require, {

		inherits: Control,

		prototype: {
			
			'@css': {
				"&.disabled": {
					"pointer-events": "none"
				}
			},

			/*- "dataawarity" */
			_source: null,

			/*- @overrides ../Control.prototype._executesAction */
			_executesAction: "onClick",

			/*- @overrides Control.prototype.getInnerHtml */
			getInnerHtml: function() {
				var tpl = this.inherited(arguments);
				if(this._source !== null) {
				    var escaping = false, open = false;
				    var fmt = "", value;
				    var values = [];

				    /**
				     *
				     */
				    function add(s) {
				        if (open === true) {
				            value += s;
				        } else {
				            fmt += s;
				        }
				    }

				    for (var i = 0, l = tpl.length; i < l; ++i) {
				        var ch = tpl.charAt(i);
				        if (escaping === true) {
				            add(ch);
				            escaping = false;
				        } else if (ch === "\\") {
				            escaping = true;
				        } else if (ch === "{" && open === false) {
				            open = true;
				            value = "";
				        } else if (ch === "}" && open === true) {
				            open = false;
				            value = value.split(":");
				            if (value[0].charAt(0) !== "%" || value.length !== 2) {
				                fmt += "%H";
				            } else {
				                fmt += value[0];
				            }
				            values.push(value.pop());
				        } else {
				            add(ch);
				        }
				    }

				    var designing = this.isDesigning();
				    var active = this._source !== null && this._source.isActive();
				    values.forEach(function(v, index) {
				    	if(designing === false) {
				    		if(active === true) {
				    			v = this._source.getAttributeValue(v);
					    		if(v === undefined || v === null) {
					    			v = "";
					    		}
				    		} else {
				    			v = "";
				    		}
				    		values[index] = v;
				    	} else {
				    		values[index] = String.format("{%H}", v);
				    	}
				    }, this);

				    tpl = String.format.apply(String, [fmt].concat(values));
				}
				return tpl;
			},

            /*- */
			setAttributes: function(value) {
				/*- Progressive: not holding on to attributes */
				var node = this.nodeNeeded();
				if(typeof value === "string") {
					value = js.str2obj(value);
				}
				for(var k in value) {
					node.setAttribute(k, value[k]);
				}
			},

			sourceNotifyEvent: function(event, data) {
				switch(event) {

					case SourceEvent.activeChanged:
					case SourceEvent.changed:
					case SourceEvent.updated:
						this.render();
						break;

					case SourceEvent.busyChanged:
						break;

					case SourceEvent.layoutChanged:
						break;
				}
			},

			sourceDestroyed: function() {
				this.setSource(null);
			},

			setSource: function(value) {
				if(this._source !== value) {
					if(this._source !== null) {
						Method.disconnect(this._source, "notifyEvent", this, "sourceNotifyEvent");
//						Method.disconnect(this._source, "destroy", this, "sourceDestroyed");
					}
					this._source = value;
					if(this._source !== null) {
						Method.connect(this._source, "notifyEvent", this, "sourceNotifyEvent");
//						Method.connect(this._source, "destroy", this, "sourceDestroyed", "before");
					}
					this.sourceNotifyEvent(SourceEvent.changed);
				}

			}
		},

		properties: {

            /*- */
			"attributes": {
				/*- This property is not stored (when not designing?) */
				stored: false,
				type: Type.OBJECT,
				get: null,
				set: Function
			}
		},

		statics: {
		}
	}));
});
define('vcl/ui/Container',["require", "js/defineClass", "./Element", "js/Type"], function(require, Container, Element, Type) {

	return (Container = Container(require, {

		inherits: Element,

		prototype: {

			/**
			 * @overrides ../Control.prototype.getInnerHtml
			 */
			getInnerHtml: function() {
				return this._content || "";
			},

			/**
			 * @overrides ../Control.prototype.isContainer
			 */
			isContainer: function() {
				return true;
			},
			
            align: function (control, origin) {
            	// No hay nada de hacer yo creo
			},

			/**
			 * @overrides ../Control.prototype.storeScroll
			 */
			storeScroll: function() {
				this.hasOwnProperty("_controls") && this._controls.forEach(function(control) {
					control.storeScroll();
				});
				return this.inherited(arguments);
			},

			/**
			 * @overrides ../Control.prototype.restoreScroll
			 */
			restoreScroll: function() {
				this.hasOwnProperty("_controls") && this._controls.forEach(function(control) {
					control.restoreScroll();
				});
				return this.inherited(arguments);
			},

			/**
			 *
			 */
			parentScrolled: function(parent, evt) {
				if(this.hasOwnProperty("_controls")) {
					for (var i = 0, l = this._controls.length; i < l; ++i) {
						this._controls[i].parentScrolled(parent, evt);
					}
				}
			}
		},

		properties: {

			"controls": {
				type: Type.ARRAY,
				visible: false,
				stored: false
			},
			"onReceiveParams": {
				type: Type.EVENT
			}
		}
	}));
});
define('vcl/ui/Group',["require", "js/defineClass", "./Container"], function(require, Group, Container) {

	return (Group = Group(require, {

		inherits: Container,

		prototype: {
			"@css": {
				"&.inline-block": {
					display: "inline-block"
				}
			}
		},

		properties: {

		}

	}));
});
define('vcl/ui/Node',['require','js/defineClass','js/referenceClass!./Tree','js/Deferred','js/Type','./Group'],function(require) {

	var Node = require("js/defineClass");
	var Tree = require("js/referenceClass!./Tree");
	var Deferred = require("js/Deferred");
	var Type = require("js/Type");
//	var HtmlElement = require("cavalion.org/util/HtmlElement");
	var Group = require("./Group");

	return (Node = Node(require, {
		inherits: Group,
		prototype: {

			'@css': {},

			_content:
			/** @overrides ../Control.prototype */
				"<div class=\"selection\">&nbsp;</div>" +
				"<div class=\"icon\"></div>" +
				"<div tabindex=\"1\" class=\"text\"></div>" +
				"<ol></ol>" +
				"",

			_element: "li",

			_text: "",
			_expanded: false,
			_expandable: "auto",

			_childNodesLoaded: false,
			_onChildNodesNeeded: null,

			_onCollapse: null,
			_onCollapsed: null,
			_onExpand: null,
			_onExpanded: null,

			createNode: function() {
			/**
			 * @overrides ../Component.prototype.loaded
			 */
				var expanded = this._expanded;
				this._expanded = false;

				this.inherited(arguments);

				this.setExpanded(expanded);
			},
			insertControl: function() {
			/**
			 * @overrides ../Control.prototype.insertControl
			 */
				this.setState("classesInvalidated");
				this.inherited(arguments);
			},
			removeControl: function(control) {
			/**
			 * @overrides ../Control.prototype.insertControl
			 */
				this.setState("classesInvalidated");
				this.inherited(arguments);

				var tree = this.getTree();
				if(tree !== null) {
					var selection = tree.getSelection(), index;
					if((index = selection.indexOf(control)) !== -1) {
						selection.splice(index, 1);
						tree.setSelection(selection);
					}
				}
			},
			determineClasses: function() {
			/**
			 * @overrides ../Control.prototype.determineClasses
			 */
				var r = this.inherited(arguments);
				if(this.isExpandable()) {
					r.push("expandable");
				}
				return r;
			},
			initializeNodes: function() {
			/**
			 * @overrides ../Control.prototype.initializeNodes
			 */
				this.inherited(arguments);

				this._nodes.selection = this.getChildNode(0);
				this._nodes.icon = this.getChildNode(1);
				this._nodes.text = this.getChildNode(2);
				this._nodes.container = this.getChildNode(3);

				if(!this._nodes.text) {
					throw new Error("No text node");
				}

				if(!this._nodes.container) {
					throw new Error("No container node");
				}
			},
			render: function() {
			/**
			 * @overrides ../Control.prototype.render
			 */
				if(this._text instanceof Array) {
					this._nodes.text.innerHTML = String.format.apply(String, this._text);
				} else {
					this._nodes.text.innerHTML = this._text;
				}
			},

			isExpanded: function() {
			/**
			 * @overrides ../Control.prototype.isExpanded
			 */
				return this._expanded;
			},
			isControlVisible: function(control) {
			/**
			 * @overrides ../Control.prototype.isControlVisible
			 */
				return this._expanded === true && this.inherited(arguments);
			},
			isContainerShowing: function() {
			/**
			 * @overrides ../Control.prototype.isContainerShowing
			 */
				return this.isExpanded();
			},

			getClientNode: function() {
			/**
			 * @overrides ../Control.prototype.getClientNode
			 */
				if(this._node === null) {
					this._nodeNeeded();
				}
				return this._nodes.container;
			},
			textChanged: function(newValue, oldValue) {
				this.setState("invalidated", true);
			},

			reloadChildNodes: function(callback) {
                delete this._childNodesLoaded;
                this.destroyControls();
                this.childNodesNeeded(callback);
			},
			childNodesNeeded: function(callback) {
				if(!this.hasOwnProperty("_childNodesLoaded")) {
					this._childNodesLoaded = this.dispatch("childnodesneeded");
				}
				if(this._childNodesLoaded instanceof Deferred) {
					var me = this;

					this.addClass("expanding");

					this._childNodesLoaded.addCallback(function(res) {
						me._childNodesLoaded = true;
						me.update(function() {
    						if(typeof callback === "function") {
    							callback();
    						}
						});
                        me.removeClass("expanding");
						return res;
					});
				} else if(this._childNodesLoaded !== false && typeof callback === "function") {
					callback();
				}
			},
			
			onclick: function(evt, force) {
			/**
			 * @overrides ../Control.prototype.onclick
			 */
				var r = this.inherited(arguments);
				if(r !== false && (force === true || (evt.target === this._nodes.icon && this.isExpandable()))) {
					if(this._expanded === true) {
						this.dispatch("collapse", evt);
					} else {
						this.dispatch("expand", evt);
					}
				}
				return r;
			},
			ondblclick: function(evt) {
			/**
			 * @overrides ../Control.prototype.ondblclick
			 */
				var r = this.inherited(arguments);
				if(r !== false && this.isExpandable()) {
					if(this._expanded === true) {
						this.dispatch("collapse", evt);
					} else {
						this.dispatch("expand", evt);
					}
				}
				return r;
			},
			onexpand: function(evt) {
				if(this._childNodesLoaded instanceof Deferred) {
					return;
				}

				if(this._onExpand !== null) {
					this._expanded = this._onExpand.apply(this, [evt]) !== false;
				} else {
					this._expanded = true;
				}

				if(this._expanded === true) {
					this.childNodesNeeded();
					this.update();
				}

				return this._expanded;
			},
			oncollapse: function(evt) {
				if(this._onCollapse !== null) {
					this._expanded = (this._onCollapse.apply(this, [evt]) === false);
				} else {
					this._expanded = false;
				}

				if(this._expanded === false) {
					this.update();
				}
				return this._expanded;
			},
			onchildnodesneeded: function(evt) {
				var tree, r;

				if(this.hasOwnProperty("_onChildNodesNeeded")) {
					r = this.fire("onChildNodesNeeded");
				}

				if(r !== false && (tree = this.getTree()) !== null) {
					r = tree.dispatch("nodesneeded", this);
				} else {
					r = true;
				}

				return r;
			},
			getChildNodesLoaded: function() {
				return this._childNodesLoaded;
			},
			whenChildNodesLoaded: function(callback) {
				this.childNodesNeeded(callback);
			},
			getTree: function() {
				if(this._parent instanceof Tree) {
					return this._parent;
				}
				return this._parent ? this._parent.getTree() : null;
			},
			getText: function() {
				if(this.isDesigning()) {
					return this._text || this._name;
				}
				return this._text;
			},
			setText: function(value) {
				if(this._text !== value) {
					value = [value, this._text];
					this._text = value[0];
					this.textChanged(this._text, value[1]);
				}
			},

			getExpanded: function() {
				return this._expanded;
			},
			setExpanded: function(value) {
				if(this._expanded !== value) {
					if(this.isExpandable() && this._node !== null && this.isLoading() === false) {
						if(this._expanded === true) {
							this.dispatch("collapse");
						} else if(this._expanded === false) {
							this.dispatch("expand");
						}
					} else {//if(value === true && this.isExpandable()) {
						this._expanded = value;
					}
				}
			},
			isExpandable: function() {
				return this._expandable === "auto" ?
						this.hasOwnProperty("_controls") && this._controls.length > 0 : this._expandable;
			},
			getExpandable: function() {
				return this._expandable;
			},
			setExpandable: function(value) {
				if(this._expandable !== value) {
					this._expandable = value;
					this.setState("classesInvalidated", true);
				}
			},

			getOnChildNodesNeeded: function() {
				return this._onChildNodesNeeded;
			},
			setOnChildNodesNeeded: function(value) {
				this._onChildNodesNeeded = value;
			},
			getOnCollapse: function() {
				return this._onCollapse;
			},
			setOnCollapse: function(value) {
				this._onCollapse = value;
			},
			getOnExpand: function() {
				return this._onExpand;
			},
			setOnExpand: function(value) {
				this._onExpand = value;
			},
			getOnCollapsed: function() {
				return this._onCollapsed;
			},
			setOnCollapsed: function(value) {
				this._onCollapsed = value;
			},
			getOnExpanded: function() {
				return this._onExpanded;
			},
			setOnExpanded: function(value) {
				this._onExpanded = value;
			}
		},
		properties: {
			"text": {
				set: Function,
				type: Type.STRING
			},
			"expanded": {
				set: Function,
				type: Type.BOOLEAN
			},
			"expandable": {
				set: Function,
				type: [
					true, false, "auto"
				]
			},
			"onChildNodesNeeded": {
				set: Function,
				type: Type.EVENT
			},
			"onCollapse": {
				set: Function,
				type: Type.EVENT
			},
			"onCollapsed": {
				set: Function,
				type: Type.EVENT
			},
			"onExpand": {
				set: Function,
				type: Type.EVENT
			},
			"onExpanded": {
				set: Function,
				type: Type.EVENT
			}
		},
		statics: {
			/*-* Example: vcl-comp/app/Home.tree.js */
			build: function($, config, obj) {
				var arr = []; config = config || {};
				for(var k in obj) {
					var props = obj[k][0], Class = props['@class'] || "vcl/ui/Node";
					var kids = arguments.callee($, config, obj[k][1]);
					
					js.mixIn(props, config.defaults || {});

					if(typeof props.vars === "string") {
						props.vars = js.str2obj(props.vars);
					}
					
					if(props.hasOwnProperty("uri")) {
						props.uri = (config.prefix || "") + props.uri;
						props.vars = js.mixIn(props.vars || {}, {formUri: props.uri});
						delete props.uri;
					}
					if(props.control) {
						props.vars = js.mixIn(props.vars || {}, {control: props.control});
						delete props.control;
					}
					if(!props.hasOwnProperty("text")) {
						props.text = k;
					}
					
					arr.push($(Class, props.name || ("node_" + k), props, kids));
				}
				return arr;
			}
		}
	}));

});
define('devtools/NavigatorNode',['require','js/defineClass','vcl/EventDispatcher','vcl/ui/Node','js/Type'],function(require) {

	var NavigatorNode = require("js/defineClass");
    var EventDispatcher = require("vcl/EventDispatcher");
	var Node = require("vcl/ui/Node");
	var Type = require("js/Type");

	return (NavigatorNode = NavigatorNode(require, {
		inherits: Node,
        prototype: {
            _onChange: null,
            
            initializeNodes: function () {
            	/** @overrides vcl/Control.prototype.initializeNodes */
                var r = this.inherited(arguments);

                var checkbox = document.createElement("input");
                checkbox.setAttribute("type", "checkbox");
                checkbox.className = "navigator checkbox";
                checkbox.onchange = EventDispatcher.handleEvent;

                this._node.insertBefore(checkbox, this._nodes.icon);
                this._nodes.checkbox = checkbox;

                return r;
            },
            hasClass: function (className) {
            	/** @overrides vcl/Control.prototype.hasClass */
                return this.determineClasses().indexOf(className) !== -1;
            },
            determineClasses: function () {
            	/** @overrides vcl/Control.prototype.determineClasses */
                var r = this.inherited(arguments);
                // if this._parent is not a NavigatorNode...
                if (this._parent && !(this._parent instanceof NavigatorNode)) {
                    // ...consider this to be a root node
                    r.push("root");
                }
                var item = this.getVar("resource") || {
                    type: ""
                };
                r.push(item.type.indexOf("Folder") === -1 ? "file" : "folder");
                return r;
            },
            render: function () {
            	/** @overrides vcl/Control.prototype.initializeNodes */
                //node.setText(root ? String.format("%H <span class='desc'>- %H</span>", item.name, item.uri) : item.name);
                var item = this.getVar("resource") || {};
                if (this.hasClass("root")) {
                    this._nodes.text.innerHTML = String.format("%H&nbsp;&nbsp;<span class='desc'>%H</span>", item.name, item.uri);
                } else {
                    this._nodes.text.innerHTML = item.name;
                }
            },
            onchange: function () {
                return this.fire("onChange", arguments);
            },
            setChecked: function (value) {
                this.nodeNeeded();
                this.getNode("checkbox").checked = value;
            },
            getChecked: function () {
                this.nodeNeeded();
                return this.getNode("checkbox").checked;
            }
        },
        properties: {
            onChange: {
                type: Type.EVENT
            }
        }
    }));
});
/*!
 * jQuery JavaScript Library v2.1.0
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-01-23T21:10Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper window is present,
		// execute the factory and get jQuery
		// For environments that do not inherently posses a window with a document
		// (such as Node.js), expose a jQuery-making factory as module.exports
		// This accentuates the need for the creation of a real window
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var trim = "".trim;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.0",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return a 'clean' array
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return just the object
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		return obj - parseFloat( obj ) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		// Support: Firefox <20
		// The try/catch suppresses exceptions thrown when attempting to access
		// the "constructor" property of certain host objects, ie. |window.location|
		// https://bugzilla.mozilla.org/show_bug.cgi?id=814622
		try {
			if ( obj.constructor &&
					!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
				return false;
			}
		} catch ( e ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android < 4.0, iOS < 6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	trim: function( text ) {
		return text == null ? "" : trim.call( text );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v1.10.16
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-01-13
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	compile,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf if we can't use a native one
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

	// Prefer arguments quoted,
	//   then not containing pseudos/brackets,
	//   then attribute selectors/non-parenthetical expressions,
	//   then anything else
	// These preferences are here to reduce the number of selectors
	//   needing tokenize in the PSEUDO preFilter
	pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( documentIsHTML && !seed ) {

		// Shortcuts
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType === 9 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== strundefined && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare,
		doc = node ? node.ownerDocument || node : preferredDoc,
		parent = doc.defaultView;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;

	// Support tests
	documentIsHTML = !isXML( doc );

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", function() {
				setDocument();
			}, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", function() {
				setDocument();
			});
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Check if getElementsByClassName can be trusted
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
		div.innerHTML = "<div class='a'></div><div class='a i'></div>";

		// Support: Safari<4
		// Catch class over-caching
		div.firstChild.className = "i";
		// Support: Opera<10
		// Catch gEBCN failure to find non-leading classes
		return div.getElementsByClassName("i").length === 2;
	});

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select t=''><option selected=''></option></select>";

			// Support: IE8, Opera 10-12
			// Nothing should be selected when empty strings follow ^= or $= or *=
			if ( div.querySelectorAll("[t^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [elem] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[5] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] && match[4] !== undefined ) {
				match[2] = match[4];

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !group ) {
			group = tokenize( selector );
		}
		i = group.length;
		while ( i-- ) {
			cached = matcherFromTokens( group[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
};

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		match = tokenize( selector );

	if ( !seed ) {
		// Try to minimize operations if there is only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
				}
				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}
	}

	// Compile and execute a filtering function
	// Provide `match` to avoid retokenization if we modified the selector above
	compile( selector, match )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger("ready").off("ready");
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android < 4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Math.random();
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android < 4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



/*
	Implementation Summary

	1. Enforce API surface and semantic compatibility with 1.9.x branch
	2. Improve the module's maintainability by reducing the storage
		paths to a single mechanism.
	3. Use the same single mechanism to support "private" and "user" data.
	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	5. Avoid exposing implementation details on user objects (eg. expando properties)
	6. Provide a clear path for implementation upgrade to WeakMap in 2014
*/
var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {
						name = attrs[ i ].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.slice(5) );
							dataAttr( elem, name, data[ name ] );
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) );

	// #11217 - WebKit loses check when the name is after the checked attribute
	div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
	// old WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Make sure textarea (and checkbox) defaultValue is properly cloned
	// Support: IE9-IE11+
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome < 28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				// Support: Android < 4.0
				src.defaultPrevented === undefined &&
				src.getPreventDefault && src.getPreventDefault() ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Create "bubbling" focus and blur events
// Support: Firefox, Chrome, Safari
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE 9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE 9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Support: IE >= 9
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Support: IE >= 9
		// Fix Cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit
					// jQuery.merge because push.apply(_, arraylike) throws
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit
					// jQuery.merge because push.apply(_, arraylike) throws
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Fixes #12346
					// Support: Webkit, IE
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, events, type, key, j,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					events = Object.keys( data.events || {} );
					if ( events.length ) {
						for ( j = 0; (type = events[j]) !== undefined; j++ ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle ?

			// Use of this method is a temporary fix (more like optmization) until something better comes along,
			// since it was removed from specification and supported only in FF
			window.getDefaultComputedStyle( elem[ 0 ] ).display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') in IE9, see #12537
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due to missing dependency),
				// remove it.
				// Since there are no other hooks for marginRight, remove the whole object.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.

			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
		divReset = "padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;" +
			"-moz-box-sizing:content-box;box-sizing:content-box",
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;" +
		"margin-top:1px";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
		div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;" +
			"position:absolute;top:1%";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Use window.getComputedStyle because jsdom on node.js will break without it.
	if ( window.getComputedStyle ) {
		jQuery.extend(support, {
			pixelPosition: function() {
				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {
				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );
				marginDiv.style.cssText = div.style.cssText = divReset;
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );

				// Clean up the div for other support tests.
				div.innerHTML = "";

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {

			if ( !values[ index ] ) {
				hidden = isHidden( elem );

				if ( display && display !== "none" || !hidden ) {
					data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css(elem, "display") );
				}
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set. See: #7116
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				// Support: Chrome, Safari
				// Setting style to blank string required to delete "style: x !important;"
				style[ name ] = "";
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// Work around by temporarily setting element display to inline-block
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );
		// Get default display if display is currently "none"
		if ( display === "none" ) {
			display = defaultDisplay( elem.nodeName );
		}
		if ( display === "inline" &&
				jQuery.css( elem, "float" ) === "none" ) {

			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS 5.1, Android 4.x, Android 2.3
	// Check the default checkbox/radio value ("" on old WebKit; "on" elsewhere)
	support.checkOn = input.value !== "";

	// Must access the parent to make an option select properly
	// Support: IE9, IE10
	support.optSelected = opt.selected;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Check if an input maintains its value after becoming a radio
	// Support: IE9, IE10
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

// Support: IE9+
// Selectedness for an option in an optgroup can be inaccurate
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {
						optionSet = true;
					}
				}

				// force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			// Support: Webkit
			// "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
if ( window.ActiveXObject ) {
	jQuery( window ).on( "unload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				// Do send the request
				// This may raise an exception which is actually
				// handled in jQuery.ajax (so no try/catch here)
				xhr.send( options.hasContent && options.data || null );
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = url.slice( off );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// If we don't have gBCR, just use 0,0 rather than error
		// BlackBerry 5, iOS 3 (original iPhone)
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// We assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// if curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

define('devtools/Resources',['require','jquery','js','js/Deferred'],function(require) {

	var $ = require("jquery");
	var js = require("js");
	var Deferred = require("js/Deferred");

	var BASE_URL = "/stuv/rest/resources/";

	function deferred(request) {
		var r = new Deferred();
		request.success(function() {
			r.callback.apply(r, arguments);
		});
		request.error(function() {
			var message = request.status + " - " + request.statusText;
			var error = js.mixIn(new Error(message), {
				request: request,
				responseJSON: request.responseJSON,
				responseText: request.responseText,
				status: request.status
			});
			r.errback(error);
		});
		return r;
	}

	function adjust(uri) {
		return BASE_URL + (window.escape(uri) || "");
	}

	return {

		index: function(uris) {
			return deferred($.ajax(adjust("index") + "?uris=" +
					window.escape(uris.join(";"))));
		},

		list: function(uri) {
			return deferred($.ajax(adjust(uri) + "?list"))
				.addCallback(function(res) {
					res.forEach(function(resource) {
						resource.uri = uri + "/" + resource.name;
					});
					return res;
				});
		},

		get: function(uri) {
			return deferred($.ajax(adjust(uri) + "?list=false"));
		},

		create: function(uri, resource) {
			return deferred($.ajax(adjust(uri), {
				method: "POST",
				contentType: "application/json",
				data: JSON.stringify({
					"text": resource.text,
					"revision": resource.revision,
					"position": 0
				})
			}));
		},
		
		'delete': function(uri) {
		    return deferred($.ajax(adjust(uri), {
		        method: "DELETE"
		    }));
		},

		update: function(uri, resource) {
			return deferred($.ajax(adjust(uri), {
				method: "PUT",
				contentType: "application/json",
				data: JSON.stringify({
					"text": resource.text,
					"revision": resource.revision,
					"position": 0
				})
			}));
		}
	}

});
define('entities/Instance',['require','js/defineClass','cavalion.org/data/Source','js'],function(require) {

	var Instance = require("js/defineClass");
	var Source = require("cavalion.org/data/Source");
	var js = require("js");

	var all = {};
	var log = [];

	return (Instance = Instance(require, {
		implementing: [Source],
		statics: {
			all: all,
			log: log,
			model: null,
			getModel: function(entity) {
				var r;
				if(!this._model || (r = this._model[entity] === undefined)) {
					r = entity;
				} else {
					
				}
				return r;
			},
			get: function(entity, key) {
				var instance;
				if(all[entity] === undefined) {
					all[entity] = {};
				}
				if((instance = all[entity][key]) === undefined) {
					instance = all[entity][key] = new Instance(entity, key);
				}
				return instance;
			},
			clearAll: function() {
				for(var k in all) {
					delete all[k];
				}
			}
		},
		prototype: {
			_entity: null,
			_values: null,
			_key: null,
			_dirty: null,
			_model: null,
			
			constructor: function(entity, key, values) {
				if(typeof entity === "string") {
					entity = Instance.getModel(entity);
				}
				
				this._entity = entity;
				this._key = key;
				this._values = values || {};
				this._dirty = {};
			},

			/**
			 * @see js/serialize
			 */
			serializeJson: function() {
				return js.sj(String.format(
				    "@@%s:%s", this._entity, this.getKey()));
			},

			/**
			 * @overrides Object.prototype.toString
			 */
			toString: function() {
				return String.format("%s:%s#%d", this._entity, this._key, this.hashCode());
			},
			getEntity: function() {
				return this._entity;
			},
			getKey: function() {
				if(this._key === null) {
					return "/" + this.hashCode();
				}
				return this._key;
			},
			setKey: function(value) {
				if(this._key !== value) {
					this._key = value;
					this.notifyEvent("changed", {attributes: "@key"});
				}
			},

			/**
			 * @overrides cavalion.org/data/Source.prototype.getSize
			 */
			getSize: function() {
				return 1;
			},

			/**
			 * @overrides cavalion.org/data/Source.prototype.getObject
			 */
			getObject: function() {
				return this._values;
			},

			/**
			 * @overrides cavalion.org/data/Source.prototype.getObjects
			 */
			getObjects: function() {
				return [this.getObject()];
			},

			/**
			 * @overrides cavalion.org/data/Source.prototype.getMonitor
			 */
			getMonitor: function(start, end) {},

			/**
			 * @overrides cavalion.org/data/Source.prototype.releaseMonitor
			 */
			releaseMonitor: function(monitor) {},

			/**
			 * @overrides cavalion.org/data/Source.prototype.isActive
			 */
			isActive: function() {
				return true;
			},

			/**
			 * @overrides cavalion.org/data/Source.prototype.isBusy
			 */
			isBusy: function() {
				return false;
			},

			/**
			 * @overrides cavalion.org/data/Source.prototype.notifyEvent
			 */
			notifyEvent: function(event, data) {},

			/**
			 * @overrides cavalion.org/data/Source.prototype.getAttributeNames
			 */
			getAttributeNames: function() {
				return this._entity.getAttributeNames();
				// return js.keys(this._value);
			},

			/**
			 * @overrides cavalion.org/data/Source.prototype.getAttributeValue
			 */
			getAttributeValue: function(name) {
				var names = name.split(".");
				var value = this._values[names.shift()];
				if(names.length) {
					if(value instanceof Instance) {
						return value.getAttributeValue(names.join("."));
					} else {
						return js.get(names.join("."), value);
					}
				}
				return value;
			},

			/**
			 * @overrides cavalion.org/data/Source.prototype.getAttributeValue
			 */
			setAttributeValue: function(name, value, index, changes, preserve_dirty) {
				name = name.split(".");
				if(name.length > 1) {
					var key = name.shift();
					var instance = this._values[key];
					if(!(instance instanceof Instance)) {
						throw new Error("Shitty shit!");
/*
						attribute = this._entity.getAttribute(key);
						if(attribute.entity === undefined || attribute.oneToMany === true) {
							throw new Error(String.format("%s.%s is not a many-to-one attribute", this._entity.getName(), key));
						}
						instance = attribute.entity.newInstance();
						this.setAttributeValue(key, instance, changes, merging);
*/
					}
					instance.setAttributeValue(name.join("."), value, changes, preserve_dirty);
				} else {
					name = name[0];

					var changed = false;
					var oldValue = this._values[name];
					var hadValue = this._values.hasOwnProperty(name);
//					var isNew = this._key === null;

					if(oldValue instanceof Date && value instanceof Date) {
						changed = oldValue.getTime() !== value.getTime();
					} else if(oldValue instanceof Array && value instanceof Array) {
						if(oldValue.length === value.length) {
							for(var i = 0; i < oldValue.length && changed === false; ++i) {
								changed = value.indexOf(oldValue) !== -1;
							}
						} else {
							changed = true;
						}
					} else {
						changed = oldValue !== value;
					}

					/*- Update the value if it changed while not being dirty already */
					if(changed === true && (preserve_dirty !== true || !this.isDirty(name))) {
						this._values[name] = value;
						if(hadValue === true) {// || isNew === true) {
							if(!this._dirty.hasOwnProperty(name)) {
								this._dirty[name] = {oldValue: oldValue, attribute: name};
							}
							this._dirty[name].time = Date.now();

							if(this._dirty[name].oldValue === value) {
								delete this._dirty[name];
							}
						}
						if(changes !== undefined) {
							changes[name] = {oldValue: oldValue, newValue: value};
						} else {
							var obj = {};
							obj[name] = {oldValue: oldValue, newValue: value};
							this._values[name] = value;
							this.notifyEvent("attributesChanged", obj);
						}
					}
				}
			},

			/**
			 * @param value
			 */
			setAttributeValues: function(values, preserve_dirty) {
				var changes = {};
				for(var k in values) {
				    // var value = this.getAttributeValue(k);
				    // if(value instanceof Instance) {
				    //     /*- TODO handle array of instances */
				    //     //console.log("setting", k, "to", values[k], "was", value);
				    // }
					this.setAttributeValue(k, values[k], 0, changes, preserve_dirty);
				}
				// for(var k in changes) {
				// 	log.push([this.toString(), k, values[k]]);
				// }
			},
			isDirty: function(attribute) {
				if(attribute !== undefined) {
					return this._dirty !== null &&
						this._dirty.hasOwnProperty(attribute);
				}
				return js.keys(this._dirty).length > 0;
			},
			isManaged: function() {
				return this._key !== null;
			},
			getDirtyAttributeValues: function(resetDirty) {
				var obj;
				if(this._key !== null) {
					obj = {};
					for(var k in this._dirty) {
						obj[k] = this.getAttributeValue(k);
					}
				} else {
					obj = js.mixIn({}, this._values);
				}

				if(resetDirty === true) {
					this._dirty = {};
					this.notifyEvent("dirtyChanged", false);
				}

				return obj;
			},
			revert: function() {
				if(this.isDirty()) {
					var changes = {};
					var changed = false;
					for(var k in this._dirty) {
						if(this._values[k] !== this._dirty[k].oldValue) {
							changed = true;
							changes[k] = {
								oldValue: this._values[k],
								newValue: this._dirty[k].oldValue
							};
							this._values[k] = this._dirty[k].oldValue;
						}
						delete this._dirty[k];
					}
					if(changed === true) {
						this.notifyEvent("attributesChanged", changes);
					}
					this.notifyEvent("dirtyChanged", false);
					this.notifyEvent("changed");
				}
			},
			resetDirty: function() {
				this._dirty = {};
			}
		}

	}));

});
define('entities/ExpressionBuilder',['require','./Instance'],function(require) {

	var Instance = require("./Instance");

	function marshallValue(rhs) {
    	if(rhs instanceof Instance) {
    		return EB.reference(rhs);
    	}
    	return rhs;
	}

    function create(props) {
        return Object.create(EB, props || {
        	items: {
        		value: [],
        		enumerable: true
        	}
        });
    }

    var EB = {
    	reference: function(instance) {
    		return String.format("@@%s:%s", instance._entity.split(":").pop(), instance._key);
    	},
        andor: function(operator, args) {
            if(this === EB) {
                return arguments.callee.apply(create(), arguments);
            }
            this.items.push([operator].concat(js.copy_args(args)));
            return this;
        },
        unary: function(operator, operand) {
            if(this === EB) {
                return arguments.callee.apply(create(), arguments);
            }
            this.items.push([operator, operand]);
            return this;
        },
        binary: function(operator, lhs, rhs) {
            if(this === EB) {
                return arguments.callee.apply(create(), arguments);
            }
            this.items.push([operator, lhs, rhs]);
            return this;
        },
        /*-
         * Parses a where structure. The result can be passed on the server.
         *
         * @param obj - where expression to be parsed
         * @param parameters - optional, when specified string constants
         * 		prefixed with a colon will be replaced by the value of the
         * 		corresponding key in parameters. If that key references
         * 		a function, it will be called in the context with args
         * @param context - The context on which a function parameter
         * 		should be applied
         * @param args - The arguments to be passed to a function parameter
         */
        where: function(obj, parameters, context, args) {
            var r;
            if(obj instanceof Array) {
                r = [].concat(obj);
                r.forEach(function(o, i) {
                    if(o instanceof Array) {
                        r[i] = EB.where(r[i], parameters, context, args);
                    } else if(typeof o === "function") {
                        r[i] = r[i].apply(context || window, args || []);
                    } else if(parameters && typeof o === "string" &&
                    		o.charAt(0) === ":" &&
                    		(o = parameters[o.substring(1)])) {

	            		r[i] = typeof o !== "function" ? o :
	            				o.apply(context || window, args || []);
                    }
                    r[i] = marshallValue(r[i]);
                });
                return r;
            } else if(obj !== null && typeof obj === "object") {
                r = {};
                for(var k in obj) {
                    r[k] = EB.where(obj[k], parameters, context, args);
                }
            } else if(obj instanceof Date) {
                r = new Date(obj.getTime());
            } else {
                r = obj;
            }
            return r;
        },
        toString: function() {
            var s = [];
            this.items.forEach(function(items) {
                if(items[0] === "and" || items[0] === "or") {
                    var a = [];
                	items.forEach(function(item, i) {
                		if(i) {
                			a.push(item.toString());
                		}
                	});
                	s.push(String.format("(%s)", a.join(" " + items[0] + " ")));
                } else if(items.length === 2) {
                    s.push(String.format("%s(%s)", items[0], items[1]));
                } else if(items.length === 3) {
                    s.push(String.format("%s %s %s", items[1], items[0], items[2]));
                } else {
                    s.push(items.toString());
                }
            });
            return "(" + s.join(" ") + ")";
        }
    };

    "and,or".split(",").forEach(function(operator) {
        EB[operator] = function() {
            return this.andor.apply(this, [operator, js.copy_args(arguments)]);
        };
    });

    "not".split(",").forEach(function(operator) {
        EB[operator] = function(operand) {
            return this.unary.apply(this, [operator, operand]);
        };
    });

    "lt,lte,gt,gte,eq,neq,like,in".split(",").forEach(function(operator) {
        EB[operator] = function(lhs, rhs) {
        	rhs = marshallValue(rhs);
            return this.binary(operator, lhs, rhs);
        };
    });
   
    EB.equals = EB.eq;
    EB.notEquals = EB.neq;
    EB.lessThan = EB.lt;
    EB.lessThanOrEquals = EB.lte;
    EB.greaterThan = EB.gt;
    EB.greaterThanOrEquals = EB.gte;
	EB.contains = function(lhs, rhs) {
	    if(this === EB) {
	        return arguments.callee.apply(create(), arguments);
	    }
    	this.items.push(["like", lhs, "%" + rhs + "%"]);
    	return this;	
    };

    return EB;

});
define('entities/EM',['require','cavalion.org/Command','./ExpressionBuilder','./Instance','jquery'],function(require) {

	var Command = require("cavalion.org/Command");
	var ExpressionBuilder = require("./ExpressionBuilder");
	var Instance = require("./Instance");
	var ajax = require("jquery").ajax;

	var IS_KEYFIELD_REGEXP = /\.id$/;
	
	function getViewData(from, attributes, criteria) {
		/*- Copy the criteria object */
    	var r = js.mixIn(criteria);

    	if(criteria && criteria.having) {
    		r.having = JSON.stringify(criteria.having);
    	}
    	
    	/*- Convert string usage */
    	if(criteria && typeof criteria.groupBy === "string") {
    		r.groupBy = criteria.groupBy.split(",");
    	}
    	
    	/* Convert string usage */
    	if(criteria && typeof criteria.orderBy === "string") {
    		r.orderBy = criteria.orderBy.split(",").map(function(ob) {
    			ob = ob.split(" ");
    			return { path: ob[0], type: ob[1] || "asc" };
    		});
    	}
    	
    	if(criteria && criteria.pagesize) {
    		r.page = criteria.page;
    		r.pagesize = criteria.pagesize;
    	}
    	
    	return JSON.stringify(r);
	}

	return {
		eb: ExpressionBuilder,
		prefix: "",

		all: function(entity) {
			return entity === undefined ? Instance.all : Instance.all[entity] || [];
		},
		arrayOfAll: function(entity) {
			var all = this.all(entity);
			var arr = [];
			for(var k in all) {
				arr.push(all[k]);
			}
			return arr;
		},
		getInstance: function(entity, key) {
		/**
		 * Returns a reference to the specified entity. There is no check
		 * to see whether this instance actually exists.
		 */
			return Instance.get(entity, key);
		},
		findInstance: function(entity, f) {
			var instances = Instance.all[entity] || [];
			if(typeof f === "function") {
				for(var k in instances) {
					if(f(instances[k])) {
						return instances[k];
					}
				}
				return null;
			}
			return instances[f] || null;
		},
		getModel: function(unit, prefix) {
			unit = unit || "";
		    if(prefix === undefined && unit.indexOf("/") !== -1) {
		    	prefix = unit.split("/");
		    	unit = prefix.pop();
		    	prefix = prefix.join("/");
		    }

			if(typeof unit === "string") {
				unit = "/" + unit;
			} else {
				unit = "";
			}
			return Command.execute(String.format("%srest/entities/model%s", 
				prefix || this.prefix, unit));
		},
		commit: function(persist, remove, unit, prefix) {
			if(!(persist instanceof Array)) {
				persist = [persist];
			}

			var work = {
				persist: [],
				remove: []
			};
			var newKeys = {};

			persist && persist.forEach(function(instance) {
				var key = instance.getKey();
				if(instance.isManaged() === false) {
					newKeys[key] = instance;
				}

				var values = instance.getDirtyAttributeValues(true);
				for(var k in values) {
					if(values[k] instanceof Instance) {
						values[k] = String.format("@@%s:%s", values[k]._entity,
								values[k].getKey());
					}
				}

				work.persist.push({
					entity: instance.getEntity(),
					key: key,
					values: values
				});
			});

			remove && remove.forEach(function(instance) {
				if(instance.isManaged()) {
					work.remove.push({
						entity: instance.getEntity(),
						key: instance.getKey()
					});
				}
			});

			return Command.execute(String.format("%srest/entities/commit?unit=%s", prefix || this.prefix, unit), {}, work).
				addCallback(function(res) {
					for(var k in res) {
						var entity = newKeys[k]._entity;
						var key = res[k];
						newKeys[k].setKey(res[k]);
						Instance.all[entity] = Instance.all[entity] || {};
						Instance.all[entity][key] = newKeys[k];
					}
					return res;
				}).
				addErrback(function(err) {
					// TODO What if the commit fails, restore the dirty values?
					work.persist.forEach(function(obj, index) {
						//Instance.getInstance(obj.entity, obj.get)
						persist[index].setAttributeValues(obj.values);
					});
					return err;
				});
		},
		remove: function(instances) {
			if(!(instances instanceof Array)) {
				instances = [instances];
			}
		},
		newInstance: function(entity, values) {
			return new Instance(entity, null, values);
		},
		query: function(entity, attributes, criteria, prefix) {
		    var params = {};

		    if(prefix === undefined && entity.indexOf("/") !== -1) {
		    	prefix = entity.split("/");
		    	entity = prefix.pop();
		    	prefix = prefix.join("/");
		    }

		    if(entity.indexOf(":") !== -1) {
		        entity = entity.split(":");
		        params.unit = entity.shift();
		        entity = entity.join(":");
		    }

		    if(typeof attributes === "string") {
		    	attributes = attributes.replace(/\s/g, "").split(",");
		    }

			var req = {
				select: attributes || ["*"],
				from: [entity]
			};

			var uri = String.format("%srest/entities/query", prefix || this.prefix);
			criteria = criteria || {};

			"where,groupBy,having,orderBy,count,start,limit".split(",").forEach(function(k) {
				var value = criteria[k];
				if(typeof value === "string") {
					req[k] = value.split(",");
				} else if(criteria.hasOwnProperty(k)) {
					req[k] = value;
				}
			});

			var me = this;
			return Command.execute(uri,	params, req).addCallback(function(res) {
					me.processQueryResult(res, req, params.unit);
					return res;
				});
		},
		query_: function(entity, attributes, criteria, prefix) {
		    var params = {};

		    if(prefix === undefined && entity.indexOf("/") !== -1) {
		    	prefix = entity.split("/");
		    	entity = prefix.pop();
		    	prefix = prefix.join("/");
		    }

		    if(entity.indexOf(":") !== -1) {
		        entity = entity.split(":");
		        params.unit = entity.shift();
		        entity = entity.join(":");
		    }
		    
        	var d = new Deferred();
		    ajax({
		        url: String.format("%srest/entities/%s", prefix || this.prefix, entity),
		        method: "GET",
		        contentType: "application/json",
		        data: getViewData(from, attributes, criteria),
		        success: function (res) {
					me.processQueryResult(res, req, params.unit);
					d.callback(res);
		        },
		        error: function (res) {
		            d.errback(res);
		        }
		    });
		    return d;
		},
		processQueryResult: function(res, req, namespace) {
			if(res.names !== undefined) {
				req.select = res.names;
			}

			var paths = [];
			var l = req.select.length;

			if(namespace !== undefined && res.types !== undefined) {
				for(var i = l; i < res.types.length; ++i) {
					res.types[i] = String.format("%s:%s",
							namespace, res.types[i]);
				}
			}

			/*- Gather all paths. A path leads to a joined entity
			 * (eg. locatie.onderzoeken.meetpunten) */
			req.select.forEach(function(namePath, i) {
				if(namePath.indexOf(":") === -1) {
					var names = namePath.split(".");
					names.pop(); namePath = [];
					names.forEach(function(name) {
						namePath.push(name);
						if(paths.indexOf(namePath.join(".")) === -1) {
							paths.push(namePath.join("."));
						}
					});
				}
			});

			res.instances = [];

			/*- For each tuple... */
			res.tuples.forEach(function(tuple, index) {
				var obj = {};
				for(var i = 0; i < l; ++i) {
					/*- ...create (nested) objects and set their values */
					if(tuple[i] !== null && res.types[i] === "timestamp") {
						tuple[i] = new Date(tuple[i]);
					}
					/*- When a key attribute instance is referenced do nothing, the reference will
					 * be picked later. Reference instances by addressing it's keyfield. (id) */
					if(!IS_KEYFIELD_REGEXP.test(req.select[i])) {
						js.set(req.select[i], tuple[i], obj);
					}
				}

				/*- Now iterate the paths, updating references to real Instance's.
				 * Reverse order, so that the outer most nested objects of obj will
				 * be set first. */
				for(var i = paths.length - 1; i >= 0; --i) {
					var instance = tuple[i + l + 1];
					if(instance !== null) {
						instance = Instance.get(res.types[i + l + 1], instance);
						//console.log("setting", paths[i],instance,  "to", js.get(paths[i], obj));
						instance.setAttributeValues(js.get(paths[i], obj), true);

						/*- Nicely store the instance in the tuple, ie. replace the key value by a real instance */
						tuple[i + l + 1] = instance;

						/*- Update reference obj[~paths[i]~] -> instance */
						js.set(paths[i], instance, obj);
					}
				}

				/*- obj is now ready to set at the root instance */
				res.instances.push(tuple[l] = Instance.get(res.types[l], tuple[l]));
				tuple[l].setAttributeValues(obj, true);
			});
		}
	};

});
define('features/FM',['require','cavalion.org/Command','entities/EM'],function(require) {

    var Command = require("cavalion.org/Command");
    var EM = require("entities/EM");

    return {

    	eb: EM.eb,

    	/**
    	 *
    	 */
        query: function (entity, attributes, criteria, prefix) {
            var params = {};

            if (prefix === undefined && entity.indexOf("/") !== -1) {
                prefix = entity.split("/");
                entity = prefix.pop();
                prefix = prefix.join("/");
            }

            if (entity.indexOf(":") !== -1) {
                entity = entity.split(":");
                params.unit = entity.shift();
                entity = entity.join(":");
            }

            if (typeof attributes === "string") {
                attributes = attributes.replace(/\s/g, "").split(",");
            }

            var req = {
                select: attributes || ["*"],
                from: [entity]
            };

            var uri = String.format("%srest/features/query", prefix || "");
            criteria = criteria || {};

            "where,groupBy,having,orderBy,count,start,limit".split(",").forEach(function (k) {
                var value = criteria[k];
                if (typeof value === "string") {
                    req[k] = value.split(",");
                } else if (criteria.hasOwnProperty(k)) {
                    req[k] = value;
                }
            });

            var me = this;
            return Command.execute(uri, params, req).addCallback(function (res) {
                return me.processQueryResult(res, req, params.unit);
            });
        },

        /**
         *
         */
        processQueryResult: function(res, req, unit) {
	        EM.processQueryResult(res, req, unit);

	        if(res.types) {
		        var index = res.types.length - 1;
		        res.instances.forEach(function (instance, tuple) {
		            instance.setAttributeValue("geom", res.tuples[tuple][index]);
		        });
	        }

	        return res;
        }
    };

});
/**
 * @license RequireJS text 2.0.3 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require: false, XMLHttpRequest: false, ActiveXObject: false,
  define: false, window: false, process: false, Packages: false,
  java: false, location: false */

define('jslib/text',['module'], function (module) {
    'use strict';

    var text, fs,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = [],
        masterConfig = (module.config && module.config()) || {};

    text = {

    	buildMap: buildMap,
    	fs: fs,
    	masterConfig: masterConfig,

        version: '2.0.3',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var strip = false, index = name.indexOf("."),
                modName = name.substring(0, index),
                ext = name.substring(index + 1, name.length);

            index = ext.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = ext.substring(index + 1, ext.length);
                strip = strip === "strip";
                ext = ext.substring(0, index);
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName + '.' + parsed.ext,
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                nonStripName = parsed.moduleName + '.' + parsed.ext,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + '.' +
                                     parsed.ext) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node)) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback) {
            var file = fs.readFileSync(url, 'utf8');
            //Remove BOM (Byte Mark Order) from utf8 files if it is there.
            if (file.indexOf('\uFEFF') === 0) {
                file = file.substring(1);
            }
            callback(file);
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback) {
            var xhr = text.createXhr();

            xhr.open('GET', url, true);

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        errback(err);
                    } else {
                        callback(xhr.responseText);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                stringBuffer.append(line);

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    }

    return text;
});
define('vcl/Application',['require','js/defineClass','js/Type','./EventDispatcher','./Component','./Component.query','./CssRules'],function(require) {

	var Application = 		require("js/defineClass");
	var Type =				require("js/Type");
	var EventDispatcher = 	require("./EventDispatcher");
	var Component = 		require("./Component");
	var query =				require("./Component.query");
	var CssRules = 			require("./CssRules");

	var instances = [];

	return (Application = Application(require, {

		inherits: Component,

		statics: {
			instances: instances,

			get: function() {
				if(instances.length !== 1) {
					throw new Error("Unexpected: Multiple instances");
				}
				return instances[0];
			},
			
			readStorage: function(key, callback, errback) {
				var app = this.get();
				return app.readStorage.apply(app, arguments);
			},
			
			writeStorage: function(key, value, callback, errback) {
				var app = this.get();
				return app.writeStorage.apply(app, arguments);
			}
		},

		prototype: {

			_dispatcher: null,
			_css: null,
			_cssRules: null,
			_icon: "",
			_title: "",
			_namespace: "",
			_states: null,
			_stateIndex: -1,
			_onGetStorageKey: null,
			_onGetState: null,
			_onSetState: null,
			_onStateChange: null,
			_onToast: null,

			constructor: function() {
				instances.push(this);
			},
			destroy: function() {
				instances.splice(instances.indexOf(this), 1);
			},
			loaded: function() {
				/**
				 * @overrides ./Component.prototype.loaded
				 */
			    if(!this.isDesigning()) {
    				this._dispatcher = new EventDispatcher();
    				this._dispatcher.activate();

    				window.onpopstate = function(evt) {
    					this.popState(evt);
    				}.bind(this);
			    }

				return this.inherited(arguments);
			},
			getSpecializer: function() {
				/** @overrides ./Component.prototype.getSpecializer */
			    var r = this.inherited(arguments);
			    if(r === "") {
			        r = this._name;
			    }
			    return r;
			},
            qsa: function(selector, context) {
				/** @overrides: ./Component.prototype.qsa */
				var me = this;
                return query(selector, context || this, 
                    Component.all.reduce(function(arr, comp) {
                        if(me.isOwnerOf(comp)) {
                            arr.push(comp);
                        }
                        return arr;
                    }, [])
                );
            },

			log: function() {
				/** */
				//console.log()
			},
			toast: function(options) {
				/** */
				return this.fire("onToast", [options || {}]);
			},
			getStorageKey: function(forKey) {
				/** */
				if(!(forKey instanceof Array)) {
					return this.inherited(arguments);
				}
				
				/*- When called by an owned component forKey is an array, where the first element holds a reference to the owned component. The second element contains the original forKey */
				var r = this.fire("onGetStorageKey", arguments);
				if(r === undefined) {
					r = forKey[0].getUri() + "$" + forKey[1];
				}
				
				if(this._namespace !== "") {
					r = this._namespace + " " + r;
				}
				
				return r;
			},
			alert: function(message, callback) {
				/**
				 *
				 */
				window.console.log(message);
				window.alert(message);
				if(typeof callback === "function") {
					callback();
				}
			},
			error: function(message, err, callback) {
				/**
				 *
				 */
				window.console.error(message, err);
				window.alert(message);
				if(typeof callback === "function") {
					callback();
				}
			},
			prompt: function(message, value, callback) {
				/**
				 *
				 */
				value = window.prompt(message, value);
				if(typeof callback === "function") {
					callback(value);
				}
			},
			confirm: function(message, callback) {
				/**
				 *
				 */
				var value = window.confirm(message);
				if(typeof callback === "function") {
					callback(value);
				}
			},
			onstatechange: function() {
				/**
				 *
				 */
				return this.fire("onStateChange", arguments);
			},
			getNamespace: function() {
				/**
				 *
				 */
				return this._namespace;
			},
			setNamespace: function(value) {
				/**
				 *
				 */
				this._namespace = value;
			},
			getTitle: function() {
				/**
				 *
				 */
				return this._title;
			},
			setTitle: function(value) {
				/**
				 *
				 */
				this._title = value;
				if(!this.isDesigning()) {
					document.title = value;
				}
			},
			finalize: function() {
				/**
				 *
				 */
				this._dispatcher.release();
				delete Application.instance;
			},
			getState: function() {
				/**
				 *
				 */
				return this.fire("onGetState") || {};
			},
			setState: function(state) {
				/**
				 *
				 */
				return this.fire("onSetState", [state]);
			},
			canBack: function() {
				/**
				 *
				 */
				return this._stateIndex > 0;
			},
			canForward: function() {
				/**
				 *
				 */
				return this._states ? this._stateIndex < this._states.length - 1 : false;
			},
			pushState: function() {
				/**
				 *
				 */
				if(!this._poppingState) {
					if(!this.hasOwnProperty("_states")) {
						this._states = [];
					}

					var state = this.getState();
					this._states.push(state);
					this._stateIndex = this._states.length - 1;
					
//console.log("pushState", state);
					state.url = state.url || window.location.toString();
					
					window.history.pushState({index: this._states.length - 1}, 
						state.title, state.url);

					this.dispatch("statechange", state);
				}
			},
			replaceState: function() {
				/**
				 *
				 */
				if(!this._poppingState) {
					if(!this.hasOwnProperty("_states")) {
						this._states = [this.getState()];
						this._stateIndex = 0;
					}

					var oldState = this._states[this._stateIndex];
					var newState = this.getState();

					this._states[this._stateIndex] = newState;
					
					newState.url = newState.url || window.location.toString();
					
// console.log("replaceState", newState);
//					this.log("replace: " + this._stateIndex, newState);

					if(this._stateIndex === 0 || oldState.title !== newState.title || oldState.url !== newState.url) {
						window.history.replaceState({index: this._stateIndex}, newState.title, newState.url);
					}

					this.dispatch("statechange", newState);
				}
			},
			popState: function(evt) {
				/**
				 *
				 */
				if(evt.state && this._states) {
					var has = this.hasOwnProperty("_poppingState");
					this._poppingState = true;
					try {
						var index = evt.state.index;
						var state = this._states[index];
						this._stateIndex = index;
						this.setState(state);
//						this.log(String.format("pop: %d", index), state);
						this.dispatch("statechange", state);
					} finally {
						if(!has) {
							delete this._poppingState;
						}
					}
				}
			},
			getIcon: function() {
				/**
				 *
				 */
				return this._icon;
			},
			setIcon: function(value) {
				/**
				 *
				 */
                if(this._icon !== value) {
                    var link = document.querySelectorAll("html head link[rel='icon shortcut']")[0];
                    if(link === undefined) {
                        link = document.createElement("link");
                        link.setAttribute("rel", "icon shortcut");
                        link.setAttribute("type", "image/x-icon");
                        document.querySelector("html head").appendChild(link);
                    }
                    link.setAttribute("href", value);
                    this._icon = value;
                }
			},
			getCssRules: function() {
				/**
				 *
				 * @returns {CssRules}
				 */
				return this._cssRules;
			},
			getCss: function() {
				/**
				 *
				 */
				return this._css;
			},
			setCss: function(value) {
				/**
				 *
				 */
				if(value === null || (typeof value === "object" && js.keys(value).length === 0)) {
					this._cssRules = null;
				} else {
					if(typeof value === "string") {
						value = js.str2obj(value);
					} else if(value instanceof Array) {
						value = js.str2obj(value.join(""));
					}

                    // resolve references to other classes
					CssRules.normalize(String.of(this.constructor), value);

					if(this._cssRules === null) {
						this._cssRules = new CssRules();
						this._cssRules.setSelector("html");
					}
					this._cssRules.setRules(value);
				}
				this._css = value;
			}

		},

		properties: {
			"css": {
				Set: Function,
				set: function(value) {
					if(typeof value === "string") {
						value = js.str2obj(value);
					} else if(value instanceof Array) {
						value = js.str2obj(value.join(""));
					}

					function superMixIn(dest, src) {
						for( var k in src) {
							if(src.hasOwnProperty(k)) {
								var v = src[k];
								if(v !== null && Object.prototype.toString.apply(v, []) === "[object Object]") {
									dest[k] = dest[k] || {};
									superMixIn(dest[k], v);
								} else {
									dest[k] = v;
								}
							}
						}
						return dest;
					}

					if(this.hasOwnProperty("_css")) {
						value = superMixIn(js.mixIn(this._css), value);
					}

					this.setCss(value, true);
				},
				type: Type.OBJECT,
				def: null
			},
			"namespace": {
				type: Type.STRING,
				set: Function
			},
			"title": {
				type: Type.STRING,
				set: Function
			},
			"icon": {
                type: Type.STRING,
                set: Function
			},
			"onToast": {
				type: Type.EVENT
			},
			"onGetStorageKey": {
				type: Type.EVENT
			},
			"onGetState": {
				type: Type.EVENT
			},
			"onSetState": {
				type: Type.EVENT
			}

		}
	}));

});
define('vcl/data/Array',['require','js/defineClass','js/Type','cavalion.org/data/Source','cavalion.org/data/SourceEvent','../Component'],function(require) {

	var Array = require("js/defineClass");
	var Type = require("js/Type");

	var Source = require("cavalion.org/data/Source");
	var SourceEvent = require("cavalion.org/data/SourceEvent");
	var Component = require("../Component");

	return Array(require, {

		inherits: Component,

		implementing: [Source],

		prototype: {

			_arr: null,					/*- the actual array exposed */
			_array: null,				/*- property array */
			_monitors: null,
			_busy: false,
			_onFilterObject: null,
    		_notifications: null,

    		_onBusyChanged: null,
    		_onActiveChanged: null,
    		_onGetAttributeValue: null,

			constructor: function() {
				this._monitors = [];
			},
			getSize: function() {
				/** @overrides cavalion.org/data/Source.prototype.getSize */
				return this._arr !== null ? this._arr.length : 0;
			},
			getObject: function(index) {
				/** @overrides cavalion.org/data/Source.prototype.getObject */
				this.assertArray(index);
				return this._arr[index || 0];
			},
			getObjects: function(start, end) {
				/** @overrides cavalion.org/data/Source.prototype.getObjects */
				this.assertArray(start);
				return this._arr;
			},
			getMonitor: function(start, end) {
				/** @overrides cavalion.org/data/Source.prototype.getMonitor */
				this.assertArray();

	// TODO reuse code from org.cavalion.persistence.ResultList
	// create class cavalion.org/data/SourceMonitor, maybe SourceMonitor can have a destroy mechanism in itself

				var monitor = {
					start: start,
					end: end,
					source: this,

					__name: function() {
						return String.format("[monitor %d-%d]", this.start, this.end);
					}
				};
				this._monitors.push(monitor);
				return monitor;
			},
			releaseMonitor: function(monitor) {
				/** @overrides cavalion.org/data/Source.prototype.releaseMonitor */
				var index = this._monitors.indexOf(monitor);
				if(index === -1) {
					throw new Error("Unknown monitor");
				}
				this._monitors.splice(index, 1);
			},
			isActive: function() {
				/** @overrides cavalion.org/data/Source.prototype.isActive */
				return this._arr !== null;
			},
			isBusy: function() {
				/** @overrides cavalion.org/data/Source.prototype.isBusy */
				return this._busy;
			},
			notifyEvent: function(event, data) {
				/** @overrides cavalion.org/data/Source.prototype.notifyEvent */
				if(event === SourceEvent.busyChanged) {
					this.fire("onBusyChanged", [data]);
				} else if(event === SourceEvent.activeChanged) {
					this.fire("onActiveChanged", [data]);
				} else if(event === SourceEvent.updated) {
					this.fire("onUpdate", [data]);
				}
			},
			getAttributeNames: function() {
				/** @overrides cavalion.org/data/Source.prototype.getAttributeNames */
				if(this._arr === null) {
					return [];
				}
				var obj = this._arr[0];
				if(typeof obj !== "object") {
					return ".";
				}
				return js.keys(obj);
			},
			getAttributeValue: function(name, index) {
				/** @overrides cavalion.org/data/Source.prototype.getAttributeValue */
				this.assertArray(index);
				if(name === ".") {
					return this.getObject(index || 0);
				}
				var value = js.get(name, this.getObject(index || 0));
				if(this._onGetAttributeValue !== null) {
					value = this.fire("onGetAttributeValue", [name, index, value]);
				}
				return value;
			},
			setAttributeValue: function(name, value, index) {
				/** @overrides cavalion.org/data/Source.prototype.getAttributeValue */
				this.assertArray(index);
				if(name !== ".") {
					return js.set(name, value, this.getObject(index));
				} else if(this._onFilterObject !== null) {
					index = this._array.indexOf(this._arr[index]);
				}
				return (this._array[index] = value);
			},
			loaded: function() {
				/** @overrides org.cavalion.comp.Component.prototype.loaded */
				if(this._arrayDuringLoad !== undefined) {
					this.setArray(this._arrayDuringLoad);
					delete this._arrayDuringLoad;
				}
				if(this.hasOwnProperty("_notifications")) {
				    var me = this;
				    this._notifications.forEach(function(args) {
				        me.notifyEvent.apply(this, args);
				    });

				    delete this._notifications;
				}
				return this.inherited(arguments);
			},

			notify: function() {
				/**
				 *  Calls notifyEvent either directly or whenever the component
				 *  looses its loading state
				 */
//				if(this.isLoading()) {
//			        this._notifications = this._notifications || [];
//			        this._notifications.push(js.copy_args(arguments));
//				} else {
    	            this.notifyEvent.apply(this, arguments);
//				}
			},
			indexOf: function(obj) {
				return this._arr.indexOf(obj);
			},
			assertArray: function(index) {
				if(this._arr === null) {
					throw new Error("No array available");
				}
				if(index !== undefined && index < 0 || index >= this._arr.length) {
					throw new Error(String.format("Index out of bounds (%d)", index));
				}
			},
			updateFilter: function(notify) {
				if(this._onFilterObject !== null) {
					this._arr = [];
					for(var i = 0; i < this._array.length; ++i) {
						var obj = this._array[i];
						if(this.fire("onFilterObject", [obj, i]) !== true) {
							this._arr.push(obj);
						}
					}
				} else {
					this._arr = this._array;
				}
				if(notify !== false) {
					this.notify(SourceEvent.changed);
				}
			},
			getOnFilterObject: function() {
				return this._onFilterObject;
			},

			setOnFilterObject: function(value) {
				if(this._onFilterObject !== value) {
					this._onFilterObject = value;
					if(!this.isLoading()) {
						this.updateFilter();
					}
				}
			},
			getBusy: function() {
				return this._busy;
			},
			setBusy: function(value) {
				if(this._busy !== value) {
					this._busy = value;
					this.notify(SourceEvent.busyChanged, value);
				}
			},
			getArray: function() {
				return this._array;
			},
			setArray: function(value) {
				if(this.isLoading()) {
					this._arrayDuringLoad = value;
				} else if(this._array !== value) {
					var wasActive = this.isActive();
					var isActive;

					this._array = value;

					this.updateFilter(false);

					if(wasActive !== (isActive = this.isActive())) {
						this.notify(SourceEvent.activeChanged, isActive);
					} else {
						this.notify(SourceEvent.changed);
					}

					this.notify(SourceEvent.layoutChanged);
				}
			},
			arrayChanged: function() {
				this.updateFilter(false);
				//this.notify(SourceEvent.layoutChanged);
				this.notify(SourceEvent.changed);
			},
			
			push: function() {
				this.assertArray();
				try {
					return window.Array.prototype.push.apply(this._array, arguments);
				} finally {
					this.arrayChanged();
				}
			},
			splice: function() {
				this.assertArray();
				try {
					return window.Array.prototype.splice.apply(this._array, arguments);
				} finally {
					this.arrayChanged();
				}
			},
			slice: function() {
				this.assertArray();
				try {
					return window.Array.prototype.slice.apply(this._array, arguments);
				} finally {
					this.arrayChanged();
				}
			},
			shift: function() {
				this.assertArray();
				try {
					return window.Array.prototype.shift.apply(this._array, arguments);
				} finally {
					this.arrayChanged();
				}
			},
			concat: function() {
				this.assertArray();
				return window.Array.prototype.concat.apply(this._array, arguments);
			}
		},

		properties: {
			"array": {
				type: Type.ARRAY,
				set: Function
    		},
    		"onActiveChanged": {
    			type: Type.EVENT
    		},
    		"onBusyChanged": {
    			type: Type.EVENT
			},
    		"onUpdate": {
    			type: Type.EVENT
			},
			"onFilterObject": {
				type: Type.FUNCTION,
				editorInfo: {
					defaultValue: "(function(object, index) {\n\t//return {true} to exclude item from exposed array\n})"
				}
			},
			"onGetAttributeValue": {
				type: Type.EVENT,
				f: function(name, index, value) { }
			}
		}

	});

});
define('vcl/ui/Panel',['require','js/Class','js','js/Type','cavalion.org/util/Browser','./Container'],function (require) {

    var Class = require("js/Class");
    var js = require("js");
    var Type = require("js/Type");
    //	var Method = require("js/Method");
    var Browser = require("cavalion.org/util/Browser");
    var Container = require("./Container");

    var PanelAlign = ["none", "client", "left", "right", "top", "bottom"];
    var PanelAlignPriority = ["index", "client-last"];
    var PanelAutoSize = ["none", "both", "width", "height"];
    var PanelAutoPosition = {
        top: false,
        left: false,
        bottom: false,
        right: false
    };
    var aligning = [];

    function getRevAnim(animation) {
        var animations = {
            "right-left": "left-right",
            "left-right": "right-left",
            "bottom-top": "top-bottom",
            "top-bottom": "bottom-top",
            "delayed": "instant",
            "instant": "delayed",
            "flip-to-front": "flip-to-back",
            "flip-to-back": "flip-to-front",
            "fadein-scaleup": "fadeout-scaledown"
        };
        return animations[animation];
    }

    /**
     *
     */
    function swap(obj, a1, a2) {
        var v = obj[a1];
        obj[a1] = obj[a2];
        obj[a2] = v;
    }

    /**
     *
     * @param control
     * @param left
     * @param top
     * @param right
     * @param bottom
     * @param callback
     */
    function setBounds(control, left, top, right, bottom, callback) {
        if (control.setBounds(left, top, right, bottom, undefined, undefined, callback) === undefined) {
            callback();
        }
    }

    var Panel = {
        inherits: Container,
        prototype: {          
            "@css": {
                "position": "absolute",
                "overflow": "auto",
                "cursor": "default",
                "&:focus": {
                    outline: "none"
                }
            },

            /** @overrides ../Control */
			//_removeNodeWhenHidden: true,

            // position and size
            _alignNode: null,
            _autoSize: "none",
            _autoPosition: PanelAutoPosition,
            _updateChildren: false,
            _left: 0,
            _top: 0,
            _right: 0,
            _bottom: 0,
            _width: 0,
            _height: 0,

            _focusable: false,
            
            _needsResize: false,

            // activePage indicates which control is currently the active client aligned control
            // FIXME Refactor activePage -> clientControl?
            _activePage: null,
            // history of activated pages
            _pages: null,
            // usePages indicates whether the behaviour is active
            _usePages: false,

            _draggable: "parent",
            
            alignControls: function (callback) {
            /**
             * @return {Boolean} Indicates whether controls were actually aligned
             */
                if (aligning.indexOf(this) !== -1) {
                    // TODO This is blocked because it is probably always true that a child control is updating its
                    // bounds and the calling Panel has supplied a notification callback for that already.
                    return false;
                }

                var controls = this.getControlsToAlign();
                if (controls.length === 0) {
                    return false;
                }

                aligning.push(this);

                var cr = this.getClientRect();
                var thisObj = this;
                var i = 0;
                var U;

                /**
                 *
                 */
                function next() {
                    if (i < controls.length) {
                        var control = controls[i];
                        var align = control._align;

                        if (align !== "none" && control.isVisible()) {
                            if (align === "client") {
                                i++;
                                next();
                            } else {
                                controls.splice(i, 1);
                                /**
 * TODO
 * The following calls setBounds rely on the post_update feature of Control.update. This is done in order to work
 * around the fact/problem that the dimensions of a[n autosized] Control are not known until the moment that its
 * DOM node is present in the document.
 *
 * FIXME What happens if the control is destroyed while aligning?
 */

                                if (align === "top") {
                                    setBounds(control, cr.left, cr.top, cr.right, U, function () {
                                        //cr.top += control._height;
                                        cr.top += (parseInt(control.getComputedStylePropValue("height"), 10) || 0);
                                        next();
                                    });
                                } else if (align === "bottom") {
                                    setBounds(control, cr.left, U, cr.right, cr.bottom, function () {
                                        //cr.bottom += control._height;
                                        cr.bottom += (parseInt(control.getComputedStylePropValue("height"), 10) || 0);
                                        next();
                                    });
                                } else if (align === "left") {
                                    setBounds(control, cr.left, cr.top, U, cr.bottom, function () {
                                        //cr.left += control._width;
                                        cr.left += (parseInt(control.getComputedStylePropValue("width"), 10) || 0);
                                        next();
                                    });
                                } else if (align === "right") {
                                    setBounds(control, U, cr.top, cr.right, cr.bottom, function () {
                                        //cr.right += control._width;
                                        cr.right += (parseInt(control.getComputedStylePropValue("width"), 10) || 0);
                                        next();
                                    });
                                }
                            }
                        } else {
                            controls.splice(i, 1);
                            next();
                        }
                    } else {
                        controls.forEach(function (control) {
                            control.setBounds(cr.left, cr.top, cr.right, cr.bottom);
                        });

                        aligning.splice(aligning.indexOf(thisObj), 1);

                        // Calls to updateChildren will be blocked while aligning
                        if (thisObj._updateChildren === true) {
                            thisObj.updateChildren();
                        }

                        if (typeof callback === "function") {
                            callback(cr);
                        }
                    }
                }
                next();
            },
            getFocusable: function () {
            /**
             * Property accessor
             */
                return this._focusable;
            },
            setFocusable: function (value) {
            /**
             *
             * @param value
             *            {Boolean}
             */
                if (this._focusable !== value) {
                    this._focusable = value;
                    if (this._node !== null) {
                        if (this._focusable === true) {
                            this._node.tabIndex = this.getIndex();
                        } else {
                            this._node.removeAttribute("tabIndex");
                        }
                    }
                }
            },
            getControlsToAlign: function () {
            /**
             *
             * @returns {Array}
             */
                var controls = [];
                this.hasOwnProperty("_controls") && this._controls.forEach(function (control) {
                    if (control._align !== "none"
                    /*&& control.isVisible()*/
                    ) {
                        controls.push(control);
                    }
                });
                return controls;
            },
            getClientRect: function () {
            /**
             *
             */
                var cs = this.getComputedStyle();
                return {
                    left: parseInt(cs.getPropertyValue("padding-left"), 10) || 0,
                    top: parseInt(cs.getPropertyValue("padding-top"), 10) || 0,
                    right: parseInt(cs.getPropertyValue("padding-right"), 10) || 0,
                    bottom: parseInt(cs.getPropertyValue("padding-bottom"), 10) || 0
                };
            },
            boundsChanged: function (changed) {
            /**
             *
             */
                this.align();
            },
            onresize: function (evt) {
            /**
             * @overrides ../Control.prototype.onresize
             */
                /*- When this._needsResize === evt, ie. being called from 
                    Panel.prototype.shown, no matter that this isn't showing, 
                    resize anyways */
                if(this._needResize !== evt && !this.isShowing()) {
                    this._needsResize = evt;
                    //return;
                }
                
                delete this._needsResize;
                
                var r = this.inherited(arguments);
                if (r !== false) {
                    this.hasOwnProperty("_controls") && this._controls.forEach(function (control) {
                        if (control.hasOwnProperty("_node") && control._align && control._align !== "none") {
                            control.dispatch("resize", evt);
                        }
                    });
                }
                return r;
            },
            initializeNodes: function () {
            /**
             * @overrides ../Control.prototype.initializeNodes
             */
                this.inherited(arguments);
                if (this._focusable === true) {
                    this._node.tabIndex = this.getIndex();
                }
            },
            updateChildren: function () {
            /**
             * @overrides ../Control.prototype.updateChildren
             */
                if (aligning.indexOf(this) !== -1) {
                    // TODO This is blocked because it is probably always true that a child control is gonna be updated
                    // by the alignControls anyways...
                    this._updateChildren = true;
                    return false;
                }
                delete this._updateChildren;
                return this.inherited(arguments);
            },
            layoutChanged: function () {
            /**
             * @overrides ../Control.prototype.layoutChanged
             */
                delete this._computedStyle;
                if (this._autoSize !== "none") {
                    if (this._align !== "none") {
                        var changed = [];
                        var cs = this.getComputedStyle(),
                        w,
                        h;

                        if (Browser.webkit === true) {
                            w = parseInt(cs.getPropertyValue("width"), 10);
                            h = parseInt(cs.getPropertyValue("height"), 10);
                        } else {
                            w = this._node.clientWidth;
                            h = this._node.clientHeight;
                        }

                        if (this._autoSize === "both" || this._autoSize === "height") {
                            if (this._height !== h) {
                                this._height = h;
                                changed.push("height");
                            }
                        }

                        if (this._autoSize === "both" || this._autoSize === "width") {
                            if (this._width != w) {
                                this._width = w;
                                changed.push("width");
                            }
                        }

                        if (changed.length > 0) {
                            this.boundsChanged(changed);
                        }
                    } else if (this._parent !== null) {
                        this._parent.contentChanged();
                    }
                } else if (this._parent !== null) {
                    this._parent.contentChanged();
                }
            },
            contentChanged: function () {
            /**
             * @overrides ../Control.prototype.contentChanged
             */
                this.alignControls();
                this.layoutChanged();
                //this.inherited(arguments);
            },
            shown: function () {
            /**
             * @overrides ../Control.prototype.shown
             */
                if(this._needsResize) {
                    //console.trace("Panel.shown-needsResize", this.hashCode(), this.isShowing());
                    this.onresize(this._needsResize);
                } else {
                    this.applyBounds();
                }
                return this.inherited(arguments);
            },
            hidden: function () {
            /**
             * @overrides ../Control.prototype.layoutChanged
             */
                if (this._autoSize !== "none") {
                    this._height = 0;
                    this._width = 0;
                }
                return this.inherited(arguments);
            },

// Bounds
            applyBounds: function (left, top, right, bottom, width, height) {
            /**
             *
             * @param left
             * @param top
             * @param right
             * @param bottom
             * @param width
             * @param height
             */

                var previousWidth = this._node.clientWidth;
                var previousHeight = this._node.clientHeight;
                var autoHeight = this._autoSize === "height" || this._autoSize === "both";
                var autoWidth = this._autoSize === "width" || this._autoSize === "both";
                var fixedHeight = !autoHeight && (this._align === "top" || this._align === "bottom" || this._align === "none");
                var fixedWidth = !autoWidth && (this._align === "right" || this._align === "left" || this._align === "none");

                var cs = this.getComputedStyle();
                this.setBoundsValidated(left, top, right, bottom, width, height);

                var bounds = {
                    top: this._top,
                    left: this._left,
                    bottom: this._bottom,
                    right: this._right
                };

                if (fixedWidth === true) {
                    bounds.width = this._width;
                }

                if (fixedHeight === true) {
                    bounds.height = this._height;
                }

                if (cs.position !== "static") {
                    if (this._align === "top") {
                        delete bounds.bottom;
                    } else if (this._align === "bottom") {
                        delete bounds.top;
                    } else if (this._align === "left") {
                        delete bounds.right;
                    } else if (this._align === "right") {
                        delete bounds.left;
                    } else if (this._align === "none") {
                    	// TODO autoPosition?
                        delete bounds.bottom;
                        delete bounds.right;
                    }
                } else {
                    //console.log(String.format("%n - position: static", this));
                }

                var ap = this._autoPosition;
                for (var k in ap) {
                    if (ap[k] === true) {
                        delete bounds[k];
                    }
                }

                var bu = "px";
                this.setStyleProp("top", bounds.top, bu);
                this.setStyleProp("left", bounds.left, bu);
                this.setStyleProp("bottom", bounds.bottom, bu);
                this.setStyleProp("right", bounds.right, bu);
                this.setStyleProp("width", bounds.width, bu);
                this.setStyleProp("height", bounds.height, bu);

                if (previousWidth !== this._node.clientWidth || previousHeight !== this._node.clientHeight) {
                    this.dispatch("resize", {
                        previousWidth: previousWidth,
                        previousHeight: previousHeight,
                        width: this._node.clientWidth,
                        height: this._node.clientHeight
                    });
                }

                this.alignControls();
            },
            setBoundsValidated: function (left, top, right, bottom, width, height) {
            /**
             *
             * @param left
             * @param top
             * @param right
             * @param bottom
             * @param width
             * @param height
             */
                // FIXME what up with this method?
                if (left !== undefined) {
                    this._left = left;
                }
                if (right !== undefined) {
                    this._right = right;
                }
                if (top !== undefined) {
                    this._top = top;
                }
                if (bottom !== undefined) {
                    this._bottom = bottom;
                }
                if (width !== undefined) {
                    this._width = width;
                }
                if (height !== undefined) {
                    this._height = height;
                }
            },
            setBounds: function (left, top, right, bottom, width, height, post_update) {
            /**
             *
             * @param left
             * @param top
             * @param right
             * @param bottom
             * @param width
             * @param height
             * @param post_update
             */
                if (this.isLoading() || !this.isVisible()) {
                    this.setBoundsValidated(left, top, right, bottom, width, height);
                } else if (this.isShowing() === false) {
                    this.setBoundsValidated(left, top, right, bottom, width, height);
                    this.update(post_update);
                    if (post_update !== undefined) {
                        return "wait_for_post_update";
                    }
                } else {
                    this.applyBounds(left, top, right, bottom, width, height);
                    this.align();
                }
            },
            align: function (control, origin) {
            /**
             * @ overrides ./Container.prototype.align
             * 
             * @param control {./Control}
             * @param origin {./Control}
             */
                if (this.isLoading()) {
                    return;
                }

                if (control !== undefined) {
                    this.alignControls();
                } else {
                    if (this._align !== "none") {
                        if (this._parent !== null) {
                            this._parent.align(this);
                        } else {
                            this.alignSelf();
                        }
                    } else if (this._node !== null && (this._parent !== null || this.getParentNode() !== undefined)) {
                        this.applyBounds();
                    }
                }
            },
            alignSelf: function () {
            /**
             *
             */
                var node = this._alignSelfNode || this.getParentNode();
                if (node !== null) {
                    switch (this._align) {
                    case "client":
                        this.applyBounds(0, 0, 0, 0, undefined, undefined);
                        break;

                    case "left":
                        this.applyBounds(0, 0, undefined, 0, this._width, undefined);
                        break;

                    case "right":
                        this.applyBounds(undefined, 0, 0, 0, this._width, undefined);
                        break;

                    case "top":
                        this.applyBounds(0, 0, 0, undefined, undefined, this._height);
                        break;

                    case "bottom":
                        this.applyBounds(0, undefined, 0, 0, undefined, this._height);
                        break;

                    case "none":
                        this.applyBounds(this._left, this._top, undefined, undefined, this._width, this._height);
                        break;

                    }
                }
            },
            setActivePage: function (value, animation) {
            /**
             *
             * @param value
             */

                // Tracks the classes added to 'node'
                var node_animation_classes;

                /**
                 *
                 */
                function dec_transitions() {
                    if (--transitions === 0) {
                        Element.removeClasses(node, node_animation_classes);
                        if (value !== null) {
                            value.setState("classesChanged", false, false);
                            value._update();
                        }
                        if (current !== null) {
                            current.setState("classesChanged", false, false);
                            current._update();
                        }
                    }
                }

                if (animation === null) {
                    this._activePage = value;
                    value._update();
                    return;
                }

                var transitions = 0;
                var node = this.getNode();
                var current = this._activePage;
                var current_node;
                var value_node;
                var current_listeners;
                var value_listeners;

                if (typeof animation === "string") {
                    animation = {
                        style: js.str2obj(animation)
                    };
                }

                if (this._animations === undefined) {
                    this._animations = [];
                }

                if (this._activePage !== value) {

                    if (value !== "previous") {
                        animation = animation || {};
                        animation.style = animation.style || {};

                        animation.show = value;
                        animation.hide = current;

                        animation.style.show = animation.style.show || "right-left";
                        animation.style.hide = animation.style.hide || animation.style.show;
                        animation.style['show-rev'] = animation.style['show-rev'] || getRevAnim(animation.style.hide);
                        animation.style['hide-rev'] = animation.style['hide-rev'] || getRevAnim(animation.style.show);

                        this._animations.push(animation);

                    } else {
                        animation = this._animations.pop();
                        value = animation.hide;
                        swap(animation.style, "show", "show-rev");
                        swap(animation.style, "hide", "hide-rev");
                    }

                    node_animation_classes = String.format("animate %s", animation.style.show);
                    Element.addClasses(node, node_animation_classes);
                    this._activePage = value;

                    if (current !== null) {
                        prepareForAnim(current, "hide", animation);
                        current_node = current.getNode();
                        Element.addClasses(current_node, String.format("%s hide from", animation.style.hide));
                    }

                    if (value !== null) {
                        prepareForAnim(value, "show", animation);
                        value_node = value.getNode();
                        if (value.hasState("classesChanged")) {
                            value._applyClasses();
                            value.clearState("classesChanged", false);
                        }

                        Element.addClasses(value_node, String.format("%s show from", animation.style.show));
                        value._update();
                    }

                    //console.log(String.format("start - %s - %s", current ? current._node.className : "*", value ? value._node.className : "*"));
                    window.setTimeout(function () {
                        if (value !== null) {
                            transitions++;
                            Element.removeClass(value_node, "from");
                            Element.addClass(value_node, "to");
                            value_listeners = value.on({

                                /**
                                 *
                                 */
                                transitionend: function () {
                                    value.un(value_listeners);
                                    dec_transitions();
                                }
                            });
                        }

                        if (current !== null) {
                            transitions++;
                            Element.removeClasses(current_node, "from");
                            Element.addClasses(current_node, "to");
                            current_listeners = current.on({

                                /**
                                 *
                                 */
                                transitionend: function () {
                                    current.un(current_listeners);
                                    dec_transitions();
                                }
                            });
                        }

                        //console.log(String.format("on - %s - %s", current ? current._node.className : "*", value ? value._node.className : "*"));
                    }.bind(this), 0);

                }
            },
            getUsePages: function () {
            /**
             *
             */
                return this._usePages;
            },
            setUsePages: function (value) {
            /**
             *
             */
                if (this._usePages !== value) {
                    if ((this._usePages = value) === false) {
                        delete this._pages;
                    } else {
                        this._pages = [];
                    }
                    this.updateChildren();
                }
            },
            getAlignNode: function () {
            /**
             *
             */
                return this._alignNode;
            },
            setAlignNode: function (value) {
            /**
             * @param value {HtmlElement}
             */
                if (this._align !== value) {
                    if (value !== null) {
                        this._alignNode = value;
                    } else {
                        delete this._alignNode;
                    }
                    if (this.isVisible()) {
                        this.align();
                    }
                }
            },
            getAlign: function () {
            /**
             *
             */
                return this._align;
            },
            
            setAlign: function (value) {
            /**
             * @param value {String} @overrides PanelAlign
             */
                if (this._align !== value) {
                    this._align = value;
                    this.align();
                }
            },
            getAutoSize: function () {
            /**
             *
             */
                return this._autoSize;
            },
            setAutoSize: function (value) {
            /**
             * @param value {String} @overrides PanelAutoSize
             */
                if (this._autoSize !== value) {
                    this._autoSize = value;
                    this.align();
                }
            },
            getAutoPosition: function () {
            /**
             *
             * @returns {String}
             */
                var r = [];
                for (var k in this._autoPosition) {
                    if (this._autoPosition[k] === true) {
                        r.push(k);
                    }
                }
                return r.sort().join("-") || "align";
            },
            setAutoPosition: function (value) {
            /**
             *
             * @param value
             */
            	if(value === "all") { value = "top-left-bottom-right"; }
                if (typeof value === "string") {
                    var values = value.split("-");
                    value = {
                        top: false,
                        left: false,
                        bottom: false,
                        right: false
                    };
                    values.forEach(function (key) {
                        if (PanelAutoPosition[key] !== undefined) {
                            value[key] = true;
                        }
                    });
                }

                if (js.equals(value, PanelAutoPosition)) {
                    if (this._autoPosition !== PanelAutoPosition) {
                        delete this._autoPosition;
                        this.layoutChanged();
                    }
                } else {
                    var now = this._autoPosition;
                    for (var k in value) {
                        if (now[k] !== value[k]) {
                            this._autoPosition = Object.create(PanelAutoPosition);
                            js.mixIn(this._autoPosition, value);
                            this.align();
                            return;
                        }
                    }
                }
            },
            getLeft: function () {
            /**
             * Returns the left property of the calling control.
             */
                return this._left;
            },
            setLeft: function (value) {
            /**
             *
             * @param value {Number}
             */
                this.setBounds(value, this._top, this._right, this._bottom, this._width, this._height);
            },
            isLeftStored: function () {
            /**
             *
             */
                return this._align === "none" && (this._autoPosition === "absolute" || this._autoPosition === "relative") && this._left !== 0;
            },
            getTop: function () {
            /**
             *
             */
                return this._top;
            },
            setTop: function (value) {
            /**
             *
             * @param value {Number}
             */
                this.setBounds(this._left, value, this._right, this._bottom, this._width, this._height);
            },
            isTopStored: function () {
            /**
             *
             */
                return this._align === "none" && (this._autoPosition === "absolute" || this._autoPosition === "relative") && this._top !== 0;
            },
            setRight: function (value) {
            /**
             *
             * @param value {Number}
             */
                this.setBounds(this._left, this._top, value, this._bottom, this._width, this._height);
            },
            isRightStored: function () {
            /**
             *
             */
                return this._align === "none" && (this._autoPosition === "absolute" || this._autoPosition === "relative") && this._right !== 0;
            },
            getBottom: function () {
            /**
             *
             */
                return this._bottom;
            },
            setBottom: function (value) {
            /**
             *
             * @param value {Number}
             */
                this.setBounds(this._left, this._top, this._right, value, this._width, this._height);
            },
            isBottomStored: function () {
            /**
             *
             */
                return this._align === "none" && (this._autoPosition === "absolute" || this._autoPosition === "relative") && this._bottom !== 0;
            },
            getWidth: function () {
            /**
             *
             */
                return this._width;
            },
            
            setWidth: function (value) {
            /**
             *
             * @param value {Number}
             */
                this.setBounds(this._left, this._top, this._right, this._bottom, value, this._height);
            },
            isWidthStored: function () {
            /**
             *
             */
                return this._align !== "top" && this._align !== "bottom" && this._align !== "client" && this._autoSize !== "width" && this._autoSize !== "both" && this._width !== 0;
            },
            getHeight: function () {
            /**
             *
             */
                return this._height;
            },
            setHeight: function (value) {
            /**
             *
             * @param value {Number}
             */
                this.setBounds(this._left, this._top, this._right, this._bottom, this._width, value);
            },
            isHeightStored: function () {
            /**
             *
             */
                return this._align !== "left" && this._align !== "right" && this._align !== "client" && this._autoSize !== "height" && this._autoSize !== "both";
            }
        },
        properties: {

            "align": {
                set: Function,
                type: PanelAlign
            },
            "autoSize": {
                set: Function,
                type: PanelAutoSize
            },
            "autoPosition": {
                get: Function,
                set: Function,
                type: Class.Type.STRING
            },
            "focusable": {
                set: Function,
                type: Type.BOOLEAN
            },
            "left": {
                set: Function,
                type: Class.Type.INTEGER,
                stored: "isLeftStored"
            },
            "top": {
                set: Function,
                type: Class.Type.INTEGER,
                stored: "isTopStored"
            },
            "right": {
                set: Function,
                type: Class.Type.INTEGER,
                stored: "isRightStored"
            },
            "bottom": {
                set: Function,
                type: Class.Type.INTEGER,
                stored: "isBottomStored"
            },
            "height": {
                set: Function,
                type: Class.Type.INTEGER,
                stored: Function
            },
            "width": {
                set: Function,
                type: Class.Type.INTEGER,
                stored: Function
            }

        },
        statics: {
            ALIGN: PanelAlign,
            ALIGNPRIORITY: PanelAlignPriority,
            AUTOSIZE: PanelAutoSize,
            AUTOPOSITION: PanelAutoPosition
        }
    };

    return (Panel = Class.define(require, Panel));
});
define('vcl/ui/Ace',["require", "js/defineClass", "ace/ace", "./Panel", "js/Type"], function(require, Ace, ace, Panel, Type) {
    
    // Automatically scrolling cursor into view after selection change this will be disabled in the next version set editor.$blockScrolling = Infinity to disable this message

	return (Ace = Ace(require, {

		inherits: Panel,

		prototype: {

			"@css": {
				"background-color": "white",
				"z-index": "200",
				">div": "position: absolute; top: 0; left: 0; bottom: 0; right: 0;"
			},

			_align: "client",
			_editor: null,
			_content: "<div></div>",

			_cursorPos: null,

			/**
			 * @overrides ./Panel.prototype.applyBounds
			 */
			applyBounds: function() {
				this.inherited(arguments);
				this._editor.resize();
			},

			/**
			 * @overrides ../Control.prototype.onnodecreated
			 */
			onnodecreated: function() {
				var me = this;
				
				this._editor = ace.edit(this._node.childNodes[0]);
				this._editor.$blockScrolling = Infinity;
				
				this._editor.setOption("useSoftTabs", false);
				
				this._editor.on("change", function(e) {
				    me.dispatch("change", e);    
			    });
				
				return this.inherited(arguments);
			},

			/**
			 * @overrides ../Control.prototype.setFocus
			 */
			setFocus: function() {
				this.nodeNeeded();
				this._editor.focus();
			},
			
			/**
			 *
			 */
			onchange: function() {
				return this.fire("onChange", arguments);
			},

			/**
			 *
			 * @returns
			 */
			getEditor: function() {
				this.nodeNeeded();
				return this._editor;
			},

			getValue: function() {
				this.nodeNeeded();
				return this._editor.session.getValue();
			},

			setValue: function(value) {
				this.nodeNeeded();
				return this._editor.session.setValue(value);
			}

		}, 
		properties: {

// 			/** @overrides ../Element.properties.executesAction */
// 			"executesAction": {
// 				type: ["No", "onClick", "onEnterPressed"]
// 			},

// 			"detectChangeTimeout": {
// 				type: Type.INTEGER
// 			},
// 			"type": {
// 				type: InputTypes,
// 				set: Function
// 			},
// 			"placeholder": {
// 				type: Type.STRING,
// 				set: Function
// 			},
			"onChange": {
				type: Type.EVENT
			}

// 			"value": {
// 				type: Type.STRING,
// 				set: Function
// 			},

// 			"source": {
// 				set: Function,
// 				type: Component
// 			},

// 			"sourceAttribute": {
// 				type: Type.STRING,
// 				set: Function
// 			}

		}
	}));
});
define('vcl/ui/Bar',["require", "js/defineClass", "./Panel"], function(require, Bar, Panel) {
	
	return (Bar = Bar(require, {

		inherits: Panel,

		prototype: {
			"@css": {
	            overflow: "hidden", 			// that's the whole point of this control
				">div.overflow_handler": {
					display: "none",
                    top: "4px",
					right: "2px",
					width: "18px",
					"text-align": "center",
                    position: "absolute",
                    //border: "1px solid black",
                    "&:active": {
                    	//"padding-top": "4px"
                    	border: "1px inset",
                    	"background-color": "white"
                    }
				},
	            "&.overflowing": {
					"padding-right": "20px", 	// width of the overflow_handler
					">div.overflow_handler": {
						display: "block"
		            }
				}
			},

			_autoSize: "height",
			_align: "top",
			_content: "<div class=\"overflow_handler\">&#187;</div>",

			/**
			 *
			 * @returns
			 */
            checkOverflow: function () {
            	if(this.hasOwnProperty("_node")) {
                    var overflowing = this._node.scrollHeight/* - this._node.offsetHeight*/ > this._node.offsetHeight;
                    var has = this.hasClass("overflowing");
                    if(overflowing === true && has === false) {
                    	this.addClass("overflowing");
                    } else if(overflowing === false && has === true) {
                    	this.removeClass("overflowing");
                    }

                    if (this.hasOwnProperty("_controls") && this._controls.length > 1 && overflowing === true) {
                        var selected = this.getSelectedControl(1);
                        while(selected) {
                            var ar0 = this._controls[0].getAbsoluteRect();
                            var arS = selected.getAbsoluteRect();
                            if (arS.top > ar0.top) {
                            	var index = selected.getIndex() - 1;
                            	if(index >= 0) {
                            		this._controls[index].setIndex(this._controls.length - 1);
                            	}
                            } else {
                            	selected = null;
                            }
                        }
                        // if(selected) {
                        //     var ar0 = this._controls[0].getAbsoluteRect();
                        //     var arS = selected.getAbsoluteRect();
                        //     if (arS.top > ar0.top) {
                        //         /*- the selected control appears below the first control, therefore it is not visible find the last control to appear on the first line */
                        //         var index = 1;
                        //         var tops = [ar0.top];
                        //         while (index < this._controls.length && this._controls[index].getAbsoluteRect().top === ar0.top) {
                        //             tops.push(this._controls[index].getAbsoluteRect().top);
                        //             index++;
                        //         }
                        //         // console.log("selected is overflowing on the next line, setting new index to: " + (index - 1) + " " + tops.join(","));
                        //         selected.setIndex(index - 1);
                        //         if (index !== 0) {
                        //             /*- check again because text might be too long to fit */
                        //             this.checkOverflow();
                        //         }
                        //     }
                        // }
                    }
            	}
            },
            
            /**
             * @overrides ../../Control.prototype.intializeNodes
             */
            initializeNodes: function() {
            	this._nodes.overflow_handler = this._node
            		.querySelector(".overflow_handler");
            	return this.inherited(arguments);
            },

            /**
             * @overrides ../../Control.prototype.insertControl
             */
            insertControl: function (control, index) {
                var r = this.inherited(arguments);
                this.setTimeout("checkOverflow", 200);
                return r;
            },

            /**
             * @overrides ../../Control.prototype.removeControl
             */
            removeControl: function (control, index) {
                var r = this.inherited(arguments);
                this.setTimeout("checkOverflow", 200);
                return r;
            },

            /**
             * @overrides ../../Control.prototype.onresize
             */
            onresize: function () {
                this.setTimeout("checkOverflow", 0);
                return this.inherited(arguments);
            },
            
            onclick: function(evt) {
            	var r = this.inherited(arguments);
            	if(r !== false) {
	            	if(evt.target === this._nodes.overflow_handler) {
	            		alert(1);
	            	}
            	}
            	return r;
            }

		},

		properties: {

		},

		statics: {


		}
	}));
});
define('vcl/ui/Button',["require", "js/defineClass", "./Element"], function(require, Button, Element) {

	return (Button = Button(require, {

		inherits: Element,

		prototype: {

			/** @extends ../Control.prototype.@css */
			"@css": {
				"padding": "4px 8px 4px 8px",
				"border": "1px solid gray",
				"border-radius": "3px 3px",
				"background": "-webkit-linear-gradient(top, rgba(255, 255, 255, 1) 0%,rgba(227, 227, 227, 1) 100%)",
				"box-shadow": "inset 0 1px 0 rgba(255, 255, 255, 0.4), 0 1px 1px rgba(0, 0, 0, 0.10)",
				"text-shadow": "0 1px 0 rgba(0, 0, 0, 0.1)",
				".dropdown": {
					"font-size": "0.85em"
				},
				"&.disabled": {
					"color": "gray"
				},
				"&:not(.disabled):hover": {
					"cursor": "pointer",
					"background": "-webkit-linear-gradient(top, rgba(255, 255, 255, 1) 0%,rgba(241, 241, 241, 1) 100%)"
				},
				"&:not(.disabled):active": {
					"box-shadow": "inset 0 1px 1px rgba(0, 0, 0, 0.2)",
					//"padding-top": "3px",
					//"padding-bottom": "5px",
					"padding-right": "7px",
					"padding-left": "9px",
					"background": "-webkit-linear-gradient(top, rgba(227, 227, 227, 1) 0%,rgba(255, 255, 255, 1) 100%)",
					"text-shadow": "0 0px 0 rgba(0, 0, 0, 0.2)"
				}
			},

			_element: "button",

			/**
			 *
			 */
			onmousedown: function() {
				return this.inherited(arguments);
			},

			/**
			 *
			 */
			onmouseup: function() {
				return this.inherited(arguments);
			},

			/**
			 *
			 */
			onmouseleave: function() {
				return this.inherited(arguments);
			}
		}
	}));
});
define('vcl/ui/Console',['require','js/Class','js/Deferred','js','cavalion.org/console/Printer','./Panel'],function(require) {

	var Class = require("js/Class");
	var Deferred = require("js/Deferred");
	var Type = Class.Type;
	var js = require("js");

	var Printer = require("cavalion.org/console/Printer");
	var Panel = require("./Panel");

	var images = {
			'collapsed': "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAANH2lDQ1BJQ0MgUHJvZmlsZQAAeJyV13k0lH0bB/DrnhnGMsYYO2Fkl31fsm+JsmZLSXaGmZAkZUnKmiUULSjaFC0kKlrIEpJCQlHZQ8iSZd4/5Kn3Oed5n/P+/rru65z7vn/3fc7n+zsXACuPO5VKRgFAYFBosK2ZIcnJ2YWE7QIMsAABVEDL3SOEamBtbQn/uOY7AQEA6JB1p1LJbC+zMn7mODv4m9i+aE3yl/rn+wAAAB/s5OwCgMgAAIfPeq0PABz712t7AOA4FEoNBUB8AYDDw9fdEwCJBACZYHtbIwDkGgDgfdbrSgDA71+vGwAAH+bhEwqAdAPQE4M8/YIAsBMA9LqeXiEeAHgZAPD0DPEIBMCnAYBcYCDFEwBfCwCSHtTgUAD8CADIOjm7kNa3vDsRQIUXgMHid+9QFkB5AYDkjt89kQcAXO4AhSm/e7O2gAAAwtUW4q2sBAAACM4QgK6fRpsVB8BmAKym02jLhTTa6mUAdC9ALdnjYHDYr/+FIC0A/3a9/s2/FhoBQAEgokgxKgIdiYmkO0YfjY1lOM5ozFjHdJL5FC6BJRlfQfBlSyems2dwnOHM4srizuGp46Pw523KE7gg2EA6KFy4+bJIm9gR8WKJdqlj0je3dMrGyt2S71E8qXRX+aNqslqF+oBmqlaV9pBOpu4TvTGDbMNnRpMmuab1ZjPml7Y3WczvKNzZavXa+rVNu+2K/Y1d7xw6Hbucul0wu++49u7p29vv9nHfp/04j4eeX7y+eg/5DPuO+I0GcJKfBn4LmqRMUacPfA+eCZkLnTv4I2z+0EL44uGliJ9HViJXjq5GSUW/i0WOo+LQJzDxdCfpT2ETGBIZk5iSmVNwqSyn8Wms6YQMtkziGfYsjmzOHK6z3Od4cnnz+M7zX9h0UeCSYL5QAalQ+PLmKyJFosViVyWuSVyXvCF1U/rmeAn5lsxt2VL5MoU7incV7yndVylXrVCrmH8QVqn+UKNKq1r70dbHW5/oPFmriarVe6r/zOC54QujOkxdXL3JS9MGs0bzJvNmpuakVxYtlq072/Btp19bt9u8se0gdmS8tXtn37mri6srp9vxvVOPywe+D3m9rn2u/Xs+Cn689MltYN+g8GDh5/1fPL56DokNFQ97j/iM+o5Jjd0Y958I+EaelJ28PRU0TflOnVGcuTsbPBfyI3Redb5iIWwxfOnwz8PLWsvVK0dWI9d01p7QaACICAqPmkY3Y27SZdJHYn0Y7BmNmFSYJXASLDx4blYeAg8bJ1GcXZJDg9OSay93CE8qbylfM/+oALugmpAP6azwSxFEVEfsgPgdiSkpSWnylmpZtJyBfLrCgJKUcrxKl5q0OlWjTotbO3zrK10uPYr+M0NRoyPG7aaCZuHbHpsvWShaeu3I2tlujbcxsw23K7J/68DkqO90wPmCS/3uqT1Ce63cIvYVutftH/Xk9NLzdvI55pvvV+vfF7AUyB60hWJM9T0QGZwWUhhafrAh7MOhsfD5CPQRtkjSUZljqlH60RYxVrG7j++L8zpBjg89GXwqOiE68XhSQnJGSlJq7ulzaTnp6RnnMzPOZGedzb6Wc/Xs7XPXcm/mlZ5/dOHRxbpLr/LbCzoKOy53XPlQ9KV4+Orgta/Xp258vzlVMnlr5vZU6XjZxJ3huwP3Bu/3lLdXND6orXzwsLTqfHXGo+jHgU9211jUbn0q/Yz4bOn5pxdNdffrM18GN9g1qjXxN9Gae17db0lsdWkTaRt6fa/96BuTDnxH39v8d/6dyp2rXS3dme/39Ej1zH6o6o3ts+jn6O//eP1TyID2IGaw6fOZL3u/SnydGKoajhnZPso52jd2ZZw8oTqx9q1xMmNq97To9MT3ezORs2ZzxLnuH0XzlAXNRfTiy6X0n7uXRZa/rVSsRq+Z07hoNAA4joSjItDa6CrMUTo9uhr6GOwJBlOGOsZ4ppPMibjtuGaWFHwKayrBitDGlkbMYM/kyOS053zLlc2dzXOWN5cvjz9v03kBV4E+wUtC+aQC4YLNBSKXRa+IFYkXS1yVvCZ1XdpPemzLDZkS2Vtyt+VLFcoU7yjdVb6ncl+1Qq1CvUIjXGNRs0qrSrt66yOdx7rHdNf0avRrDZ4aPjN6bhxngjGpM603e7mtwbxxe5NFkiXO8tWOlp2tVm3WaTYEm3bbN3Yd9m93dTpkO3I5djl1O7936dmd58rv2runb+9Ht0/7PrkX7BfeP+jx2fOL11fvYh/x9QTxHwu4SZYhT/xXisz+lSKVhzUOL0X8PLIcuXJ09dhaFC0GYlF/JQn2FDaBIaExcXsSczIuBZfKcpo1jZDO9leWcOVwn+X5lSWb/sySwsHLHldEikSLxa+Kb6RJicwt2dtyf2SJcrlKheoD9Ur1hxpVmtXaj7Qfb32iW6P7R46Y1Ju+NG0wa9zWZN5s8SqsdXPbztfW7dZvbDqOvpPudOhy7I7tkf/g0hvfr/wxYUB1MPmL55D2cPqo37j/N/IU5XvinMv86aWkVVsaDWD97AMAoFcDyN4C4JALYFcIEL8FQMINgOsagDULgL0moOgEAaVDBWS7zsb5AQgQQADkwBCcIQTSoAwWERJigYQj15BWZBjFijJDxaAeo1bQOugYdD16BSOMccYUY37QmdKdoCulm6I3oy+gH8JyYl2xjxmwDJoMcQzjjFqMFMZaJlmmaKZKZjxzDPN7HAcuCDfCYsJynGUA745/xopm9WadINgQsgmrbAlsM0QtYhG7OnsR+xSHG8cCpx9nBdcWrpfc3jxYnhu8YryHeOf4LvCb8c9uyhcQFYgURATLhfxJwqQe4TObN2+OFmEVaRNNF9slzic+KHFT0kjyupShNJv0wJZ7MidlXeWU5XHywwovFAuVYpU9VcxUZdTY1VbUhzRyNPGatVpl2gVbz+ic0o3SO6R/wIBs6Gfka+xrEmAaZBa67Yh53PbTFnmW13dU7my06rX+bou1E7TX2GXnQHVMdbrt/Npl1pVnj+5eb7e0fdXuIx7cnmZeh71L/Hj8rQMSyXVBKIoBNebA8xD6UIuDGeGihykRjyKZjrocK4mixdjHoU64xj84xZ5wILE9JSt1Kc0tvT5T/kxuTsjZz7l2eXUXb+eLFVy4zF1MuJp6HX/j9K2cUoGyK3dly40r2ivdH35/zP2kpNbweWgda31Jw/bmxBbZ1vbXYR3176hd/N0NveJ93R8TB/S+lAx5jgiN9nxzmOKa7prJnXNbmFgqX46i8dBoAIACJuAGKdADJzgIWVAJ/QgWUUDckFSkBplFSaPcULmot2hW9A50MroFw4KxwmRhPtCR6PzoyugW6Y3oT9O/x4phD2KfMxAZPBkqGZkZXRlvM2GY9jLdZ2Zi9mCuwXHiqLgWFmmWFJYJvCW+lJWFlcLaSdAnXGHDs4WxfSCaEu+wk9gz2Nc4Qji+cfpzjnGRuWa4Q7nneSJ4Ed5kPj6+G/ya/PWbHDaNCkQL8gpWCNkIjZHihcWFGzYHiXCLPBH1EMOJPRUPkhCSeCOZIGUotSpdvSVSRkdmQbZG7pS8vYKwwpRijVK6sr+Ksaqg6rLaO/WHGhc0Y7R8tB236ujI6wrrEfUxBmiDGcPvRlPG4yZDprNm49t+bEdZcFhy71DcqWtlZW1rE2B72C7P/u6uVw4fHFecOVzkd+90PbDn3N46t2F3xv0KHr6euV413tO+Un5e/jkB7wL5g3ZR8qgjwZIhYaGNYQKHQsKbIkSOpEaOHXOOaohRiy2KI55IPUk8lZ3Ik5SXopramuaV/jMzJUs9++vZi7n+53ddlMqnK5i4/Kyo/Oq56/E3PW65lpre0binUi73QPahZLXYY8kahad6z7fV2bwkNx5oTm/Jb3vU3t9B6xTq1unx7E3qr/o08Zn3q+Fw9Oi18S+TfNPeMxfnhhYkl4KWK9YQGg0A6IEAAmAIzpAGZfBmw/6G+3X1GFaMM+YHnSld7i/va1hXBiGGOIZxRnvGWiZZpvPMeOYY5gVcEG6ExRPvjv/M6s06QQghrLIlELmIRezq7E0cbhwLnGl/md7JO/fLs7UgIlj+y7LNuuRfjsOkDP80/FvwL79vNGu1yn7b/S33n93+L7U+A348/tZ/VxvW83e3sTf+lJus9FtuNv2G3QuaG3qvZG74LSFuCL5XuWG4+vi64qc9G44bR5sTX71oyW5tfx32RqCj/h21s6wrvruhJ6xXvC+g3/hj4oDe4MnP+7+UfJ0f6hgRGg0YMx+XnMB+c5gsnoqf9vm+bUZ6lnl2cu71j3vz2Qv2CxOLcUuGPyV+Di1HrfCsXFxlW41bXVi7Qkui0QDW5yUAAGAyopApwSRLI+N/Ge7+3xVIPrjxDgQAcF5Bu+wAgAgAm8AIKEAGCgQDCSzBCIwB1mc1AAB6AsB5RwCAmsUj0X9/bqhXeCgAgBGFejjYz8c3lGRApZK9SEaUQOrBUK9gGZJ5kIecDElJQUEdAOA/QDcDSMfdcGMAAACFSURBVBiVdY4xCkIxEERn4y83bYLn8AzW3kpPIYKlljZ2HsJOECx3U6WICEGyVkIQM93AG94ghLAEMGGQGTNvmXnlvb+XUgSA9QDFGC9dFwBrVb2OgG9uRLQRkYcbqOettQV+z5nZyzl3NLNDSunZA28Ap1rrPuec+9FERGcz26lq+uf6AJ0/M9pbbH4+AAAAAElFTkSuQmCC",
			'expanded':  "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAANH2lDQ1BJQ0MgUHJvZmlsZQAAeJyV13k0lH0bB/DrnhnGMsYYO2Fkl31fsm+JsmZLSXaGmZAkZUnKmiUULSjaFC0kKlrIEpJCQlHZQ8iSZd4/5Kn3Oed5n/P+/rru65z7vn/3fc7n+zsXACuPO5VKRgFAYFBosK2ZIcnJ2YWE7QIMsAABVEDL3SOEamBtbQn/uOY7AQEA6JB1p1LJbC+zMn7mODv4m9i+aE3yl/rn+wAAAB/s5OwCgMgAAIfPeq0PABz712t7AOA4FEoNBUB8AYDDw9fdEwCJBACZYHtbIwDkGgDgfdbrSgDA71+vGwAAH+bhEwqAdAPQE4M8/YIAsBMA9LqeXiEeAHgZAPD0DPEIBMCnAYBcYCDFEwBfCwCSHtTgUAD8CADIOjm7kNa3vDsRQIUXgMHid+9QFkB5AYDkjt89kQcAXO4AhSm/e7O2gAAAwtUW4q2sBAAACM4QgK6fRpsVB8BmAKym02jLhTTa6mUAdC9ALdnjYHDYr/+FIC0A/3a9/s2/FhoBQAEgokgxKgIdiYmkO0YfjY1lOM5ozFjHdJL5FC6BJRlfQfBlSyems2dwnOHM4srizuGp46Pw523KE7gg2EA6KFy4+bJIm9gR8WKJdqlj0je3dMrGyt2S71E8qXRX+aNqslqF+oBmqlaV9pBOpu4TvTGDbMNnRpMmuab1ZjPml7Y3WczvKNzZavXa+rVNu+2K/Y1d7xw6Hbucul0wu++49u7p29vv9nHfp/04j4eeX7y+eg/5DPuO+I0GcJKfBn4LmqRMUacPfA+eCZkLnTv4I2z+0EL44uGliJ9HViJXjq5GSUW/i0WOo+LQJzDxdCfpT2ETGBIZk5iSmVNwqSyn8Wms6YQMtkziGfYsjmzOHK6z3Od4cnnz+M7zX9h0UeCSYL5QAalQ+PLmKyJFosViVyWuSVyXvCF1U/rmeAn5lsxt2VL5MoU7incV7yndVylXrVCrmH8QVqn+UKNKq1r70dbHW5/oPFmriarVe6r/zOC54QujOkxdXL3JS9MGs0bzJvNmpuakVxYtlq072/Btp19bt9u8se0gdmS8tXtn37mri6srp9vxvVOPywe+D3m9rn2u/Xs+Cn689MltYN+g8GDh5/1fPL56DokNFQ97j/iM+o5Jjd0Y958I+EaelJ28PRU0TflOnVGcuTsbPBfyI3Redb5iIWwxfOnwz8PLWsvVK0dWI9d01p7QaACICAqPmkY3Y27SZdJHYn0Y7BmNmFSYJXASLDx4blYeAg8bJ1GcXZJDg9OSay93CE8qbylfM/+oALugmpAP6azwSxFEVEfsgPgdiSkpSWnylmpZtJyBfLrCgJKUcrxKl5q0OlWjTotbO3zrK10uPYr+M0NRoyPG7aaCZuHbHpsvWShaeu3I2tlujbcxsw23K7J/68DkqO90wPmCS/3uqT1Ce63cIvYVutftH/Xk9NLzdvI55pvvV+vfF7AUyB60hWJM9T0QGZwWUhhafrAh7MOhsfD5CPQRtkjSUZljqlH60RYxVrG7j++L8zpBjg89GXwqOiE68XhSQnJGSlJq7ulzaTnp6RnnMzPOZGedzb6Wc/Xs7XPXcm/mlZ5/dOHRxbpLr/LbCzoKOy53XPlQ9KV4+Orgta/Xp258vzlVMnlr5vZU6XjZxJ3huwP3Bu/3lLdXND6orXzwsLTqfHXGo+jHgU9211jUbn0q/Yz4bOn5pxdNdffrM18GN9g1qjXxN9Gae17db0lsdWkTaRt6fa/96BuTDnxH39v8d/6dyp2rXS3dme/39Ej1zH6o6o3ts+jn6O//eP1TyID2IGaw6fOZL3u/SnydGKoajhnZPso52jd2ZZw8oTqx9q1xMmNq97To9MT3ezORs2ZzxLnuH0XzlAXNRfTiy6X0n7uXRZa/rVSsRq+Z07hoNAA4joSjItDa6CrMUTo9uhr6GOwJBlOGOsZ4ppPMibjtuGaWFHwKayrBitDGlkbMYM/kyOS053zLlc2dzXOWN5cvjz9v03kBV4E+wUtC+aQC4YLNBSKXRa+IFYkXS1yVvCZ1XdpPemzLDZkS2Vtyt+VLFcoU7yjdVb6ncl+1Qq1CvUIjXGNRs0qrSrt66yOdx7rHdNf0avRrDZ4aPjN6bhxngjGpM603e7mtwbxxe5NFkiXO8tWOlp2tVm3WaTYEm3bbN3Yd9m93dTpkO3I5djl1O7936dmd58rv2runb+9Ht0/7PrkX7BfeP+jx2fOL11fvYh/x9QTxHwu4SZYhT/xXisz+lSKVhzUOL0X8PLIcuXJ09dhaFC0GYlF/JQn2FDaBIaExcXsSczIuBZfKcpo1jZDO9leWcOVwn+X5lSWb/sySwsHLHldEikSLxa+Kb6RJicwt2dtyf2SJcrlKheoD9Ur1hxpVmtXaj7Qfb32iW6P7R46Y1Ju+NG0wa9zWZN5s8SqsdXPbztfW7dZvbDqOvpPudOhy7I7tkf/g0hvfr/wxYUB1MPmL55D2cPqo37j/N/IU5XvinMv86aWkVVsaDWD97AMAoFcDyN4C4JALYFcIEL8FQMINgOsagDULgL0moOgEAaVDBWS7zsb5AQgQQADkwBCcIQTSoAwWERJigYQj15BWZBjFijJDxaAeo1bQOugYdD16BSOMccYUY37QmdKdoCulm6I3oy+gH8JyYl2xjxmwDJoMcQzjjFqMFMZaJlmmaKZKZjxzDPN7HAcuCDfCYsJynGUA745/xopm9WadINgQsgmrbAlsM0QtYhG7OnsR+xSHG8cCpx9nBdcWrpfc3jxYnhu8YryHeOf4LvCb8c9uyhcQFYgURATLhfxJwqQe4TObN2+OFmEVaRNNF9slzic+KHFT0kjyupShNJv0wJZ7MidlXeWU5XHywwovFAuVYpU9VcxUZdTY1VbUhzRyNPGatVpl2gVbz+ic0o3SO6R/wIBs6Gfka+xrEmAaZBa67Yh53PbTFnmW13dU7my06rX+bou1E7TX2GXnQHVMdbrt/Npl1pVnj+5eb7e0fdXuIx7cnmZeh71L/Hj8rQMSyXVBKIoBNebA8xD6UIuDGeGihykRjyKZjrocK4mixdjHoU64xj84xZ5wILE9JSt1Kc0tvT5T/kxuTsjZz7l2eXUXb+eLFVy4zF1MuJp6HX/j9K2cUoGyK3dly40r2ivdH35/zP2kpNbweWgda31Jw/bmxBbZ1vbXYR3176hd/N0NveJ93R8TB/S+lAx5jgiN9nxzmOKa7prJnXNbmFgqX46i8dBoAIACJuAGKdADJzgIWVAJ/QgWUUDckFSkBplFSaPcULmot2hW9A50MroFw4KxwmRhPtCR6PzoyugW6Y3oT9O/x4phD2KfMxAZPBkqGZkZXRlvM2GY9jLdZ2Zi9mCuwXHiqLgWFmmWFJYJvCW+lJWFlcLaSdAnXGHDs4WxfSCaEu+wk9gz2Nc4Qji+cfpzjnGRuWa4Q7nneSJ4Ed5kPj6+G/ya/PWbHDaNCkQL8gpWCNkIjZHihcWFGzYHiXCLPBH1EMOJPRUPkhCSeCOZIGUotSpdvSVSRkdmQbZG7pS8vYKwwpRijVK6sr+Ksaqg6rLaO/WHGhc0Y7R8tB236ujI6wrrEfUxBmiDGcPvRlPG4yZDprNm49t+bEdZcFhy71DcqWtlZW1rE2B72C7P/u6uVw4fHFecOVzkd+90PbDn3N46t2F3xv0KHr6euV413tO+Un5e/jkB7wL5g3ZR8qgjwZIhYaGNYQKHQsKbIkSOpEaOHXOOaohRiy2KI55IPUk8lZ3Ik5SXopramuaV/jMzJUs9++vZi7n+53ddlMqnK5i4/Kyo/Oq56/E3PW65lpre0binUi73QPahZLXYY8kahad6z7fV2bwkNx5oTm/Jb3vU3t9B6xTq1unx7E3qr/o08Zn3q+Fw9Oi18S+TfNPeMxfnhhYkl4KWK9YQGg0A6IEAAmAIzpAGZfBmw/6G+3X1GFaMM+YHnSld7i/va1hXBiGGOIZxRnvGWiZZpvPMeOYY5gVcEG6ExRPvjv/M6s06QQghrLIlELmIRezq7E0cbhwLnGl/md7JO/fLs7UgIlj+y7LNuuRfjsOkDP80/FvwL79vNGu1yn7b/S33n93+L7U+A348/tZ/VxvW83e3sTf+lJus9FtuNv2G3QuaG3qvZG74LSFuCL5XuWG4+vi64qc9G44bR5sTX71oyW5tfx32RqCj/h21s6wrvruhJ6xXvC+g3/hj4oDe4MnP+7+UfJ0f6hgRGg0YMx+XnMB+c5gsnoqf9vm+bUZ6lnl2cu71j3vz2Qv2CxOLcUuGPyV+Di1HrfCsXFxlW41bXVi7Qkui0QDW5yUAAGAyopApwSRLI+N/Ge7+3xVIPrjxDgQAcF5Bu+wAgAgAm8AIKEAGCgQDCSzBCIwB1mc1AAB6AsB5RwCAmsUj0X9/bqhXeCgAgBGFejjYz8c3lGRApZK9SEaUQOrBUK9gGZJ5kIecDElJQUEdAOA/QDcDSMfdcGMAAACOSURBVBiVbY+xDcIwFETfTyawF4iUjk3YiI4yayBRhiGYAKWgo7BcUNDFCFlIQP6nArnwlffeFSd9329EZE0lqjo0IrIDPhV+77ru2M7znL33DliV1My20zRdG4BlWfbAs+C3EMIJoAGIMSYzOxTrAdC/AJBzHs3soaqXEML517eF8HbOvcxsTCml2qtqvtDEQyHTPrvpAAAAAElFTkSuQmCC"
		};

	var Console = {

		inherits: Panel,

		prototype: {

			"@css": {
				"font-family": "menlo, 'lucida console'",
				"font-size": "12px",
				"cursor": "default",
				"div.node:before": {
					// content: "Ralph"
				},
				".node": {
					"white-space": "nowrap",
					"margin-top": "2px",
					"margin-bottom": "2px",
					">.time":
							"vertical-align: top; text-align: right; color: silver; width: 60px; " +
							"padding-right: 12px; display: inline-block;",
					">.message": "padding-left: 15px; display: inline-block;",
					">.key": "padding-left: 15px; display: inline-block; padding-right: 5px; max-width: 75%; overflow: hidden; text-overflow: ellipsis;",
					">.value": "display: inline-block; vertical-align: top;",
					">.container": "padding-left: 85px; clear: both; display: none; margin-bottom: 4px;",
					"&.border-bottom": {
						"padding-bottom": "2px",
						"border-bottom": "1px solid silver",
						"margin-bottom": "2px"
					},
					"&:hover>.key": "background-color: #f0f0f0;",
					"&.expandable": {
						">.value": "cursor: pointer;",
						">.message": {
							"background-image": String.format("url(%s)", images.collapsed),
							"background-repeat": "no-repeat",
							"background-position": "4px 1px",
							"cursor": "pointer"
						},
						">.key": {
							"background-image": String.format("url(%s)", images.collapsed),
							"background-repeat": "no-repeat",
							"background-position": "4px 1px",
							"cursor": "pointer"
						},
						"&.expanded": {
							">.message": {
								"background-image": String.format("url(%s)", images.expanded)
							},
							">.key": {
								"background-image": String.format("url(%s)", images.expanded)
							}
						}
					},
					"&.key>.container": "padding-left: 15px;",
					"&.expanded>.container": "display: block;",
					"&.error.error>.message": "color: red;",
					"&.error.error>.value": "color: red;",
					"&.string>.value": "color: green;",
					"&.number>.value": "color: red;",
					"&.undefined>.value": "color: silver;",
					"&.null>.value": "color: purple;",
					"&.boolean>.value": "color: purple;",
					"&.function>.value": "color: purple;",
					"&.function>.value>.proto": "color: silver;",
					"&.function>.container>.code":
						"margin: 8px; padding: 8px; background-color: #f0f0f0; overflow: auto;",
					"&.array>.value": "color: purple;",
					"&.object>.value": "color: blue;",
					"&.object>.value>.uri": "color: silver;"
				},
				"div.console": {
					"padding-top": "2px"
				},
				"div.cmdline": {
					margin: "2px 10px 0 64px",
					'border-top': "1px solid rgba(192, 192, 192, 0.2)",
					">input": {
						//position: "relative",
						margin: "4px 0 3px 0",
						//"padding-left": "12px",
						//top: "-20px",
						"background-color": "transparent",
						width: "100%",
						border: "none",
						outline: "none",
						font: "inherit"
					}
				}
			},

			_align: "client",

			_content: "<div class='console'></div><div class='cmdline'><input></div>",
			_history: null,
			
			_onEvaluate: null,

			/**
			 *
			 */
			constructor: function() {
			},

			/**
			 *
			 */
			loaded: function() {
				this.loadHistory();
				return this.inherited(arguments);
			},

			/**
			 * @overrides ../../Control.prototype.initializeNodes
			 */
			initializeNodes: function() {
				this.inherited(arguments);

				this._nodes.console = this.getChildNode(0);
				this._nodes.input = this.getChildNode(1, 0);

				this._printer = new Printer(this._nodes.console);
			},

			/**
			 * @overrides ../../Control.prototype.onclick
			 */
			onclick: function(evt) {
		        // FIXME why was this scrolling thing necessary again?
			    this.setTimeout("clicked", function() {
			        //if(evt.target === this._node) {
        				this.storeScroll();
        				this._nodes.input.focus();
        				this.restoreScroll();
			        //}
			    }.bind(this), 350);
				return this.inherited(arguments);
			},

			/**
			 * @overrides ../../Control.prototype.onkeydown
			 */
			onkeypress: function(evt) {
				var r = this.inherited(arguments);
				if(r !== false) {
					if(evt.keyCode === 13) {
						var text = this._nodes.input.value;
						if(text !== "") {
							var value;

							this._nodes.input.value = "";
							this.pushHistory(text);

							try {
								value = this.evaluate(text);
							} catch(e) {
								value = e;
							}
							this.print(text, value);
						}
					}
				}
				//this.print("press", evt.keyCode);
				return r;
			},

			/**
			 * @overrides ../../Control.prototype.onkeyup
			 */
			onkeydown: function(evt) {
				var r = this.inherited(arguments);

				if(evt.ctrlKey === true) {
					if(evt.keyCode === 76) {
						this._nodes.console.innerHTML = "";
						evt.preventDefault();
					}
				} else if(evt.keyCode === 38) {
					if(this._history.index > 0) {
						this._history.index--;
						this._nodes.input.value = this._history[this._history.index];
					}
					evt.preventDefault();
				} else if(evt.keyCode === 40) {
					if(this._history.index < this._history.length - 1) {
						this._history.index++;
						this._nodes.input.value = this._history[this._history.index];
					}
					evt.preventDefault();
				}

				return r;
			},

			/**
			 * @overrides ../../Control.prototype.setFocus
			 */
			setFocus: function(evt) {
				this.nodeNeeded();
				this._nodes.input.focus();
			},

			/**
			 *
			 */
			clear: function() {
				if(this.hasOwnProperty("_node")) {
					this._node.childNodes[0].innerHTML = "";
				}
			},

			/**
			 *
			 */
			evaluate: function(expr) {
				if(expr === "#") {
					expr = "require('js/JsObject').$";
				} else if (expr.charAt(0) !== " ") {
                    expr = expr.replace(/#(\d+)/g, "require('js/JsObject').$['$1']");
                }

				if(this._onEvaluate !== null) {
					return this.fire("onEvaluate", [expr]);
				}
				
				function req() {
				    var d = new Deferred();
				    require.apply(this, [js.copy_args(arguments),
				        function () {
				            d.callback.apply(d, js.copy_args(arguments));
				        },
				        function (err) {
				            d.errback(err);
				        }
				    ]);
				    return d;
				}				

                /* jshint evil: true */
				return eval(expr);
			},

			/**
			 *
			 */
			loadHistory: function() {
				var key = this.getStorageKey("history");
				this._history = JSON.parse(localStorage.getItem(key)) || [];
				this._history.index = this._history.length;
			},
			
			saveHistory: function(text) {
				var key = this.getStorageKey("history");
		        try {
		            var history = JSON.parse(localStorage.getItem(key)) || [];
		            if (history[history.length - 1] !== text) {
		                history.push(text);
		                if (history.length > 100) {
		                    history.splice(0, history.length - 100);
		                }
		                localStorage.setItem(key, JSON.stringify(history));
		            }
		        } catch(e) {
		        	this.print(e);
		        }
			},

			/**
			 *
			 */
			pushHistory: function(text) {
			    this.saveHistory(text);

		        if(this._history[this._history.length - 1] !== text) {
		        	this._history.index = this._history.push(text);
		        } else {
		        	this._history.index = this._history.length;
		        }
			},

			/**
			 *
			 */
			print: function() {
				this.nodeNeeded();
				try {
					return this._printer.print.apply(this._printer, arguments);
				} finally {
					this._node.scrollTop = this._node.scrollHeight;
				}
			},

			/**
			 *
			 * @returns
			 */
			log: function() {
				return this.print.apply(this, arguments);
			},

			/**
			 *
			 * @returns
			 */
			getPrinter: function() {
				return this._printer;
			},

			/**
			 *
			 * @returns
			 */
			getOnEvaluate: function() {
				return this._onEvaluate;
			},

			/**
			 *
			 * @param value
			 */
			setOnEvaluate: function(value) {
				this._onEvaluate = value;
			}
		},

		properties: {
			"onEvaluate": {
				type: Type.EVENT
			}
		}
	};

	return (Console = Class.define(require, Console));
});
define('vcl/ui/Form',['require','js/defineClass','js/Type','./Panel','../Control'],function(require) {

	var Form = require("js/defineClass");
	var Type = require("js/Type");
	var Panel = require("./Panel");
	var Control = require("../Control");

	return (Form = Form(require, {
		inherits: Panel,
		prototype: {
			"@css": {
				//"div": "margin-top: 100px;"
			},

			_align: "client",
			_activeControl: null,
			_caption: "",
			_activated: false,

			_onShow: null,
			_onHide: null,
			_onCloseQuery: null,
			_onClose: null,
			_onActivate: null,
			_onDeactivate: null,
			_onSubmit: null,
			_onReflectHash: null,
			
			onshow: function() {
				/** s ../Control.prototype.onshow */
				if(this.fire("onShow", arguments) !== false) {
				    var me = this;
				    (function() {
    					if(me._activeControl !== null) {
    					    if(me._activeControl.isShowing()) {
    					        me._activeControl.setFocused(true);
    					    } else {
        						me.setTimeout("focus:activeControl",
        						        arguments.callee, 500);
    					    }
    					}
				    }());
				}
			},
			onhide: function() {
				/** s ../Control.prototype.onhide */
				if(this.fire("onHide", arguments) !== false) {
				}
			},
			visibleChanged: function() {
				/** s ../Control.prototype.visibleChanged */
				var r = this.inherited(arguments);

				if(this.isVisible()) {
					if(this._activated === false) {
						this._activated = true;
						this.dispatch("activate");
					}
				} else {
					if(this._activated === true) {
						this._activated = false;
						this.dispatch("deactivate");
					}
				}

				return r;
			},
	        setFocus: function () {
	            /** @overrides ../Control.prototype.setFocus */
                if(this._activeControl) {
                    this._activeControl.setFocus.apply(this._activeControl, arguments);
                }
            },
			close: function() {
				if(this.dispatch("closequery") !== false) {
					this.setVisible(false);
					this.dispatch("close");
				}
			},
			onactivate: function() {
				return this.fire("onActivate", arguments);
			},
			ondeactivate: function() {
				return this.fire("onDeactivate", arguments);
			},
			oncaptionchanged: function() {
				return this.fire("onCaptionChanged", arguments);
			},
			onclosequery: function() {
				return this.fire("onCloseQuery", arguments);
			},
			onclose: function() {
				return this.fire("onClose", arguments);
			},
			getActiveControl: function() {
				return this._activeControl;
			},
			setActiveControl: function(value) {
				this._activeControl = value;
			},
			getCaption: function() {
                return this._caption;
			},
			setCaption: function(value) {
                if(this._caption !== value) {
                    this._caption = value;
					this.dispatch("captionchanged", value);
                }
			}

		},
		properties: {
			"activeControl": {
				type: Control,
				set: Function
			},
			"caption": {
                type: Type.STRING,
                set: Function
			},
			"onReflectHash": {
				type: Type.EVENT
			},
			"onCaptionChanged": {
				type: Type.EVENT
			},
			"onShow": {
				type: Type.EVENT
			},
			"onHide": {
				type: Type.EVENT
			},
			"onClose": {
				type: Type.EVENT
			},
			"onCloseQuery": {
				type: Type.EVENT
			},
			"onActivate": {
				type: Type.EVENT
			},
			"onDeactivate": {
				type: Type.EVENT
			},
			"onSubmit": {
				type: Type.EVENT
			}
		},
		statics: {
			cache: function(form) {
				form.setParent(null);
				form.setOwner(null);
				form.setVisible(true);
				//org.cavalion.comp.Component.cache(form);
			}
		}
	}));
});
define('vcl/ui/FormContainer',['require','js/defineClass','js/Type','./Panel','./Form','../Control','../Factory'],function (require) {

    var FormContainer = require("js/defineClass");
    var Type = require("js/Type");
    var Panel = require("./Panel");
    var Form = require("./Form");
    var Control = require("../Control");
    var Factory = require("../Factory");

    return (FormContainer = FormContainer(require, {

        inherits: Panel,

        prototype: {

            "@css": {
                ">.loading": {
                    background: "url(/shared/vcl/images/loading.gif) no-repeat center",
                    position: "absolute",
                    width: "100%",
                    top: "25%",
                    height: "20px"
                }
            },

            _align: "client",

            _form: null,
            _formUri: "",
            _formListeners: null,
            _loading_form: false,

            _formParams: null,
            _onGetFormParams: null,

            _onFormOpen: null,
            _onFormLoad: null,
            _onFormLoadError: null,
            _onFormClose: null,
            _onFormCloseQuery: null,
            _onFormActivate: null,
            _onFormDeactivate: null,

            destroy: function () {
            /**
             * @overrides ../Component.prototype.destroy
             */
                // TODO check ../Component.prototype.destroy
                if (this._form !== null) {
                    this._form.destroy();
                }
                this.inherited(arguments);
            },
            removeComponent: function (component) {
            /**
             * @overrides ../Component.prototype.removeComponent
             */
                this.inherited(arguments);
                if (component === this._form) {
                    this._form = null;
                }
            },
            dispatchChildEvent: function (component, name, evt, f) {
            /**
             * @overrides ../Component.prototype.dispatchChildEvent
             */
                if (component === this._form) {
                    this.dispatch("form" + name, evt);
                }
                return this.inherited(arguments);
            },
            initializeNodes: function () {
            /**
             * @overrides ../Control.prototype.initializeNodes
             */
                this.inherited(arguments);

                this._nodes.loading = document.createElement("div");
                this._nodes.loading.className = "loading";
                this._nodes.loading.innerHTML = "&nbsp;";
            },
            showNode: function () {
            /**
             * @overrides ../Control.prototype.showNode
             */
                var r = this.inherited(arguments);

                if (this._formUri !== "" && this._form === null && this._loading_form !== true) {
                    this.loadForm();
                }

                return r;
            },
            visibleChanged: function (value) {
            /**
             * @overrides ../Control.prototype.visibleChanged
             */
                if (this._form === null) {
                    if (this.isVisible() && this._formUri !== "" && this._loading_form !== true) {
                        this.loadForm();
                    }
                }
                return this.inherited(arguments);
            },
            setFocus: function () {
            /**
             * @overrides ../Control.prototype.setFocus
             */
                if(this._form) {
                    this._form.setFocus.apply(this._form, arguments);
                }
            },
            
            forceLoad: function () {
                if (this._formUri !== "" && this._form === null && this._loading_form !== true) {
                    this.loadForm();
                }
            },
            reloadForm: function () {
                if (this._form) {
                    this._form.destroy();
                    delete this._form;
                }
                Factory.unreq(this.getSpecializedFormUri());
                this.loadForm();
            },
            loadForm: function () {
                if (this.isDesigning()) { return; }

                var thisObj = this;
                var uri = this.getSpecializedFormUri();
                var uri_classes = uri.split(" ");
                this.dispatch("formloadstart");

                if (uri_classes.length > 1) {
                    uri = uri_classes.shift();
                }
                
                var base = this.getBaseUri();
                Factory.require(js.normalize(base, uri), function (factory) {
                    try {
                        var component = factory.newInstance(thisObj, uri, {

                            loaded: function(component) {
                                /*- do nothing, blocking */
                            }

                        });

                        if (uri_classes.length > 0 && component instanceof Control) {
                        	//console.debug("adding", uri_classes.join(" && "));
                            component.addClasses(uri_classes);
                        }

                        if(component !== null) {
                        	if(!(component instanceof Form)) {
	                            console.error(String.format("%s is not a %n (but a %n)", uri, Form,
	                                typeof component.getClass === "function" ?
	                                    component.getClass() : component));
	                                    
                        		var form = new Form();
                        		form._uri = uri;
	                        	if(component instanceof Control) {
	                        		component.setParent(form);
	                        	}
	                        	component = form;
                        	}
                        }

                        if (component instanceof Form) {
                            thisObj.setForm(component);

	                        /*- loaded() was blocked, call it now */
	                        component.loaded();

                            thisObj.dispatch("formload");
                            component.setParams(thisObj.getFormParamsValue());
                            component.setParent(thisObj);
                            thisObj.dispatch("formopen");
                        } else if (component !== null) {
                            throw new Error(String.format("%s is not a %n (but a %n)", uri, Form,
                                typeof component.getClass === "function" ?
                                    component.getClass() : component));
                        }


                    } finally {
                        thisObj.dispatch("formloadend");
                    }
                },
                function (e) {
                    alert(e);
                    thisObj.dispatch("formloadend");
                    if (thisObj.dispatch("formloaderror", uri, e) === true) {
                    	console.error(e);
                        throw new Error(String.format("Could not instantiate form %s", uri), e);
                    }
                });
            },
            reload: function (evt) {
                if (this._form !== null) {
                    this._form.setParent(null);
                    //this._form.setOwner(null);
                    this._form.destroy(false); // false === do not cache the instance (@overrides ../Component._cache)
                    this._useCache = evt.useCache;
                    this._useScaffolding = evt.useScaffolding;
                    this.loadForm();
                }
            },
            
            releaseForm: function() {
            	var form = this._form;
            	if(form !== null) {
            		form.setParent(null);
            		form.setOwner(null);
            		this._form = null;
            	}	
            	return form;
            },

            onformloadstart: function () {
                this.setLoading(true);
                //return this.fire("onFormLoad", arguments);
            },
            onformloadend: function () {
                this.setLoading(false);
                //return this.fire("onFormLoad", arguments);
            },
            onformload: function () {
                this.emit("formloaded", arguments);
                return this.fire("onFormLoad", arguments);
            },
            onformloaderror: function (uri, e) {
                var r = this.fire("onFormLoadError", arguments);
                if (r === undefined) {
                    r = true;
                }
                return r;
            },
            onformactivate: function () {
                return this.fire("onFormActivate", arguments);
            },
            onformclose: function () {
                return this.fire("onFormClose", arguments);
            },
            onformopen: function () {
                return this.fire("onFormOpen", arguments);
            },
            onformdeactivate: function () {
                return this.fire("onFormDeactivate", arguments);
            },
            
            setLoading: function (value) {
                if (this._loading_form !== value) {
                    this._loading_form = value;

                    if (!this.isLoading()) {
                        this.getNode();
                    }
                    if (this._nodes !== null) {
                        if (this._loading_form === true && this._nodes.loading.parentNode !== this._node) {
                            this._node.appendChild(this._nodes.loading);
                            this.addClass("loading");
                        } else if (this._loading_form === !true && this._nodes.loading.parentNode === this._node) {
                            this._node.removeChild(this._nodes.loading);
                            this.removeClass("loading");
                        } else {
                            console.log("?");
                        }
                    }
                }
            },            
            getFormParamsValue: function () {
                if (this._formParams !== null || this._onGetFormParams !== null) {
                    var params = js.mixIn({},
                    this._formParams || {});
                    if (this._onGetFormParams !== null) {
                        params = this._onGetFormParams.apply(this, [params]);
                    }
                    return params;
                }
                return null;
            },
            refreshParams: function () {
            /**
             * Use this function to refresh the forms parameters.  If the form is not loaded, nothing happens.
             * The event onGetFormParams will be triggered if applicable.
             */
                if (this._form !== null) {
                    // TODO Might wanna refresh only when visible?
                    this._form.setParams(this.getFormParamsValue());
                }
            },
            
            getBaseUri: function() { return this.getUri(); },
            getForm: function () {
                return this._form;
            },
            setForm: function(value) {
            	this._form = value;
            },
            swapForm: function (value, takeOwnership) {
				/* value can be of type string or Form */
            	var form; // returns undefined when no swap was made !!
                if (this._form !== value) {
                	form = this.releaseForm();
                	if(value instanceof Form) {
                    	this._form = value;
                    	if(takeOwnership !== false) value.setOwner(this);
                    	value.setParent(this);
                	} else if(typeof value === "string") {
						this.setFormUri(value);
					}
                }
                return form;
            },
            getSpecializedFormUri: function () {
                var uri = this._formUri;
                if (this._owner !== null && uri.indexOf("<>") !== -1) {
                    var specializer = this._owner.getSpecializer(false);
                    if(specializer !== ""){
                    	uri = String.format("%s<%s>%s", uri.split("<")[0], specializer, uri.split(">")[1]);//.split(".")[0]);
                    } else {
                    	uri = String.format("%s%s", uri.split("<")[0], uri.split(">")[1]);//.split(".")[0]);
                    }
                }
                return uri;
            },
            getFormUri: function () {
                return this._formUri;
            },
            setFormUri: function (value) {
                if (this._formUri !== value) {
                    this._formUri = value;
                    if (this._form !== null) {
                        this._form.destroy();
                    }
                    if (!this.isLoading() && this.isVisible()) {
                        this.loadForm();
                    }
                }
            },
            getFormParams: function () {
                return this._formParams;
            },
            setFormParams: function (value) {
                if (this._formParams !== value) {
                    this._formParams = value;
                }
            },
            getUseCache: function () {
                return this._useCache;
            },
            setUseCache: function (value) {
                if (this._useCache !== value) {
                    this._useCache = value;
                }
            },
            getReflectHash: function () {
                return this._reflectHash;
            },
            setReflectHash: function (value) {
                if (this._reflectHash !== value) {
                    this._reflectHash = value;
                }
            },
            
            getOnFormActivate: function () {
                return this._onFormActivate;
            },
            setOnFormActivate: function (value) {
                if (this._onFormActivate !== value) {
                    this._onFormActivate = value;
                }
            },
            getOnFormClose: function () {
                return this._onFormClose;
            },
            setOnFormClose: function (value) {
                if (this._onFormClose !== value) {
                    this._onFormClose = value;
                }
            },
            getOnFormDeactivate: function () {
                return this._onFormDeactivate;
            },
            setOnFormDeactivate: function (value) {
                if (this._onFormDeactivate !== value) {
                    this._onFormDeactivate = value;
                }
            },
            getOnFormLoad: function () {
                return this._onFormLoad;
            },
            setOnFormLoad: function (value) {
                if (this._onFormLoad !== value) {
                    this._onFormLoad = value;
                }
            },
            getOnFormLoadError: function () {
                return this._onFormLoadError;
            },
            setOnFormLoadError: function (value) {
                if (this._onFormLoadError !== value) {
                    this._onFormLoadError = value;
                }
            },
            getOnFormOpen: function () {
                return this._onFormOpen;
            },
            setOnFormOpen: function (value) {
                if (this._onFormOpen !== value) {
                    this._onFormOpen = value;
                }
            },
            getOnGetFormParams: function () {
                return this._onGetFormParams;
            },
            setOnGetFormParams: function (value) {
                if (this._onGetFormParams !== value) {
                    this._onGetFormParams = value;
                }
            }
        },

        properties: {

            "align": {
                set: Function,
                type: Panel.ALIGN
            },

            "formUri": {
                type: Type.STRING,
                editor: "./propertyeditor/FormContainerFormUri"
            },

            "formsParams": {
                type: Type.OBJECT
            },

            "onFormActivate": {
                type: Type.EVENT
            },

            "onFormClose": {
                type: Type.EVENT
            },

            "onFormDeactivate": {
                type: Type.EVENT
            },

            "onFormLoad": {
                type: Type.EVENT
            },

            "onFormLoadError": {
                type: Type.EVENT
            },

            "onFormOpen": {
                type: Type.EVENT
            },

            "onGetFormParams": {
                type: Type.EVENT
            }
        }
    }));
});

define('vcl/ui/Input',['require','js/defineClass','js/Type','js/Method','cavalion.org/data/SourceEvent','./Element','../EventDispatcher','../Component'],function(require) {

	var Input = require("js/defineClass");
	var Type = require("js/Type");
	var Method = require("js/Method");

	var SourceEvent = require("cavalion.org/data/SourceEvent");

	var Element = require("./Element");
	var EventDispatcher = require("../EventDispatcher");
	var Component = require("../Component");

	var InputTypes = ["text", "password", "tel", "search", "url", "email", "datetime", "date",
	                 "month", "year", "week", "time", "datetime-local", "number",
	                 "range", "color"];

	return (Input = Input(require, {
		inherits: Element,
		prototype: {

			'@css': {},

			_element: "input",
			_type: "",
			_placeholder: "",
			_value: "",

			_detectChangeTimeout: 50,
			_onChange: null,

			_source: null,
			_sourceAttribute: "",

			initializeNodes: function() {
				/**
				 * @overrides ../Control.prototype.initializeNodes
				 */
				this.inherited(arguments);

				var input = this._nodes.input;
				if(input === undefined) {
					input = (this._nodes.input = this._node);
				}

				if(this.hasOwnProperty("_placeholder")) {
					input.placeholder = this._placeholder;
				}

				if(this.hasOwnProperty("_type")) {
					input.type = this._type;
				}

				if(this._name !== "") {
					input.name = this._name;
				}

				["cut", "paste", "change"].forEach(function(e) {
					var k = "on" + e;
					if(input[k] === null) {
						input[k] = EventDispatcher.handleEvent;
					}
				}, this);
			},
			onnodecreated: function() {
				/**
				 * @overrides ../Control.prototype.onnodecreated
				 */
				this.inherited(arguments);
			},
			setFocus: function(select) {
				/**
				 * @overrides ../Control.prototype.setFocus
				 */
				this.nodeNeeded();
				if(this.isShowing()) {
					this._node.select(select);
				} else {
					var me = this;
					this.update(function() {
						me._node && me._node.select(select);
					});
				}
			},
			oncut: function() {
				this.checkChange();
			},
			oncopy: function() {
				this.checkChange();
			},
			onchange: function() {
				this.checkChange();
			},
			onrealchange: function() {
				return this.fire("onChange", arguments);
			},
			onkeydown: function(evt) {
				/**
				 * @overrides ../Control.prototype.onkeydown
				 */
				if([9, 13, 27].indexOf(evt.keyCode) === -1) {
					this.checkChange();
				}
				return this.inherited(arguments);
			},
			onkeyup: function(evt) {
				/**
				 * @overrides ../Control.prototype.onkeyup
				 */
				if([9, 13, 27].indexOf(evt.keyCode) === -1) {
					this.checkChange();
				}
				return this.inherited(arguments);
			},
			onkeypress: function(evt) {
				/**
				 * @overrides ../Control.prototype.onkeypress
				 */
				this.checkChange();

				if(evt.keyCode === 13 && this._executesAction === "onEnterPressed") {
					this._action.execute.apply(this._action,
							[this].concat(js.copy_args(arguments)));
				}
				return this.inherited(arguments);
			},
			checkChange: function() {
				if(this._nodes.input.readOnly === true) {
					return;
				}
				var me = this, source = this._source, 
					attribute = this._sourceAttribute;
					
				this.setTimeout("checkChange", function() {
					var currentValue = me.toInputValue(me._value);
					var value = me.getInputValue();
					
					if(source !== null && attribute !== "") {
						source.setAttributeValue(attribute, me.fromInputValue(value));
					} else if(currentValue !== value) { /* comparing strings */
						me.dispatch("realchange", {oldValue: me._value, newValue: value});
						me._value = me.fromInputValue(value);
					}
				}, this._detectChangeTimeout);
			},
			// equalsValue: function(value) {
			// 	if(this._value === null && value !== null) {
			// 		return false;
			// 	}
			// 	if(value === null && this._value !== null) {
			// 		return false;
			// 	}
			// 	if(this._type === "date") {
			// 		return this._value.getTime() === value.getTime();
			// 	}
				
			// 	return this._value === value;
			// },
			render: function() {
				var value;
				if(this._source === null || this._sourceAttribute === "") {
					value = this._value;
				} else {
					value = this._source.getAttributeValue(this._sourceAttribute);
				}
				this.setInputValue(this.toInputValue(value));
			},
			sourceNotifyEvent: function(event, data) {
				switch(event) {

					case SourceEvent.activeChanged:
						this.setState("invalidated", true);
						//this.setReadonly(this._source.getSize() === 0);
						break;

					case SourceEvent.changed:
						this.setState("invalidated", true);
						break;

					case SourceEvent.busyChanged:
						break;

					case SourceEvent.updated:
						this.setState("invalidated", true);
						break;

					case SourceEvent.layoutChanged:
						break;

					case SourceEvent.attributesChanged:
						if(data.hasOwnProperty(this._sourceAttribute)) {
							this.setState("invalidated", true);
						}
						break;
				}
			},
			sourceDestroyed: function() {
				this.setSource(null);
			},
			getSource: function() {
				return this._source;
			},
			setSource: function(value) {
				if(this._source !== value) {
					if(this._source !== null) {
						Method.disconnect(this._source, "notifyEvent", this, "sourceNotifyEvent");
						Method.disconnect(this._source, "destroy", this, "sourceDestroyed");
					}
					this._source = value;
					if(this._source !== null) {
						Method.connect(this._source, "notifyEvent", this, "sourceNotifyEvent");
						Method.connect(this._source, "destroy", this, "sourceDestroyed", "before");
					}
					this.setState("invalidated", true);
				}
			},
			getSourceAttribute: function() {
				return this._sourceAttribute;
			},
			setSourceAttribute: function(value) {
				if(this._sourceAttribute !== value) {
					this._sourceAttribute = value;
					this.setState("invalidated", true);
				}
			},
			getType: function() {
				/**
				 *
				 * @returns {String}
				 */
				return this._type;
			},
			setType: function(value) {
				/**
				 *
				 * @param value {String} InputType
				 */
				if(this._type !== value) {
					this._type = value;
					this._value = this.fromInputValue(this.toInputValue(this._value));
					this.recreateNode();
				}
			},
			toInputValue: function(value) {
				if(value === null || value === undefined) {
					return "";
				} else if(this._type === "date" && value instanceof Date) {
					return String.format("%4d-%02d-%02d", 
						value.getFullYear(), value.getMonth() + 1, 
						value.getDate());
				}
				return value.toString();
			},
			fromInputValue: function(value) {
				if(this._type === "date" && typeof value === "string") {
					if((value = value.split("-")).length === 3) {
						return new Date(parseInt(value[0], 10), 
							parseInt(value[1], 10) - 1, 
							parseInt(value[2], 10));
					}
					return null;
				}
				return value;
			},
			getInputValue: function() {
				// console.debug("is this method really needed?");
				this.nodeNeeded();
				return this._nodes.input.value;
			},
			setInputValue: function(value) {
				// console.debug("is this method really needed?");
				this.nodeNeeded();
				this._nodes.input.value = value;
				this.checkChange();
			},
			hasValue: function() {
				return !!this._value;	
			},
			getValue: function() {
				return this._value;
			},
			setValue: function(value, oldValue) {
				value = this.toInputValue(value);
				if((oldValue = this.toInputValue(this._value)) !== value) {
					this._value = this.fromInputValue(value);
					this.setState("invalidated", true);
					this.dispatch("realchange", {oldValue: oldValue, newValue: value});
				}
			},
			getPlaceholder: function() {
				return this._placeholder;
			},
			setPlaceholder: function(value) {
				if(this._placeholder !== value) {
					this._placeholder = value;
					if(this._node) {
						this._node.placeholder = value;
					}
				}
			}

		},
		properties: {
			"executesAction": {
				/** @overrides ../Element.properties.executesAction */
				type: ["No", "onClick", "onEnterPressed"]
			},
			"detectChangeTimeout": {
				type: Type.INTEGER
			},
			"type": {
				type: InputTypes,
				set: Function
			},
			"placeholder": {
				type: Type.STRING,
				set: Function
			},
			"onChange": {
				type: Type.EVENT
			},
			"value": {
				type: Type.STRING,
				set: Function
			},
			"source": {
				set: Function,
				type: Component
			},
			"sourceAttribute": {
				type: Type.STRING,
				set: Function
			}
		}
	}));
});

define('vcl/ui/ListColumn',['require','js/Class','cavalion.org/util/DocumentHook','cavalion.org/util/Stylesheet','./Element','js/referenceClass!./List'],function(require) {

	var Class = require("js/Class");
	var DocumentHook = require("cavalion.org/util/DocumentHook");
	var Stylesheet = require("cavalion.org/util/Stylesheet");
	var Element = require("./Element");
	var List = require("js/referenceClass!./List");

	var ListColumn = {
		inherits: Element,
		prototype: {

			"@css": {
				display: "inline-block",
				overflow: "hidden",
				padding: "4px 6px 4px 6px",
				// "border-right": "1px solid silver",
				// "font-weight": "bold",
				"&.size": {
					"background-color": "#f0f0f0",
					cursor: "e-resize",
					"border-right": "5px solid silver",
					"padding-right": "12px"
				},
				"&.designing.invisible": {
					opacity: "0.35"
				},
				"&.sortable": {
					":active": {
						padding: "5px 5px 3px 7px",
						"background-position": "100% 60%"
					},
					"&.asc": {
						background: "url(/shared/vcl/images/sortarrowasc.png) no-repeat right"
					},
					"&.desc": {
						background: "url(/shared/vcl/images/sortarrowdesc.png) no-repeat right"
					}
				},
				".autowidth": {
					visibility: "hidden",
					height: "0px"
				}
			},

			_autoWidth: true,
			_autoWidthValue: "",
			_list: null,
			_attribute: "",
			_rule: null,
			_sizeable: true,
			_custom: false,

			_classNameCells: "",

			_displayFormat: "",

			_onGetValue: null,
			_onRenderCell: null,

			_sizer: null,

			constructor: function(owner) {
				this._rule = Stylesheet.createCssRule("width: 130px;", 5);
				this._rule.style.setProperty("display", "none", "important");
				//this._rule.style.setProperty("transition", "width 50ms");
			},
			destroy: function() {
			/**
			 * @overrides ../Component.prototype.destroy
			 */
				this.setList(null);
				Stylesheet.destroyCssRule(this._rule);
				this.inherited(arguments);
			},
			getParentComponent: function() {
			/**
			 * @overrides ../Component.prototype.getParentComponent
			 */
				return this._list;
			},
			setParentComponent: function(value) {
			/**
			 * @overrides ../Component.prototype.setParentComponent
			 */
				if(value instanceof List) {
					this.setList(value);
				} else {
					throw new Error("A %s-instance should be nested within List", this.getClass().getName());
				}
			},
			getInnerHtml: function() {
			/**
			 * @overrides ../Control.prototype.getInnerHtml
			 */
				if(this._autoWidth === true) {
					return String.format("<div class=\"autowidth%s\">%s</div>%s",
							this._attribute !== "" ? (" " + this.getAttributeClassName()) : "",
							this._autoWidthValue,
							this.getCaption()
					);
				}
				return this.inherited(arguments);
			},
			showNode: function() {
			/**
			 * @overrides ../Control.prototype.showNode
			 */
				var r = this.inherited(arguments);
				this._rule.style.setProperty("display", "", "important");
				this.autoWidth();
				return r;
			},
			hideNode: function() {
			/**
			 * @overrides ../Control.prototype.hideNode
			 */
				var r = this.inherited(arguments);
				this._rule.style.setProperty("display", "none", "important");
				return r;
			},
			setIndex: function() {
			/**
			 * @overrides ../Control.prototype.setIndex
			 */
				var oldValue = this.getIndex();
				var r = this.inherited(arguments);
				var newValue = this.getIndex();
				if(oldValue !== newValue) {
					this.propertyChanged("index", {oldValue: oldValue, newValue: newValue});
				}
				return r;
			},
			isVisible: function() {
			/**
			 * @overrides ../Control.prototype.isVisible
			 */
				return this._visible;
			},
			setVisible: function() {
			/**
			 * @overrides ../Control.prototype.setVisible
			 */
				var visible = this.isVisible();
				try {
					return this.inherited(arguments);
				} finally {
					if(visible !== this.isVisible()) {
						this.propertyChanged("visible", this.isVisible());
					}
				}
			},
			mousemove: function(evt) {
			/**
			 * @overrides ../Control.prototype.mousemove
			 */
				if(this._sizeable === true) {
					var xy = this.documentToClient(evt.clientX, evt.clientY);

					//var first = false; // and prev allowing sizing
					var last = false;

					if(/*(first === false && xy.x < 5) || */(last === false && xy.x > this._width - 8)) {
						this.addClass("size");
					} else {
						this.setTimeout("removeClass-size", this.removeClass.bind(this, "size"), 200);
					}
				}
				this.inherited(arguments);
			},
			mouseleave: function(evt) {
			/**
			 * @overrides ../Control.prototype.mousemove
			 */
				this.removeClass("size");
				this.inherited(arguments);
			},
			dragstart: function(evt) {
			/**
			 * @overrides ../Control.prototype.mousedown
			 */
				if(this.hasClass("size") === true) {
					var thisObj = this;
					var x = evt.clientX;

					if(this._sizer !== null && this._sizer.isActive()) {
						console.log("released sizer", this);
						this._sizer.release();
					} else {
						this._sizer = new DocumentHook(null, false).override({

							/**
							 *
							 */
							handle: function(evt) {
								if(evt.type === "mouseup" || (evt.type === "keyup" && evt.keyCode === 27)) {
	//								for(var i = 0; i < thisObj._parent._controls.length; ++i) {
	//									thisObj._parent._controls[i].layoutChanged();
	//								}
									thisObj._sizer.release();
									thisObj.dispatch("resized", evt);
									evt.preventDefault();
								}
								if(evt.type === "mousemove") {
									var d = (evt.clientX - x);
									var w = thisObj._width + d;

									if(w > 10) { // FIXME minWidth, maxWidth?
										thisObj.setWidth(w);
										x = evt.clientX;
									}

									thisObj.dispatch("sizing", evt);
								}
							}

						});
					}

					this.setAutoWidth(false);
					this.setWidth(parseInt(this._rule.style.width, 10));

					this._sizer.activate();
					evt.bubbleUp = false; // prevent global hook to register dragging info
				}
				this.inherited(arguments);
			},
			dblclick: function(evt) {
			/**
			 * @overrides ../Control.prototype.dblclick
			 */
				var r;
				if((r=this.inherited(arguments)) !== false) {
					if(this._sizer !== null && this._sizer.isActive()) {
						this._sizer.release();
					}
					if(this.hasClass("size") === true) {
						this.setAutoWidth(true);
					}
				}
				return r;
			},

			sizing: function(evt) {
			},
			setList: function(value) {
				if(this._list !== value) {
					if(this._list !== null) {
						this._list.removeColumn(this);
					}
					if(value !== null) {
						value.insertColumn(this);
					}
				}
			},
			propertyChanged: function(which, newValue) {
				if(this._list !== null) {
					this._list.columnPropertyChanged(this, which, newValue);
				}
			},
			autoWidth: function(value, cell) {
				if(arguments.length === 0) {
					value = this._autoWidthValue;
					this._autoWidthValue = "";
				}
				if(this._autoWidthValue.length < value.length) {
					this.setAutoWidthValue(value);
				}
			},
			getAttributeClassName: function() {
				return this._attribute.
					replace(/\#/g, "-").
					replace(/\./g, "-").
					replace(/\(/g, "-").
					replace(/\)/g, "-").
					replace(/ /g, "-").
					replace(/-$/g, "").
					replace(/^$/g, "dot");
			},
			getCellClassName: function() {
				var r = [this._rule.selectorText.substring(1)];
				if(this._classNameCells !== "") {
					r.push(this._classNameCells);
				}
				if(this._attribute !== "") {
					r.push(this.getAttributeClassName());
				}
				return r.join(" ");
			},
			getCaption: function() {
			    if(this._content instanceof Array) {
			        return String.format.apply(String, this._content);
			    }
				return this._content ||
					String.format("%s%s", this._attribute.charAt(0).toUpperCase(),
							this._attribute.substring(1));
			},
			setCaption: function(value) {
				if(this._caption !== value) {
					this._caption = value;
					if(this._node !== null) {
						this._node.innerHTML = this.getInnerHtml();
						this.layoutChanged();
					}
					this.propertyChanged("caption", value);
				}
			},
			getSizeable: function() {
				return this._sizeable;
			},
			setSizeable: function(value) {
				if(this._sizeable !== value) {
					this._sizeable = value;
					this.propertyChanged("sizeable", value);
				}
			},
			getCustom: function() {
				return this._custom;
			},
			setCustom: function(value) {
				if(this._custom !== value) {
					this._custom = value;
				}
			},
			getAutoWidth: function() {
				return this._autoWidth;
			},
			setAutoWidth: function(value) {
				if(this._autoWidth !== value) {
					this._autoWidth = value;
					if(this._node !== null) {
						this._node.innerHTML = this.getInnerHtml();
						this.layoutChanged();
					}
					this.propertyChanged("autoWidth", value);
				}
			},
			getAutoWidthValue: function() {
				return this._autoWidthValue;
			},
			setAutoWidthValue: function(value) {
				value = value.trim();
				if(this._autoWidthValue !== value) {
					this._autoWidthValue = value;
					if(this._node !== null) {
// console.debug(js.nameOf(this) + "->setTimeout", name, [this, arguments]);
						this.setTimeout("setAutoWidthValue", function() {
// var start = Date.now();
							this._node.innerHTML = this.getInnerHtml();
							var cs = this.getComputedStyle();
							var ph = parseInt(cs.paddingLeft, 10) + parseInt(cs.paddingRight, 10);
							var sw = parseInt(this._node.childNodes[0].scrollWidth, 10) + ph;
							var csw = parseInt(cs.width, 10);
							this._width = Math.max(sw, csw);
							this.layoutChanged();
							var w = parseInt(this._rule.style.width, 10);
							if(w !== this._width - ph) {
								this._rule.style.width = String.format("%dpx", this._width);
								this.propertyChanged("width", this._width);
							}
// console.debug(String.format("%n ran %d ms", this, Date.now() - start), name, [this, arguments]);
						}.bind(this), 250);

					}
					this.propertyChanged("autoWidthValue", value);
				}
			},
			getAttribute: function() {
				return this._attribute;
			},
			setAttribute: function(value) {
				if(this._attribute !== value) {
					this._attribute = value;
					this.setAutoWidthValue("");
					if(this._node !== null && this._caption === "") {
						this._node.innerHTML = this.getInnerHtml();
						this.layoutChanged();
					}
					this.propertyChanged("attribute", value);
				}
			},
			getClassNameCells: function() {
				return this._classNameCells;
			},
			setClassNameCells: function(value) {
				if(this._classNameCells !== value) {
					this._classNameCells = value;
					this.propertyChanged("classNameCells", value);
				}
			},
			getDisplayFormat: function() {
				return this._displayFormat;
			},
			setDisplayFormat: function(value) {
				if(this._displayFormat !== value) {
					this._displayFormat = value;
					this.propertyChanged("displayFormat", value);
				}
			},
			getOnGetValue: function() {
				return this._onGetValue;
			},
			setOnGetValue: function(value) {
				if(this._onGetValue !== value) {
					this._onGetValue = value;
					this.propertyChanged("onGetValue", value);
				}
			},
			getOnRenderCell: function() {
				return this._onRenderCell;
			},
			setOnRenderCell: function(value) {
				if(this._onRenderCell !== value) {
					this._onRenderCell = value;
					this.propertyChanged("onRenderCell", value);
				}
			}
		},
		properties: {
			"caption": {
				set: "setContent",
				type: Class.Type.STRING
			},
			"autoWidth": {
				set: Function,
				type: Class.Type.BOOLEAN
			},
			"attribute": {
				set: Function,
				type: Class.Type.STRING
			},
			"classNameCells": {
				set: Function,
				type: Class.Type.STRING
			},
			"displayFormat": {
				set: Function,
				type: Class.Type.STRING
			},
			"sizeable": {
				set: Function,
				type: Class.Type.BOOLEAN
			},
			"custom": {
				set: Function,
				type: Class.Type.BOOLEAN
			},
			"width": {
				get: Function,
				set: Function,
				type: Class.Type.INTEGER,
				def: 130,
				stored: function(component) {
					return !component._autoWidth;
				}
			},
			"onGetValue": {
				set: Function,
				type: Class.Type.EVENT,
				editorInfo: {
					defaultValue: "(function(value, row, source) {})"
				}
			},
			"onRenderCell": {
				set: Function,
				type: Class.Type.EVENT,
				editorInfo: {
					defaultValue: "(function(cell, value, column, row, source, orgValue) {})"
				}
			}
		}
	};

	return (ListColumn = Class.define(require, ListColumn));
});
define('vcl/ui/ListHeader',['require','js/Class','js/Method','../Dragger','./Panel','js/referenceClass!./List','js/referenceClass!./List'],function(require) {

	var Class = require("js/Class");
	var Method = require("js/Method");

	var Dragger = require("../Dragger");
//	var Mover = require("cavalion.org/util/ui/Mover");
	var Panel = require("./Panel");
	var List = require("js/referenceClass!./List");
	var ListColumn = require("js/referenceClass!./List");

	var ListHeader = {

		inherits: Panel,

		prototype: {

			"@css": {
			    overflow: "hidden",
			    transition: "width 50ms",
				">div": {
//					background: "-webkit-linear-gradient(top,  rgba(240,240,240,1) 0%,rgba(227,227,227,1) 100%)", // Chrome10+,Safari5.1+
					// "background-image": "-webkit-gradient(linear, 0% 0%, 0% 100%, from(rgb(245, 245, 245)), to(rgb(229, 229, 229)))",
					
					"background-image": "-webkit-gradient(linear, 0% 0%, 0% 100%, from(rgba(245, 245, 245, 0.9)), to(rgba(229, 229, 229, 0.9)))",
					
					// background: "rgba(255, 255, 255, 0.9)",
/**
					background: [
						"rgb(240,240,240)", // Old browsers
						"-moz-linear-gradient(top,  rgba(240,240,240,1) 0%, rgba(227,227,227,1) 100%)", //FF3.6+
						"-webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(240,240,240,1)), color-stop(100%,rgba(227,227,227,1)))", /* Chrome,Safari4+
						"-webkit-linear-gradient(top,  rgba(240,240,240,1) 0%,rgba(227,227,227,1) 100%)", // Chrome10+,Safari5.1+
						"-o-linear-gradient(top,  rgba(240,240,240,1) 0%,rgba(227,227,227,1) 100%)", // Opera 11.10+
						"-ms-linear-gradient(top,  rgba(240,240,240,1) 0%,rgba(227,227,227,1) 100%)", // IE10+
						"linear-gradient(top, rgba(240,240,240,1) 0%,rgba(227,227,227,1) 100%)", // W3C
					],
					filter: "progid:DXImageTransform.Microsoft.gradient( startColorstr='#f0f0f0', endColorstr='#e3e3e3',GradientType=0 )", // IE6-9
*/
					"border-bottom": "1px solid silver",
					"overflow": "hidden",
					"white-space": "nowrap",
					cursor: "default",
					display: "inline-flex"
				}
			},

			/**
			 *
			constructor: function() {
			},
			 */

			/**
			 * @overrides ../Control.prototype
			 */
			_align: "top",
			_autoSize: "height",
			_content: "<div></div>",

			/**
			 * @overrides ../Control.prototype.getClientNode
			 */
			getClientNode: function() {
				return this._node.childNodes[0];
			},

			/**
			 * @overrides ../Control.prototype.setParent
			 */
			setParent: function(value) {
				if(this._parent !== value) {
					if(this._parent !== null) {
						Method.disconnect(this._parent, "notifyEvent", this, "listNotifyEvent");
					}
					if(value !== null && !(value instanceof List)) {
						throw new Error("Need a List as parent");
					}
					this.inherited(arguments);
					if(this._parent !== null) {
						Method.connect(this._parent, "notifyEvent", this, "listNotifyEvent");
					}
				}
			},

			/**
			 * @overrides ../Control.prototype.dispatchChildEvent
			 */
			dispatchChildEvent: function(component, name, evt, f) {
				if(component instanceof ListColumn && component._parent === this) {
					if(name === "dragstart" && component.hasClass("size") === false) {
						var listview = this.getList();
						if(this === listview._header) {
							var r = f.apply(component, [evt]);
							if(r !== false && !(r instanceof Dragger)) {
								//var index = this.getIndex();
								//var parent = this;
								var dragger = new Mover(component).__override({

									/**
									 *
									 */
									start: function() {
										this.inherited(arguments);
									},

									/**
									 *
									 */
									end: function() {
										this.inherited(arguments);
										if(this._target === null && this._cancelled !== true) {
											listview.columnDropped(component, null);
										}
									},

									_updateHandles: function() {
										this.inherited(arguments);
										if(this._target !== null) {
											//component.getDefinition().setIndex(this._target.getIndex());
											//component.getDefinition().setVisible(true);
										} else {
											//component.getDefinition().setVisible(false);
										}
									},

									/**
									 *
									 */
									dropped: function(target) {
										//component.setIndex(target.getIndex());
										listview.columnDropped(component, target);
									}
								});
								dragger.start(evt);
							}
							return false;
						}
					}
				}

				return this.inherited(arguments);
			},

			/**
			 *
			 */
			listNotifyEvent: function(event, data) {
				if(event === "setScrollLeft" && this._node !== null) {
					this._node/*.childNodes[0]*/.scrollLeft = data;
				}
			},

			/**
			 *
			 */
			getList: function() {
				return this._parent !== null ? this._parent : null;
			}
		},

		properties: {

			"align": {
				set: Method,
				type: Panel.ALIGN
			},
			"autoSize": {
				set: Method,
				type: Panel.AUTOSIZE
			}
		}
	};

	return (ListHeader = Class.define(require, ListHeader));
});
define('vcl/ui/ListFooter',['require','js/Class','./Panel'],function(require) {

	var Class = require("js/Class");
	var Panel = require("./Panel");

	var ListFooter = {

		inherits: Panel,

		prototype: {

			"@css": {

			},

			/**
			 *
			constructor: function() {
			},
			 */

			/**
			 * @overrides ../Control.prototype
			 */
			_align: "bottom",
			_autoSize: "height",
			_content: "<div class=\"customize\">...</div><div></div>",

			/**
			 *
			 */
			getList: function() {
				return this._parent !== null ? this._parent : null;
			}
		},

		properties: {

			"align": {
				set: Function,
				type: Panel.ALIGN
			},
			"autoSize": {
				set: Function,
				type: Panel.AUTOSIZE
			}
		}
	};

	return (ListFooter = Class.define(require, ListFooter));
});
define('vcl/ui/ListRow',['require','js/Class','./Panel'],function(require) {

	var Class = require("js/Class");
	var Panel = require("./Panel");

	var ListRow = {
		inherits: Panel,
		prototype: {
			"@css": {
				cursor: "default",
				overflow: "hidden",
				position: "absolute",
				"white-space": "nowrap",
				"&:nth-child(even)": {
					"background-color": "#f0f0f0"	
				},
				"&.selected": {
					color: "white",
					"background-color": "rgb(56, 121, 217)"
				},
				">.ListCell": {
					display: "inline-block",
					overflow: "hidden",
					"padding-left": "6px",
					"padding-top": "7px",
					"text-overflow": "ellipsis"
				}
			},
			_autoSize: "width",
			_rowIndex: -1,
			_list: null,

			getInnerHtml: function() {
			/**
			 * @overrides ../Control.prototype.getInnerHtml
			 */
				var list = this.getList();
				var className = "ListCell";
				var height = list.getRowHeight();
				var columns = list.getColumns();
				var html = [];

				for(var i = 0; i < columns.length; ++i) {
					html.push(String.format(
						"<div style=\"height: %dpx;\" class=\"%s %s\">" +
	//						"<div style='float: left; padding: 5px;'></div>" +
						"</div>",
						height, className, columns[i].getCellClassName(), this._rowIndex, i));
				}
				return html.join("");
			},
			initializeNodes: function(layoutChanged) {
			/**
			 * @overrides ../Control.prototype.initializeNodes
			 */
				this.inherited(arguments);
				if(this._rowIndex !== -1) {
					var list = this.getList();
					var columns = list.getColumnCount();

					if(layoutChanged === true || this._node.childNodes.length !== columns) {
						this._node.innerHTML = this.getInnerHtml();
					}

					this.setState("classesChanged", true);

					for(var i = 0; i < columns; ++i) {
						var column = list.getColumn(i);
						var cell = this._node.childNodes[i];
						list.renderCell(cell, this._rowIndex, column);
					}
				} else if(layoutChanged === true) {
					this._node.innerHTML = this.getInnerHtml();
				}
			},
			determineClasses: function() {
			/**
			 * @overrides ../Control.prototype.determineClasses
			 */
				var classes = this.inherited(arguments);
				if(this._rowIndex % 2 === 1) {
					classes.push("odd");
				}
				return classes.concat(this.getList().getRowClasses(this));
			},
			// applyBounds: function() {
			// /**
			//  * @overrides ./Panel.prototype.applyBounds
			//  */
			// 	var bu = "px";
			// 	this.setStyleProp("top", this._top, bu);
			// 	this.setStyleProp("left", this._left, bu);
			// 	this.setStyleProp("bottom", bounds.bottom, bu);
			// 	this.setStyleProp("right", bounds.right, bu);
			// 	this.setStyleProp("width", bounds.width, bu);
			// 	this.setStyleProp("height", this._height, bu);
			// },
			layoutChanged: function() {
			/**
			 * @overrides ../Control.prototype.layoutChanged
			 */
				delete this._computedStyle;
				// blocked, no need to notify parent, the dimensions of a Row are fixed slash already known
			},
			isSelected: function() {
			/**
			 * @overrides ../Control.prototype.isSelected
			 */
				var list = this.getList();
				if(list !== null) {
					return list.isRowSelected(this._rowIndex);
				}
				return false;
			},
			ondblclick: function(evt) {
			/**
			 * @overrides ../Control.prototype.ondblclick
			 */
				var r = this.inherited(arguments);
				if(r !== false) {
					var list = this.getList();
					if(list._executesAction === "onRowDblClick" && list._action !== null && list._action.isEnabled()) {
						r = list._action.execute(evt, list);
					}
				}
				return r;
			},

			getList: function() {
				if(this._list === null) {
					// FIXME Should be reset when parent (or parents parent) changes
					this._list = (this._parent !== null ? this._parent.getList() : null);
				}
				return this._list;
			},
			getRowIndex: function() {
				return this._rowIndex;
			},
			setRowIndex: function(value) {
				if(this._rowIndex !== value) {
					this._rowIndex = value;
					if(this._rowIndex >= this.getList().getCount()) {
						console.error("Out of bounds", this._rowIndex, this);
						this._rowIndex = -1;
					}
					if(this._node === null) {
						this.setTop(this._rowIndex * this.getList().getRowHeight());
					} else {
						this._top = this._rowIndex * this.getList().getRowHeight();
						this._node.style.top = String.format("%dpx", this._top);
						//this._node.style.top = "";
						//this._node.style.webkitTransform = String.format("translate3d(0, %dpx, 0)", this._top);
					}

					this.setState("classesInvalidated");

					if(this._node !== null) {
						this.initializeNodes();
						this.update();
					}
				}
			}
		}
	};

	return (ListRow = Class.define(require, ListRow));
});
define('vcl/ui/ListBody',['require','js/Class','js/Method','./Panel','./ListRow','js/referenceClass!./List'],function(require) {

	var Class = require("js/Class");
	var Method = require("js/Method");
//	var Component = require("../Component");
	var Panel = require("./Panel");
	var ListRow = require("./ListRow");
	var List = require("js/referenceClass!./List");

	var ListBody = {
		inherits: Panel,
		prototype: {

			constructor: function() {
				this._rowCache = [];
			},

			"@css": {
				overflow: "hidden"
			},

			_count: 0,
			_rowCache: null,
			_firstRow: -1,

			alignControls: function() {
			/**
			 * @overrides ./Panel.prototype.alignControls
			 */
			},
			setParent: function(value) {
			/**
			 * @overrides ../Control.prototype.setParent
			 */
				if(this._parent !== value) {
					if(this._parent !== null) {
						Method.disconnect(this._parent, "notifyEvent", this, "listNotifyEvent");
					}
					if(value !== null && !(value instanceof List)) {
						throw new Error("Need a List as parent");
					}
					this.inherited(arguments);
					if(this._parent !== null) {
						Method.connect(this._parent, "notifyEvent", this, "listNotifyEvent");
						this.columnsChanged();
					}
				}
			},

			listNotifyEvent: function(event, data) {
				if(event === "columnsChanged") {
					this.columnsChanged(data);
				} else if(event === "updateRows") {
					this.updateRows(data);
				}
			},
			getList: function() {
				return this._parent !== null ? this._parent : null;
			},
			render: function() {
				var list = this.getList();
				if(list.getCount() === 0) {
					this._firstRow = 0;
					this.setCount(0);
				} else {
					// visual effect, a form will seem to render more quickly
					this.setTimeout("renderRows", 0);
					//this.renderRows();
				}
			},
			renderRows: function() {
				var list = this.getList();
				var firstRow = list.getTopRow();
				var visibleRows = list.getVisibleRowCount(true);
				var max = list.getCount();
				var rowBuffer = list._rowBuffer; //getRowBuffer() ?
				var row;

				var count = visibleRows + rowBuffer * 2;

				if(count > max) {
					count = max;
				}

				firstRow -= rowBuffer;
				if(firstRow < 0) {
					firstRow = 0;
				}

				if(firstRow + count > max) {
					firstRow = max - count;
				}

				var delta = Math.abs(this._firstRow - firstRow);
//console.log("delta", delta, "count", count, "firstRow", firstRow);
				this.setCount(count);

				if(this._firstRow === -1 || delta > rowBuffer) {
					for(var i = 0; i < count; ++i) {
						row = this._controls[i];
						row.setRowIndex(i + firstRow);
					}
					this._firstRow = firstRow;
				} else {

					if(delta > rowBuffer * 0.75 || firstRow === 0 || firstRow === max - count) {

						while(this._firstRow < firstRow) {
							row = this._controls.splice(0, 1)[0];
							this._controls.push(row);
							row.setRowIndex(this._firstRow + count);
							this._firstRow++;
						}

						while(this._firstRow > firstRow) {
							row = this._controls.pop();
							this._controls = [row].concat(this._controls);
							row.setRowIndex(--this._firstRow);
						}

					}
				}
			},
			updateRows: function(range) {
				if(this.hasOwnProperty("_controls")) {
					for(var i = 0; i < this._controls.length; ++i) {
						var c = this._controls[i];
						if(c._node !== null) {
							// Update row when the range is unknown or it's rowIndex is within the range
							if(range === undefined || (c._rowIndex >= range.start && c._rowIndex <= range.end)) {
								c.initializeNodes();
							}
						}
					}
				}
			},
			rowHeightChanged: function() {
				var rowHeight = this.getList().getRowHeight();
				if(this.hasOwnProperty("_controls")) {
					for(var i = 0; i < this._controls.length; ++i) {
						var row = this._controls[i];
						var index = row._rowIndex;
						if(index !== -1) {
							row._rowIndex = -1;
							row.setRowIndex(index);
							row.setHeight(rowHeight);
						}
					}
				}
			},
			columnsChanged: function() {

				function f() {
					var i;

					if(this.hasOwnProperty("_controls")) {
						for(i = 0; i < this._controls.length; ++i) {
							if(this._controls[i]._node !== null) {
								this._controls[i].initializeNodes(true);
							}
						}
					}
					for(i = 0; i < this._rowCache.length; ++i) {
						// FIXME
						if(this._rowCache[i]._node !== null) {
							this._rowCache[i]._node.innerHTML = "";
						}
					}
				}

				this.setTimeout("columnsChanged", f.bind(this), 50);
			},
			setCount: function(value) {
				if(this._count !== value) {
					this._count = value;

					var list = this.getList();
					var rowHeight = list.getRowHeight();
					var count = list.getCount();
					var index;

					if(!this.hasOwnProperty("_controls")) {
						this._controls = [];
					}

					while(this._controls.length < this._count) {
						var row;
						if(this._rowCache.length) {
							row = this._rowCache.splice(0, 1)[0];
						} else {
							row = new ListRow();
							row.setOwner(this);
						}
						row.setHeight(rowHeight);
						row._parent = this;
						this._controls.push(row);

						index = this._controls.length - 1 + this._firstRow;
						if(index < count) {
							row.setRowIndex(index);
						} else {
							row.setRowIndex(-1);
						}
						row._update();
					}

					if(this._controls.length > this._count) {
						var n = this._controls.length - this._count;
						var rows = this._controls.splice(this._controls.length - n, n);
						for(var i = 0; i < rows.length; ++i) {
							rows[i]._parent = null;
							rows[i]._rowIndex = -1;
							rows[i]._update();
						}
						this._rowCache = this._rowCache.concat(rows);
					}
				}
			}
		}
	};

	return (ListBody = Class.define(require, ListBody));
});
define('vcl/ui/List',['require','js/Class','js/Method','cavalion.org/util/HtmlElement','cavalion.org/data/Source','cavalion.org/data/SourceEvent','../Component','./Panel','./ListColumn','./ListHeader','./ListFooter','./ListBody','./ListRow'],function(require) {

	var Class = require("js/Class");
	var Method = require("js/Method");
	var HtmlElement = require("cavalion.org/util/HtmlElement");
	var Source = require("cavalion.org/data/Source");
	var SourceEvent = require("cavalion.org/data/SourceEvent");
	var Component = require("../Component");
	var Panel = require("./Panel");
	var ListColumn = require("./ListColumn");
	var ListHeader = require("./ListHeader");
	var ListFooter = require("./ListFooter");
	var ListBody = require("./ListBody");
	var ListRow = require("./ListRow");

	var List = {

		inherits: Panel,

		prototype: {

			constructor: function() {
				this._columns = [];

				this._header = new ListHeader();
				this._footer = new ListFooter();
				this._body = new ListBody();

				this._header.setParent(this);
				this._body.setParent(this);
				this._footer.setParent(this);
				this._footer.setVisible(false);

				this._selection = [];
			},

			"@css": {
				overflow: "hidden",
				"overflow-x": "auto",
				"&.busy": {
					"background": "url(/shared/vcl/images/loading.gif) no-repeat 4px 32px",
					".body": {
						visibility: "hidden"
					}
				},
				".body": {
					overflow: "auto",
					position: "absolute",
					left: "0",
					top: "0",
					right: "0",
					bottom: "0",
					"line-height": "13px",
//					"background-color": "white",
					".scroll": {
						position: "absolute",
						width: "1px",
						height: "1px",
						overflow: "hidden"
					}
				}
			},
			
			/** @overrides ../Control.prototype */
			_align: "client",
			_executesAction: "onRowDblClick",
			_content:
				"<div class=\"body\">" +
					"<div class=\"scroll\">.</div>" +
				"</div>",

            /** @overrides ./Panel.prototype._focusable */
            _focusable: true,

			_autoColumns: false,
			_formatDates: true,

			_source: null,
			_sourceMonitor: null,
			_rowHeight: 23,
			_rowBuffer: 50,
			_count: 0,
			_topRow: 0,
			_visibleRowCount: 0,

			_selection: null,

			_header: null,
			_footer: null,
			_body: null,
			_columns: null,

			_onSelectionChange: null,
			_onColumnDropped: null,
			_onGetRowClasses: null,
			_onColumnGetValue: null,
			_onColumnRenderCell: null,

/**--		overrides ../Component.prototype */
			destroy: function() {
				/** @overrides ../Component.prototype.destroy */
				this.setSource(null);

				this._header.destroy();
				this._body.destroy();
				this._footer.destroy();

				// this._columns will change while nilling listview reference
				var columns = [].concat(this._columns);
				for(var i = 0; i < columns.length; ++i) {
					columns[i].setList(null);
				}

				return this.inherited(arguments);
			},
			getChildren: function(func, root) {
				/** @overrides ../Component.prototype.getChildren */
				this.inherited(arguments);
				if(root !== this) {
					this._columns.forEach(function(column) {
						if(column.getOwner() === root) {
							func(column);
						}
					});
				}
			},
			loaded: function() {
				/** @overrides ../Component.prototype.loaded */
				this.inherited(arguments);
				if(this._sourceSetWhileLoading === true) {
					delete this._sourceSetWhileLoading;
					this.setCount(this._source.getSize());
				}
			},
			
/**--		overrides ../Control.prototype */
			initializeNodes: function() {
				/** @overrides ../Control.prototype.initializeNodes */
				this.inherited(arguments);

				this._nodes.body = this.getChildNode(0);
				this._nodes.scroll = this.getChildNode(0, 0);

				var thisObj = this;

				/**
				 *
				 */
				this._nodes.body.onscroll = function(e) {
					//EventDispatcher.handleEvent;
					thisObj.scroll(e);
				};
				this._nodes.body.scrollTop = this._topRow * this._rowHeight;

				this._header.nodeNeeded();
				this._footer.nodeNeeded();
				this._body.nodeNeeded();
				if(this._source === null || this._source.isBusy() === false) {
					this.removeClass("busy");
				}
			},
			alignControls: function(callback) {
				/** @overrides ../Control.prototype.alignControls */
				var thisObj = this;

				var args; args = [function(rect) {
					var h = parseInt(thisObj.getComputedStylePropValue("height"), 10);
					h -= rect.top;
					h -= rect.bottom;
					thisObj.setVisibleRowCount(Math.round(h / thisObj._rowHeight));

					var bw = thisObj.getBodyWidth();
					var bh = thisObj.getBodyHeight();
					var s = thisObj._nodes.scroll.style;
					s.left = String.format("%dpx", bw);
					s.top = String.format("%dpx", bh + rect.top);

					thisObj._body.setBounds(rect.left, rect.top, undefined, undefined, bw, bh);
				}];

				args.callee = arguments.callee;

				return this.inherited(args);
			},
			getClientRect: function() {
				/** @overrides ./Panel.prototype.getClientRect */
				var r = this.inherited(arguments);
				// Adjust for the scrollbars which are rendered in this._nodes.body
				r.right = (this._node.clientWidth - this._nodes.body.clientWidth);
				r.bottom = (this._node.clientHeight - this._nodes.body.clientHeight);
				return r;
			},
			getClientNode: function(control) {
				/** @overrides ../Control.prototype.getClientNode */
				if(control === this._body) {
					return this._nodes.body;
				}
				return this._node;
			},
			scroll: function(evt) {
				/** @overrides ../Control.prototype.scroll */
				if(evt.target === this._nodes.body) {
					this.notifyEvent("setScrollLeft", this._nodes.body.scrollLeft);

					var me = this;
					this.setTimeout("scroll", function() {
						var topRow = parseInt(me._nodes.body.scrollTop / me._rowHeight, 10);
						me._topRow = topRow;
						me.render();
					}, 20);
				}

				return this.inherited(arguments);
			},
			storeScroll: function() {
				/** @overrides ../Control.prototype.storeScroll */
				if(this._nodes !== null) {
					this._scrollLeft = this._nodes.body.scrollLeft;
					this._scrollTop = this._nodes.body.scrollTop;
				}
			},
			restoreScroll: function() {
				/** @overrides ../Control.prototype.restoreScroll */
				if(this._nodes !== null) {
					// leave as is for IE
					var body = this._nodes.body;
					if(body !== null && (this._scrollLeft !== body.scrollLeft || this._scrollTop !== body.scrollTop)) {
						body.scrollLeft = this._scrollLeft;
						body.scrollTop = this._scrollTop;
					}
				}
			},
			dispatchChildEvent: function(component, name, evt, f, args) {
				/** @overrides ../Control.prototype.dispatchChildEvent */
				if(name === "mousedown" && evt.shiftKey === true) {
					// prevent selection with mouse
					evt.preventDefault();
				} else if(component instanceof ListRow) {
					if(["dblclick", "dragenter", "dragover", "dragleave", "drop"].indexOf(name) !== -1) {
						this.dispatch(name, evt);
					} else if(name === "click") {
						var rowIndex = component._rowIndex;
						var selection;
						if(evt.ctrlKey === true || evt.metaKey === true) {
							if(this.isRowSelected(rowIndex)) {
								var index = this._selection.indexOf(rowIndex);
								selection = [].concat(this._selection);
								selection.splice(index, 1);
							} else {
								selection = this._selection.concat([rowIndex]);
							}

						} else if(evt.shiftKey === true) {
							var length = this._selection.length;
							var prev = length > 0 ? this._selection[length - 1] : 0;
							var i;

							HtmlElement.clearSelection();

							if(prev === rowIndex) {
								selection = this._selection;
							} else {
								selection = [];
								if(this.isRowSelected(prev)) {
									selection.push(prev);
								}
								if(prev < rowIndex) {
									for(i = prev + 1; i <= rowIndex; ++i) {
										if(!this.isRowSelected(i)) {
											selection.push(i);
										}
									}
								} else {
									for(i = prev - 1; i >= rowIndex; --i) {
										if(!this.isRowSelected(i)) {
											selection.push(i);
										}
									}
								}
							}
						} else {
							selection = [component._rowIndex];
							evt.preventDefault();
						}
						this.setSelection(selection);
						this.dispatch("click", evt);
					}
				}
				return this.inherited(arguments);
			},
			onresize: function(evt) {
				/** @overrides ../Control.prototype.onresize */
				this.alignControls();
				return this.inherited(arguments);
			},
			onkeydown: function(evt) {
				/** @overrides ../Control.prototype.onkeydown */
				var r = this.inherited(arguments);
				if(r !== false) {
					if(evt.keyCode === 13 && this._selection.length) {
						if(this._action && this._action.isEnabled() && this._executesAction === "onRowDblClick") {
							this._action.execute(evt, this);
						}
					} else if(evt.keyCode === 38 || evt.keyCode === 33) {
						if(this._selection.length) {
							var index = this.getSelection().pop() - 1;
							if(index >= 0) {
								this.setSelection([index]);
								if(index < this._topRow + 1) {
									this.setTopRow(this._topRow - parseInt(this._visibleRowCount / 2));
								}
							}
						} else if(this._count) {
							this.setSelection([0]);
						}
					} else if(evt.keyCode === 40 || evt.keyCode === 34) {
						if(this._selection.length) {
							var index = this.getSelection().pop() + 1;
							if(index < this._count) {
								this.setSelection([index]);
								if(this._topRow + this._visibleRowCount - 2 < index) {
									this.setTopRow(this._topRow + parseInt(this._visibleRowCount / 2));
								}
							}
						} else if(this._count) {
							this.setSelection([0]);
						}
					}
				}
				return r;
			},

			notifyEvent: function(event, data) {},
			render: function() {
				var vrc = this.getVisibleRowCount(true);

				if(this._topRow > this._count - vrc + 1) {
					this._topRow = this._count - vrc + 1;
				}

				var start = this._topRow - this._rowBuffer;

				if(start < 0) {
					start = 0;
				}

				var end = start + vrc + this._rowBuffer * 2;

				if(end > this._count - 1) {
					start = start - (end - (this._count - 1));
					if(start < 0) {
						start = 0;
					}
					end = this._count - 1;
				}

				if(this._count > 0 && this._source !== null && this._source.isActive()) {
					if(this._sourceMonitor === null || this._sourceMonitor.start !== start || this._sourceMonitor.end !== end) {
						var me = this;
						if(this._sourceMonitor !== null) {
							this._source.releaseMonitor(this._sourceMonitor);
						}
						this._sourceMonitor = this._source.getMonitor(start, end);
						this._sourceMonitor.process = function() {
							me.setTimeout("updateBodyRows", function() {
								me._body.updateRows();
							}, 10);
						};
						// if(!this._source.isBusy()) {
							this._source.getObjects(start, end);
						// } else {
						// 	console.log("postponed getObjects...")
						// }
					}
				}

				if(end > start && this._source !== null && this._source.isActive()) {
					// console.log([start, end], "???");
					// if(!this._source.isBusy()) {
						this._source.getObjects(start, end);
					// } else {
					// 	console.log("postponed getObjects...")
					// }
				}
				this._body.render();
			},
			renderCell: function(cell, row, column) {
				var value, orgValue;
				if(column._attribute !== "") {
					orgValue = (value = this._source.getAttributeValue(
					    column._attribute, row));
				}

				if(value !== Source.Pending) {
					if(column._displayFormat !== "") {
						value = String.format(column._displayFormat, value);
					}
					if(column._onGetValue !== null) {
						value = column.fire("onGetValue", [
						        value, row, this._source]);
					}
					if(this._onColumnGetValue !== null) {
					    value = this.fire("onColumnGetValue", [
					            column, value, row, this._source]);
					}
					if(column._onRenderCell !== null) {
						if(column.fire("onRenderCell", [cell, value, column, 
    						    row, this._source, orgValue]) === false) {
							return;
						}
					}
					if(this._onColumnRenderCell !== null) {
					    if(this.fire("onColumnRenderCell", [cell, value, column, 
    						    row, this._source, orgValue]) === false) {
					        return;
					    }
					}
					if(value === null || value === undefined) {
						value = "";
					} else if(this._formatDates === true && 
					        value instanceof Date) {
						// FIXME
						value = this.formatDate(value);
					}
				} else {
					value = "...";
				}
				if(value === null || value === undefined || value === "") {
					value = "&nbsp;";
				} else if(value instanceof Array) {
					value = value.join("");
				} else {
					value = String.format("%H", value);
				}

				column.autoWidth(value, cell);
				cell.innerHTML = value;
			},
			formatDate: function(value) {
				return String.format("%d/%02d/%d %02d:%02d", value.getDate(), value.getMonth() + 1,
						value.getFullYear(), value.getHours(), value.getMinutes());
			},

			getBodyWidth: function() {
				var r = 0;
				for(var i = 0; i < this._columns.length; ++i) {
					var column = this._columns[i];
					if(column.isVisible() === true) {
						if(i < this._header._controls.length) {
							r += parseInt(this._header._controls[i].getComputedStylePropValue("width"), 10);
						} else {
							r += column.getWidth();
						}
					}
				}
				return r;
			},
			getBodyHeight: function() {
				return this._count * this._rowHeight;
			},
			getCount: function() {
				return this._count;
			},
			setCount: function(value) {
				if(this._count !== value) {
					this._count = value;
					if(value === 0) {
						this.resetColumnAutoWidth();
					}
					this.setSelection([]);
					//this.alignControls();
					this.render();
				}
			},

			getRowClasses: function(row) {
				if(this._onGetRowClasses !== null) {
					return this.fire("onGetRowClasses", [row]) || [];
				}
				return [];
			},
			getRowHeight: function() {
				return this._rowHeight;
			},
			setRowHeight: function(value) {
				if(this._rowHeight !== value) {
					this._rowHeight = value;
					this.alignControls();
					this._body.rowHeightChanged();
				}
			},
			isRowSelected: function(rowIndex) {
				return this._selection.indexOf(rowIndex) !== -1;
			},
			getTopRow: function() {
				return this._topRow;
			},
			setTopRow: function(value) {
				if(value >= 0 && value < this._count) {
					if(this._nodes !== null) {
						this._nodes.body.scrollTop = value * this._rowHeight;
					} else {
						this._topRow = value;
					}
				}
			},
			getVisibleRowCount: function(adjusted) {
				if(adjusted && this._visibleRowCount > this._count) {
					return this._count;
				}
				return this._visibleRowCount;
			},
			setVisibleRowCount: function(value) {
				if(this._visibleRowCount !== value) {
					this._visibleRowCount = value;
					this.render();
				}
			},
			
			columnPropertyChanged: function(column, which, newValue) {
				if(which === "width") {
					if(this._node !== null) {
						this.setTimeout("applyBounds", 100);
					}
				} else if(which === "visible") {
					if(this._node !== null) {
						this.notifyEvent("columnsChanged", {
							type: "visible",
							column: column,
							newValue: newValue
						});
					}
				} else if(which === "index") {
					this._columns = Array.move(this._columns, newValue.oldValue, newValue.newValue);
					if(this._node !== null) {
						this.notifyEvent("columnsChanged", {
							type: "visible",
							column: column,
							newValue: newValue
						});
					}
				} else if(which === "attribute" || which === "onGetValue" || which === "onRenderCell" || which === "displayFormat") {
					if(this._node !== null) {
						this._body.updateRows();
					}
				}
			},
			getColumnCount: function() {
				return this._columns.length;
			},
			getColumn: function(index) {
				return this._columns[index];
			},
			getColumnByAttribute: function(attribute) {
				for(var i = 0, l = this._columns.length; i < l; ++i) {
					var c = this._columns[i];
					if(c._custom === false && c._attribute === attribute) {
						return c;
					}
				}
				return null;
			},
			insertColumn: function(column, index) {
				this._columns.push(column);
				column._list = this;
				if(index !== undefined) {
					var begin = this._columns.splice(0, index);
					var end = this._columns.splice(0, this._columns.length - 1);
					this._columns = begin.concat(this._columns).concat(end);
				}
				column.setParent(this._header);
				column.setIndex(index);
				this.notifyEvent("columnsChanged", {
					type: "add",
					column: column,
					index: index
				});
			},
			removeColumn: function(column) {
				this._columns.splice(this._columns.indexOf(column), 1);
				column._list = null;
				column.setParent(null);
				this.notifyEvent("columnsChanged", {
					type: "remove",
					column: column
				});
			},
			addColumn: function(owner) {
				var column = new ListColumn(owner || this._autoColumns === true ? this : this._owner);
				column.setList(this);
				return column;
			},
			columnDropped: function(column, target) {
				if(this.dispatch("columndrop", {
					column: column,
					target: target
				}) !== false) {
					if(target === null) {
						column.setVisible(false);
					} else {
						column.setIndex(target.getIndex());
					}
				}
			},
			getColumnIndex: function(column) {
				return this._columns.indexOf(column);
			},
			setColumnIndex: function(column, newIndex) {
				var curIndex = this.getColumnIndex(column);
				if(curIndex !== newIndex && newIndex >= 0 && newIndex < this._columns.length) {
					this._columns = Array.move(this._columns, curIndex, newIndex);
					this.notifyEvent("columnsChanged", {
						type: "setColumnIndex",
						oldValue: curIndex,
						newValue: newIndex
					});
				}
			},
			getColumns: function() {
				return this._columns;
			},
			destroyColumns: function() {
				while(this._columns.length) {
					this._columns[0].destroy();
				}
				this.notifyEvent("columnsChanged");
			},
			updateColumns: function() {
				var updateColumns = this.updateColumns;
				this.updateColumns = function() {
					console.log("updateColumns blocked");
				};
				try {
					if(this._source !== null) {
						var columns = [].concat(this._columns);
						var attributes = [];
						var changed = false;
						var attrs = this._source.getAttributeNames();

//						sort(function(i1, i2) {
//						    var s1 = i1.split(".").length;
//						    var s2 = i2.split(".").length;
//						    if(s1 !== s2) {
//						        return s1 < s2 ? -1 : 1;
//						    }
//						    return i1 < i2 ? -1 : 1;
//						});

						for(var i = 0; i < attrs.length; ++i) {
							var column = this.getColumnByAttribute(attrs[i]);
							if(column === null) {
								column = this.addColumn();
								column.setAttribute(attrs[i]);
								var s = attrs[i].split(":").pop().split(".");
								if(s.length === 1) {
									s = String.format("%s%s", s[0].charAt(0).toUpperCase(),
											s[0].substring(1));
								} else {
									s = [s.pop(), s.join(".")];
									s[0] = String.format("%s%s", s[0].charAt(0).toUpperCase(),
									     			s[0].substring(1));
                                    s = s.join(" - ");
								}
								column.setContent(s);
								column.setList(this);
							}
							attributes.push(attrs[i]);
						}

						for(i = 0; i < columns.length; ++i) {
							if(columns[i]._custom === false && (
									columns[i]._attribute === "" ||
									attributes.indexOf(columns[i]._attribute) === -1)) {
								columns[i].destroy();
							}
						}

						if(changed === true) {
							//this.notifyEvent("columnsChanged");
						}
					} else {
						this.destroyColumns();
					}
				} finally {
					this.updateColumns = updateColumns;
				}
			},
			resetColumnAutoWidth: function() {
				for(var i = 0; i < this._columns.length; ++i) {
					this._columns[i].setAutoWidthValue("");
				}
				this.render();
			},
			getOnColumnDropped: function() {
				return this._onColumnDropped;
			},
			setOnColumnDropped: function(value) {
				this._onColumnDropped = value;
			},
			getAutoColumns: function() {
				return this._autoColumns;
			},
			setAutoColumns: function(value) {
				if(this._autoColumns !== value) {
					this._autoColumns = value;
					this.updateColumns();
				}
			},
			
			sourceNotifyEvent: function(event, data) {
				switch(event) {

					case SourceEvent.activeChanged:
						this.setCount(this._source.getSize());
						break;

					case SourceEvent.changed:
						this.setCount(0);
						this.setCount(this._source.getSize());
						this.notifyEvent("updateRows");
/*- FIXME Following line is necessary in order to make sure that the scrollbars are visible */
						this.alignControls();
						break;

					case SourceEvent.busyChanged:
						if(data && this._source.getSize() > 0) {
							return;
						}
						if(data && !this.hasClass("busy")) {
							this.addClass("busy");
						} else if(!data && this.hasClass("busy")) {
							this.removeClass("busy");
						}
						break;

					case SourceEvent.updated:
						this.notifyEvent("updateRows", data);
						break;

					case SourceEvent.layoutChanged:
						if(this._autoColumns === true) {
							this.updateColumns();
						}
						break;
				}
			},
			sourceDestroyed: function() {
				this.setSource(null);
			},
			getSource: function() {
				return this._source;
			},
			setSource: function(value) {
				if(this._source !== value) {
					if(this._source !== null) {
						if(this._sourceMonitor !== null) {
							this._source.releaseMonitor(this._sourceMonitor);
							this._sourceMonitor = null;
						}
						Method.disconnect(this._source, "notifyEvent", this, "sourceNotifyEvent");
						Method.disconnect(this._source, "destroy", this, "sourceDestroyed");
						this.setCount(0);
					}
					this._source = value;
					if(this._source !== null) {
						Method.connect(this._source, "notifyEvent", this, "sourceNotifyEvent");
						Method.connect(this._source, "destroy", this, "sourceDestroyed", "before");
						if(!this.isLoading()) {
							this.setCount(this._source.getSize());
						} else {
							this._sourceSetWhileLoading = true;
						}
					}
					this.sourceNotifyEvent(SourceEvent.layoutChanged);
				}
			},
			
			onselectionchange: function() {
				return this.fire("onSelectionChange", arguments);
			},
			oncolumndrop: function() {
				return this.fire("onColumnDropped", arguments);
			},
			
			hasSelection: function() {
				return this._selection.length > 0;
			},
			getSelection: function(asObjects) {
				var r = [].concat(this._selection);
				if(asObjects === true) {
					for(var i = 0, l = r.length; i < l; ++i) {
						r[i] = this._source.getObject(r[i]);
					}
				}
				return r;
			},
			setSelection: function(value) {
				var oldValue = this._selection;
				var length = oldValue.length;

				if(length === value.length) {
					var equals = true;
					for(var i = 0; i < length && equals === true; ++i) {
						equals = oldValue[i] === value[i];
					}
					if(equals === true) {
						return; // no change
					}
				}

                // FIXME validate selection
				this._selection = value;
				this.dispatch("selectionchange", {
					newValue: value,
					oldValue: oldValue
				});
				this.updateChildren(true, true);
			},
			getOnSelectionChange: function() {
				return this._onSelectionChange;
			},
			setOnSelectionChange: function(value) {
				this._onSelectionChange = value;
			}
		},
		properties: {

			"align": {
				set: Function,
				type: Panel.ALIGN
			},

			"autoColumns": {
				type: Class.Type.BOOLEAN,
				set: Function
			},

			"columns": {
				type: Class.Type.ARRAY,
				stored: false,
				visible: false
			},

			"executesAction": {
				type: ["No", "onClick", "onRowDblClick"]
			},

        	"focusable": {
        		type: Class.Type.BOOLEAN,
        		set: Function
        	},

			"onSelectionChange": {
				type: Class.Type.EVENT,
				editorInfo: {
					defaultValue: "(function(data) {})"
				}
			},

			"onColumnDropped": {
				type: Class.Type.EVENT
			},

			"onGetRowClasses": {
				type: Class.Type.EVENT,
				editorInfo: {
					defaultValue: "(function(row) {})"
				}
			},

			"onColumnGetValue": {
				type: Class.Type.EVENT,
				editorInfo: {
					defaultValue: "(function(column, value, row, source) {})"
				}
			},
			
			"onColumnRenderCell": {
				type: Class.Type.EVENT,
				editorInfo: {
					defaultValue: "(function(cell, value, column, row, source, orgValue) {})"
				}
			},

			"rowHeight": {
				type: Class.Type.INTEGER
			},

			"source": {
				set: Function,
				type: Component
			}
		},
		statics: {

		}
	};

	return (List = Class.define(require, List));
});
define('vcl/ui/Sizer',['require','js/defineClass','js/Type','../Component','../Control','cavalion.org/util/DocumentHook','cavalion.org/util/Event','cavalion.org/util/HtmlElement','js/Method'],function(require) {

	var Sizer = require("js/defineClass");
	var Type = require("js/Type");

	var Component = require("../Component");
	var Control = require("../Control");

	var DocumentHook = require("cavalion.org/util/DocumentHook");
	var Event = require("cavalion.org/util/Event");
	var HtmlElement = require("cavalion.org/util/HtmlElement");

	var Method = require("js/Method");

	var SizerType = ["eight-outside", "four-inside"];

	// TODO Refactor this block
	(function() {
		var css =
			".org-cavalion-comp-util-ui-Sizer-handle.outside {\n" +
			"   background-color: black;\n" +
			"   position: absolute;\n" +
			"   width: 6px;\n" +
			"   height: 6px;\n" +
			"   line-height: 6px;\n" +
			"   z-index: 400;\n" +
			"}";

		var head = document.getElementsByTagName("head")[0];
		var style = document.createElement("style");
		style.type = "text/css";
        if (style.styleSheet) {
            style.styleSheet.cssText = css;
        } else {
            style.appendChild(document.createTextNode(css));
        }

		head.appendChild(style);
	}());

	return (Sizer = Sizer(require, {

		inherits: Component,

		/**
		 * Member definitions
		 */
		prototype: {
			_control: null,
			_host: null,
			_parent: null,
			_nodes: null,
			_visible: true,
			_onChange: null,
			_type: "eight-outside",

			_onSizing: null,
			_onSized: null,

			/**
			 *	@overrides Component.prototype.destroy
			 */
			destroy: function() {
				this.setParent(null);
				this.setControl(null);
				this.destroyNodes();
				this.inherited(arguments);
			},

			/**
			 *
			 */
			nodesNeeded: function() {
				var i;
				if(this._control !== null) {
					if(this._nodes === null) {
						this._nodes = [];
						if(this._type === "eight-outside") {
							for(i = 0; i < 8; ++i) {
								this._nodes.push(this.createNode(document, i));
							}
						} else {
							for(i = 0; i < 4; ++i) {
								this._nodes.push(this.createNode(document, i));
							}
						}
					}
				} else {
					throw new Error("Can not render");
				}
			},

			/**
			 *
			 */
			createNode: function(documentNode, n) {
				var node = documentNode.createElement("div");
				var thisObj = this;
				var parentNode;

				if(this._host === null) {
					parentNode = documentNode.body;
				} else {
					parentNode = this._host.getClientNode();
				}

				node.style.display = "none";
				node.className = "org-cavalion-comp-util-ui-Sizer-handle " + (this._type === "eight-outside" ? "outside" : "inside");
				if(this._type === "eight-outside") {
					node.style.cursor = Sizer.cursors[n] + "-resize";
					node.onmousedown = function() {
						thisObj.mousedown.apply(thisObj, arguments);
					};
				}

				parentNode.appendChild(node);
				return node;
			},

			/**
			 *
			 */
			destroyNodes: function() {
				if(this._nodes !== null) {
					this._nodes.forEach(function(node) {
						// FIXME apparently this can happen when forms.design.Designer is closed
						if(node.parentNode !== null) {
							node.parentNode.removeChild(node);
						}
					});
					this._nodes = null;
				}
			},

			/**
			 *
			 */
			positionNode: function(node, xy, i) {
//				if(this._host !== null) {
//					this._host.getComputedStyle();
//				}
				if(this._type === "eight-outside") {
					if(document.all) { // FIXME Yyyyaaaak!
						node.style.left = String.format("%dpx", xy[0] - 1);
						node.style.top = String.format("%dpx", xy[1] - 1);
					} else {
						node.style.left = String.format("%dpx", xy[0] - 3);
						node.style.top = String.format("%dpx", xy[1] - 3);
					}
				} else {
					var x = (i === 1 || i === 2) ? 4 : 0;
					var y = i > 1 ? 4 : 0;
					node.style.left = String.format("%dpx", xy[0] - x);
					node.style.top = String.format("%dpx", xy[1] - y);
				}
				node.style.display = "";
			},

			/**
			 * 	Receives notifications when the hooked controls visibility changes
			 */
			update: function() {
				if(!this.isLoading() && !this.isDesigning() && this._cancelUpdate !== true) {
					if(this._visible === true && this._control !== null && this._control.isVisible() && this._timeout === undefined) {
						var bounds = this.getControlBounds(this._control);
						this.setParent(this._control.getParent());
						this.nodesNeeded();
						for(var i = 0, l = this._nodes.length; i < l; ++i) {
							var xy;
							switch(i) {
								case 0: xy = [bounds.x, bounds.y];	break;
								case 1: xy = [bounds.x + bounds.width, bounds.y]; break;
								case 2: xy = [bounds.x + bounds.width, bounds.y + bounds.height]; break;
								case 3: xy = [bounds.x, bounds.y + bounds.height]; break;
								case 4: xy = [bounds.x + bounds.width / 2, bounds.y]; break;
								case 5: xy = [bounds.x, bounds.y + bounds.height / 2]; break;
								case 6: xy = [bounds.x + bounds.width, bounds.y + bounds.height / 2]; break;
								case 7: xy = [bounds.x + bounds.width / 2, bounds.y + bounds.height]; break;
							}
							this.positionNode(this._nodes[i], xy, i);
						}
					} else {
						this.destroyNodes();
					}
				}
			},

			/**
			 *
			 */
			mousedown: function(evt) {
				evt = Event.fix(evt);

				var x = evt.clientX;
				var y = evt.clientY;
				var pt = this._control.clientToDocument(0, 0);
				var node = document.createElement("div");
				var type = evt.target.style.cursor.split("-")[0];
				var style = node.style;
				var thisObj = this;
				var control = this._control;

				var bounds = this._control.getAbsoluteRect();
				bounds.left = pt.x;
				bounds.top = pt.y;

				style.position = "absolute";
				style.border = "2px solid black";
				style.left = String.format("%dpx", pt.x);
				style.top = String.format("%dpx", pt.y);
				style.width = String.format("%dpx", bounds.width - 4);
				style.height = String.format("%dpx", bounds.height - 4);

				var hook = new DocumentHook();
				hook.override({

					/**
					 *
					 */
					getBounds: function(evt) {
						var left = bounds.left;
						var top = bounds.top;
						var width = bounds.width;
						var height = bounds.height;

						var dx = evt.clientX - x;
						var dy = evt.clientY - y;

						if(evt.ctrlKey === false) {
							dx = parseInt(dx / 8, 10) * 8;
							dy = parseInt(dy / 8, 10) * 8;
						}

						if(type.indexOf("e") !== -1) {
							width += dx;
						}

						if(type.indexOf("n") !== -1) {
							if(height > dy) {
								top += dy;
								height -= dy;
							} else {
								top = 0;
								height = 0;
							}
						}

						if(type.indexOf("s") !== -1) {
							height += dy;
						}

						if(type.indexOf("w") !== -1) {
							if(width > dx) {
								left += dx;
								width -= dx;
							} else {
								left = 0;
								width = 0;
							}
						}

						if(isNaN(left)) {
							left = 0;
							dx = 0;
						}

						if(isNaN(top)) {
							top = 0;
							dy = 0;
						}

						if(width < 0 || isNaN(width)) {
							width = 0;
							dx = 0;
						}

						if(height < 0 || isNaN(height)) {
							height = 0;
							dy = 0;
						}

						return {left: left, top: top, width: width, height: height};
					},

					handle: function(evt) {
						console.log(evt.type);

						return this.inherited(arguments);
					},

					/**
					 *
					 */
					activate: function() {
						HtmlElement.disableSelection();

						thisObj.destroyNodes();
						document.body.appendChild(node);

						return this.inherited(arguments);
					},

					/**
					 *
					 */
					release: function() {
						HtmlElement.enableSelection();

						document.body.removeChild(node);
						thisObj.update();

						return this.inherited(arguments);
					},

					/**
					 *
					 */
					mouseup: function(evt) {
						try {
							var b = this.getBounds(evt);
							bounds = control.getAbsoluteRect();
							bounds.left += (b.left - pt.x);
							bounds.top += (b.top - pt.y);
							bounds.width = b.width;
							bounds.height = b.height;
							if(thisObj.dispatch("sized", evt, bounds) !== false) {
								control.setBounds && control.setBounds(
								    bounds.left, bounds.top,
								    bounds.right, bounds.bottom);
							}
						} finally {
							this.release();
						}
					},

					/**
					 *
					 */
					mousemove: function(evt) {
						if(thisObj.dispatch("sizing", evt) !== false) {
							var bounds = this.getBounds(evt);
							style.left = bounds.left + "px";
							style.top = bounds.top + "px";
							style.width = (bounds.width - 4) + "px";
							style.height = (bounds.height - 4) + "px";
						}
					},

					/**
					 *
					 */
					keyup: function(evt) {
						if(evt.keyCode === 27) {
							this.release();
							evt.preventDefault();
						}
					}

				}, true);

				hook.activate();
			},

			/**
			 *	Receives notification that hooked control was destroyed
			 */
			controlDestroy: function() {
				this.setControl(null);
			},

			/**
			 *	Receives notification that hooked host was destroyed
			 */
			hostDestroy: function() {
				this.setHost(null);
			},

			/**
			 *
			 */
			controlParentScrolled: function() {
				this.destroyNodes();
				this.setTimeout("update", 250);
			},

			/**
			 *
			 */
			controlVisibleChanged: function() {
				this.update();
			},

			/**
			 *
			 */
			getControlBounds: function(control) {
				var bounds = control.getAbsoluteRect();
				var offset = control.clientToDocument(0, 0);
				bounds.left = offset.x;
				bounds.top = offset.y;

				if(this._host !== null) {
					var pt = this._host.clientToDocument(0, 0, true);

					bounds.left -= pt.x;
					bounds.top -= pt.y;
				}


				if(control._node !== null) {
					control.nodeNeeded();
				}

				bounds.x = bounds.left;
				bounds.y = bounds.top;

				return bounds;
			},

			/**
			 *
			 */
			changed: function() {
				return this.fire("onChange", arguments);
			},

			/**
			 *
			 */
			sized: function() {
				return this.fire("onSized", arguments);
			},

			/**
			 *
			 */
			getControl: function() {
				return this._control;
			},

			/**
			 *
			 */
			setControl: function(value) {
				if(this._control !== value) {
					if(this._control !== null) {
						// FIXME listen
						//Method.disconnect(this._control, "applyBounds", this, "update");
						Method.disconnect(this._control, "applyClasses", this, "update");
						Method.disconnect(this._control, "visibleChanged", this, "update");
						//Method.disconnect(this._control, "parentScrolled", this, "controlParentScrolled");
						Method.disconnect(this._control, "destroy", this, "controlDestroy");
						this.setParent(null);
					}
					this._control = value;
					if(this._control !== null) {
						//Method.connect(this._control, "applyBounds", this, "update");
						Method.connect(this._control, "applyClasses", this, "update");
						Method.connect(this._control, "visibleChanged", this, "update");
						//Method.connect(this._control, "parentScrolled", this, "controlParentScrolled");
						Method.connect(this._control, "destroy", this, "controlDestroy", "before");
					}
					this.update();
				}
			},

			/**
			 *
			 */
			setParent: function(value) {
				if(this._parent !== value) {
					this._parent = value;
				}
			},

			/**
			 *
			 */
			getVisible: function() {
				return this._visible;
			},

			/**
			 *
			 */
			setVisible: function(value) {
				if(this._visible !== value) {
					this._visible = value;
					this.update();
				}
			},

			/**
			 *
			 */
			getHost: function() {
				return this._host;
			},

			/**
			 *
			 */
			setHost: function(value) {
				if(this._host !== value) {
					this._host = value;
					this.destroyNodes();
					this.update();
				}
			},

			/**
			 *
			 */
			getType: function() {
				return this._type;
			},

			/**
			 *
			 */
			setType: function(value) {
				if(this._type !== value) {
					this._type = value;
					this.destroyNodes();
					this.update();
				}
			}
		},

		statics: {

			cursors: [
			  		"nw",
			  		"ne",
			  		"se",
			  		"sw",
			  		"n",
			  		"w",
			  		"e",
			  		"s"
			  	]

		},

		/**
		 * Property definitions
		 */
		properties: {

			"host": {
				type: Control,
				set: Function
			},

			"visible": {
				type: Type.BOOLEAN,
				set: Function
			},

			"type": {
				type: SizerType,
				set: Function
			},

			"onSizing": {
				type: Type.EVENT
			},

			"onSized": {
				type: Type.EVENT
			}

		}

	}));

});
define('vcl/ui/Tab',['require','js/Class','../Control','./Element'],function(require) {

	var Class = require("js/Class");
	var Control = require("../Control");
	var Element = require("./Element");

	var Tab = {

		inherits: Element,

		prototype: {

			"@css": {
				"&:not(.closeable) .close": {
					display: "none"
				},
				"a": {
					"color": "inherit",
					"text-decoration": "none"
				},
				".close": {
					"vertical-align": "top",
					"margin-left": "4px",
					color: "silver",
					cursor: "pointer",
					"&:hover": {
						"font-weight": "bold",
						color: "black"
					}
				}
			},

			//_element: "li",
			_content:
				"<a class='text'></a>" +
				"<a class='close'></a>",
			_groupIndex: 1,

			_text: "",
			_closeable: false,
			_control: null,
			_onCloseClick: null,

			/**
			 * @overrides ../Control.prototype.initializeNodes
			 */
			initializeNodes: function() {
                this.inherited(arguments);
				this._nodes.text = this._node.childNodes[0];
				this._nodes.close = this._node.childNodes[1];
			},

			/**
			 * @overrides ../Control.prototype.render
			 */
			render: function() {
				this._nodes.text.innerHTML = this.getText();
			},

			/**
			 * @overrides ../Control.prototype.select
			 */
			select: function() {
				if(this._control !== null) {
					this._control.setVisible(true);
					this._control.bringToFront();
					this._control.setFocus();
				}
				this.inherited(arguments);
			},

			/**
			 * @overrides ../Control.prototype.unselect
			 */
			unselect: function() {
				if(this._control !== null) {
					this._control.setVisible(false);
				}
				this.inherited(arguments);
			},

			/**
			 * @overrides ../Control.prototype.ontap
			 */
			ontap: function(evt) {
				var r = this.inherited(arguments);

				if(r !== false) {
					if(evt.target === this._nodes.close || evt.target.parentNode === this._nodes.close) {
						this.dispatch("closeclick", evt);
					} else {
						this.setSelected(this._groupIndex < -1 ? !this.getSelected() : true);
						//this._node.childNodes[0].blur();
					}
				}

				return r;
			},

			/**
			 * @overrides ../Control.prototype.determineClasses
			 */
			determineClasses: function() {
				var classes = this.inherited(arguments);

				if(this._closeable === true) {
					classes.push("closeable");
				}

				return classes;
			},

			/**
			 *
			 */
			oncloseclick: function() {
				return this.fire("onCloseClick", arguments);
			},

			/**
			 *
			setSelected: function() {
				try {
					return js.lang.Class.__inherited(this, arguments);
				} finally {
					if(this._control !== null && this.isVisible() === false) {
						this._control.setVisible(this.isSelected());
					}
				}
			},
			 */

			/**
			 *
			 */
			getCloseable: function() {
				return this._closeable;
			},

			/**
			 *
			 */
			setCloseable: function(value) {
				if(this._closeable !== value) {
					this._closeable = value;
					this.setState("classesInvalidated", true);
				}
			},

			/**
			 *
			 */
			getOnCloseClick: function() {
				return this._onCloseClick;
			},

			/**
			 *
			 */
			setOnCloseClick: function(value) {
				if(this._onCloseClick !== value) {
					this._onCloseClick = value;
				}
			},

			/**
			 *
			 */
			getText: function() {
				return this._text;
			},

			/**
			 *
			 */
			setText: function(value) {
				if(this._text !== value) {
					this._text = value;
					this.setState("invalidated", true);
				}
			},

			/**
			 *
			 */
			getControl: function() {
				return this._control;
			},

			/**
			 *
			 */
			setControl: function(value) {
				if(this._control !== value) {
					this._control = value;
				}
			}

		},

		properties: {

			"text": {
				set: Function,
				type: Class.Type.STRING },

			"closeable": {
				set: Function,
				type: Class.Type.BOOLEAN },

			"control": {
				set: Function,
				type: Control },

			"groupIndex": {
				set: Function,
				type: Class.Type.INTEGER },

			"onCloseClick": {
				type: Class.Type.EVENT }

		}

	};

	return (Tab = Class.define(require, Tab));
});
define('vcl/ui/Tabs',['require','js/defineClass','./Bar','js/Type','js'],function(require) {

    var Tabs = require("js/defineClass");
    var Bar = require("./Bar");
    var Type = require("js/Type");
    var js = require("js");

    return (Tabs = js.defineClass(require, {

    	inherits: Bar,
    	

    	prototype: {

    		_history: null,
    		_onChange: null,

	    	/**
	    	 * Constructor
	    	 */
	    	constructor: function() {
	    		this._history = [];
	    		js.mixIn(this._history, {
	    			remove: function(item) {
	    				for(var i = 0; i < this.length;) {
	    					if(this[i] === item) {
	    						this.splice(i, 1);
	    					} else {
	    						++i;
	    					}
	    				}
	    			}
	    		});
	    	},
	    	
	    	onkeyup: function(evt) {
	    		var r = this.inherited(arguments);
    			var selected = this.getSelectedControl(1);
	    		
    			function move(direction) {
    				var l = selected._parent._controls.length;
    				if(evt.ctrlKey === true) {
    					selected.setIndex(direction < 0 ? 0 : l - 1);
    				} else {
    					var index = (selected.getIndex() + direction + l) % l;
    					selected.setIndex(index);
    				}
    			}
    			
	    		if(r !== false && selected !== null) {
	    			switch(evt.keyCode) {
	    				case evt.KEY_LEFT_ARROW:
		    				evt.shiftKey ? move(-1) : this.selectPrevious();
	    					break;
	    					
	    				case evt.KEY_RIGHT_ARROW:
		    				evt.shiftKey ? move(1) : this.selectNext();
	    					break;
	    			}
	    		}
	    		return r;
	    	},
	    	
	    	/**
	    	 * 
	    	 */
	    	selectNext: function() {
	    	    var index = this.getSelectedControl(1).getIndex();
	    	    if(++index === this._controls.length) {
	    	        index = 0;
	    	    }
	    	    this.getControl(index).setSelected(true);
	    	},
	    	
	    	/**
	    	 * 
	    	 */
	    	selectPrevious: function() {
	    	    var index = this.getSelectedControl(1).getIndex();
	    	    if(--index < 0) {
	    	        index = this._controls.length - 1;
	    	    }
	    	    this.getControl(index).setSelected(true);
	    	},
	    	
    		/**
    		 * @overrides ../Control.prototype.initializeNodes
    		 */
    		initializeNodes: function(control) {
    			this._node.tabIndex = 1;
    			return this.inherited(arguments);
    		}, 
    		
    		/**
    		 * @overrides ../Control.prototype.insertControl
    		 */
    		insertControl: function(control) {
    		    this.inherited(arguments);
    		},
    		
    		/**
    		 * @overrides ../Control.prototype.removeControl
    		 */
    		removeControl: function(control) {
    			if(this._history.length > 0) {
    				if(control.isSelected()) {
    					this._history.pop().setSelected(true);
    				}
    				this._history.remove(control);
    			} else if(this._controls.length > 1) {
    				var index = control.getIndex();
    				index += (index > 0 ? - 1 : 1);
					this._controls[index].setSelected(true);
    			}
    			var r = this.inherited(arguments);
    			if(this._controls.length === 0) {
				    this.dispatch("change", null, control);
    			}
    			return r;
    		},

    		/**
    		 * @overrides ../Control.prototype.selectControl
    		 */
    		selectControl: function(control) {
    			var selected = this.getSelectedControl(1);
    			if(this.isDesigning() === true || 
    				this.dispatch("change", control, selected) !== false) {
        			if(selected !== null) {
        				this._history.push(selected);
        			}
    				var r = this.inherited(arguments);
    				if((selected = this.getSelectedControl(1)) !== null) {
    					selected.update(this.checkOverflow.bind(this));	
    				}
    				return r;
    			}
    		},

    		/**
    		 *
    		 */
    		onchange: function() {
				return this.fire("onChange", arguments);
    		}
    	},

    	properties: {

    		"onChange": {
    			type: Type.EVENT
    		}
    	},

    	statics: {

    	}
    }));
});
define('vcl/ui/Tree',['require','js/defineClass','./Node','./Panel','js/Type','cavalion.org/util/Event','cavalion.org/util/HtmlElement','jquery'],function (require) {

    var Tree = require("js/defineClass");
    var Node = require("./Node");
    var Panel = require("./Panel");
    var Type = require("js/Type");
    var Event = require("cavalion.org/util/Event");
    var HtmlElement = require("cavalion.org/util/HtmlElement");
    var jquery = require("jquery");

    var platform = window.navigator.platform;

    return (Tree = Tree(require, {

        inherits: Panel,

        prototype: {

            '@css': {
            	"padding-left": "0",
                "-webkit-user-select": "none",
                "margin": "0",
                "line-height": "15px",
                ".{./Node}": {
    		        display: "block",
                    "list-style-type": "none",
                    "white-space": "nowrap",
                    ">.close": {
                    	position: "absolute",
                    	right: "4px",
                    	"padding-top": "4px",
                    	cursor: "pointer",
                    	display: "none"
                    },
                    ">ol": {
                        "margin": "0",
                        "display": "none",
                        "padding-left": "18px",
                        "-webkit-padding-start": "18px"
                    },
                    "&.closeable>.close": {
                    	display: "block"
                    },
                    "&.expanded>ol": {
                    	"display": "block"
                    },
                    ">.selection": {
                        position: "absolute",
                        left: "0",
                        right: "0",
                        height: "20px",
                        "z-index": "0",
                        "border-radius": "3px",
                        "pointer-events": "none"//,display:"none"
                    },
                    ">.icon": {
                        display: "inline-block",
                        height: "20px",
                        width: "12px",
                        "padding-top": "3px",
                        "vertical-align": "top",
                        "&::before": {
                            content: "' '",
                            display: "inline-block",
                            "font-size": platform === "MacIntel" ? "1.4em" : "1.75em",
                            //"margin-top": platform === "MacIntel" ? "-2px" : "-8px",
                            "padding-left": platform === "MacIntel" ? "2px" : "0"
                        }
                    },
                    ">.text": {
                    	cursor: "pointer",
                        position: "relative",
//        				width: "100%",
                        display: 'inline-block',
                        "margin-left": "2px",
                        padding: "4px 4px 2px 4px"
                    },
                    "&.selected": {
                        ">.selection": {
                            "background-color": "rgb(56, 121, 217)"
                        },
                        ">.text": {
                            "background-color": "rgb(56, 121, 217)",
                        	"padding-bottom": "1px",
                        	"margin-bottom": "1px",
                            // "padding-left": "4px",
                            // "padding-right": "4px",
                            "border-radius": "3px",
                            color: "white"
                        },
                        ">.close": {
                            color: "white",
                            "background-color": "rgb(56, 121, 217)",
                            "font-weight": "bold"
                        },
                        ">.icon": {
                            opacity: "0.9",
                            color: "white"
                        }
                    },
					"&.expanding": {
						background: "url(/shared/vcl/images/loading.gif) no-repeat right",
                        ">.selection": {
							"background-image": "url(/shared/vcl/images/loading.gif)",
							"background-repeat": "no-repeat",
							"background-position": "right"
                        },
						">.text": {
						}
					},
                    "&.expandable:not(.expanding)": {
                        ">.icon::before": {
                            content: "''" // http://www.alanwood.net/unicode/geometric_shapes.html
                        }
                    },
                    "&.expandable.expanded:not(.expanding)": {
                        ">.icon::before": {
                            content: "''" // http://www.alanwood.net/unicode/geometric_shapes.html
                        }
                    },
                    ">.container": {
                        "padding-left": "12px"
                    }
                }
            },

            _align: "client",
            /** @overrides ./Panel.prototype._focusable */
            _focusable: true,
            _onSelectionChange: null,
            _onNodesNeeded: null,
            _selection: [],
            _element: "ol",
            
            constructor: function() {
                var tree = this;
                
                this._history = [];
                this._history.pointer = 0;
                this._history.back = function() {
                    if(this.pointer > 0) {
                        tree.setSelection(this[(--this.pointer) - 1] || [], false);
                    }
                };
                this._history.forward = function() {
                    if(this.pointer < this.length) {
                        tree.setSelection(this[this.pointer++], false);
                    }
                };
                this._history.push = function() {
                    this.splice(this.pointer);
                    this.pointer += arguments.length;
                    return Array.prototype.push.apply(this, arguments);
                };
            },
            insertControl: function (control) {
            /**
             * @overrides ../Control.prototype.insertControl
             */
                if (! (control instanceof Node)) {
                    throw new Error("Only Node instances can be nested in a Tree");
                }
                return this.inherited(arguments);
            },
            removeControl: function(control) {
            /**
             * @overrides ../Control.prototype.removeControl
             */
				var selection = this.getSelection(), index;
				if((index = selection.indexOf(control)) !== -1) {
					selection.splice(index, 1);
					this.setSelection(selection);
				}
                return this.inherited(arguments);
            },
            dispatchChildEvent: function (component, name, evt, f, args) {
            /**
             * @overrides ../Control.prototype.dispatchChildEvent
             */
                var r = this.inherited(arguments);
                if (r !== false && component instanceof Node && component.isEnabled()) {
                    if (name === "keyup") {
                        r = this.onnodekeyup(evt);
                    } else if (name === "click") {
                        var rect = HtmlElement.getAbsoluteRect(component._nodes.icon);
                        if(rect.left < evt.clientX && 
                            rect.left + rect.width > evt.clientX && 
                            rect.top < evt.clientY && 
                            rect.top + rect.height > evt.clientY) {
                        	// Node.prototype.onclick will handle event
                        } else {
                            this.setSelection([component]);
                        }
                    } else if(name === "dblclick") {
                        this.setSelection([component]);
                    }
                }
                return r;
            },
            loaded: function() {
            /** @overrides ../Component.prototype.loaded */
            	this.invalidateSelection();	
            	return this.inherited(arguments);	
            },
            invalidateSelection: function() {
            	var selection = [];
            	function loop(control) {
        			if(control.isSelected()) {
        				selection.push(control);
        			}
        			control._controls && control._controls.forEach(loop);
            	}
            	loop(this);
            	this.setSelection(selection);
            },
            refresh: function() {
                this.destroyControls();
                this.dispatch("nodesneeded", null);
            },
			makeVisible: function(childNode) {
			    var node = this.nodeNeeded();
			    var pos = jquery(childNode.nodeNeeded()).position();
			    var top = this.getAbsoluteRect().height / 3;
			    node.scrollTop -= (top - pos.top);
            },
            
            onnodekeyup: function(evt) {
                if(Event.eventModifiersMatch(evt, [])) {
                    if(evt.keyCode === evt.KEY_F5) {
                        this._selection.forEach(function(node) {
                            node.reloadChildNodes();
                        });
                    }
                } else if(Event.eventModifiersMatch(evt, ["alt"])) {
                    if(evt.keyCode === evt.KEY_LEFT_ARROW) {
                        console.log("alt <-");
                        this._history.back();
                    } else if(evt.keyCode === evt.KEY_RIGHT_ARROW) {
                        console.log("alt ->");
                        this._history.forward();
                    }
                }
            },
            onkeyup: function(evt) {
                if(evt.keyCode === evt.KEY_F5) {
                	this.refresh();
                }
                return this.inherited(arguments);
            },
            onclick: function (evt) {
            /**
             * @overrides ../Control.prototype.onclick
             */
                var r = this.inherited(arguments);
                if (r !== false) {
                    this.setSelection([]);
                }
                return r;
            },
            onselectionchange: function () {
                return this.fire("onSelectionChange", [this.getSelection()]);
            },
            onnodesneeded: function (parent) {
                return this.fire("onNodesNeeded", [parent]);
            },
            
            getSelection: function () {
                return [].concat(this._selection);
            },
            setSelection: function (value, allow_history) {
                // FIXME do some smart selection comparing, only (de)select what is needed...
                
            	if(value.length === this._selection.length) {
            		var same = true;
            		for(var i = 0; i < value.length && same; ++i) {
            			same = value[i] === this._selection[i];
            		}
            		if(same) {
            			return;
            		}
            	}

                this._selection.forEach(function (node) {
                    node.setSelected(false);
                });
                this._selection = value;
                this._selection.forEach(function (node) {
                    node.setSelected(true);
                });

                allow_history !== false && this._history.push(this._selection);

                // FIXME do dispatch if order of selected nodes was changed
                this.dispatch("selectionchange", this._selection);
            }

        },

        properties: {

        	"focusable": {
        		type: Type.BOOLEAN,
        		set: Function
        	},

            "onSelectionChange": {
                type: Type.EVENT
            },

            "onNodesNeeded": {
                type: Type.EVENT
            }

        }

    }));

});
require(['app'], function() { require(['main']); })}());
